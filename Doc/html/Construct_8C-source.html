<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oct/Construct.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">oct</a></div>
<h1>Construct.C</h1><a href="Construct_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00009 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="dendro_8h.html">dendro.h</a>"</span>
00012 
00013 <span class="preprocessor">#ifdef __DEBUG__</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_OCT__</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_OCT__</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span>
00019 <span class="keyword">namespace </span>ot {
00020 
00021   <span class="comment">//New Implementation. Written on April 20, 2008</span>
<a name="l00022"></a><a class="code" href="namespaceot.html#a33">00022</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a33">completeOctree</a>(<span class="keyword">const</span> std::vector&lt;TreeNode &gt; &amp; inp,
00023       std::vector&lt;TreeNode &gt; &amp; out, 
00024       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, <span class="keywordtype">bool</span> isUnique,
00025       <span class="keywordtype">bool</span> isSorted, <span class="keywordtype">bool</span> assertNoEmptyProcs, MPI_Comm comm) {
00026 
00027     <a class="code" href="octUtils_8h.html#a17">PROF_N2O_BEGIN</a>
00028 
00029       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root (dim, maxDepth);
00030 
00031     <span class="keywordtype">int</span> size;
00032     MPI_Comm_size(comm, &amp;size);
00033 
00034     <span class="keywordflow">if</span>(size == 1) {
00035       <a class="code" href="namespaceot.html#a34">completeSubtree</a>(root, inp, out, dim, maxDepth, isUnique, isSorted);
00036       <a class="code" href="octUtils_8h.html#a56">PROF_N2O_END</a>
00037     }<span class="comment">//end single proc case     </span>
00038 
00039     out = inp;
00040 
00041     <span class="comment">//Sort and remove duplicate leaves.</span>
00042     <span class="keywordflow">if</span> (!isUnique) {
00043       par::removeDuplicates&lt;ot::TreeNode&gt;(out, isSorted, comm);
00044     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isSorted) {
00045       std::vector&lt;TreeNode&gt; tmpOut;
00046       par::sampleSort&lt;ot::TreeNode&gt;(out, tmpOut,comm); 
00047       out = tmpOut;
00048       tmpOut.clear();
00049     }
00050 
00051     <span class="comment">//Remove empty processors...    </span>
00052     MPI_Comm   new_comm;
00053     <span class="keywordflow">if</span>(assertNoEmptyProcs) {
00054       new_comm = comm;
00055       assert(!out.empty());
00056     } <span class="keywordflow">else</span> {
00057       <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(out.empty(), &amp;new_comm, comm);
00058     }
00059 
00060     <span class="keywordflow">if</span>(!(out.empty())) {        
00061       <span class="keywordtype">int</span> new_rank, new_size; 
00062 
00063       MPI_Comm_rank (new_comm, &amp;new_rank);
00064       MPI_Comm_size (new_comm, &amp;new_size);
00065 
00066       MPI_Request requestSend;    
00067       MPI_Request requestRecv;
00068 
00069       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> begBuf;
00070       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> lastElem;
00071 
00072       <span class="keywordflow">if</span>(new_rank) {
00073         <span class="comment">//Recv</span>
00074         par::Mpi_Irecv&lt;ot::TreeNode&gt;(&amp;begBuf, 1, (new_rank-1) , 1, new_comm, &amp;requestRecv);
00075       }<span class="comment">//end if not P0</span>
00076 
00077       <span class="keywordflow">if</span> (new_rank &lt; (new_size-1)) {
00078         lastElem = out[out.size() - 1];
00079         <span class="comment">//Send</span>
00080         par::Mpi_Issend&lt;ot::TreeNode&gt;(&amp;lastElem, 1, (new_rank+1), 1, new_comm, &amp;requestSend);
00081       }<span class="comment">//end if not PN </span>
00082 
00083 
00084       <span class="comment">//Add missing corners to complete the region.</span>
00085       <span class="comment">//Add the first corner leaf on the first processor.</span>
00086       <span class="keywordflow">if</span> (new_rank == 0) {
00087         <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> minCorner(0,0,0,maxDepth,dim,maxDepth);
00088 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00089 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[0], minCorner));
00090 <span class="preprocessor">#endif</span>
00091 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( (out[0] != minCorner) &amp;&amp; (!out[0].isAncestor(minCorner)) ) {
00092           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> ncaTmp = <a class="code" href="namespaceot.html#a47">getNCA</a>(out[0],minCorner);
00093           std::vector&lt;ot::TreeNode&gt;  kids;
00094           ncaTmp.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(kids);
00095           out.insert(out.begin(),kids[0]);
00096           kids.clear();
00097         }<span class="comment">//end if</span>
00098       }<span class="comment">//end if</span>
00099 
00100       <span class="comment">//Add the last corner leaf on the last processor.</span>
00101       <span class="keywordflow">if</span> (new_rank == (new_size-1) ) {
00102         <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> maxCorner(((1u &lt;&lt; maxDepth)-1),
00103             ((1u &lt;&lt; maxDepth)-1),((1u &lt;&lt; maxDepth)-1),maxDepth,dim,maxDepth);
00104 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00105 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[out.size()-1], maxCorner));
00106 <span class="preprocessor">#endif</span>
00107 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( (out[out.size()-1] != maxCorner) &amp;&amp; 
00108             (!out[out.size()-1].isAncestor(maxCorner)) ) {
00109           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> ncaTmp =  <a class="code" href="namespaceot.html#a47">getNCA</a>(out[out.size()-1],maxCorner);
00110           std::vector&lt;ot::TreeNode&gt; kids;
00111           ncaTmp.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(kids);
00112           out.insert(out.end(),kids[(1 &lt;&lt; dim)-1]);
00113           kids.clear();
00114         }<span class="comment">//end if</span>
00115       }<span class="comment">//end if</span>
00116 
00117       std::vector&lt;ot::TreeNode&gt; tmpList;
00118       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (out.size()-1); i++) {
00119 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00120 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], out[i+1]));
00121 <span class="preprocessor">#endif</span>
00122 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(out[i].isAncestor(out[i+1])) {
00123           <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(out[i], out[i+1], tmpList, <span class="keyword">false</span>, <span class="keyword">false</span>);
00124         } <span class="keywordflow">else</span> {
00125           <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(out[i], out[i+1], tmpList, <span class="keyword">true</span>, <span class="keyword">false</span>);
00126         }
00127       }<span class="comment">//end for i</span>
00128 
00129       <span class="comment">//Only the last processor adds the last element. All the other processors would have </span>
00130       <span class="comment">//sent it to the next processor, which will add it if it is not an ancestor of </span>
00131       <span class="comment">//the first element on that processor</span>
00132       <span class="keywordflow">if</span>(new_rank == (new_size - 1) ) {
00133         tmpList.push_back(out[out.size() - 1]);
00134       }
00135 
00136       <span class="keywordflow">if</span>(new_rank) {
00137         MPI_Status statusWait;
00138         MPI_Wait(&amp;requestRecv, &amp;statusWait);
00139 
00140         std::vector&lt;ot::TreeNode&gt; begList;
00141 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00142 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(begBuf, out[0]));
00143 <span class="preprocessor">#endif</span>
00144 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(begBuf.<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(out[0])) {
00145           <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(begBuf, out[0], begList, <span class="keyword">false</span>, <span class="keyword">false</span>);
00146         } <span class="keywordflow">else</span> {
00147           <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(begBuf, out[0], begList, <span class="keyword">true</span>, <span class="keyword">false</span>);
00148         }
00149         out = begList;
00150         begList.clear();
00151         out.insert(out.end(), tmpList.begin(), tmpList.end());
00152       } <span class="keywordflow">else</span> {
00153         out = tmpList;
00154       }
00155 
00156       tmpList.clear();
00157 
00158       <span class="keywordflow">if</span>(new_rank &lt; (new_size-1)) {
00159         MPI_Status statusWait;
00160         MPI_Wait(&amp;requestSend, &amp;statusWait);
00161       }
00162 
00163     } <span class="comment">//out not empty</span>
00164 
00165 
00166     <a class="code" href="octUtils_8h.html#a56">PROF_N2O_END</a>
00167 
00168   }<span class="comment">//end function</span>
00169 
00170   <span class="comment">//New Implementation. Written on April 19, 2008</span>
<a name="l00171"></a><a class="code" href="namespaceot.html#a34">00171</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a34">completeSubtree</a>(<a class="code" href="classot_1_1TreeNode.html">TreeNode</a> block, <span class="keyword">const</span> std::vector&lt;TreeNode &gt; &amp; inp, std::vector&lt;TreeNode &gt; &amp; out,
00172       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, <span class="keywordtype">bool</span> isUnique, <span class="keywordtype">bool</span> isSorted) {
00173 
00174     <a class="code" href="octUtils_8h.html#a18">PROF_N2O_SEQ_BEGIN</a>
00175 
00176       out = inp;
00177     <span class="comment">//Sort and remove duplicate leaves.</span>
00178     <span class="keywordflow">if</span> (!isUnique) {
00179       seq::makeVectorUnique&lt;TreeNode&gt;(out, isSorted) ;
00180     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!isSorted) {
00181       <a class="code" href="Sort_8h.html#a7">sort</a>(out.begin(),out.end());
00182     }
00183 
00184     <span class="keywordflow">if</span> (!out.empty()) {
00185       <span class="comment">//Add missing corners to complete the region.</span>
00186       <span class="comment">//Add the first corner .</span>
00187       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> minCorner = block.<a class="code" href="classot_1_1TreeNode.html#a6">getDFD</a>();
00188 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00189 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[0], minCorner));
00190 <span class="preprocessor">#endif</span>
00191 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( (out[0] != minCorner) &amp;&amp; (!out[0].isAncestor(minCorner)) ) {
00192         <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> ncaTmp = <a class="code" href="namespaceot.html#a47">getNCA</a>(out[0],minCorner);
00193         std::vector&lt;ot::TreeNode&gt; kids;
00194         ncaTmp.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(kids);
00195         out.insert(out.begin(),kids[0]);
00196         kids.clear();
00197       }<span class="comment">//end if</span>
00198 
00199       <span class="comment">//Add the last corner.</span>
00200       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> maxCorner = block.<a class="code" href="classot_1_1TreeNode.html#a7">getDLD</a>();
00201 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00202 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[out.size()-1], maxCorner));
00203 <span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( (out[out.size()-1] != maxCorner) &amp;&amp; (!out[out.size()-1].isAncestor(maxCorner)) ) {
00205         <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> ncaTmp = <a class="code" href="namespaceot.html#a47">getNCA</a>(out[out.size()-1],maxCorner);
00206         std::vector&lt;ot::TreeNode&gt; kids;
00207         ncaTmp.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(kids);
00208         out.insert(out.end(),kids[(1 &lt;&lt; dim)-1]);
00209         kids.clear();
00210       }<span class="comment">//end if</span>
00211 
00212       std::vector&lt;ot::TreeNode&gt; tmpList;
00213       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (out.size()-1); i++) {
00214 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00215 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], out[i+1]));
00216 <span class="preprocessor">#endif</span>
00217 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(out[i].isAncestor(out[i+1])) {
00218           <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(out[i], out[i+1], tmpList, <span class="keyword">false</span>, <span class="keyword">false</span>);
00219         } <span class="keywordflow">else</span> {
00220           <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(out[i], out[i+1], tmpList, <span class="keyword">true</span>, <span class="keyword">false</span>);
00221         }
00222       }<span class="comment">//end for i</span>
00223 
00224       tmpList.push_back(out[out.size() - 1]);
00225 
00226       out = tmpList;
00227       tmpList.clear();
00228     }<span class="comment">//end if out empty</span>
00229 
00230     <a class="code" href="octUtils_8h.html#a57">PROF_N2O_SEQ_END</a>
00231 
00232   }<span class="comment">//end function</span>
00233 
<a name="l00234"></a><a class="code" href="namespaceot.html#a35">00234</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a35">points2Octree</a>(std::vector&lt;double&gt;&amp; pts, <span class="keywordtype">double</span> * gLens, std::vector&lt;TreeNode&gt; &amp; nodes,
00235       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxNumPts, MPI_Comm comm ) {
00236 
00237     <a class="code" href="octUtils_8h.html#a14">PROF_P2O_BEGIN</a>
00238 
00239       <span class="keywordtype">int</span> size;
00240     MPI_Comm_size(comm, &amp;size);
00241 
00242     <span class="comment">//Sequential...</span>
00243     <span class="keywordflow">if</span> (size == 1) {
00244       <a class="code" href="namespaceot.html#a36">points2OctreeSeq</a>(pts, gLens, nodes, dim, maxDepth, maxNumPts); 
00245       <a class="code" href="octUtils_8h.html#a53">PROF_P2O_END</a>
00246     }<span class="comment">//end if sequential</span>
00247 
00248     <span class="keywordtype">int</span> rank;
00249     MPI_Comm_rank(comm, &amp;rank);
00250 
00251     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root (dim, maxDepth);
00252 
00253     <span class="keywordflow">if</span> (maxDepth == 0) {
00254       <span class="keywordflow">if</span> (!rank) {
00255         nodes.resize(1);
00256         nodes[0] = root;
00257       } <span class="keywordflow">else</span> {
00258         nodes.resize(0);
00259       }
00260       <a class="code" href="octUtils_8h.html#a53">PROF_P2O_END</a>
00261     }
00262 
00263     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ptsLen = pts.size();
00264     assert( (dim == 1) || (dim == 2) || (dim == 3 ));
00265     assert( (ptsLen%dim) == 0);
00266 
00267     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> numNodes = (ptsLen/dim);
00268 
00269     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> totSize;
00270     par::Mpi_Allreduce&lt;DendroIntL&gt;(&amp;numNodes, &amp;totSize, 1, MPI_SUM, comm);
00271 
00272     <span class="keywordflow">if</span> (totSize &lt;= static_cast&lt;DendroIntL&gt;(maxNumPts)) {
00273       <span class="keywordflow">if</span> (!rank) {
00274         nodes.resize(1);
00275         nodes[0] = root;
00276       } <span class="keywordflow">else</span> {
00277         nodes.resize(0);
00278       }<span class="comment">//end if-else</span>
00279       <a class="code" href="octUtils_8h.html#a53">PROF_P2O_END</a>
00280     }<span class="comment">//end if</span>
00281 
00282     <span class="comment">//Tackle small problems separately....</span>
00283     <span class="comment">//min Grain size = 1000 </span>
00284     <span class="keyword">const</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a> THOUSAND = 1000;
00285     <span class="keywordflow">if</span> (totSize &lt; (THOUSAND*size)) {
00286       <span class="keywordtype">int</span> splittingSize = (totSize/THOUSAND); 
00287 
00288       <span class="keywordflow">if</span>(splittingSize == 0) {
00289         splittingSize = 1; 
00290       }
00291 
00292       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> avgLoad = (totSize/splittingSize);
00293       <span class="keywordtype">int</span> leftOvers = (totSize - (splittingSize*avgLoad));
00294 
00295       std::vector&lt;double&gt; tmpPts;
00296       <span class="keywordflow">if</span>(rank &gt;= splittingSize) {
00297         par::scatterValues&lt;double&gt;(pts, tmpPts, 0, comm);
00298       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rank &lt; leftOvers) {
00299         par::scatterValues&lt;double&gt;(pts, tmpPts, (dim*(avgLoad+1)), comm);
00300       }<span class="keywordflow">else</span> {
00301         par::scatterValues&lt;double&gt;(pts, tmpPts, (dim*avgLoad), comm);
00302       }
00303       pts.clear();
00304 
00305       MPI_Comm newComm;
00306       <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(splittingSize, &amp;newComm, comm);
00307 
00308 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
00309 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(!rank) {
00310         std::cout&lt;&lt;<span class="stringliteral">"Input to p2o is small ("</span>&lt;&lt;totSize
00311           &lt;&lt;<span class="stringliteral">"). npes = "</span>&lt;&lt;size&lt;&lt;<span class="stringliteral">" Splitting Comm. "</span>&lt;&lt;std::endl;
00312       }
00313 <span class="preprocessor">#endif</span>
00314 <span class="preprocessor"></span>
00315       <span class="keywordflow">if</span>(rank &lt; splittingSize) {
00316         <a class="code" href="namespaceot.html#a35">points2Octree</a>(tmpPts, gLens, nodes, dim, maxDepth, maxNumPts, newComm); 
00317       }
00318       tmpPts.clear();
00319 
00320       <a class="code" href="octUtils_8h.html#a53">PROF_P2O_END</a>
00321     }<span class="comment">//reduce procs for small problems</span>
00322 
00323     <span class="comment">//Tackle large problems.... </span>
00324 
00325     nodes.resize(numNodes);
00326 
00327     <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 0; i &lt; numNodes; i++) {
00328       <span class="comment">//The constructor will ignore unnecessary arguments (for lower</span>
00329       <span class="comment">//dimensions).</span>
00330       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> px = (<span class="keywordtype">unsigned</span> int)(pts[i*dim]*((double)(1u &lt;&lt; maxDepth))/(gLens[0]));
00331       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> py, pz = 0;
00332       <span class="keywordflow">if</span>(dim &gt; 1) {
00333         py = (<span class="keywordtype">unsigned</span> int)(pts[(i*dim)+1]*((double)(1u &lt;&lt; maxDepth))/gLens[1]);
00334         <span class="keywordflow">if</span>(dim &gt; 2) {
00335           pz = (<span class="keywordtype">unsigned</span> int)(pts[(i*dim)+2]*((double)(1u &lt;&lt; maxDepth))/gLens[2]);
00336         }
00337       }
00338       nodes[i] = <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>(px, py, pz, maxDepth, dim, maxDepth);
00339     }<span class="comment">//end for</span>
00340 
00341     pts.clear(); 
00342 
00343     std::vector&lt;ot::TreeNode&gt; tmpNodes ;
00344 
00345     <span class="comment">//Sort nodes (pts.) and partition them.</span>
00346     par::sampleSort&lt;ot::TreeNode&gt;(nodes, tmpNodes, comm); 
00347     nodes = tmpNodes;
00348     tmpNodes.clear();
00349 
00350     std::vector&lt;ot::TreeNode&gt; leaves;
00351     std::vector&lt;ot::TreeNode&gt; minsAllBlocks;
00352 
00353     <a class="code" href="namespaceot.html#a26">blockPartStage1_p2o</a>(nodes, leaves, dim, maxDepth, comm);
00354     <a class="code" href="namespaceot.html#a27">blockPartStage2_p2o</a>(nodes, leaves, minsAllBlocks, dim, maxDepth, comm);
00355     <span class="comment">//leaves will be sorted.</span>
00356 
00357     <a class="code" href="namespaceot.html#a37">p2oLocal</a>(nodes, leaves, maxNumPts, dim, maxDepth);
00358 
00359     <a class="code" href="octUtils_8h.html#a53">PROF_P2O_END</a>
00360 
00361   }<span class="comment">//end function</span>
00362 
00363   <span class="comment">//Added on April 19, 2008</span>
<a name="l00364"></a><a class="code" href="namespaceot.html#a36">00364</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a36">points2OctreeSeq</a>(std::vector&lt;double&gt;&amp; pts, <span class="keywordtype">double</span> * gLens, std::vector&lt;TreeNode&gt; &amp; nodes,
00365       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxNumPts) {
00366 
00367     <a class="code" href="octUtils_8h.html#a15">PROF_P2O_SEQ_BEGIN</a>
00368 
00369       <span class="keywordflow">if</span> (maxDepth == 0) {    
00370         nodes.resize(1);
00371         nodes[0] = <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>(dim,maxDepth);
00372         <a class="code" href="octUtils_8h.html#a54">PROF_P2O_SEQ_END</a>
00373       }
00374 
00375     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ptsLen = pts.size();
00376     assert( (dim == 1) || (dim == 2) || (dim == 3 ));
00377     assert( (ptsLen%dim) == 0);
00378 
00379     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root (dim,maxDepth);
00380     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNodes = ptsLen/dim;
00381     nodes.resize(numNodes);
00382 
00383     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numNodes; i++) {
00384       <span class="comment">//The constructor will ignore unnecessary arguments (for lower</span>
00385       <span class="comment">//dimensions).</span>
00386       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> px = (<span class="keywordtype">unsigned</span> int)(pts[i*dim]*((double)(1u &lt;&lt; maxDepth))/(gLens[0]));
00387       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> py, pz = 0;
00388       <span class="keywordflow">if</span>(dim &gt; 1) {
00389         py = (<span class="keywordtype">unsigned</span> int)(pts[(i*dim)+1]*((double)(1u &lt;&lt; maxDepth))/gLens[1]);
00390         <span class="keywordflow">if</span>(dim &gt; 2) {
00391           pz = (<span class="keywordtype">unsigned</span> int)(pts[(i*dim)+2]*((double)(1u &lt;&lt; maxDepth))/gLens[2]);
00392         }
00393       }
00394       nodes[i] = <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>(px, py, pz, maxDepth, dim, maxDepth);
00395     }<span class="comment">//end for</span>
00396 
00397     pts.clear(); 
00398 
00399     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totSize = nodes.size();
00400 
00401     <span class="keywordflow">if</span> (totSize &lt;= maxNumPts) {
00402       nodes.resize(1);
00403       nodes[0] = root;
00404       <a class="code" href="octUtils_8h.html#a54">PROF_P2O_SEQ_END</a>
00405     }<span class="comment">//end if</span>
00406 
00407     <span class="comment">//Sort nodes (pts.) and partition them.  </span>
00408     <a class="code" href="Sort_8h.html#a7">sort</a>(nodes.begin(), nodes.end());
00409 
00410     std::vector&lt;TreeNode&gt; leaves;
00411     leaves.push_back(root);
00412 
00413     <a class="code" href="namespaceot.html#a37">p2oLocal</a>(nodes, leaves, maxNumPts, dim, maxDepth);
00414 
00415     <a class="code" href="octUtils_8h.html#a54">PROF_P2O_SEQ_END</a>
00416 
00417   }<span class="comment">//end function</span>
00418 
<a name="l00419"></a><a class="code" href="namespaceot.html#a37">00419</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a37">p2oLocal</a>(std::vector&lt;TreeNode&gt; &amp; nodes, std::vector&lt;TreeNode&gt;&amp; leaves,
00420       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxNumPts, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00421     <a class="code" href="octUtils_8h.html#a16">PROF_P2O_LOCAL_BEGIN</a>
00422 
00423       std::vector&lt;TreeNode&gt; nodesDup = nodes;
00424     nodes.clear();
00425 
00426     std::vector&lt;TreeNode&gt; addList;
00427     std::vector&lt;TreeNode&gt; nodesTmp;
00428 
00429     std::vector&lt;TreeNode&gt; *nodeSrc = &amp;nodes;
00430     std::vector&lt;TreeNode&gt; *nodeDest = &amp;nodesTmp;
00431     std::vector&lt;TreeNode&gt; *leafSrc = &amp;leaves;
00432     std::vector&lt;TreeNode&gt; *leafDest = &amp;addList;
00433 
00434     <span class="comment">//The source and destination alternate for each iteration.</span>
00435     <span class="keywordflow">do</span> {
00436       <span class="comment">//Leaves remain sorted inside this loop!</span>
00437       <span class="comment">//Reset all wts to 0.</span>
00438       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; leafSrc-&gt;size(); i++) {
00439         (*leafSrc)[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(0);
00440       }
00441 
00442       <span class="comment">//nodesDup and leaves are both sorted at this point.</span>
00443       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextNode = 0;
00444       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextPt = 0;
00445       <span class="comment">//Some elements of nodesDup are not inside any element in leaves.</span>
00446       <span class="comment">//Note, this is different from other similar loops.</span>
00447       <span class="comment">//Here, nodesDup is merely  a counter and remains unchanged for all</span>
00448       <span class="comment">//outer do-while iterations, if a box had less than maxNumpts, it will</span>
00449       <span class="comment">//be removed from leaves and placed in nodeDest. However, all its</span>
00450       <span class="comment">//decendants in nodesDup still remain.</span>
00451       <span class="comment">//Also, note the first pt. need not be in any block. Hence, there is an</span>
00452       <span class="comment">//extra if-else wrapper to skip pts, that lie outside all blocks and</span>
00453       <span class="comment">//are lesser than them in the Morton order.</span>
00454       <span class="keywordflow">while</span> (nextPt &lt; nodesDup.size()) {
00455         <span class="keywordflow">if</span> (nodesDup[nextPt] &gt;= (*leafSrc)[nextNode]) {
00456 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00457 <span class="preprocessor"></span>          assert(<a class="code" href="namespaceot.html#a54">areComparable</a>((*leafSrc)[nextNode], nodesDup[nextPt]));
00458 <span class="preprocessor">#endif</span>
00459 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (((*leafSrc)[nextNode].isAncestor(nodesDup[nextPt])) ||
00460               ((*leafSrc)[nextNode] == nodesDup[nextPt])) {
00461             (*leafSrc)[nextNode].<a class="code" href="classot_1_1TreeNode.html#z19_0">addWeight</a>(1);
00462             nextPt++;
00463           } <span class="keywordflow">else</span> {
00464             nextNode++;
00465             <span class="keywordflow">if</span> (nextNode == leafSrc-&gt;size()) {
00466               <span class="comment">//Note: No assert(false) here. </span>
00467               <span class="keywordflow">break</span>;
00468             }
00469           }
00470         } <span class="keywordflow">else</span> {
00471           nextPt++;
00472         }
00473       }<span class="comment">//end while</span>
00474 
00475       leafDest-&gt;resize((1 &lt;&lt; dim)*(leafSrc-&gt;size()));
00476       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> addListSz=0;     
00477       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodesPrevSz = nodeSrc-&gt;size();
00478       nodeSrc-&gt;resize(nodesPrevSz + (leafSrc-&gt;size()));
00479       nodeDest-&gt;resize(nodeSrc-&gt;size());
00480       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpCtr=0;
00481       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodesCtr=0;
00482       <span class="comment">// int cntX=0;</span>
00483       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; leafSrc-&gt;size(); i++) {
00484         <span class="keywordflow">if</span> ( ((*leafSrc)[i].getWeight() &gt; maxNumPts) &amp;&amp;
00485             ((*leafSrc)[i].getLevel() &lt; maxDepth) ) {
00486           <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> thisNode = (*leafSrc)[i];
00487           std::vector&lt;TreeNode&gt; children;
00488           thisNode.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(children);
00489           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ci = 0; ci &lt; (1 &lt;&lt; dim); ci++) {
00490             (*leafDest)[addListSz] = children[ci];
00491             addListSz++;
00492           }
00493           children.clear();
00494         } <span class="keywordflow">else</span> {
00495           <span class="keywordflow">while</span> ((nodesCtr &lt; nodesPrevSz) &amp;&amp;
00496               ((*nodeSrc)[nodesCtr] &lt; (*leafSrc)[i]) ) {
00497             (*nodeDest)[tmpCtr++] = (*nodeSrc)[nodesCtr++];
00498           }
00499           (*nodeDest)[tmpCtr++] = (*leafSrc)[i];
00500         }<span class="comment">//end if-else</span>
00501       }<span class="comment">//end for i</span>
00502 
00503       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = nodesCtr; i &lt; nodesPrevSz; i++) {
00504         (*nodeDest)[tmpCtr++] = (*nodeSrc)[i];
00505       }
00506 
00507       leafDest-&gt;resize(addListSz);
00508       nodeDest-&gt;resize(tmpCtr);
00509 
00510       <span class="comment">// swap pointers ...</span>
00511       std::vector&lt;TreeNode&gt; *tmpPtr = nodeSrc;
00512       nodeSrc = nodeDest;
00513       nodeDest = tmpPtr;
00514       tmpPtr = leafSrc;
00515       leafSrc = leafDest;
00516       leafDest = tmpPtr;
00517       leafDest-&gt;clear();
00518       nodeDest-&gt;clear();  
00519     } <span class="keywordflow">while</span> (!leafSrc-&gt;empty());
00520 
00521     <span class="keywordflow">if</span> ( nodeSrc != &amp;nodes ) {
00522       nodes = nodesTmp;
00523     }
00524     nodesTmp.clear();
00525 
00526     <span class="comment">//Reset All weights to 1.</span>
00527     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodes.size(); i++) {
00528       nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
00529     }
00530 
00531     <a class="code" href="octUtils_8h.html#a55">PROF_P2O_LOCAL_END</a>
00532   }
00533 
00534   <span class="comment">//New Implementation. Written on April 19th, 2008</span>
00535   <span class="comment">//Both ends are inclusive. The output is sorted.</span>
<a name="l00536"></a><a class="code" href="namespaceot.html#a38">00536</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(<a class="code" href="classot_1_1TreeNode.html">TreeNode</a> first, <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> second, 
00537       std::vector&lt;ot::TreeNode&gt;&amp; newNodes, <span class="keywordtype">bool</span> includeMin, <span class="keywordtype">bool</span> includeMax) {
00538 
00539     <a class="code" href="octUtils_8h.html#a19">PROF_COMPLETE_REGION_BEGIN</a>
00540 
00541       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = first.<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00542     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = first.<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
00543 
00544     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> min = ((first &lt; second) ? first : second);
00545 
00546     <span class="keywordflow">if</span>(includeMin) {
00547       newNodes.push_back(min);
00548     }
00549 
00550     <span class="keywordflow">if</span> (first == second) {
00551       <a class="code" href="octUtils_8h.html#a58">PROF_COMPLETE_REGION_END</a>
00552     }
00553 
00554     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> max = ((first &gt; second) ? first : second);
00555 
00556     <span class="comment">//Add nodes &gt; min and &lt; max</span>
00557     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> nca = <a class="code" href="namespaceot.html#a47">getNCA</a>(min,max);
00558 
00559     <span class="keywordflow">if</span>(min == nca) {
00560       <span class="comment">//special case. Top down approach</span>
00561       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> tmpAncestor = min;
00562       <span class="keywordtype">bool</span> repeatLoop;
00563       <span class="keywordflow">do</span> {
00564         repeatLoop = <span class="keyword">false</span>;
00565         std::vector&lt;ot::TreeNode&gt; tmpChildList;
00566         tmpAncestor.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(tmpChildList);
00567         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; tmpChildList.size(); j++) {
00568 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00569 <span class="preprocessor"></span>          assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(tmpChildList[j], max));
00570 <span class="preprocessor">#endif</span>
00571 <span class="preprocessor"></span>          <span class="keywordflow">if</span>( (tmpChildList[j] &lt; max) &amp;&amp;
00572               (!(tmpChildList[j].isAncestor(max))) ) {
00573             newNodes.push_back(tmpChildList[j]);
00574           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(tmpChildList[j].isAncestor(max)) {
00575             tmpAncestor = tmpChildList[j];
00576             repeatLoop = <span class="keyword">true</span>;
00577             <span class="keywordflow">break</span>;
00578           } <span class="keywordflow">else</span> {
00579             assert(tmpChildList[j] == max);
00580             <span class="keywordflow">break</span>;
00581           }
00582         }<span class="comment">//end for j</span>
00583       } <span class="keywordflow">while</span> (repeatLoop);
00584     } <span class="keywordflow">else</span> {
00585       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> currentNode = min;    
00586       <span class="keywordflow">while</span>(currentNode &gt; nca) {
00587         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> parentOfCurrent = currentNode.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
00588         std::vector&lt;ot::TreeNode&gt; myBros;
00589         parentOfCurrent.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(myBros);
00590         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; myBros.size(); i++) {
00591 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00592 <span class="preprocessor"></span>          assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(myBros[i], max));
00593 <span class="preprocessor">#endif</span>
00594 <span class="preprocessor"></span>          <span class="keywordflow">if</span>( (myBros[i] &gt; min) &amp;&amp;
00595               (myBros[i] &lt; max) &amp;&amp; (!(myBros[i].isAncestor(max))) ) {
00596             <span class="comment">//Bottom-up here</span>
00597             newNodes.push_back(myBros[i]);
00598           } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(myBros[i].isAncestor(max)) {
00599             <span class="comment">//Top-down now</span>
00600             <span class="comment">//nca will be the parentOfCurrent </span>
00601             <span class="comment">//If myBros[i] is an acestor of max then</span>
00602             <span class="comment">//it is automatically &gt; min and &lt; max</span>
00603             <span class="comment">//The octants are automatically inserted in</span>
00604             <span class="comment">//the sorted order, due to properties of space-filling curves.</span>
00605             <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> tmpAncestor = myBros[i];
00606             <span class="keywordtype">bool</span> repeatLoop;
00607             <span class="keywordflow">do</span> {
00608               repeatLoop = <span class="keyword">false</span>;
00609               std::vector&lt;ot::TreeNode&gt; tmpChildList;
00610               tmpAncestor.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(tmpChildList);
00611               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; tmpChildList.size(); j++) {
00612 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00613 <span class="preprocessor"></span>                assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(tmpChildList[j], max));
00614 <span class="preprocessor">#endif</span>
00615 <span class="preprocessor"></span>                <span class="keywordflow">if</span>( (tmpChildList[j] &lt; max) &amp;&amp;
00616                     (!(tmpChildList[j].isAncestor(max))) ) {
00617                   newNodes.push_back(tmpChildList[j]);
00618                 } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(tmpChildList[j].isAncestor(max)) {
00619                   tmpAncestor = tmpChildList[j];
00620                   repeatLoop = <span class="keyword">true</span>;
00621                   <span class="keywordflow">break</span>;
00622                 } <span class="keywordflow">else</span> {
00623                   assert(tmpChildList[j] == max);
00624                   <span class="keywordflow">break</span>;
00625                 }
00626               }<span class="comment">//end for j</span>
00627             } <span class="keywordflow">while</span> (repeatLoop);
00628             <span class="keywordflow">break</span>;      
00629           }<span class="comment">//end select between bottom-up/ top-down</span>
00630         }<span class="comment">//end for i            </span>
00631         currentNode = parentOfCurrent;
00632       }<span class="comment">//end while      </span>
00633     }<span class="comment">//end if special case</span>
00634 
00635     <span class="keywordflow">if</span>(includeMax) {
00636       newNodes.push_back(max);
00637     }
00638 
00639     <a class="code" href="octUtils_8h.html#a58">PROF_COMPLETE_REGION_END</a>
00640   }<span class="comment">//end function</span>
00641 
00642   <span class="comment">/*</span>
00643 <span class="comment">  //Original Code</span>
00644 <span class="comment">  //Both ends are inclusive. The output is sorted.</span>
00645 <span class="comment">  int completeRegion(TreeNode first, TreeNode second, </span>
00646 <span class="comment">  std::vector&lt;ot::TreeNode&gt;&amp; newNodes, bool includeMin, bool includeMax) {</span>
00647 <span class="comment"></span>
00648 <span class="comment">  PROF_COMPLETE_REGION_BEGIN</span>
00649 <span class="comment"></span>
00650 <span class="comment">  unsigned int dim = first.getDim();</span>
00651 <span class="comment">  unsigned int maxDepth = first.getMaxDepth();</span>
00652 <span class="comment"></span>
00653 <span class="comment">  TreeNode min = ( (first &lt; second) ? first : second );</span>
00654 <span class="comment">  TreeNode max = ( (first &gt; second) ? first : second );</span>
00655 <span class="comment"></span>
00656 <span class="comment">  newNodes.clear();</span>
00657 <span class="comment"></span>
00658 <span class="comment">  if(includeMin) {</span>
00659 <span class="comment">  newNodes.push_back(min);</span>
00660 <span class="comment">  }</span>
00661 <span class="comment"></span>
00662 <span class="comment">  if (first == second) {</span>
00663 <span class="comment">  return 1;</span>
00664 <span class="comment">  }</span>
00665 <span class="comment"></span>
00666 <span class="comment">  if(includeMax) {</span>
00667 <span class="comment">  newNodes.push_back(max);</span>
00668 <span class="comment">  }</span>
00669 <span class="comment"></span>
00670 <span class="comment">//Add nodes &gt; min and &lt; max</span>
00671 <span class="comment">TreeNode nca = getNCA(min,max);</span>
00672 <span class="comment"></span>
00673 <span class="comment">std::vector&lt;TreeNode&gt; workingNodes;</span>
00674 <span class="comment">std::vector&lt;TreeNode&gt; addList;</span>
00675 <span class="comment">std::vector&lt;TreeNode&gt; * wSrc = &amp;(workingNodes);</span>
00676 <span class="comment">std::vector&lt;TreeNode&gt; * wDest = &amp;(addList);</span>
00677 <span class="comment">workingNodes.push_back(nca);</span>
00678 <span class="comment">while (!(wSrc-&gt;empty())) {</span>
00679 <span class="comment">wDest-&gt;resize((wSrc-&gt;size())*(1 &lt;&lt; dim));</span>
00680 <span class="comment">unsigned int addListCtr=0;</span>
00681 <span class="comment">for (unsigned int k=0;k &lt; wSrc-&gt;size();k++) {</span>
00682 <span class="comment">if ( ((*wSrc)[k] &gt; min) &amp;&amp; ((*wSrc)[k] &lt; max) &amp;&amp; </span>
00683 <span class="comment">(!(*wSrc)[k].isAncestor(max)) ) {</span>
00684 <span class="comment">newNodes.push_back((*wSrc)[k]);</span>
00685 <span class="comment">} else if ((*wSrc)[k].getLevel() &lt; maxDepth) {</span>
00686 <span class="comment">if ((*wSrc)[k].isAncestor(min) || (*wSrc)[k].isAncestor(max) ) {</span>
00687 <span class="comment">std::vector&lt;TreeNode&gt;  tmpChildren;</span>
00688 <span class="comment">(*wSrc)[k].addChildren(tmpChildren);</span>
00689 <span class="comment">for (int l=0;l&lt;(1 &lt;&lt; dim);l++) {</span>
00690 <span class="comment">if (tmpChildren[l]&lt;max) {</span>
00691 <span class="comment">(*wDest)[addListCtr++] = tmpChildren[l];</span>
00692 <span class="comment">}</span>
00693 <span class="comment">}//end for l</span>
00694 <span class="comment">tmpChildren.clear();</span>
00695 <span class="comment">}</span>
00696 <span class="comment">}//end if-else</span>
00697 <span class="comment">}//end for k</span>
00698 <span class="comment">wDest-&gt;resize(addListCtr);</span>
00699 <span class="comment">std::vector&lt;TreeNode&gt; * tmpPtr = wSrc;</span>
00700 <span class="comment">wSrc = wDest;</span>
00701 <span class="comment">wDest = tmpPtr;</span>
00702 <span class="comment">}//end while</span>
00703 <span class="comment"></span>
00704 <span class="comment">sort(newNodes.begin(),newNodes.end());</span>
00705 <span class="comment"></span>
00706 <span class="comment">PROF_COMPLETE_REGION_END</span>
00707 <span class="comment">}//end function</span>
00708 <span class="comment">*/</span>
00709 
00710 }<span class="comment">//end namespace</span>
00711 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:31 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
