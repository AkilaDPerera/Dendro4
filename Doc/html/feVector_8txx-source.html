<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/include/fem/feVector.txx Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000003.html">fem</a></div>
<h1>feVector.txx</h1><a href="feVector_8txx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00003 feVector&lt;T&gt;::feVector() {
00004   <a class="code" href="classot_1_1fem_1_1feVec.html#p1">m_daType</a> = PETSC;
00005   <a class="code" href="classot_1_1fem_1_1feVec.html#p0">m_DA</a>          = NULL;
00006   <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>       = NULL;
00007   <a class="code" href="classot_1_1fem_1_1feVector.html#p0">m_stencil</a>     = NULL;
00008   <a class="code" href="classot_1_1fem_1_1feVector.html#p4">m_uiDof</a>       = 1;
00009   <a class="code" href="classot_1_1fem_1_1feVector.html#p3">m_ucpLut</a>      = NULL;
00010 
00011   <span class="comment">// initialize the stencils ...</span>
00012   <a class="code" href="classot_1_1fem_1_1feVector.html#a13">initStencils</a>();
00013 }
00014 
00015 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00016 feVector&lt;T&gt;::feVector(daType da) {
00017 <span class="preprocessor">#ifdef __DEBUG__</span>
00018 <span class="preprocessor"></span>  assert ( ( da == PETSC ) || ( da == OCT ) );
00019 <span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span>  <a class="code" href="classot_1_1fem_1_1feVec.html#p1">m_daType</a> = da;
00021   <a class="code" href="classot_1_1fem_1_1feVec.html#p0">m_DA</a>          = NULL;
00022   <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>       = NULL;
00023   <a class="code" href="classot_1_1fem_1_1feVector.html#p0">m_stencil</a>     = NULL;
00024   <a class="code" href="classot_1_1fem_1_1feVector.html#p3">m_ucpLut</a>      = NULL;
00025 
00026   <span class="comment">// initialize the stencils ...</span>
00027   <a class="code" href="classot_1_1fem_1_1feVector.html#a13">initStencils</a>();
00028   <span class="keywordflow">if</span> (da == OCT)
00029     <a class="code" href="classot_1_1fem_1_1feVector.html#a12">initOctLut</a>();
00030 }
00031 
00032 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00033 <span class="keywordtype">void</span> feVector&lt;T&gt;::initOctLut() {
00034   <span class="comment">//Note: It is not symmetric.</span>
00035   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp[8][8]={
00036     {0,1,2,3,4,5,6,7},
00037     {1,3,0,2,5,7,4,6},
00038     {2,0,3,1,6,4,7,5},
00039     {3,2,1,0,7,6,5,4},
00040     {4,5,0,1,6,7,2,3},
00041     {5,7,1,3,4,6,0,2},
00042     {6,4,2,0,7,5,3,1},
00043     {7,6,3,2,5,4,1,0}
00044   };
00045 
00046   <span class="comment">//Is Stored in  ROW_MAJOR Format.  </span>
00047   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* charPtr;
00048   <a class="code" href="classot_1_1fem_1_1feVector.html#p3">m_ucpLut</a> = <span class="keyword">new</span> charPtr[8];
00049   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;8;i++) {
00050     <a class="code" href="classot_1_1fem_1_1feVector.html#p3">m_ucpLut</a>[i] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[8]; 
00051     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;8;j++) {
00052       <a class="code" href="classot_1_1fem_1_1feVector.html#p3">m_ucpLut</a>[i][j] = tmp[i][j];
00053     }
00054   }
00055 }
00056 
00057 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00058 feVector&lt;T&gt;::~feVector() {
00059 }
00060 
00061 
00075 <span class="comment">/*#undef __FUNCT__</span>
00076 <span class="comment">#define __FUNCT__ "feVector_AddVec"</span>
00077 <span class="comment">template &lt;typename T&gt;</span>
00078 <span class="comment">bool feVector&lt;T&gt;::addVec(Vec _in, double scale){</span>
00079 <span class="comment">PetscFunctionBegin;</span>
00080 <span class="comment"></span>
00081 <span class="comment">#ifdef __DEBUG__</span>
00082 <span class="comment">assert ( ( m_daType == PETSC ) || ( m_daType == OCT ) );</span>
00083 <span class="comment">#endif</span>
00084 <span class="comment"></span>
00085 <span class="comment">int ierr;</span>
00086 <span class="comment">// PetscScalar zero=0.0;</span>
00087 <span class="comment"></span>
00088 <span class="comment">if (m_daType == PETSC) {</span>
00089 <span class="comment"></span>
00090 <span class="comment">PetscInt x,y,z,m,n,p;</span>
00091 <span class="comment">PetscInt mx,my,mz;</span>
00092 <span class="comment">int xne,yne,zne;</span>
00093 <span class="comment"></span>
00094 <span class="comment">PetscScalar ***in;</span>
00095 <span class="comment">Vec inlocal;</span>
00096 <span class="comment"></span>
00097 <span class="comment">// Get all corners</span>
00098 <span class="comment">if (m_DA == NULL)</span>
00099 <span class="comment">std::cerr &lt;&lt; "Da is null" &lt;&lt; std::endl;</span>
00100 <span class="comment">ierr = DAGetCorners(m_DA, &amp;x, &amp;y, &amp;z, &amp;m, &amp;n, &amp;p); CHKERRQ(ierr); </span>
00101 <span class="comment">// Get Info</span>
00102 <span class="comment">ierr = DAGetInfo(m_DA,0, &amp;mx, &amp;my, &amp;mz, 0,0,0,0,0,0,0); CHKERRQ(ierr); </span>
00103 <span class="comment"></span>
00104 <span class="comment">if (x+m == mx) {</span>
00105 <span class="comment">xne=m-1;</span>
00106 <span class="comment">} else {</span>
00107 <span class="comment">xne=m;</span>
00108 <span class="comment">}</span>
00109 <span class="comment">if (y+n == my) {</span>
00110 <span class="comment">yne=n-1;</span>
00111 <span class="comment">} else {</span>
00112 <span class="comment">yne=n;</span>
00113 <span class="comment">}</span>
00114 <span class="comment">if (z+p == mz) {</span>
00115 <span class="comment">zne=p-1;</span>
00116 <span class="comment">} else {</span>
00117 <span class="comment">zne=p;</span>
00118 <span class="comment">}</span>
00119 <span class="comment"></span>
00120 <span class="comment">double norm;</span>
00121 <span class="comment"></span>
00122 <span class="comment">#ifdef __DEBUG__</span>
00123 <span class="comment">VecNorm(_in, NORM_INFINITY, &amp;norm);</span>
00124 <span class="comment">std::cout &lt;&lt; " norm of _in in feVector.cpp before adding force = " &lt;&lt; norm &lt;&lt; std::endl;</span>
00125 <span class="comment">#endif</span>
00126 <span class="comment"></span>
00127 <span class="comment">ierr = DAGetLocalVector(m_DA,&amp;inlocal); CHKERRQ(ierr);</span>
00128 <span class="comment"></span>
00129 <span class="comment">ierr = VecZeroEntries(inlocal); CHKERRQ(ierr);</span>
00130 <span class="comment"></span>
00131 <span class="comment">ierr = DAVecGetArray(m_DA,inlocal, &amp;in);</span>
00132 <span class="comment"></span>
00133 <span class="comment">// Any derived class initializations ...</span>
00134 <span class="comment">preAddVec();</span>
00135 <span class="comment"></span>
00136 <span class="comment">// loop through all elements ...</span>
00137 <span class="comment">for (int k=z; k&lt;z+zne; k++){</span>
00138 <span class="comment">for (int j=y; j&lt;y+yne; j++){</span>
00139 <span class="comment">for (int i=x; i&lt;x+xne; i++){</span>
00140 <span class="comment">// std::cout &lt;&lt; i &lt;&lt;"," &lt;&lt; j &lt;&lt; "," &lt;&lt; k &lt;&lt; std::endl;</span>
00141 <span class="comment">ElementalAddVec(i, j, k, in, scale);</span>
00142 <span class="comment">} // end i</span>
00143 <span class="comment">} // end j</span>
00144 <span class="comment">} // end k</span>
00145 <span class="comment"></span>
00146 <span class="comment">postAddVec();</span>
00147 <span class="comment"></span>
00148 <span class="comment">ierr = DAVecRestoreArray(m_DA, inlocal, &amp;in);</span>
00149 <span class="comment"></span>
00150 <span class="comment">ierr = DALocalToGlobalBegin(m_DA,inlocal,_in); CHKERRQ(ierr);</span>
00151 <span class="comment">ierr = DALocalToGlobalEnd(m_DA,inlocal,_in); CHKERRQ(ierr);</span>
00152 <span class="comment"></span>
00153 <span class="comment">ierr = DARestoreLocalVector(m_DA,&amp;inlocal); CHKERRQ(ierr);</span>
00154 <span class="comment"></span>
00155 <span class="comment">#ifdef __DEBUG__</span>
00156 <span class="comment">VecNorm(_in, NORM_INFINITY, &amp;norm);</span>
00157 <span class="comment">std::cout &lt;&lt; " norm of _in in feVector.cpp after adding force = " &lt;&lt; norm &lt;&lt; std::endl;</span>
00158 <span class="comment">#endif</span>
00159 <span class="comment">// ierr = VecDestroy(outlocal); CHKERRQ(ierr);  </span>
00160 <span class="comment"></span>
00161 <span class="comment">} else {</span>
00162 <span class="comment">  // loop for octree DA.</span>
00163 <span class="comment"></span>
00164 <span class="comment"></span>
00165 <span class="comment">  PetscScalar *out=NULL;</span>
00166 <span class="comment">  PetscScalar *in=NULL; </span>
00167 <span class="comment"></span>
00168 <span class="comment">  // get Buffers ...</span>
00169 <span class="comment">  //Nodal,Non-Ghosted,Read,1 dof, Get in array and get ghosts during computation</span>
00170 <span class="comment">  m_octDA-&gt;vecGetBuffer(_in,   in, false, false, false,  m_uiDof);</span>
00171 <span class="comment"></span>
00172 <span class="comment"></span>
00173 <span class="comment">  // start comm for in ...</span>
00174 <span class="comment">  //m_octDA-&gt;updateGhostsBegin&lt;PetscScalar&gt;(in, false, m_uiDof);</span>
00175 <span class="comment">  m_octDA-&gt;ReadFromGhostsBegin&lt;PetscScalar&gt;(in, false, m_uiDof);</span>
00176 <span class="comment">  preAddVec();</span>
00177 <span class="comment"></span>
00178 <span class="comment">  // Independent loop, loop through the nodes this processor owns..</span>
00179 <span class="comment">  for ( m_octDA-&gt;init&lt;ot::DA::INDEPENDENT&gt;(), m_octDA-&gt;init&lt;ot::DA::WRITABLE&gt;(); m_octDA-&gt;curr() &lt; m_octDA-&gt;end&lt;ot::DA::INDEPENDENT&gt;(); m_octDA-&gt;next&lt;ot::DA::INDEPENDENT&gt;() ) {</span>
00180 <span class="comment">    ElementalAddVec( m_octDA-&gt;curr(), in, scale); </span>
00181 <span class="comment">  }//end INDEPENDENT</span>
00182 <span class="comment"></span>
00183 <span class="comment">  // Wait for communication to end.</span>
00184 <span class="comment">  //m_octDA-&gt;updateGhostsEnd&lt;PetscScalar&gt;(in);</span>
00185 <span class="comment">  m_octDA-&gt;ReadFromGhostsEnd&lt;PetscScalar&gt;(in);</span>
00186 <span class="comment"></span>
00187 <span class="comment">  // Dependent loop ...</span>
00188 <span class="comment">  for ( m_octDA-&gt;init&lt;ot::DA::DEPENDENT&gt;(), m_octDA-&gt;init&lt;ot::DA::WRITABLE&gt;();m_octDA-&gt;curr() &lt; m_octDA-&gt;end&lt;ot::DA::DEPENDENT&gt;(); m_octDA-&gt;next&lt;ot::DA::DEPENDENT&gt;() ) {</span>
00189 <span class="comment">    ElementalAddVec( m_octDA-&gt;curr(), in, scale); </span>
00190 <span class="comment">  }//end DEPENDENT</span>
00191 <span class="comment"></span>
00192 <span class="comment">  postAddVec();</span>
00193 <span class="comment"></span>
00194 <span class="comment">  // Restore Vectors ...</span>
00195 <span class="comment">  m_octDA-&gt;vecRestoreBuffer(_in,   in, false, false, false,  m_uiDof);</span>
00196 <span class="comment"></span>
00197 <span class="comment">}</span>
00198 <span class="comment"></span>
00199 <span class="comment">PetscFunctionReturn(0);</span>
00200 <span class="comment">}</span>
00201 <span class="comment">*/</span>
00202 
00216 <span class="preprocessor">#undef __FUNCT__</span>
00217 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "feVector_AddVec_Indx"</span>
00218 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00219 <span class="keywordtype">bool</span> feVector&lt;T&gt;::addVec(Vec _in, <span class="keywordtype">double</span> scale, <span class="keywordtype">int</span> indx){
00220   PetscFunctionBegin;
00221 
00222 <span class="preprocessor">#ifdef __DEBUG__</span>
00223 <span class="preprocessor"></span>  assert ( ( m_daType == PETSC ) || ( m_daType == OCT ) );
00224 <span class="preprocessor">#endif</span>
00225 <span class="preprocessor"></span>
00226   <span class="keywordtype">int</span> ierr;
00227   <span class="comment">// PetscScalar zero=0.0;</span>
00228 
00229   <a class="code" href="classot_1_1fem_1_1feVec.html#p5">m_iCurrentDynamicIndex</a> = indx;
00230 
00231   <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feVec.html#p1">m_daType</a> == PETSC) {
00232 
00233     PetscInt x,y,z,m,n,p;
00234     PetscInt mx,my,mz;
00235     <span class="keywordtype">int</span> xne,yne,zne;
00236 
00237     PetscScalar ***in;
00238     Vec inlocal;
00239 
00240     <span class="comment">/* Get all corners*/</span>
00241     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feVec.html#p0">m_DA</a> == NULL)
00242       std::cerr &lt;&lt; <span class="stringliteral">"Da is null"</span> &lt;&lt; std::endl;
00243     ierr = DAGetCorners(m_DA, &amp;x, &amp;y, &amp;z, &amp;m, &amp;n, &amp;p); CHKERRQ(ierr); 
00244     <span class="comment">/* Get Info*/</span>
00245     ierr = DAGetInfo(m_DA,0, &amp;mx, &amp;my, &amp;mz, 0,0,0,0,0,0,0); CHKERRQ(ierr); 
00246 
00247     <span class="keywordflow">if</span> (x+m == mx) {
00248       xne=m-1;
00249     } <span class="keywordflow">else</span> {
00250       xne=m;
00251     }
00252     <span class="keywordflow">if</span> (y+n == my) {
00253       yne=n-1;
00254     } <span class="keywordflow">else</span> {
00255       yne=n;
00256     }
00257     <span class="keywordflow">if</span> (z+p == mz) {
00258       zne=p-1;
00259     } <span class="keywordflow">else</span> {
00260       zne=p;
00261     }
00262 
00263     <span class="keywordtype">double</span> norm;
00264 
00265 <span class="preprocessor">#ifdef __DEBUG__</span>
00266 <span class="preprocessor"></span>    VecNorm(_in, NORM_INFINITY, &amp;norm);
00267     std::cout &lt;&lt; <span class="stringliteral">" norm of _in in feVector.cpp before adding force = "</span> &lt;&lt; norm &lt;&lt; std::endl;
00268 <span class="preprocessor">#endif</span>
00269 <span class="preprocessor"></span>
00270     ierr = DAGetLocalVector(m_DA,&amp;inlocal); CHKERRQ(ierr);
00271 
00272     ierr = VecZeroEntries(inlocal); CHKERRQ(ierr);
00273 
00274     ierr = DAVecGetArray(m_DA,inlocal, &amp;in);
00275 
00276     <span class="comment">// Any derived class initializations ...</span>
00277     <span class="comment">// std::cout &lt;&lt; __func__ &lt;&lt; " -&gt; preAddVec " &lt;&lt; std::endl; </span>
00278     <a class="code" href="classot_1_1fem_1_1feVector.html#a17">preAddVec</a>();
00279 
00280     <span class="comment">// std::cout &lt;&lt; __func__ &lt;&lt; " -&gt; Elemental Loop " &lt;&lt; std::endl;</span>
00281     <span class="comment">// loop through all elements ...</span>
00282     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=z; k&lt;z+zne; k++){
00283       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=y; j&lt;y+yne; j++){
00284         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=x; i&lt;x+xne; i++){
00285           <span class="comment">// std::cout &lt;&lt; i &lt;&lt;"," &lt;&lt; j &lt;&lt; "," &lt;&lt; k &lt;&lt; std::endl;</span>
00286           <a class="code" href="classot_1_1fem_1_1feVector.html#a7">ElementalAddVec</a>(i, j, k, in, scale);
00287         } <span class="comment">// end i</span>
00288       } <span class="comment">// end j</span>
00289     } <span class="comment">// end k</span>
00290 
00291     <span class="comment">// std::cout &lt;&lt; __func__ &lt;&lt; " -&gt; postAddVec " &lt;&lt; std::endl;</span>
00292     <a class="code" href="classot_1_1fem_1_1feVector.html#a15">postAddVec</a>();
00293 
00294     ierr = DAVecRestoreArray(m_DA, inlocal, &amp;in);
00295 
00296     ierr = DALocalToGlobalBegin(m_DA,inlocal,_in); CHKERRQ(ierr);
00297     ierr = DALocalToGlobalEnd(m_DA,inlocal,_in); CHKERRQ(ierr);
00298 
00299     ierr = DARestoreLocalVector(m_DA,&amp;inlocal); CHKERRQ(ierr);
00300 
00301 <span class="preprocessor">#ifdef __DEBUG__</span>
00302 <span class="preprocessor"></span>    VecNorm(_in, NORM_INFINITY, &amp;norm);
00303     std::cout &lt;&lt; <span class="stringliteral">" norm of _in in feVector.cpp after adding force = "</span> &lt;&lt; norm &lt;&lt; std::endl;
00304 <span class="preprocessor">#endif</span>
00305 <span class="preprocessor"></span>    <span class="comment">// ierr = VecDestroy(outlocal); CHKERRQ(ierr);  </span>
00306 
00307   } <span class="keywordflow">else</span> {
00308     <span class="comment">// loop for octree DA.</span>
00309 
00310 
00311     PetscScalar *out=NULL;
00312     PetscScalar *in=NULL; 
00313 
00314     <span class="comment">// get Buffers ...</span>
00315     <span class="comment">//Nodal,Non-Ghosted,Read,1 dof, Get in array and get ghosts during computation</span>
00316     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(_in,   in, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,  m_uiDof);
00317 
00318 
00319     <span class="comment">// start comm for in ...</span>
00320     <span class="comment">//m_octDA-&gt;updateGhostsBegin&lt;PetscScalar&gt;(in, false, m_uiDof);</span>
00321     <span class="comment">//m_octDA-&gt;ReadFromGhostsBegin&lt;PetscScalar&gt;(in, false, m_uiDof);</span>
00322     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;PetscScalar&gt;(in, m_uiDof);
00323     <a class="code" href="classot_1_1fem_1_1feVector.html#a17">preAddVec</a>();
00324 
00325     <span class="comment">// Independent loop, loop through the nodes this processor owns..</span>
00326     <span class="keywordflow">for</span> ( <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA::INDEPENDENT&gt;(), <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA::WRITABLE&gt;(); <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA::INDEPENDENT&gt;(); <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA::INDEPENDENT&gt;() ) {
00327       <a class="code" href="classot_1_1fem_1_1feVector.html#a7">ElementalAddVec</a>( <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>(), in, scale); 
00328     }<span class="comment">//end INDEPENDENT</span>
00329 
00330     <span class="comment">// Wait for communication to end.</span>
00331     <span class="comment">//m_octDA-&gt;updateGhostsEnd&lt;PetscScalar&gt;(in);</span>
00332     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;PetscScalar&gt;(in);
00333 
00334     <span class="comment">// Dependent loop ...</span>
00335     <span class="keywordflow">for</span> ( <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA::DEPENDENT&gt;(), <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA::WRITABLE&gt;();<a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA::DEPENDENT&gt;(); <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA::DEPENDENT&gt;() ) {
00336       <a class="code" href="classot_1_1fem_1_1feVector.html#a7">ElementalAddVec</a>( <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>(), in, scale); 
00337     }<span class="comment">//end DEPENDENT</span>
00338 
00339     <a class="code" href="classot_1_1fem_1_1feVector.html#a15">postAddVec</a>();
00340 
00341     <span class="comment">// Restore Vectors ...</span>
00342     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(_in,   in, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,  m_uiDof);
00343 
00344   }
00345 
00346   PetscFunctionReturn(0);
00347 }
00348 
00360 <span class="preprocessor">#undef __FUNCT__</span>
00361 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "feVector_ComputeVec"</span>
00362 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00363 <span class="keywordtype">bool</span> feVector&lt;T&gt;::computeVec(Vec _in, Vec _out,<span class="keywordtype">double</span> scale){
00364   PetscFunctionBegin;
00365 
00366 <span class="preprocessor">#ifdef __DEBUG__</span>
00367 <span class="preprocessor"></span>  assert ( ( m_daType == PETSC ) || ( m_daType == OCT ) );
00368 <span class="preprocessor">#endif</span>
00369 <span class="preprocessor"></span>
00370   <span class="keywordtype">int</span> ierr;
00371   <span class="comment">// PetscScalar zero=0.0;</span>
00372 
00373   <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feVec.html#p1">m_daType</a> == PETSC) {
00374 
00375     PetscInt x,y,z,m,n,p;
00376     PetscInt mx,my,mz;
00377     <span class="keywordtype">int</span> xne,yne,zne;
00378 
00379     PetscScalar ***in;
00380     PetscScalar ***out;
00381 
00382 
00383     <span class="comment">/* Get all corners*/</span>
00384     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feVec.html#p0">m_DA</a> == NULL)
00385       std::cerr &lt;&lt; <span class="stringliteral">"Da is null"</span> &lt;&lt; std::endl;
00386 
00387     ierr = DAGetCorners(m_DA,&amp;x,&amp;y,&amp;z,&amp;m,&amp;n,&amp;p); CHKERRQ(ierr);
00388     ierr = DAVecGetArray(m_DA,_in,&amp;in); CHKERRQ(ierr);
00389     ierr = DAVecGetArray(m_DA,_out,&amp;out); CHKERRQ(ierr);
00390     <span class="comment">// Any derived class initializations ...</span>
00391     <a class="code" href="classot_1_1fem_1_1feVector.html#a18">preComputeVec</a>();
00392 
00393     <span class="comment">// loop through all elements ...</span>
00394     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=z; k&lt;z+p; k++){
00395       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=y; j&lt;y+n; j++){
00396         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=x; i&lt;x+m; i++){
00397           <span class="comment">// std::cout &lt;&lt; i &lt;&lt;"," &lt;&lt; j &lt;&lt; "," &lt;&lt; k &lt;&lt; std::endl;</span>
00398           <a class="code" href="classot_1_1fem_1_1feVector.html#a4">ComputeNodalFunction</a>(i, j, k, in, out,scale);
00399         } <span class="comment">// end i</span>
00400       } <span class="comment">// end j</span>
00401     } <span class="comment">// end k</span>
00402 
00403     <a class="code" href="classot_1_1fem_1_1feVector.html#a16">postComputeVec</a>();
00404 
00405 
00406     ierr = DAVecRestoreArray(m_DA,_in,&amp;in); CHKERRQ(ierr);
00407     ierr = DAVecRestoreArray(m_DA,_out,&amp;out); CHKERRQ(ierr);
00408 
00409   } <span class="keywordflow">else</span> {
00410     <span class="comment">// loop for octree DA.</span>
00411 
00412 
00413     PetscScalar *out=NULL;
00414     PetscScalar *in=NULL; 
00415 
00416     <span class="comment">// get Buffers ...</span>
00417     <span class="comment">//Nodal,Non-Ghosted,Read,1 dof, Get in array </span>
00418     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(_in,   in, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,  m_uiDof);
00419     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(_in,   out, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,m_uiDof);
00420 
00421     <a class="code" href="classot_1_1fem_1_1feVector.html#a17">preAddVec</a>();
00422 
00423     <span class="comment">// Independent loop, loop through the nodes this processor owns..</span>
00424     <span class="keywordflow">for</span> ( <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA::INDEPENDENT&gt;(), <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA::WRITABLE&gt;(); <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA::INDEPENDENT&gt;(); <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA::INDEPENDENT&gt;() ) {
00425       <a class="code" href="classot_1_1fem_1_1feVector.html#a4">ComputeNodalFunction</a>(in, out,scale); 
00426     }<span class="comment">//end INDEPENDENT</span>
00427 
00428 
00429     <a class="code" href="classot_1_1fem_1_1feVector.html#a15">postAddVec</a>();
00430 
00431     <span class="comment">// Restore Vectors ...</span>
00432     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(_in,   in, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,  m_uiDof);
00433     <a class="code" href="classot_1_1fem_1_1feVec.html#p6">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(_out,  out,<span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, m_uiDof);
00434 
00435   }
00436 
00437   PetscFunctionReturn(0);
00438 }
00439 
00440 <span class="preprocessor">#undef __FUNCT__</span>
00441 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "alignElementAndVertices"</span>
00442 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00443 PetscErrorCode feVector&lt;T&gt;::alignElementAndVertices(<a class="code" href="classot_1_1DA.html">ot::DA</a> * da, 
00444     stdElemType &amp; sType, ot::index* indices) {
00445   PetscFunctionBegin;
00446 
00447   sType = ST_0;
00448   da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00449 
00450   <span class="comment">// not required ....</span>
00451   <span class="comment">// int rank;</span>
00452   <span class="comment">// MPI_Comm_rank(da-&gt;getComm(), &amp;rank);</span>
00453 
00454   <span class="keywordflow">if</span> (da-&gt;<a class="code" href="classot_1_1DA.html#z36_11">isHanging</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>())) {
00455 
00456     <span class="keywordtype">int</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00457     <a class="code" href="classPoint.html">Point</a> pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();   
00458 
00459     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hangingMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());    
00460 
00461     <span class="comment">//Change HangingMask and indices based on childNum</span>
00462     <a class="code" href="classot_1_1fem_1_1feVector.html#a14">mapVtxAndFlagsToOrientation</a>(childNum, indices, hangingMask);    
00463 
00464     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> eType = ((126 &amp; hangingMask)&gt;&gt;1);
00465 
00466     <a class="code" href="classot_1_1fem_1_1feVector.html#a19">reOrderIndices</a>(eType, indices);
00467   }<span class="comment">//end if hangingElem.</span>
00468   PetscFunctionReturn(0);
00469 }<span class="comment">//end function.</span>
00470 
00471 <span class="preprocessor">#undef __FUNCT__</span>
00472 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "mapVtxAndFlagsToOrientation"</span>
00473 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00474 PetscErrorCode feVector&lt;T&gt;::mapVtxAndFlagsToOrientation(<span class="keywordtype">int</span> childNum, 
00475 ot::index* indices, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> &amp; mask) {
00476   PetscFunctionBegin;
00477   ot::index tmp[8];
00478   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmpFlags = 0;
00479   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00480     tmp[i] = indices[<a class="code" href="classot_1_1fem_1_1feVector.html#p3">m_ucpLut</a>[childNum][i]];
00481     tmpFlags = ( tmpFlags | ( ( (1 &lt;&lt; (m_ucpLut[childNum][i])) &amp; mask ) ? (1 &lt;&lt; i) : 0 ) );
00482   }
00483   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;8;i++) {
00484     indices[i] = tmp[i];
00485   }
00486   mask = tmpFlags;
00487   PetscFunctionReturn(0);
00488 }<span class="comment">//end function</span>
00489 
00490 <span class="preprocessor">#undef __FUNCT__</span>
<a name="l00491"></a><a class="code" href="feVector_8txx.html#a9">00491</a> <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "reOrderIndices"</span>
00492 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00493 PetscErrorCode feVector&lt;T&gt;::reOrderIndices(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> eType, ot::index* indices) {
00494 <span class="preprocessor">#ifdef __DEBUG_1</span>
00495 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">"Entering "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
00496 <span class="preprocessor">#endif</span>
00497 <span class="preprocessor"></span>  PetscFunctionBegin;
00498   ot::index tmp;
00499   <span class="keywordflow">switch</span> (eType) {
00500     <span class="keywordflow">case</span>  ET_N: 
00501       <span class="keywordflow">break</span>;
00502     <span class="keywordflow">case</span>  ET_Y:
00503       <span class="keywordflow">break</span>;
00504     <span class="keywordflow">case</span>  ET_X:
00505       <span class="comment">//Swap 1 &amp; 2, Swap 5 &amp; 6</span>
00506       tmp = indices[1];
00507       indices[1] = indices[2];
00508       indices[2] = tmp;
00509       tmp = indices[5];
00510       indices[5] = indices[6];
00511       indices[6] = tmp;
00512       <span class="keywordflow">break</span>;
00513     <span class="keywordflow">case</span>  ET_XY:
00514       <span class="keywordflow">break</span>;
00515     <span class="keywordflow">case</span>  ET_Z:
00516       <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00517       tmp = indices[2];
00518       indices[2] = indices[4];
00519       indices[4] = tmp;
00520       tmp = indices[3];
00521       indices[3] = indices[5];
00522       indices[5] = tmp;
00523       <span class="keywordflow">break</span>;
00524     <span class="keywordflow">case</span>  ET_ZY:
00525       <span class="comment">//Swap 1 &amp; 4, Swap 3 &amp; 6</span>
00526       tmp = indices[1];
00527       indices[1] = indices[4];
00528       indices[4] = tmp;
00529       tmp = indices[3];
00530       indices[3] = indices[6];
00531       indices[6] = tmp;
00532       <span class="keywordflow">break</span>;
00533     <span class="keywordflow">case</span>  ET_ZX:
00534       <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00535       tmp = indices[2];
00536       indices[2] = indices[4];
00537       indices[4] = tmp;
00538       tmp = indices[3];
00539       indices[3] = indices[5];
00540       indices[5] = tmp;
00541       <span class="keywordflow">break</span>;
00542     <span class="keywordflow">case</span>  ET_ZXY:
00543       <span class="keywordflow">break</span>;
00544     <span class="keywordflow">case</span>  ET_XY_XY:
00545       <span class="keywordflow">break</span>;
00546     <span class="keywordflow">case</span>  ET_XY_ZXY:
00547       <span class="keywordflow">break</span>;
00548     <span class="keywordflow">case</span>  ET_YZ_ZY:
00549       <span class="comment">//Swap 1 &amp; 4, Swap 3 &amp; 6</span>
00550       tmp = indices[1];
00551       indices[1] = indices[4];
00552       indices[4] = tmp;
00553       tmp = indices[3];
00554       indices[3] = indices[6];
00555       indices[6] = tmp;
00556       <span class="keywordflow">break</span>;
00557     <span class="keywordflow">case</span>  ET_YZ_ZXY:
00558       <span class="comment">//Swap 1 &amp; 4, Swap 3 &amp; 6</span>
00559       tmp = indices[1];
00560       indices[1] = indices[4];
00561       indices[4] = tmp;
00562       tmp = indices[3];
00563       indices[3] = indices[6];
00564       indices[6] = tmp;
00565       <span class="keywordflow">break</span>;
00566     <span class="keywordflow">case</span>  ET_YZ_XY_ZXY:
00567       <span class="keywordflow">break</span>;
00568     <span class="keywordflow">case</span>  ET_ZX_ZX:
00569       <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00570       tmp = indices[2];
00571       indices[2] = indices[4];
00572       indices[4] = tmp;
00573       tmp = indices[3];
00574       indices[3] = indices[5];
00575       indices[5] = tmp;
00576       <span class="keywordflow">break</span>;
00577     <span class="keywordflow">case</span>  ET_ZX_ZXY:
00578       <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00579       tmp = indices[2];
00580       indices[2] = indices[4];
00581       indices[4] = tmp;
00582       tmp = indices[3];
00583       indices[3] = indices[5];
00584       indices[5] = tmp;
00585       <span class="keywordflow">break</span>;
00586     <span class="keywordflow">case</span>  ET_ZX_XY_ZXY:
00587       <span class="comment">//Swap 1 &amp; 2, Swap 5 &amp; 6</span>
00588       tmp = indices[1];
00589       indices[1] = indices[2];
00590       indices[2] = tmp;
00591       tmp = indices[5];
00592       indices[5] = indices[6];
00593       indices[6] = tmp;
00594       <span class="keywordflow">break</span>;
00595     <span class="keywordflow">case</span>  ET_ZX_YZ_ZXY:
00596       <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00597       tmp = indices[2];
00598       indices[2] = indices[4];
00599       indices[4] = tmp;
00600       tmp = indices[3];
00601       indices[3] = indices[5];
00602       indices[5] = tmp;
00603       <span class="keywordflow">break</span>;
00604     <span class="keywordflow">case</span>  ET_ZX_YZ_XY_ZXY:
00605       <span class="keywordflow">break</span>;
00606     <span class="keywordflow">default</span>:
00607       std::cout&lt;&lt;<span class="stringliteral">"in reOrder Etype: "</span>&lt;&lt; (int) eType &lt;&lt; std::endl;
00608       assert(<span class="keyword">false</span>);
00609   }
00610 <span class="preprocessor">#ifdef __DEBUG_1</span>
00611 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">"Leaving "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
00612 <span class="preprocessor">#endif</span>
00613 <span class="preprocessor"></span>  PetscFunctionReturn(0);
00614 }
00615 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:27 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
