<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/examples/odaJac.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">examples</a></div>
<h1>odaJac.C</h1><a href="odaJac_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "petsc.h"</span>
00008 <span class="preprocessor">#include "petscvec.h"</span>
00009 <span class="preprocessor">#include "petscmat.h"</span>
00010 <span class="preprocessor">#include "<a class="code" href="odaJac_8h.html">odaJac.h</a>"</span>
00011 
00012 <span class="preprocessor">#ifdef PETSC_USE_LOG</span>
00013 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> Jac1DiagEvent;
00014 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac1MultEvent;
00015 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac1FinestDiagEvent;
00016 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac1FinestMultEvent;
00017 <span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span>
00019 <span class="keyword">extern</span> <span class="keywordtype">double</span>**** LaplacianType2Stencil; 
00020 <span class="keyword">extern</span> <span class="keywordtype">double</span>**** MassType2Stencil; 
00021 
<a name="l00022"></a><a class="code" href="odaJac_8h.html#a9">00022</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a9">Jacobian1ShellMatMult</a>(Mat J, Vec in, Vec out) {
00023   PetscFunctionBegin;
00024 
00025   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* ctx;
00026 
00027   MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;ctx));
00028 
00029   assert(ctx != NULL);
00030   assert(ctx-&gt;da != NULL);  
00031 
00032   <span class="keywordflow">if</span>(ctx-&gt;da-&gt;iAmActive()) {      
00033     PetscScalar* inArray;
00034     PetscScalar* outArray;
00035 
00036     VecGetArray(in, &amp;inArray);
00037     VecGetArray(out, &amp;outArray);
00038 
00039     VecPlaceArray(ctx-&gt;inTmp, inArray);
00040     VecPlaceArray(ctx-&gt;outTmp, outArray);
00041 
00042     MatMult(ctx-&gt;Jmat_private, ctx-&gt;inTmp, ctx-&gt;outTmp);
00043 
00044     VecResetArray(ctx-&gt;inTmp);
00045     VecResetArray(ctx-&gt;outTmp);
00046 
00047     VecRestoreArray(in, &amp;inArray);
00048     VecRestoreArray(out, &amp;outArray);
00049   }
00050 
00051   PetscFunctionReturn(0);
00052 }
00053 
<a name="l00054"></a><a class="code" href="odaJac_8h.html#a2">00054</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a5">CreateJacobian1</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a> *da, Mat *jac)
00055 {
00056   PetscInt  m,n;
00057   PetscFunctionBegin;
00058   <span class="comment">//The size this processor owns ( without ghosts).</span>
00059   m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00060   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* data = <span class="keyword">new</span> <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>;
00061   data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a> = da;
00062   data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00063   data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00064   data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00065   data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">true</span>;<span class="comment">//single grid is always the finest.</span>
00066   <a class="code" href="omg_8C.html#a0">iC</a>(MatCreateShell(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(), m ,n,PETSC_DETERMINE,PETSC_DETERMINE,
00067         (<span class="keywordtype">void</span>*)(data), jac));
00068   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a13">Jacobian1MatMult</a>));
00069   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a11">Jacobian1MatGetDiagonal</a>));
00070   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a9">Jacobian1MatDestroy</a>));
00071   PetscFunctionReturn(0);
00072 }
00073 
<a name="l00074"></a><a class="code" href="odaJac_8h.html#a3">00074</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a3">CreateActiveJacobian1</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a> *da, Mat *jac)
00075 {
00076   PetscInt  m,n;
00077   PetscFunctionBegin;
00078   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00079     <span class="comment">//The size this processor owns ( without ghosts).</span>
00080     m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00081     <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* data = <span class="keyword">new</span> <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>;
00082     data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a> = da;
00083     data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00084     data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00085     data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00086     data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">true</span>;<span class="comment">//single grid is always the finest.</span>
00087     <a class="code" href="omg_8C.html#a0">iC</a>(MatCreateShell(da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>(), m ,n,PETSC_DETERMINE,PETSC_DETERMINE,
00088           (<span class="keywordtype">void</span>*)(data), jac));
00089     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a13">Jacobian1MatMult</a>));
00090     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a11">Jacobian1MatGetDiagonal</a>));
00091     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a9">Jacobian1MatDestroy</a>));
00092   }
00093   PetscFunctionReturn(0);
00094 }
00095 
<a name="l00096"></a><a class="code" href="odaJac_8h.html#a4">00096</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a6">ComputeJacobian1</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da, Mat J)
00097 {
00098   PetscFunctionBegin;
00099   <span class="comment">//Do nothing</span>
00100   PetscFunctionReturn(0);
00101 }
00102 
<a name="l00103"></a><a class="code" href="odaJac_8h.html#a7">00103</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a9">CreateAndComputeMassMatrix</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da, Mat* jac) {
00104   PetscInt  m,n;
00105   PetscFunctionBegin;
00106   <span class="comment">//The size this processor owns ( without ghosts).</span>
00107   m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00108   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* data = <span class="keyword">new</span> <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>;
00109   data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a> = da;
00110   data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00111   data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00112   data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00113   <a class="code" href="omg_8C.html#a0">iC</a>(MatCreateShell(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(), m ,n,PETSC_DETERMINE,PETSC_DETERMINE, (<span class="keywordtype">void</span>*)(data), jac));
00114   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a14">MassMatMult</a>));
00115   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a12">MassMatGetDiagonal</a>));
00116   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a10">MassMatDestroy</a>));
00117   PetscFunctionReturn(0);
00118 }
00119 
<a name="l00120"></a><a class="code" href="odaJac_8h.html#a13">00120</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a13">Jacobian1MatDestroy</a>(Mat J) {
00121   PetscFunctionBegin;
00122   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00123   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext( J, (<span class="keywordtype">void</span> **)&amp;data));
00124   <span class="keywordflow">if</span>(data != NULL) {
00125     <span class="keywordflow">if</span>(J != data-&gt;Jmat_private) {
00126       <span class="keywordflow">if</span>(data-&gt;Jmat_private) {
00127         MatDestroy(data-&gt;Jmat_private);
00128         data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00129       }
00130     }
00131     <span class="keywordflow">if</span>(data-&gt;inTmp) {
00132       VecDestroy(data-&gt;inTmp);
00133       data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00134     }
00135     <span class="keywordflow">if</span>(data-&gt;outTmp) {
00136       VecDestroy(data-&gt;outTmp);
00137       data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00138     }
00139     <span class="keyword">delete</span> data;
00140     data = NULL;
00141   }
00142   PetscFunctionReturn(0);
00143 }
00144 
<a name="l00145"></a><a class="code" href="odaJac_8h.html#a14">00145</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a14">MassMatDestroy</a>(Mat J) {
00146   PetscFunctionBegin;    
00147   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00148   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext( J, (<span class="keywordtype">void</span> **)&amp;data));
00149   <span class="keywordflow">if</span>(data) {
00150     <span class="keywordflow">if</span>(data-&gt;Jmat_private) {
00151       MatDestroy(data-&gt;Jmat_private);
00152       data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00153     }
00154     <span class="keyword">delete</span> data;
00155     data = NULL;
00156   }
00157   PetscFunctionReturn(0);
00158 }
00159 
<a name="l00160"></a><a class="code" href="odaJac_8h.html#a11">00160</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a11">Jacobian1MatGetDiagonal</a>(Mat J, Vec diag) {
00161   PetscFunctionBegin;
00162 
00163   PetscLogEventBegin(Jac1DiagEvent,diag,0,0,0);
00164   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00165   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span> **)&amp;data));
00166   <span class="keywordflow">if</span>(data-&gt;isFinestLevel) {
00167     PetscLogEventBegin(Jac1FinestDiagEvent,diag,0,0,0);
00168   }
00169   <a class="code" href="omg_8C.html#a0">iC</a>(VecZeroEntries(diag));
00170 
00171   PetscScalar *diagArr;
00172   <span class="comment">//Nodal,Non-Ghosted,Write,1 dof</span>
00173   data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(diag,diagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00174 
00175   <span class="comment">//If Required Use Some Problem Specific information and set xFac, yFac, zFac.</span>
00176   <span class="comment">//Here, I'm simply assuming that the domain is of unit size.</span>
00177   <span class="comment">//To get the physical dimension of any element in a particular direction say</span>
00178   <span class="comment">//'x', xFac will be multiplied by (1u &lt;&lt; (maxD-level)) of that element.</span>
00179   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00180   <span class="keywordtype">double</span> hFac;
00181 
00182   PetscReal lapFac = 1.0;
00183   PetscReal massFac = 1.0;
00184   PetscTruth optFound;
00185   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00186   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;massFac,&amp;optFound);
00187 
00188   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00189     maxD = (data-&gt;da-&gt;getMaxDepth());
00190     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00191 
00192     <span class="comment">//Loop through All Elements including ghosted</span>
00193     <span class="keywordflow">for</span>(data-&gt;da-&gt;init&lt;ot::DA_FLAGS::ALL&gt;();
00194         data-&gt;da-&gt;curr() &lt; data-&gt;da-&gt;end&lt;ot::DA_FLAGS::ALL&gt;(); 
00195         data-&gt;da-&gt;next&lt;ot::DA_FLAGS::ALL&gt;()) {
00196       <span class="comment">//This returns the 8 vertices in the Morton order.</span>
00197       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(data-&gt;da-&gt;curr());
00198       <span class="keywordtype">double</span> h = hFac*(1u &lt;&lt; (maxD - lev));
00199       <span class="keywordtype">double</span> fac1 = lapFac*h/2.0;
00200       <span class="keywordtype">double</span> fac2 = massFac*h*h*h/8.0;
00201       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00202       data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00203       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00204       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(data-&gt;da-&gt;curr()); 
00205       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00206       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00207         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0;k &lt; 8;k++) {
00208           diagArr[indices[k]] +=  ((fac1*(<a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>[childNum][elemType][k][k])) +  
00209               (fac2*(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>[childNum][elemType][k][k])));
00210         }<span class="comment">//end k</span>
00211     }<span class="comment">//end i</span>
00212   }
00213 
00214   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(diag,diagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00215 
00216   PetscLogFlops(44*(data-&gt;da-&gt;getGhostedElementSize()));
00217   PetscLogEventEnd(Jac1DiagEvent,diag,0,0,0);
00218   <span class="keywordflow">if</span>(data-&gt;isFinestLevel) {
00219     PetscLogEventEnd(Jac1FinestDiagEvent,diag,0,0,0);
00220   }
00221 
00222   PetscFunctionReturn(0);
00223 }
00224 
<a name="l00225"></a><a class="code" href="odaJac_8h.html#a12">00225</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a12">MassMatGetDiagonal</a>(Mat J, Vec diag) {
00226   PetscFunctionBegin;  
00227   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00228   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span> **)&amp;data));
00229   <a class="code" href="omg_8C.html#a0">iC</a>(VecZeroEntries(diag));
00230 
00231   <span class="comment">//If Required Use Some Problem Specific information and set xFac, yFac, zFac.</span>
00232   <span class="comment">//Here, I'm simply assuming that the domain is of unit size.</span>
00233   <span class="comment">//To get the physical dimension of any element in a particular direction say</span>
00234   <span class="comment">//'x', xFac will be multiplied by (1u &lt;&lt; (maxD-level)) of that element.</span>
00235   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00236   <span class="keywordtype">double</span> hFac;
00237   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00238     maxD = (data-&gt;da-&gt;getMaxDepth());
00239     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00240   }
00241 
00242   PetscScalar *diagArr;
00243   <span class="comment">//Nodal,Non-Ghosted,Write,1 dof</span>
00244   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(diag,diagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00245 
00246   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00247     <span class="comment">//Loop through All Elements including ghosted</span>
00248     <span class="keywordflow">for</span>(data-&gt;da-&gt;init&lt;ot::DA_FLAGS::ALL&gt;();
00249         data-&gt;da-&gt;curr() &lt; data-&gt;da-&gt;end&lt;ot::DA_FLAGS::ALL&gt;();
00250         data-&gt;da-&gt;next&lt;ot::DA_FLAGS::ALL&gt;()) {
00251       <span class="comment">//This returns the 8 vertices in the Morton order.</span>
00252       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(data-&gt;da-&gt;curr());
00253       <span class="keywordtype">double</span> h = hFac*(1u &lt;&lt; (maxD - lev));
00254       <span class="keywordtype">double</span> fac2 = h*h*h/8.0;
00255       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00256       data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00257       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00258       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(data-&gt;da-&gt;curr()); 
00259       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00260       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00261         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0;k &lt; 8;k++) {
00262           diagArr[indices[k]] +=  (fac2*(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>[childNum][elemType][k][k]));
00263         }<span class="comment">//end k        </span>
00264     }<span class="comment">//end i</span>
00265   }
00266 
00267   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(diag,diagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);  
00268   PetscFunctionReturn(0);
00269 }
00270 
<a name="l00271"></a><a class="code" href="odaJac_8C.html#a0">00271</a> <span class="preprocessor">#define JACOBIAN_TYPE1_MULT_BLOCK {\</span>
00272 <span class="preprocessor">  unsigned int lev = data-&gt;da-&gt;getLevel(data-&gt;da-&gt;curr());\</span>
00273 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00274 <span class="preprocessor">  double fac1 = lapFac*h/2.0;\</span>
00275 <span class="preprocessor">  double fac2 = massFac*h*h*h/8.0;\</span>
00276 <span class="preprocessor">  unsigned int indices[8];\</span>
00277 <span class="preprocessor">  data-&gt;da-&gt;getNodeIndices(indices);\</span>
00278 <span class="preprocessor">  unsigned char childNum = data-&gt;da-&gt;getChildNumber();\</span>
00279 <span class="preprocessor">  unsigned char hnMask = data-&gt;da-&gt;getHangingNodeIndex(data-&gt;da-&gt;curr());\</span>
00280 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00281 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00282 <span class="preprocessor">  for(int k = 0;k &lt; 8;k++) {\</span>
00283 <span class="preprocessor">    for(int j=0;j&lt;8;j++) {\</span>
00284 <span class="preprocessor">      outArr[indices[k]] +=  (((fac1*(LaplacianType2Stencil[childNum][elemType][k][j])) +\</span>
00285 <span class="preprocessor">            (fac2*(MassType2Stencil[childNum][elemType][k][j])))*inArr[indices[j]]);\</span>
00286 <span class="preprocessor">    } </span><span class="comment">/*end for j*/</span>\
00287   } <span class="comment">/*end for k*/</span>\
00288 }
00289 
<a name="l00290"></a><a class="code" href="odaJac_8h.html#a8">00290</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a8">Jacobian1MatMult</a>(Mat J, Vec in, Vec out)
00291 {
00292   PetscFunctionBegin;
00293 
00294   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00295   PetscLogEventBegin(Jac1MultEvent,in,out,0,0);
00296   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext( J, (<span class="keywordtype">void</span> **)&amp;data));  
00297   <span class="keywordflow">if</span>(data-&gt;isFinestLevel) {
00298     PetscLogEventBegin(Jac1FinestMultEvent,in,out,0,0);
00299   }
00300   <a class="code" href="omg_8C.html#a0">iC</a>(VecZeroEntries(out));
00301 
00302   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00303   <span class="keywordtype">double</span> hFac;
00304   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00305     maxD = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>(); 
00306     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00307   }
00308 
00309   PetscReal lapFac = 1.0;
00310   PetscReal massFac = 1.0;
00311   PetscTruth optFound;
00312   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00313   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;massFac,&amp;optFound);
00314 
00315   PetscScalar *outArr=NULL;
00316   PetscScalar *inArr=NULL; 
00317   <span class="comment">//Nodal,Non-Ghosted,Read,1 dof</span>
00318   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in,inArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,1);
00319 
00320   <span class="comment">//std::cout &lt;&lt; __func__ &lt;&lt; ": Updating Ghost..." &lt;&lt; std::endl;</span>
00321   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00322     data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;PetscScalar&gt;(inArr,1);
00323   }
00324 
00325   <span class="comment">//Nodal,Non-Ghosted,Write,1 dof</span>
00326   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(out,outArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00327 
00328   <span class="comment">//Loop through All Independent Elements     </span>
00329 
00330   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00331     <span class="keywordflow">for</span>(data-&gt;da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;();
00332         data-&gt;da-&gt;curr() &lt; data-&gt;da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();
00333         data-&gt;da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;() ) {
00334       <a class="code" href="odaJac_8C.html#a0">JACOBIAN_TYPE1_MULT_BLOCK</a>
00335     }<span class="comment">//end independent</span>
00336   }
00337 
00338   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00339     data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;PetscScalar&gt;(inArr);
00340   }
00341   <span class="comment">//Loop through All Dependent Elements, i.e. Elements which have atleast one</span>
00342   <span class="comment">//vertex owned by this processor and at least one vertex not owned by this</span>
00343   <span class="comment">//processor. For simplicity, I may write to nodes that I do not own. These</span>
00344   <span class="comment">//can be discarded later. Every processor is only supposed to write to the</span>
00345   <span class="comment">//nodes it owns. An alternate strategy would require me to check if i own the</span>
00346   <span class="comment">//node before i write, I think this might be inefficient. So, if possible</span>
00347   <span class="comment">//allow me to write to nodes I do not own. You can discard them while</span>
00348   <span class="comment">//restoring the buffers.</span>
00349   <span class="comment">//Note: Whenever, I refer to nodes I refer to regular nodes only. If any of the</span>
00350   <span class="comment">//vertices are hanging then the regular node that will be used instead is used</span>
00351   <span class="comment">//to make the classifications such as ghost or non-ghost elem/node.</span>
00352 
00353   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00354     <span class="keywordflow">for</span>(data-&gt;da-&gt;init&lt;ot::DA_FLAGS::DEPENDENT&gt;();
00355         data-&gt;da-&gt;curr() &lt; data-&gt;da-&gt;end&lt;ot::DA_FLAGS::DEPENDENT&gt;();
00356         data-&gt;da-&gt;next&lt;ot::DA_FLAGS::DEPENDENT&gt;() ) {
00357       <a class="code" href="odaJac_8C.html#a0">JACOBIAN_TYPE1_MULT_BLOCK</a>
00358     }<span class="comment">//end loop for dependent elems</span>
00359   }
00360 
00361   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in,inArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,1);
00362   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(out,outArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00363 
00364   <span class="comment">//Only useful flops, i.e. flops for the FEM calculation itself, are included.</span>
00365   <span class="comment">//The overhead due to looping through the octants and uncompressing the</span>
00366   <span class="comment">//nodelist and the transformations for the maps are not included. </span>
00367   PetscLogFlops(332*(data-&gt;da-&gt;getGhostedElementSize()));
00368   PetscLogEventEnd(Jac1MultEvent,in,out,0,0);
00369   <span class="keywordflow">if</span>(data-&gt;isFinestLevel) {
00370     PetscLogEventEnd(Jac1FinestMultEvent,in,out,0,0);
00371   }
00372 
00373   PetscFunctionReturn(0);
00374 }
00375 
00376 <span class="preprocessor">#undef JACOBIAN_TYPE1_MULT_BLOCK</span>
00377 <span class="preprocessor"></span>
<a name="l00378"></a><a class="code" href="odaJac_8C.html#a1">00378</a> <span class="preprocessor">#define MASS_MULT_BLOCK {\</span>
00379 <span class="preprocessor">  unsigned int lev = data-&gt;da-&gt;getLevel(data-&gt;da-&gt;curr());\</span>
00380 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00381 <span class="preprocessor">  double fac2 = h*h*h/8.0;\</span>
00382 <span class="preprocessor">  unsigned int indices[8];\</span>
00383 <span class="preprocessor">  data-&gt;da-&gt;getNodeIndices(indices);\</span>
00384 <span class="preprocessor">  unsigned char childNum = data-&gt;da-&gt;getChildNumber();\</span>
00385 <span class="preprocessor">  unsigned char hnMask = data-&gt;da-&gt;getHangingNodeIndex(data-&gt;da-&gt;curr());\</span>
00386 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00387 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00388 <span class="preprocessor">  for(int k = 0;k &lt; 8;k++) {\</span>
00389 <span class="preprocessor">    for(int j=0;j&lt;8;j++) {\</span>
00390 <span class="preprocessor">      outArr[indices[k]] +=  ((fac2*(MassType2Stencil[childNum][elemType][k][j]))*inArr[indices[j]]);\</span>
00391 <span class="preprocessor">    } </span><span class="comment">/*end for j*/</span>\
00392   } <span class="comment">/*end for k*/</span>\
00393 }
00394 
<a name="l00395"></a><a class="code" href="odaJac_8h.html#a10">00395</a> PetscErrorCode <a class="code" href="odaJac_8h.html#a10">MassMatMult</a>(Mat J, Vec in, Vec out)
00396 {
00397   PetscFunctionBegin;
00398   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00399 
00400   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext( J, (<span class="keywordtype">void</span> **)&amp;data));  
00401 
00402   <a class="code" href="omg_8C.html#a0">iC</a> (VecSet(out, 0));
00403 
00404   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00405   <span class="keywordtype">double</span> hFac;
00406 
00407   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00408     maxD = data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>(); 
00409     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00410   }
00411 
00412   PetscScalar *outArr=NULL;
00413   PetscScalar *inArr=NULL; 
00414   <span class="comment">//Nodal,Non-Ghosted,Read,1 dof</span>
00415   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in,inArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,1);
00416 
00417   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00418     data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;PetscScalar&gt;(inArr,1);
00419   }
00420 
00421   <span class="comment">//Nodal,Non-Ghosted,Write,1 dof</span>
00422   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(out,outArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00423 
00424   <span class="comment">//Loop through All Independent Elements     </span>
00425   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00426     <span class="keywordflow">for</span>(data-&gt;da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;();
00427         data-&gt;da-&gt;curr() &lt; data-&gt;da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();
00428         data-&gt;da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;() ) {
00429       <a class="code" href="odaJac_8C.html#a1">MASS_MULT_BLOCK</a>
00430     }<span class="comment">//end independent</span>
00431   }
00432 
00433   <span class="comment">// std::cout &lt;&lt; "Finished Independent" &lt;&lt; std::endl;</span>
00434   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00435     data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;PetscScalar&gt;(inArr);
00436   }
00437   <span class="comment">//Loop through All Dependent Elements, i.e. Elements which have atleast one</span>
00438   <span class="comment">//vertex owned by this processor and at least one vertex not owned by this</span>
00439   <span class="comment">//processor. For simplicity, I may write to nodes that I do not own. These</span>
00440   <span class="comment">//can be discarded later. Every processor is only supposed to write to the</span>
00441   <span class="comment">//nodes it owns. An alternate strategy would require me to check if i own the</span>
00442   <span class="comment">//node before i write, I think this might be inefficient. So, if possible</span>
00443   <span class="comment">//allow me to write to nodes I do not own. You can discard them while</span>
00444   <span class="comment">//restoring the buffers.</span>
00445   <span class="comment">//Note: Whenever, I refer to nodes I refer to regular nodes only. If any of the</span>
00446   <span class="comment">//vertices are hanging then the regular node that will be used instead is used</span>
00447   <span class="comment">//to make the classifications such as ghost or non-ghost elem/node.</span>
00448 
00449   <span class="keywordflow">if</span>(data-&gt;da-&gt;iAmActive()) {
00450     <span class="keywordflow">for</span>(data-&gt;da-&gt;init&lt;ot::DA_FLAGS::DEPENDENT&gt;();
00451         data-&gt;da-&gt;curr() &lt; data-&gt;da-&gt;end&lt;ot::DA_FLAGS::DEPENDENT&gt;();
00452         data-&gt;da-&gt;next&lt;ot::DA_FLAGS::DEPENDENT&gt;() ) {
00453       <a class="code" href="odaJac_8C.html#a1">MASS_MULT_BLOCK</a>
00454     }<span class="comment">//end loop for dependent elems</span>
00455   }
00456 
00457   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in,inArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,1);
00458 
00459   data-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(out,outArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00460 
00461   PetscFunctionReturn(0);
00462 }
00463 
00464 <span class="preprocessor">#undef MASS_MULT_BLOCK </span>
00465 <span class="preprocessor"></span>
<a name="l00466"></a><a class="code" href="odaJac_8h.html#a5">00466</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a7">CreateAndComputeFullJacobian1</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da,Mat * J)
00467 {
00468   PetscFunctionBegin;
00469 
00470   assert(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>());
00471 
00472   <span class="keywordtype">char</span> matType[30];
00473   PetscTruth typeFound;
00474   PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00475   <span class="keywordflow">if</span>(!typeFound) {
00476     std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00477     MPI_Finalize();
00478     exit(0);            
00479   } 
00480   da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*J, matType, 1);
00481   MatZeroEntries(*J);
00482   std::vector&lt;ot::MatRecord&gt; records;
00483 
00484   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00485   <span class="keywordtype">double</span> hFac;
00486   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00487     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>(); 
00488     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00489   }
00490 
00491 
00492   PetscReal lapFac = 1.0;
00493   PetscReal massFac = 1.0;
00494   PetscTruth optFound;
00495   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00496   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;massFac,&amp;optFound);
00497 
00498   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00499     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00500         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00501         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;()) {
00502       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00503       <span class="keywordtype">double</span> h = hFac*(1u &lt;&lt; (maxD - lev));
00504       <span class="keywordtype">double</span> fac1 = lapFac*h/2.0;
00505       <span class="keywordtype">double</span> fac2 = massFac*h*h*h/8.0;
00506       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00507       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00508       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00509       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00510       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00511       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00512         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0;k &lt; 8;k++) {
00513           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;8;j++) {
00514             <a class="code" href="classot_1_1MatRecord.html">ot::MatRecord</a> currRec;
00515             currRec.<a class="code" href="classot_1_1MatRecord.html#o3">rowIdx</a> = indices[k];
00516             currRec.<a class="code" href="classot_1_1MatRecord.html#o1">colIdx</a> = indices[j];
00517             currRec.<a class="code" href="classot_1_1MatRecord.html#o2">rowDim</a> = 0;
00518             currRec.<a class="code" href="classot_1_1MatRecord.html#o0">colDim</a> = 0;
00519             currRec.<a class="code" href="classot_1_1MatRecord.html#o4">val</a> = ((fac1*(<a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>[childNum][elemType][k][j])) +
00520                 (fac2*(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>[childNum][elemType][k][j])));
00521             records.push_back(currRec);
00522           }<span class="comment">//end for j</span>
00523         }<span class="comment">//end for k</span>
00524       <span class="keywordflow">if</span>(records.size() &gt; 1000) {
00525         da-&gt;<a class="code" href="classot_1_1DA.html#z35_9">setValuesInMatrix</a>(*J, records, 1, ADD_VALUES);
00526       }
00527     }<span class="comment">//end writable</span>
00528   }<span class="comment">//end if active</span>
00529 
00530   da-&gt;<a class="code" href="classot_1_1DA.html#z35_9">setValuesInMatrix</a>(*J, records, 1, ADD_VALUES);
00531 
00532   MatAssemblyBegin(*J, MAT_FINAL_ASSEMBLY);
00533   MatAssemblyEnd(*J, MAT_FINAL_ASSEMBLY);
00534 
00535   PetscFunctionReturn(0);
00536 }
00537 
<a name="l00538"></a><a class="code" href="odaJac_8h.html#a6">00538</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a8">CreateAndComputeFullActiveJacobian1</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da,Mat * J)
00539 {
00540   PetscFunctionBegin;
00541 
00542   assert(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>());
00543 
00544   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00545     <span class="keywordtype">char</span> matType[30];
00546     PetscTruth typeFound;
00547     PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00548     <span class="keywordflow">if</span>(!typeFound) {
00549       std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00550       MPI_Finalize();
00551       exit(0);          
00552     } 
00553     da-&gt;<a class="code" href="classot_1_1DA.html#z35_4">createActiveMatrix</a>(*J, matType, 1);
00554     MatZeroEntries(*J);
00555     std::vector&lt;ot::MatRecord&gt; records;
00556 
00557     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00558     <span class="keywordtype">double</span> hFac;
00559     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>(); 
00560     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00561 
00562     PetscReal lapFac = 1.0;
00563     PetscReal massFac = 1.0;
00564     PetscTruth optFound;
00565     PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00566     PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;massFac,&amp;optFound);
00567 
00568     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00569         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00570         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;()) {
00571       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00572       <span class="keywordtype">double</span> h = hFac*(1u &lt;&lt; (maxD - lev));
00573       <span class="keywordtype">double</span> fac1 = lapFac*h/2.0;
00574       <span class="keywordtype">double</span> fac2 = massFac*h*h*h/8.0;
00575       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00576       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00577       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00578       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00579       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00580       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00581         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0;k &lt; 8;k++) {
00582           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j=0;j&lt;8;j++) {
00583             <a class="code" href="classot_1_1MatRecord.html">ot::MatRecord</a> currRec;
00584             currRec.<a class="code" href="classot_1_1MatRecord.html#o3">rowIdx</a> = indices[k];
00585             currRec.<a class="code" href="classot_1_1MatRecord.html#o1">colIdx</a> = indices[j];
00586             currRec.<a class="code" href="classot_1_1MatRecord.html#o2">rowDim</a> = 0;
00587             currRec.<a class="code" href="classot_1_1MatRecord.html#o0">colDim</a> = 0;
00588             currRec.<a class="code" href="classot_1_1MatRecord.html#o4">val</a> =
00589               ((fac1*(<a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>[childNum][elemType][k][j])) +
00590                (fac2*(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>[childNum][elemType][k][j])));
00591             records.push_back(currRec);
00592           }<span class="comment">//end for j</span>
00593         }<span class="comment">//end for k</span>
00594       <span class="keywordflow">if</span>(records.size() &gt; 1000) {
00595         da-&gt;<a class="code" href="classot_1_1DA.html#z35_9">setValuesInMatrix</a>(*J, records, 1, ADD_VALUES);
00596       }
00597     }<span class="comment">//end writable</span>
00598 
00599     da-&gt;<a class="code" href="classot_1_1DA.html#z35_9">setValuesInMatrix</a>(*J, records, 1, ADD_VALUES);
00600 
00601     MatAssemblyBegin(*J, MAT_FINAL_ASSEMBLY);
00602     MatAssemblyEnd(*J, MAT_FINAL_ASSEMBLY);
00603 
00604   }<span class="comment">//end if active</span>
00605 
00606   PetscFunctionReturn(0);
00607 }
00608 
00609 
00610 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:24 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
