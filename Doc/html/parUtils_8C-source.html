<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/par/parUtils.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000019.html">par</a></div>
<h1>parUtils.C</h1><a href="parUtils_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00008 <span class="preprocessor">#include "mpi.h"</span>
00009 <span class="preprocessor">#include "<a class="code" href="binUtils_8h.html">binUtils.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="dtypes_8h.html">dtypes.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00012 
00013 <span class="preprocessor">#ifdef __DEBUG__</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_PAR__</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_PAR__</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span>
<a name="l00019"></a><a class="code" href="namespacepar.html">00019</a> <span class="keyword">namespace </span>par {
00020 
<a name="l00021"></a><a class="code" href="namespacepar.html#a0">00021</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a0">splitCommBinary</a>( MPI_Comm orig_comm, MPI_Comm *new_comm) {
00022     <span class="keywordtype">int</span> npes, rank;
00023 
00024     MPI_Group  orig_group, new_group;
00025 
00026     MPI_Comm_size(orig_comm, &amp;npes);
00027     MPI_Comm_rank(orig_comm, &amp;rank);
00028 
00029     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> splitterRank = <a class="code" href="namespacebinOp.html#a6">binOp::getPrevHighestPowerOfTwo</a>(npes);
00030 
00031     <span class="keywordtype">int</span> *ranksAsc, *ranksDesc;
00032     <span class="comment">//Determine sizes for the 2 groups </span>
00033     ranksAsc = <span class="keyword">new</span> <span class="keywordtype">int</span>[splitterRank];
00034     ranksDesc = <span class="keyword">new</span> <span class="keywordtype">int</span>[( npes - splitterRank)];
00035 
00036     <span class="keywordtype">int</span> numAsc = 0;
00037     <span class="keywordtype">int</span> numDesc = ( npes - splitterRank - 1);
00038 
00039     <span class="comment">//This is the main mapping between old ranks and new ranks.</span>
00040     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00041       <span class="keywordflow">if</span>( static_cast&lt;unsigned int&gt;(i) &lt; splitterRank) {
00042         ranksAsc[numAsc] = i;
00043         numAsc++;
00044       }<span class="keywordflow">else</span> {
00045         ranksDesc[numDesc] = i;
00046         numDesc--;
00047       }
00048     }<span class="comment">//end for i</span>
00049 
00050     MPI_Comm_group(orig_comm, &amp;orig_group);
00051 
00052     <span class="comment">/* Divide tasks into two distinct groups based upon rank */</span>
00053     <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;(rank) &lt; splitterRank) {
00054       MPI_Group_incl(orig_group, splitterRank, ranksAsc, &amp;new_group);
00055     }<span class="keywordflow">else</span> {
00056       MPI_Group_incl(orig_group, (npes-splitterRank), ranksDesc, &amp;new_group);
00057     }
00058 
00059     MPI_Comm_create(orig_comm, new_group, new_comm);
00060 
00061     <span class="keyword">delete</span> [] ranksAsc;
00062     <span class="keyword">delete</span> [] ranksDesc;
00063 
00064     <span class="keywordflow">return</span> splitterRank;
00065   }<span class="comment">//end function</span>
00066 
<a name="l00067"></a><a class="code" href="namespacepar.html#a1">00067</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a1">splitCommBinaryNoFlip</a>( MPI_Comm orig_comm, MPI_Comm *new_comm) {
00068     <span class="keywordtype">int</span> npes, rank;
00069 
00070     MPI_Group  orig_group, new_group;
00071 
00072     MPI_Comm_size(orig_comm, &amp;npes);
00073     MPI_Comm_rank(orig_comm, &amp;rank);
00074 
00075     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> splitterRank =  <a class="code" href="namespacebinOp.html#a6">binOp::getPrevHighestPowerOfTwo</a>(npes);
00076 
00077     <span class="keywordtype">int</span> *ranksAsc, *ranksDesc;
00078     <span class="comment">//Determine sizes for the 2 groups </span>
00079     ranksAsc = <span class="keyword">new</span> <span class="keywordtype">int</span>[splitterRank];
00080     ranksDesc = <span class="keyword">new</span> <span class="keywordtype">int</span>[( npes - splitterRank)];
00081 
00082     <span class="keywordtype">int</span> numAsc = 0;
00083     <span class="keywordtype">int</span> numDesc = 0; <span class="comment">//( npes - splitterRank - 1);</span>
00084 
00085     <span class="comment">//This is the main mapping between old ranks and new ranks.</span>
00086     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00087       <span class="keywordflow">if</span>(static_cast&lt;unsigned int&gt;(i) &lt; splitterRank) {
00088         ranksAsc[numAsc] = i;
00089         numAsc++;
00090       }<span class="keywordflow">else</span> {
00091         ranksDesc[numDesc] = i;
00092         numDesc++;
00093       }
00094     }<span class="comment">//end for i</span>
00095 
00096     MPI_Comm_group(orig_comm, &amp;orig_group);
00097 
00098     <span class="comment">/* Divide tasks into two distinct groups based upon rank */</span>
00099     <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;(rank) &lt; splitterRank) {
00100       MPI_Group_incl(orig_group, splitterRank, ranksAsc, &amp;new_group);
00101     }<span class="keywordflow">else</span> {
00102       MPI_Group_incl(orig_group, (npes-splitterRank), ranksDesc, &amp;new_group);
00103     }
00104 
00105     MPI_Comm_create(orig_comm, new_group, new_comm);
00106 
00107     <span class="keyword">delete</span> [] ranksAsc;
00108     <span class="keyword">delete</span> [] ranksDesc;
00109 
00110     <span class="keywordflow">return</span> splitterRank;
00111   }<span class="comment">//end function</span>
00112 
00113   <span class="comment">//create Comm groups and remove empty processors...</span>
<a name="l00114"></a><a class="code" href="namespacepar.html#a2">00114</a>   <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a4">splitComm2way</a>(<span class="keywordtype">bool</span> iAmEmpty, MPI_Comm * new_comm, MPI_Comm comm) {
00115 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00116 <span class="preprocessor"></span>    MPI_Barrier(comm);
00117 <span class="preprocessor">#endif</span>
00118 <span class="preprocessor"></span>    <a class="code" href="parUtils_8h.html#a3">PROF_SPLIT_COMM_2WAY_BEGIN</a>
00119 
00120       MPI_Group  orig_group, new_group;
00121     <span class="keywordtype">int</span> size;
00122     MPI_Comm_size(comm, &amp;size);
00123 
00124     <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[size];
00125     par::Mpi_Allgather&lt;bool&gt;(&amp;iAmEmpty, isEmptyList, 1, comm);
00126 
00127     <span class="keywordtype">int</span> numActive=0, numIdle=0;
00128     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00129       <span class="keywordflow">if</span>(isEmptyList[i]) {
00130         numIdle++;
00131       }<span class="keywordflow">else</span> {
00132         numActive++;
00133       }
00134     }<span class="comment">//end for i</span>
00135 
00136     <span class="keywordtype">int</span>* ranksActive = <span class="keyword">new</span> <span class="keywordtype">int</span>[numActive];
00137     <span class="keywordtype">int</span>* ranksIdle = <span class="keyword">new</span> <span class="keywordtype">int</span>[numIdle];
00138 
00139     numActive=0;
00140     numIdle=0;
00141     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00142       <span class="keywordflow">if</span>(isEmptyList[i]) {
00143         ranksIdle[numIdle] = i;
00144         numIdle++;
00145       }<span class="keywordflow">else</span> {
00146         ranksActive[numActive] = i;
00147         numActive++;
00148       }
00149     }<span class="comment">//end for i</span>
00150 
00151     <span class="keyword">delete</span> [] isEmptyList;      
00152 
00153     <span class="comment">/* Extract the original group handle */</span>
00154     MPI_Comm_group(comm, &amp;orig_group);
00155 
00156     <span class="comment">/* Divide tasks into two distinct groups based upon rank */</span>
00157     <span class="keywordflow">if</span> (!iAmEmpty) {
00158       MPI_Group_incl(orig_group, numActive, ranksActive, &amp;new_group);
00159     }<span class="keywordflow">else</span> {
00160       MPI_Group_incl(orig_group, numIdle, ranksIdle, &amp;new_group);
00161     }
00162 
00163     <span class="comment">/* Create new communicator */</span>
00164     MPI_Comm_create(comm, new_group, new_comm);
00165 
00166     <span class="keyword">delete</span> [] ranksActive;
00167     <span class="keyword">delete</span> [] ranksIdle;
00168 
00169     <a class="code" href="parUtils_8h.html#a23">PROF_SPLIT_COMM_2WAY_END</a>
00170   }<span class="comment">//end function</span>
00171 
<a name="l00172"></a><a class="code" href="namespacepar.html#a3">00172</a>   <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a3">splitCommUsingSplittingRank</a>(<span class="keywordtype">int</span> splittingRank, MPI_Comm* new_comm,
00173       MPI_Comm comm) {
00174 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00175 <span class="preprocessor"></span>    MPI_Barrier(comm);
00176 <span class="preprocessor">#endif</span>
00177 <span class="preprocessor"></span>    <a class="code" href="parUtils_8h.html#a4">PROF_SPLIT_COMM_BEGIN</a>
00178 
00179       MPI_Group  orig_group, new_group;
00180     <span class="keywordtype">int</span> size;
00181     <span class="keywordtype">int</span> rank;
00182     MPI_Comm_rank(comm, &amp;rank);
00183     MPI_Comm_size(comm, &amp;size);
00184 
00185     <span class="keywordtype">int</span>* ranksActive = <span class="keyword">new</span> <span class="keywordtype">int</span>[splittingRank];
00186     <span class="keywordtype">int</span>* ranksIdle = <span class="keyword">new</span> <span class="keywordtype">int</span>[size - splittingRank];
00187 
00188     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; splittingRank; i++) {
00189       ranksActive[i] = i;
00190     }
00191 
00192     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = splittingRank; i &lt; size; i++) {
00193       ranksIdle[i - splittingRank] = i;
00194     }
00195 
00196     <span class="comment">/* Extract the original group handle */</span>
00197     MPI_Comm_group(comm, &amp;orig_group);
00198 
00199     <span class="comment">/* Divide tasks into two distinct groups based upon rank */</span>
00200     <span class="keywordflow">if</span> (rank &lt; splittingRank) {
00201       MPI_Group_incl(orig_group, splittingRank, ranksActive, &amp;new_group);
00202     }<span class="keywordflow">else</span> {
00203       MPI_Group_incl(orig_group, (size - splittingRank), ranksIdle, &amp;new_group);
00204     }
00205 
00206     <span class="comment">/* Create new communicator */</span>
00207     MPI_Comm_create(comm, new_group, new_comm);
00208 
00209     <span class="keyword">delete</span> [] ranksActive;
00210     <span class="keyword">delete</span> [] ranksIdle;
00211 
00212     <a class="code" href="parUtils_8h.html#a24">PROF_SPLIT_COMM_END</a>
00213   }<span class="comment">//end function</span>
00214 
00215   <span class="comment">//create Comm groups and remove empty processors...</span>
<a name="l00216"></a><a class="code" href="namespacepar.html#a4">00216</a>   <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a4">splitComm2way</a>(<span class="keyword">const</span> <span class="keywordtype">bool</span>* isEmptyList, MPI_Comm * new_comm, MPI_Comm comm) {
00217       
00218     MPI_Group  orig_group, new_group;
00219     <span class="keywordtype">int</span> size, rank;
00220     MPI_Comm_size(comm, &amp;size);
00221     MPI_Comm_rank(comm, &amp;rank);
00222 
00223     <span class="keywordtype">int</span> numActive=0, numIdle=0;
00224     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00225       <span class="keywordflow">if</span>(isEmptyList[i]) {
00226         numIdle++;
00227       }<span class="keywordflow">else</span> {
00228         numActive++;
00229       }
00230     }<span class="comment">//end for i</span>
00231 
00232     <span class="keywordtype">int</span>* ranksActive = <span class="keyword">new</span> <span class="keywordtype">int</span>[numActive];
00233     <span class="keywordtype">int</span>* ranksIdle = <span class="keyword">new</span> <span class="keywordtype">int</span>[numIdle];
00234 
00235     numActive=0;
00236     numIdle=0;
00237     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00238       <span class="keywordflow">if</span>(isEmptyList[i]) {
00239         ranksIdle[numIdle] = i;
00240         numIdle++;
00241       }<span class="keywordflow">else</span> {
00242         ranksActive[numActive] = i;
00243         numActive++;
00244       }
00245     }<span class="comment">//end for i</span>
00246 
00247     <span class="comment">/* Extract the original group handle */</span>
00248     MPI_Comm_group(comm, &amp;orig_group);
00249 
00250     <span class="comment">/* Divide tasks into two distinct groups based upon rank */</span>
00251     <span class="keywordflow">if</span> (!isEmptyList[rank]) {
00252       MPI_Group_incl(orig_group, numActive, ranksActive, &amp;new_group);
00253     }<span class="keywordflow">else</span> {
00254       MPI_Group_incl(orig_group, numIdle, ranksIdle, &amp;new_group);
00255     }
00256 
00257     <span class="comment">/* Create new communicator */</span>
00258     MPI_Comm_create(comm, new_group, new_comm);
00259 
00260     <span class="keyword">delete</span> [] ranksActive;
00261     <span class="keyword">delete</span> [] ranksIdle;
00262 
00263     <span class="keywordflow">return</span> 0;
00264   }<span class="comment">//end function</span>
00265 
00266 
00267 }<span class="comment">// end namespace</span>
00268 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:33 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
