<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oct/TreeNode.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">oct</a></div>
<h1>TreeNode.C</h1><a href="TreeNode_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00008 <span class="preprocessor">#include "<a class="code" href="binUtils_8h.html">binUtils.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00011 
00012 <span class="preprocessor">#ifdef __DEBUG__</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_TN__</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_TN__</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00017 <span class="preprocessor"></span>
00018 <span class="keyword">namespace </span>ot {
00019 
<a name="l00020"></a><a class="code" href="classot_1_1TreeNode.html#z21_0">00020</a>   std::vector&lt;TreeNode&gt; TreeNode::getAllNeighbours()<span class="keyword"> const </span>{
00021     <span class="comment">/*</span>
00022 <span class="comment">       0 = Left;  1 =  Right;  2 =  Front;  3 = Back;   4 = LeftBack;  5 = RightBack;  6 = LeftFront;  7 = RightFront;  8 = Top;</span>
00023 <span class="comment">       9 = TopRight;  10 =  TopBack;  11 =  TopRightBack;  12 =  Bottom;  13 =  BottomBack;  14 =  TopLeft;  15 =  BottomLeft; </span>
00024 <span class="comment">       16 =  BottomRight;  17 =  TopFront;  18 =  BottomFront;  19 =  TopLeftFront;  20 =  TopRightFront;  21 =  BottomLeftFront;</span>
00025 <span class="comment">       22 =  BottomRightFront;  23 =  TopLeftBack;  24 = BottomLeftBack;  25 = BottomRightBack;</span>
00026 <span class="comment">       */</span>
00027     std::vector&lt;TreeNode&gt; neighList;
00028 
00029     <span class="keywordflow">if</span>( <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>== 3){
00030       neighList.resize(26);
00031       neighList[0] = <a class="code" href="classot_1_1TreeNode.html#z21_12">getLeft</a>();
00032       neighList[1] =  <a class="code" href="classot_1_1TreeNode.html#z21_15">getRight</a>();
00033       neighList[2] =  <a class="code" href="classot_1_1TreeNode.html#z21_11">getFront</a>();
00034       neighList[3] =  <a class="code" href="classot_1_1TreeNode.html#z21_1">getBack</a>(); 
00035       neighList[4] =  <a class="code" href="classot_1_1TreeNode.html#z21_13">getLeftBack</a>();
00036       neighList[5] = <a class="code" href="classot_1_1TreeNode.html#z21_16">getRightBack</a>();
00037       neighList[6] =  <a class="code" href="classot_1_1TreeNode.html#z21_14">getLeftFront</a>();
00038       neighList[7] =  <a class="code" href="classot_1_1TreeNode.html#z21_17">getRightFront</a>();
00039       neighList[8] =  <a class="code" href="classot_1_1TreeNode.html#z21_18">getTop</a>();
00040       neighList[9] = <a class="code" href="classot_1_1TreeNode.html#z21_24">getTopRight</a>();
00041       neighList[10] =  <a class="code" href="classot_1_1TreeNode.html#z21_19">getTopBack</a>();
00042       neighList[11] =  <a class="code" href="classot_1_1TreeNode.html#z21_25">getTopRightBack</a>();
00043       neighList[12] =  <a class="code" href="classot_1_1TreeNode.html#z21_2">getBottom</a>();
00044       neighList[13] =  <a class="code" href="classot_1_1TreeNode.html#z21_3">getBottomBack</a>();
00045       neighList[14] =  <a class="code" href="classot_1_1TreeNode.html#z21_21">getTopLeft</a>();
00046       neighList[15] =  <a class="code" href="classot_1_1TreeNode.html#z21_5">getBottomLeft</a>(); 
00047       neighList[16] =  <a class="code" href="classot_1_1TreeNode.html#z21_8">getBottomRight</a>();
00048       neighList[17] =  <a class="code" href="classot_1_1TreeNode.html#z21_20">getTopFront</a>();
00049       neighList[18] =  <a class="code" href="classot_1_1TreeNode.html#z21_4">getBottomFront</a>();
00050       neighList[19] =  <a class="code" href="classot_1_1TreeNode.html#z21_23">getTopLeftFront</a>();
00051       neighList[20] =  <a class="code" href="classot_1_1TreeNode.html#z21_26">getTopRightFront</a>();
00052       neighList[21] =   <a class="code" href="classot_1_1TreeNode.html#z21_7">getBottomLeftFront</a>();
00053       neighList[22] =   <a class="code" href="classot_1_1TreeNode.html#z21_10">getBottomRightFront</a>();
00054       neighList[23] =  <a class="code" href="classot_1_1TreeNode.html#z21_22">getTopLeftBack</a>();
00055       neighList[24] = <a class="code" href="classot_1_1TreeNode.html#z21_6">getBottomLeftBack</a>();
00056       neighList[25] = <a class="code" href="classot_1_1TreeNode.html#z21_9">getBottomRightBack</a>();
00057     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> == 2) {
00058       neighList.resize(8);
00059       neighList[0] = <a class="code" href="classot_1_1TreeNode.html#z21_12">getLeft</a>();
00060       neighList[1] =  <a class="code" href="classot_1_1TreeNode.html#z21_15">getRight</a>();
00061       neighList[2] =  <a class="code" href="classot_1_1TreeNode.html#z21_11">getFront</a>();
00062       neighList[3] =  <a class="code" href="classot_1_1TreeNode.html#z21_1">getBack</a>(); 
00063       neighList[4] =  <a class="code" href="classot_1_1TreeNode.html#z21_13">getLeftBack</a>();
00064       neighList[5] = <a class="code" href="classot_1_1TreeNode.html#z21_16">getRightBack</a>();
00065       neighList[6] =  <a class="code" href="classot_1_1TreeNode.html#z21_14">getLeftFront</a>();
00066       neighList[7] =  <a class="code" href="classot_1_1TreeNode.html#z21_17">getRightFront</a>();
00067     }<span class="keywordflow">else</span> {
00068       neighList.resize(2);
00069       neighList[0] = <a class="code" href="classot_1_1TreeNode.html#z21_12">getLeft</a>();
00070       neighList[1] =  <a class="code" href="classot_1_1TreeNode.html#z21_15">getRight</a>();
00071     }
00072     <span class="keywordflow">return</span> neighList;
00073   }
00074 
<a name="l00075"></a><a class="code" href="classot_1_1TreeNode.html#z23_0">00075</a>   std::vector&lt;std::vector&lt;TreeNode&gt; &gt; TreeNode::getAllB_Neighbours()<span class="keyword"> const </span>{
00076     <span class="comment">/*</span>
00077 <span class="comment">       0 = Left;  1 =  Right;  2 =  Front;  3 = Back;   4 = LeftBack;  5 = RightBack;  6 = LeftFront;  7 = RightFront;  8 = Top;</span>
00078 <span class="comment">       9 = TopRight;  10 =  TopBack;  11 =  TopRightBack;  12 =  Bottom;  13 =  BottomBack;  14 =  TopLeft;  15 =  BottomLeft; </span>
00079 <span class="comment">       16 =  BottomRight;  17 =  TopFront;  18 =  BottomFront;  19 =  TopLeftFront;  20 =  TopRightFront;  21 =  BottomLeftFront;</span>
00080 <span class="comment">       22 =  BottomRightFront;  23 =  TopLeftBack;  24 = BottomLeftBack;  25 = BottomRightBack;</span>
00081 <span class="comment">       */</span>
00082 
00083     std::vector&lt;std::vector&lt;TreeNode&gt; &gt; neighList;
00084 
00085     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> == 3){
00086       neighList.resize(26);
00087       neighList[0] = <a class="code" href="classot_1_1TreeNode.html#z23_12">getB_Left</a>();
00088       neighList[1] =  <a class="code" href="classot_1_1TreeNode.html#z23_15">getB_Right</a>();
00089       neighList[2] =  <a class="code" href="classot_1_1TreeNode.html#z23_11">getB_Front</a>();
00090       neighList[3] =  <a class="code" href="classot_1_1TreeNode.html#z23_1">getB_Back</a>(); 
00091       neighList[4] =  <a class="code" href="classot_1_1TreeNode.html#z23_13">getB_LeftBack</a>();
00092       neighList[5] = <a class="code" href="classot_1_1TreeNode.html#z23_16">getB_RightBack</a>();
00093       neighList[6] =  <a class="code" href="classot_1_1TreeNode.html#z23_14">getB_LeftFront</a>();
00094       neighList[7] =  <a class="code" href="classot_1_1TreeNode.html#z23_17">getB_RightFront</a>();
00095       neighList[8] =  <a class="code" href="classot_1_1TreeNode.html#z23_18">getB_Top</a>();
00096       neighList[9] = <a class="code" href="classot_1_1TreeNode.html#z23_24">getB_TopRight</a>();
00097       neighList[10] =  <a class="code" href="classot_1_1TreeNode.html#z23_19">getB_TopBack</a>();
00098       neighList[11] =  <a class="code" href="classot_1_1TreeNode.html#z23_25">getB_TopRightBack</a>();
00099       neighList[12] =  <a class="code" href="classot_1_1TreeNode.html#z23_2">getB_Bottom</a>();
00100       neighList[13] =  <a class="code" href="classot_1_1TreeNode.html#z23_3">getB_BottomBack</a>();
00101       neighList[14] =  <a class="code" href="classot_1_1TreeNode.html#z23_21">getB_TopLeft</a>();
00102       neighList[15] =  <a class="code" href="classot_1_1TreeNode.html#z23_5">getB_BottomLeft</a>(); 
00103       neighList[16] =  <a class="code" href="classot_1_1TreeNode.html#z23_8">getB_BottomRight</a>();
00104       neighList[17] =  <a class="code" href="classot_1_1TreeNode.html#z23_20">getB_TopFront</a>();
00105       neighList[18] =  <a class="code" href="classot_1_1TreeNode.html#z23_4">getB_BottomFront</a>();
00106       neighList[19] =  <a class="code" href="classot_1_1TreeNode.html#z23_23">getB_TopLeftFront</a>();
00107       neighList[20] =  <a class="code" href="classot_1_1TreeNode.html#z23_26">getB_TopRightFront</a>();
00108       neighList[21] =   <a class="code" href="classot_1_1TreeNode.html#z23_7">getB_BottomLeftFront</a>();
00109       neighList[22] =   <a class="code" href="classot_1_1TreeNode.html#z23_10">getB_BottomRightFront</a>();
00110       neighList[23] =  <a class="code" href="classot_1_1TreeNode.html#z23_22">getB_TopLeftBack</a>();
00111       neighList[24] = <a class="code" href="classot_1_1TreeNode.html#z23_6">getB_BottomLeftBack</a>();
00112       neighList[25] = <a class="code" href="classot_1_1TreeNode.html#z23_9">getB_BottomRightBack</a>();
00113     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> == 2) {
00114       neighList.resize(8);
00115       neighList[0] = <a class="code" href="classot_1_1TreeNode.html#z23_12">getB_Left</a>();
00116       neighList[1] =  <a class="code" href="classot_1_1TreeNode.html#z23_15">getB_Right</a>();
00117       neighList[2] =  <a class="code" href="classot_1_1TreeNode.html#z23_11">getB_Front</a>();
00118       neighList[3] =  <a class="code" href="classot_1_1TreeNode.html#z23_1">getB_Back</a>(); 
00119       neighList[4] =  <a class="code" href="classot_1_1TreeNode.html#z23_13">getB_LeftBack</a>();
00120       neighList[5] = <a class="code" href="classot_1_1TreeNode.html#z23_16">getB_RightBack</a>();
00121       neighList[6] =  <a class="code" href="classot_1_1TreeNode.html#z23_14">getB_LeftFront</a>();
00122       neighList[7] =  <a class="code" href="classot_1_1TreeNode.html#z23_17">getB_RightFront</a>();
00123     }<span class="keywordflow">else</span> {
00124       neighList.resize(2);
00125       neighList[0] = <a class="code" href="classot_1_1TreeNode.html#z23_12">getB_Left</a>();
00126       neighList[1] =  <a class="code" href="classot_1_1TreeNode.html#z23_15">getB_Right</a>();
00127     }
00128     <span class="keywordflow">return</span> neighList;
00129   }
00130 
00131 
<a name="l00132"></a><a class="code" href="classot_1_1TreeNode.html#a0">00132</a>   <span class="keywordtype">int</span> TreeNode::addBalancingDescendants(<a class="code" href="classot_1_1TreeNode.html">TreeNode</a> other, std::vector&lt;TreeNode&gt;&amp; seeds, <span class="keywordtype">bool</span> incCorner)<span class="keyword"> const </span>{
00133 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00134 <span class="preprocessor"></span>    assert( (other.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()) &gt; ( <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>() + 1));
00135     assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, other));
00136     assert(!(this-&gt;isAncestor(other)));
00137 <span class="preprocessor">#endif</span>
00138 <span class="preprocessor"></span>    <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00139     std::vector&lt;TreeNode&gt; nhs = other.<a class="code" href="classot_1_1TreeNode.html#z21_0">getAllNeighbours</a>();
00140     <span class="comment">/*</span>
00141 <span class="comment">       0 = Left;  1 =  Right;  2 =  Front;  3 = Back;   4 = LeftBack;  5 = RightBack;  6 = LeftFront;  7 = RightFront;  8 = Top;</span>
00142 <span class="comment">       9 = TopRight;  10 =  TopBack;  11 =  TopRightBack;  12 =  Bottom;  13 =  BottomBack;  14 =  TopLeft;  15 =  BottomLeft; </span>
00143 <span class="comment">       16 =  BottomRight;  17 =  TopFront;  18 =  BottomFront;  19 =  TopLeftFront;  20 =  TopRightFront;  21 =  BottomLeftFront;</span>
00144 <span class="comment">       22 =  BottomRightFront;  23 =  TopLeftBack;  24 = BottomLeftBack;  25 = BottomRightBack;</span>
00145 <span class="comment">       */</span>
00146     std::vector&lt;unsigned int&gt; dirs;
00147     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> == 1) {
00148       <span class="comment">//ignore incCorner</span>
00149       dirs.resize(2);
00150       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dirs.size(); i++) {
00151         dirs[i] = i;
00152       }
00153     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>== 2){
00154       <span class="keywordflow">if</span>(incCorner){
00155         dirs.resize(8);
00156         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dirs.size(); i++) {
00157           dirs[i] = i;
00158         }
00159       }<span class="keywordflow">else</span>{
00160         dirs.resize(4);
00161         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dirs.size(); i++) {
00162           dirs[i] = i;
00163         }
00164       }
00165     }<span class="keywordflow">else</span> {
00166       <span class="keywordflow">if</span>(incCorner){
00167         dirs.resize(26);
00168         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dirs.size(); i++) {
00169           dirs[i] = i;
00170         }
00171       }<span class="keywordflow">else</span>{
00172         dirs.resize(18);
00173         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 11; i++) {
00174           dirs[i] = i;
00175         }
00176         <span class="comment">//skip 11 = TRBk</span>
00177         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 12; i &lt; 19; i++) {
00178           dirs[i-1] = i;
00179         }
00180       }
00181     }
00182     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldSz = static_cast&lt;unsigned int&gt;(seeds.size());
00183     seeds.resize(seeds.size()+dirs.size());
00184     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dirs.size(); i++) {
00185 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00186 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, nhs[dirs[i]]));
00187 <span class="preprocessor">#endif</span>
00188 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(nhs[dirs[i]])){
00189         seeds[oldSz + i] = nhs[dirs[i]].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
00190       }<span class="keywordflow">else</span> {
00191         seeds[oldSz + i]  = root;
00192       }<span class="comment">//end if - else</span>
00193     }<span class="comment">//end for i</span>
00194     <span class="keywordflow">return</span> 1;
00195   }<span class="comment">//end function</span>
00196 
00197 
<a name="l00198"></a><a class="code" href="classot_1_1TreeNode.html#a12">00198</a>   <span class="keywordtype">bool</span> TreeNode::isBoundaryOctant(<span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> &amp;block, <span class="keywordtype">int</span> type, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *flags)<span class="keyword"> const </span>{
00199     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _flags = 0;
00200 
00201     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x = block.<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00202     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _y = block.<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00203     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _z = block.<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00204     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _d = block.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00205 
00206     <span class="comment">/*</span>
00207 <span class="comment">    // Block has to be an ancestor of the octant or equal to the octant.</span>
00208 <span class="comment">    if( (!block.isAncestor(*this)) &amp;&amp; (block != *this) ) {</span>
00209 <span class="comment">    if (flags) {</span>
00210 <span class="comment">     *flags = _flags;</span>
00211 <span class="comment">     }</span>
00212 <span class="comment">     return false;</span>
00213 <span class="comment">     }</span>
00214 <span class="comment">     */</span>
00215 
00216     <span class="keywordflow">if</span> ( (type &amp; NEGATIVE) == NEGATIVE ) {
00217       <span class="comment">// test if any of the anchor values matches those of the block ... </span>
00218       <span class="keywordflow">if</span> (<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> == _x) _flags |= X_NEG_BDY;  
00219       <span class="keywordflow">if</span> (<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> == _y) _flags |= Y_NEG_BDY;  
00220       <span class="keywordflow">if</span> (<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> == _z) _flags |= Z_NEG_BDY;  
00221     }
00222 
00223     <span class="keywordflow">if</span> ( (type &amp; POSITIVE) == POSITIVE ) {
00224       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len  = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; ( <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>() ) );
00225       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blen = ((<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; (<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> - _d))) - len;
00226 
00227       <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> == (_x+blen) )  _flags |= X_POS_BDY;
00228       <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> == (_y+blen) )  _flags |= Y_POS_BDY;
00229       <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> == (_z+blen) )  _flags |= Z_POS_BDY;
00230     }
00231 
00232     <span class="keywordflow">if</span> (flags) {
00233       *flags = _flags;
00234     }
00235     <span class="keywordflow">if</span> (_flags) {
00236       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00237     }
00238     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00239   } <span class="comment">//end function</span>
00240 
<a name="l00241"></a><a class="code" href="classot_1_1TreeNode.html#a13">00241</a>   <span class="keywordtype">bool</span> TreeNode::isBoundaryOctant(<span class="keywordtype">int</span> type, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *flags)<span class="keyword"> const </span>{
00242     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _flags = 0;
00243     <span class="keywordflow">if</span> ( (type &amp; NEGATIVE) == NEGATIVE ) {
00244       <span class="comment">// test if any of the anchor values is zero ...  (sufficient ??? )</span>
00245       <span class="keywordflow">if</span> (!m_uiX) _flags |= X_NEG_BDY;  
00246       <span class="keywordflow">if</span> (!m_uiY) _flags |=  Y_NEG_BDY; 
00247       <span class="keywordflow">if</span> (!m_uiZ) _flags |=   Z_NEG_BDY;
00248     }
00249 
00250     <span class="keywordflow">if</span> ( (type &amp; POSITIVE) == POSITIVE ) {
00251       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len  = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; ( <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>() ) );
00252       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blen = ((<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; m_uiMaxDepth)) - len;
00253 
00254       <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> == blen )  _flags |= X_POS_BDY;
00255       <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> == blen )  _flags |= Y_POS_BDY;
00256       <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> == blen )  _flags |= Z_POS_BDY;
00257     }
00258 
00259     <span class="keywordflow">if</span> (flags)
00260       *flags = _flags;
00261     <span class="keywordflow">if</span> (_flags)
00262       <span class="keywordflow">return</span> <span class="keyword">true</span>;
00263 
00264     <span class="keywordflow">return</span> <span class="keyword">false</span>;
00265   } <span class="comment">//end function</span>
00266 
00267 
<a name="l00268"></a><a class="code" href="classot_1_1TreeNode.html#a2">00268</a>   <span class="keywordtype">int</span> TreeNode  ::addChildren(std::vector&lt;ot::TreeNode  &gt; &amp;children)<span class="keyword"> const </span>{ 
00269     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = m_uiDim;
00270     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = m_uiMaxDepth;
00271     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> childrenSz = children.size();
00272     children.resize(childrenSz + (1 &lt;&lt; dim));
00273     <span class="keywordflow">if</span>( (<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; ot::TreeNode::MAX_LEVEL) == maxDepth) {
00274       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; (1 &lt;&lt; dim); i++) {
00275         children[childrenSz + i] = *<span class="keyword">this</span>;
00276       }
00277       <span class="keywordflow">return</span> 1;
00278     }
00279     <span class="comment">//The check that lev &lt; maxD is taken care of in the constructor.</span>
00280 
00281     <span class="comment">//Order: X first, Y next and Z last</span>
00282 
00283     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; ( maxDepth - ((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; ot::TreeNode::MAX_LEVEL)+1) ) ) ;
00284 
00285     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode0(1,<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>,<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> ,<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> ,((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00286     children[childrenSz + 0] = tmpNode0;
00287 
00288     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode1(1,(<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> + len),<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> ,<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> ,((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00289     children[childrenSz + 1] = tmpNode1;
00290 
00291     <span class="keywordflow">if</span>( dim &gt;= 2 ) {    
00292       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode2(1,<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>,(<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> + len) ,<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> ,((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00293       children[childrenSz + 2] = tmpNode2;
00294 
00295       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode3(1,(<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> + len),(<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> + len) ,<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a>  ,((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00296       children[childrenSz + 3] = tmpNode3;
00297     }
00298 
00299     <span class="keywordflow">if</span> (dim == 3) {
00300       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode4(1,<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>,<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> ,(<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> + len),((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00301       children[childrenSz + 4] = tmpNode4;
00302 
00303       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode5(1,(<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>+ len),<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> ,(<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> + len),((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00304       children[childrenSz + 5] = tmpNode5;
00305 
00306       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode6(1,<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>,(<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a>+ len) ,(<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> + len),((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00307       children[childrenSz + 6] = tmpNode6;
00308 
00309       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   tmpNode7(1,(<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>+ len),(<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> + len),(<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> + len),((<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; <a class="code" href="classot_1_1TreeNode.html#w12w8">ot::TreeNode::MAX_LEVEL</a>)+1),<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
00310       children[childrenSz + 7] = tmpNode7;
00311     }<span class="comment">//end if</span>
00312     <span class="keywordflow">return</span> 1;
00313   }<span class="comment">//end function</span>
00314 
<a name="l00315"></a><a class="code" href="classot_1_1TreeNode.html#a1">00315</a>   <span class="keywordtype">int</span> TreeNode  ::addBrothers(std::vector&lt;TreeNode&gt;&amp; bros)<span class="keyword"> const </span>{
00316     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = m_uiDim;
00317     bros.resize(((1 &lt;&lt; dim) - 1));
00318     <span class="keywordflow">if</span>( (this-&gt;<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> &amp; ot::TreeNode::MAX_LEVEL) == 0) {
00319       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i&lt; ((1 &lt;&lt; dim) - 1); i++) {
00320         bros[i] = *<span class="keyword">this</span>;
00321       }<span class="comment">//end for</span>
00322       <span class="keywordflow">return</span> 1;
00323     }<span class="comment">//end if</span>
00324 
00325     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> parent = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
00326     std::vector&lt;TreeNode&gt; childrenOfParent;
00327     parent.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(childrenOfParent);
00328     <span class="keywordtype">int</span> k= 0;
00329     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0;i &lt; (1 &lt;&lt; dim); i++) {
00330       <span class="keywordflow">if</span>(childrenOfParent[i] != (*this)) {
00331         bros[k] = childrenOfParent[i];
00332         k++;
00333       }
00334     }<span class="comment">//end for</span>
00335     childrenOfParent.clear();
00336     <span class="keywordflow">return</span> 1;
00337   }<span class="comment">//end fn.</span>
00338 
<a name="l00339"></a><a class="code" href="classot_1_1TreeNode.html#a10">00339</a>   std::vector&lt;TreeNode&gt; TreeNode::getSearchKeys(<span class="keywordtype">bool</span> incCorners){
00340 
00341     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myK = this-&gt;<a class="code" href="classot_1_1TreeNode.html#z19_3">getChildNumber</a>();
00342     <span class="comment">//Morton Order: X,Y,Z</span>
00343     <span class="keywordtype">bool</span> zdir = (myK &gt;= 4);
00344     <span class="keywordtype">bool</span> ydir = ((myK - ((zdir)?4:0)) &gt;= 2);
00345     <span class="keywordtype">bool</span> xdir = (myK%2); 
00346 
00347     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xCor = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00348     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yCor = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00349     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zCor = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00350     <span class="keywordflow">if</span>(xdir){
00351       xCor = ((this-&gt;<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>())-1);
00352     }
00353     <span class="keywordflow">if</span>(ydir){
00354       yCor = ((this-&gt;<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>())-1);
00355     }
00356     <span class="keywordflow">if</span>(zdir){
00357       zCor = ((this-&gt;<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>())-1);
00358     }
00359 
00360     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> searchCorner(1,xCor,yCor,zCor,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>,<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>,<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);  
00361     std::vector&lt;TreeNode&gt; tList;
00362     <span class="keywordflow">if</span>(xdir) {
00363       tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_15">getRight</a>());
00364     }<span class="keywordflow">else</span> {
00365       tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_12">getLeft</a>());
00366     }
00367     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> &gt; 1) {
00368       <span class="keywordflow">if</span>(ydir) {
00369         tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_1">getBack</a>());
00370       }<span class="keywordflow">else</span> {
00371         tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_11">getFront</a>());
00372       }
00373       <span class="keywordflow">if</span>(incCorners || <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> &gt; 2) {
00374         <span class="keywordflow">if</span>(ydir) {
00375           <span class="keywordflow">if</span>(xdir) {
00376             tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_16">getRightBack</a>());
00377           }<span class="keywordflow">else</span> {
00378             tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_13">getLeftBack</a>());
00379           }
00380         }<span class="keywordflow">else</span> {
00381           <span class="keywordflow">if</span>(xdir) {
00382             tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_17">getRightFront</a>());
00383           }<span class="keywordflow">else</span> {
00384             tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_14">getLeftFront</a>());
00385           }
00386         }
00387       }
00388     }
00389     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> &gt; 2) {
00390       <span class="keywordflow">if</span>(zdir) {
00391         tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_18">getTop</a>());
00392         <span class="keywordflow">if</span>(xdir) {
00393           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_24">getTopRight</a>());
00394         }<span class="keywordflow">else</span> {
00395           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_21">getTopLeft</a>());
00396         }
00397         <span class="keywordflow">if</span>(ydir) {
00398           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_19">getTopBack</a>());
00399         }<span class="keywordflow">else</span> {
00400           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_20">getTopFront</a>());
00401         }
00402       }<span class="keywordflow">else</span> {
00403         tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_2">getBottom</a>());
00404         <span class="keywordflow">if</span>(xdir) {
00405           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_8">getBottomRight</a>());
00406         }<span class="keywordflow">else</span> {
00407           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_5">getBottomLeft</a>());
00408         }
00409         <span class="keywordflow">if</span>(ydir) {
00410           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_3">getBottomBack</a>());
00411         }<span class="keywordflow">else</span> {
00412           tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_4">getBottomFront</a>());
00413         }
00414       }
00415       <span class="keywordflow">if</span>(incCorners) {
00416         <span class="keywordflow">if</span>(zdir) {
00417           <span class="keywordflow">if</span>(xdir) {
00418             <span class="keywordflow">if</span>(ydir) {
00419               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_25">getTopRightBack</a>());
00420             }<span class="keywordflow">else</span> {
00421               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_26">getTopRightFront</a>());
00422             }
00423           }<span class="keywordflow">else</span> {
00424             <span class="keywordflow">if</span>(ydir) {
00425               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_22">getTopLeftBack</a>());
00426             }<span class="keywordflow">else</span> {
00427               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_23">getTopLeftFront</a>());
00428             }
00429           }
00430         }<span class="keywordflow">else</span> {
00431           <span class="keywordflow">if</span>(xdir) {
00432             <span class="keywordflow">if</span>(ydir) {
00433               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_9">getBottomRightBack</a>());
00434             }<span class="keywordflow">else</span> {
00435               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_10">getBottomRightFront</a>());
00436             }
00437           }<span class="keywordflow">else</span> {
00438             <span class="keywordflow">if</span>(ydir) {
00439               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_6">getBottomLeftBack</a>());
00440             }<span class="keywordflow">else</span> {
00441               tList.push_back(searchCorner.<a class="code" href="classot_1_1TreeNode.html#z21_7">getBottomLeftFront</a>());
00442             }
00443           }
00444         }
00445       }
00446     }
00447 
00448     <span class="keywordflow">return</span> tList;
00449   }<span class="comment">//end function</span>
00450 
<a name="l00451"></a><a class="code" href="classot_1_1TreeNode.html#a8">00451</a>   std::vector&lt;bool&gt; <a class="code" href="classot_1_1TreeNode.html#a8">ot::TreeNode  ::getMorton</a>()<span class="keyword"> const </span>{
00452     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = <a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00453     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = <a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
00454     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> Ln = 1;
00455     <span class="keywordflow">if</span>(maxDepth &gt; 0) {
00456       Ln = <a class="code" href="namespacebinOp.html#a0">binOp::binLength</a>(maxDepth);
00457     }
00458     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> N = (dim*maxDepth) + Ln;
00459     std::vector&lt;bool&gt; numBin(N);
00460     std::vector&lt;bool&gt; xBin(maxDepth);
00461     std::vector&lt;bool&gt; yBin(maxDepth);
00462     std::vector&lt;bool&gt; zBin(maxDepth);
00463     std::vector&lt;bool&gt; levBin(Ln);
00464 
00465     <span class="comment">//create Binary Representations</span>
00466     <a class="code" href="namespacebinOp.html#a2">binOp::toBin</a>(<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>(), maxDepth, xBin);
00467     <span class="keywordflow">if</span>(dim &gt; 1) { <a class="code" href="namespacebinOp.html#a2">binOp::toBin</a>(<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>(), maxDepth, yBin); }
00468     <span class="keywordflow">if</span>(dim &gt; 2) { <a class="code" href="namespacebinOp.html#a2">binOp::toBin</a>(<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>(), maxDepth, zBin); }
00469     <a class="code" href="namespacebinOp.html#a2">binOp::toBin</a>(<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>(), Ln, levBin);
00470 
00471     <span class="comment">//Interleave bits</span>
00472     <span class="keywordflow">if</span>(dim &gt; 2) {
00473       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; maxDepth; j++) {        
00474         numBin[(j*dim)] = zBin[j];
00475         numBin[((j*dim)+1)] = yBin[j];
00476         numBin[((j*dim)+2)] = xBin[j];
00477       }<span class="comment">//end for  </span>
00478     }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim &gt; 1) {
00479       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; maxDepth; j++) {        
00480         numBin[(j*dim)] = yBin[j];
00481         numBin[((j*dim)+1)] = xBin[j];
00482       }<span class="comment">//end for  </span>
00483     }<span class="keywordflow">else</span> {
00484       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; maxDepth; j++) {        
00485         numBin[j] = xBin[j];
00486       }<span class="comment">//end for  </span>
00487     }<span class="comment">//end if-else</span>
00488 
00489     <span class="comment">//Append level</span>
00490     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; Ln; j++) {
00491       numBin[((maxDepth*dim)+j)] = levBin[j];
00492     }
00493 
00494     <span class="keywordflow">return</span> numBin ;
00495   }
00496 
00497   <span class="comment">//Constructors...</span>
<a name="l00498"></a><a class="code" href="classot_1_1TreeNode.html#z15_0">00498</a>   TreeNode :: TreeNode () {
00499     <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> = <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = <a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> =
00500       <a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a> = <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> = <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> = 0;
00501   }
00502 
<a name="l00503"></a><a class="code" href="classot_1_1TreeNode.html#b0">00503</a>   TreeNode  :: TreeNode (<span class="keyword">const</span> <span class="keywordtype">int</span> dummy, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x,<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y,
00504       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {              
00505     <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> = dim;
00506     <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> = maxDepth;
00507     <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> = x;
00508     <span class="keywordflow">if</span>(dim &gt; 1) { <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = y; } <span class="keywordflow">else</span> { <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = 0; }
00509     <span class="keywordflow">if</span>(dim &gt; 2) { <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = z; } <span class="keywordflow">else</span> { <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = 0; }
00510 
00511     <a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> = lev;
00512     <a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a> = 1;
00513   }<span class="comment">//end function</span>
00514 
<a name="l00515"></a><a class="code" href="classot_1_1TreeNode.html#z15_3">00515</a>   TreeNode  :: TreeNode (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00516     <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> = 0;
00517     <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = 0;
00518     <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = 0;
00519     <a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> = 0;
00520     <a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a> = 1;
00521     <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> = dim; 
00522     <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> = maxDepth;
00523 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00524 <span class="preprocessor"></span>    <span class="keywordflow">if</span>((dim != 1) &amp;&amp; (dim != 2) &amp;&amp; (dim != 3)) {
00525       std::cout&lt;&lt;<span class="stringliteral">"Wrong Value for dim: "</span>&lt;&lt;dim&lt;&lt;std::endl;   
00526     }
00527 <span class="preprocessor">#endif</span>
00528 <span class="preprocessor"></span>    assert((dim == 1)|| (dim == 2) || (dim == 3));
00529   }<span class="comment">//end function</span>
00530 
<a name="l00531"></a><a class="code" href="classot_1_1TreeNode.html#z15_2">00531</a>   TreeNode  :: TreeNode (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x,<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y,
00532       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {              
00533     <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> = dim;
00534     <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> = maxDepth;
00535     <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> = x;
00536     <span class="keywordflow">if</span>(dim &gt; 1) { <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = y; } <span class="keywordflow">else</span> { <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = 0; }
00537     <span class="keywordflow">if</span>(dim &gt; 2) { <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = z; } <span class="keywordflow">else</span> { <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = 0; }
00538 
00539     <a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> = lev;
00540     <a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a> = 1;
00541 
00542 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00543 <span class="preprocessor"></span>    <span class="keywordflow">if</span>((dim != 1) &amp;&amp; (dim != 2) &amp;&amp; (dim != 3)) {
00544       std::cout&lt;&lt;<span class="stringliteral">"Wrong Value for dim: "</span>&lt;&lt;dim&lt;&lt;std::endl;   
00545     }
00546     assert(<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1u &lt;&lt; maxDepth)) );
00547     assert( (<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> % ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1u &lt;&lt; (maxDepth-lev))) ) == 0 );
00548     assert(<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1u &lt;&lt; maxDepth)) );
00549     assert( (<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> % ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1u &lt;&lt; (maxDepth-lev))) ) == 0 );
00550     assert(<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1u &lt;&lt; maxDepth)) );
00551     assert( (<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> % ((<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(1u &lt;&lt; (maxDepth-lev))) ) == 0 );
00552     assert((dim == 1)|| (dim == 2) || (dim == 3));      
00553 <span class="preprocessor">#endif</span>
00554 <span class="preprocessor"></span>
00555   }<span class="comment">//end function</span>
00556 
00557   <span class="comment">//copy constructor    </span>
<a name="l00558"></a><a class="code" href="classot_1_1TreeNode.html#z15_1">00558</a>   TreeNode  :: TreeNode  (<span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  &amp;other) {
00559     <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> = other.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>;
00560     <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = other.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a>;
00561     <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = other.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a>;
00562     <a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> = other.<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a>;
00563     <a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a> = other.<a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a>;
00564     <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> = other.<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>;
00565     <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> = other.<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>;
00566   }<span class="comment">//end function</span>
00567 
00568 
<a name="l00569"></a><a class="code" href="namespaceot.html#a67">00569</a>   std::ostream &amp; <a class="code" href="namespaceot.html#a67">operator &lt;&lt;</a>(std::ostream &amp; os, <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> <span class="keyword">const</span> &amp; other){
00570     <span class="keywordflow">return</span> (os &lt;&lt; other.<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>() &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt; other.<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>() &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;other.<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>()&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;other.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>());
00571   }<span class="comment">//end fn.</span>
00572 
00573 
00574   <span class="comment">//Assignment operator</span>
00575   <span class="comment">//No checks for dim or maxD. It's ok to change dim and maxD using the</span>
00576   <span class="comment">//assignment operator.</span>
<a name="l00577"></a><a class="code" href="classot_1_1TreeNode.html#z17_3">00577</a>   <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> &amp; TreeNode  :: operator = ( <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>   <span class="keyword">const</span> &amp; other) {
00578     <span class="keywordflow">if</span>(<span class="keyword">this</span> == (&amp;other)) {<span class="keywordflow">return</span> *<span class="keyword">this</span>;}        
00579     <a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> = other.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a>;
00580     <a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> = other.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a>;
00581     <a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> = other.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a>;
00582     <a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a> = other.<a class="code" href="classot_1_1TreeNode.html#p1">m_uiLevel</a>;
00583     <a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a> = other.<a class="code" href="classot_1_1TreeNode.html#p3">m_uiWeight</a>;
00584     <a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a> = other.<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>;
00585     <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a> = other.<a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>;
00586     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
00587   }<span class="comment">//end fn.</span>
00588 
<a name="l00589"></a><a class="code" href="classot_1_1TreeNode.html#a20">00589</a>   <span class="keywordtype">int</span> TreeNode::pickInternalBoundaryCells(std::vector&lt;TreeNode &gt; &amp; allInternal,
00590       std::vector&lt;TreeNode &gt; &amp; boundary)<span class="keyword">  const </span>{
00591     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = this-&gt;<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00592 
00593     <span class="comment">//Pre-alloc</span>
00594     boundary.resize(allInternal.size());
00595     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> boundarySz = 0; 
00596 
00597     <span class="keywordtype">int</span> myMinX = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00598     <span class="keywordtype">int</span> myMinY = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00599     <span class="keywordtype">int</span> myMinZ = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00600     <span class="keywordtype">int</span> myMaxX = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00601     <span class="keywordtype">int</span> myMaxY = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
00602     <span class="keywordtype">int</span> myMaxZ = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
00603 
00604     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; allInternal.size(); i++) {
00605 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00606 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, allInternal[i]));
00607       <span class="keywordflow">if</span>(!(this-&gt;<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(allInternal[i]) )) {
00608         std::cout&lt;&lt;(*this)&lt;&lt;<a class="code" href="colors_8h.html#a0">RED</a>&lt;&lt;<span class="stringliteral">" is not an Ancestor of "</span>&lt;&lt;<a class="code" href="colors_8h.html#a6">NRM</a>&lt;&lt;allInternal[i]&lt;&lt;std::endl;
00609       }
00610       assert( this-&gt;isAncestor(allInternal[i]) );
00611 <span class="preprocessor">#endif</span>
00612 <span class="preprocessor"></span>      <span class="keywordtype">int</span> testMinX = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00613       <span class="keywordtype">int</span> testMinY = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00614       <span class="keywordtype">int</span> testMinZ = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00615       <span class="keywordtype">int</span> testMaxX = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00616       <span class="keywordtype">int</span> testMaxY = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>(); 
00617       <span class="keywordtype">int</span> testMaxZ = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>(); 
00618       <span class="keywordflow">if</span>((myMinX == testMinX) || (myMaxX == testMaxX)) {
00619         boundary[boundarySz]=(allInternal[i]);
00620         boundarySz++;
00621       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim &gt; 1) {
00622         <span class="keywordflow">if</span>((myMinY == testMinY) || (myMaxY == testMaxY)) {
00623           boundary[boundarySz]=(allInternal[i]);
00624           boundarySz++;
00625         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim &gt; 2) {
00626           <span class="keywordflow">if</span>((myMinZ == testMinZ) || (myMaxZ == testMaxZ)) {
00627             boundary[boundarySz]=(allInternal[i]);
00628             boundarySz++;
00629           }<span class="comment">//end if</span>
00630         }<span class="comment">//end if-else-if       </span>
00631       }<span class="comment">//end if-else-if on boundary</span>
00632     }<span class="comment">//end for</span>
00633 
00634     boundary.resize(boundarySz);
00635     <span class="keywordflow">return</span> 1;
00636   }<span class="comment">//end function</span>
00637 
00638 
<a name="l00639"></a><a class="code" href="classot_1_1TreeNode.html#a21">00639</a>   <span class="keywordtype">int</span> TreeNode::splitInternalAndBoundaryCells(std::vector&lt;TreeNode&gt; &amp; allInternal,
00640       std::vector&lt;TreeNode&gt; &amp; onlyInternal, std::vector&lt;TreeNode&gt; &amp; boundary)<span class="keyword"> const</span>{
00641     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = this-&gt;<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00642 
00643     <span class="comment">//Pre-alloc</span>
00644     boundary.resize(allInternal.size());
00645     onlyInternal.resize(allInternal.size());
00646     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> boundarySz = 0; 
00647     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> onlyInternalSz = 0; 
00648 
00649     <span class="keywordtype">int</span> myMinX = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00650     <span class="keywordtype">int</span> myMinY = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00651     <span class="keywordtype">int</span> myMinZ = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00652     <span class="keywordtype">int</span> myMaxX = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00653     <span class="keywordtype">int</span> myMaxY = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
00654     <span class="keywordtype">int</span> myMaxZ = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
00655 
00656     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; allInternal.size(); i++) {
00657 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00658 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, allInternal[i]));
00659       <span class="keywordflow">if</span>(!(this-&gt;<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(allInternal[i]) )) {
00660         std::cout&lt;&lt;(*this)&lt;&lt;<a class="code" href="colors_8h.html#a0">RED</a>&lt;&lt;<span class="stringliteral">" is not an Ancestor of "</span>&lt;&lt;<a class="code" href="colors_8h.html#a6">NRM</a>&lt;&lt;allInternal[i]&lt;&lt;std::endl;
00661       }
00662       assert( this-&gt;isAncestor(allInternal[i]) );
00663 <span class="preprocessor">#endif</span>
00664 <span class="preprocessor"></span>      <span class="keywordtype">int</span> testMinX = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00665       <span class="keywordtype">int</span> testMinY = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00666       <span class="keywordtype">int</span> testMinZ = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00667       <span class="keywordtype">int</span> testMaxX = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00668       <span class="keywordtype">int</span> testMaxY = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>(); 
00669       <span class="keywordtype">int</span> testMaxZ = allInternal[i].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>(); 
00670       <span class="keywordflow">if</span>((myMinX == testMinX) || (myMaxX == testMaxX)) {
00671         boundary[boundarySz]=(allInternal[i]);
00672         boundarySz++;
00673       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim &gt; 1) {
00674         <span class="keywordflow">if</span>((myMinY == testMinY) || (myMaxY == testMaxY)) {
00675           boundary[boundarySz]=(allInternal[i]);
00676           boundarySz++;
00677         }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(dim &gt; 2) {
00678           <span class="keywordflow">if</span>((myMinZ == testMinZ) || (myMaxZ == testMaxZ)) {
00679             boundary[boundarySz]=(allInternal[i]);
00680             boundarySz++;
00681           }<span class="keywordflow">else</span> {
00682             onlyInternal[onlyInternalSz]=(allInternal[i]);
00683             onlyInternalSz++;
00684           }<span class="comment">//end if</span>
00685         }<span class="keywordflow">else</span> {
00686           onlyInternal[onlyInternalSz]=(allInternal[i]);
00687           onlyInternalSz++;
00688         }<span class="comment">//end if-else-if       </span>
00689       }<span class="keywordflow">else</span> {
00690         onlyInternal[onlyInternalSz]=(allInternal[i]);
00691         onlyInternalSz++;
00692       }<span class="comment">//end if-else-if on boundary</span>
00693     }<span class="comment">//end for</span>
00694 
00695     boundary.resize(boundarySz);
00696     onlyInternal.resize(onlyInternalSz);
00697     <span class="keywordflow">return</span> 1;
00698   }<span class="comment">//end function</span>
00699 
<a name="l00700"></a><a class="code" href="classot_1_1TreeNode.html#a3">00700</a>   <span class="keywordtype">int</span> TreeNode ::balanceSubtree(std::vector&lt;TreeNode &gt; &amp; inp,
00701       std::vector&lt;TreeNode  &gt; &amp; out, <span class="keywordtype">bool</span> incCorner,
00702       <span class="keywordtype">bool</span> isSortedCompleteLinear)<span class="keyword"> const </span>{
00703 
00704     <a class="code" href="octUtils_8h.html#a12">PROF_BAL_SUBTREE_BEGIN</a>
00705 
00706       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = <a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00707     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = <a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();      
00708     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxCornerX = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();     
00709     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxCornerY = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();     
00710     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxCornerZ = this-&gt;<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();     
00711     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minLevInp = maxDepth;
00712     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxLevInp = 0;
00713 
00714     out.clear();
00715     <span class="keywordflow">if</span>( (maxDepth == 0) || (<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>() == maxDepth) || (inp.empty()) ) {
00716       <span class="comment">//No decendants.</span>
00717       <a class="code" href="octUtils_8h.html#a51">PROF_BAL_SUBTREE_END</a>
00718     }
00719 
00720     std::vector&lt;TreeNode &gt; *workVec = NULL;
00721     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *workVecSz = NULL;     
00722 
00723     <span class="keywordflow">if</span>(maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()) {
00724       workVec = <span class="keyword">new</span> std::vector&lt;TreeNode &gt;[maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()];      
00725       workVecSz = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> [maxDepth-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()];       
00726     }
00727 
00728     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()); i++) {
00729       workVecSz[i] = 0;
00730     }
00731 
00732     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inp.size(); i++) {
00733 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00734 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, inp[i]));
00735 <span class="preprocessor">#endif</span>
00736 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( this-&gt;<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(inp[i]) ) {
00737         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currOctLev = inp[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00738         workVecSz[maxDepth - currOctLev]++;
00739         <span class="keywordflow">if</span>(currOctLev &lt; minLevInp) {
00740           minLevInp = currOctLev;
00741         }
00742         <span class="keywordflow">if</span>(currOctLev &gt; maxLevInp) {
00743           maxLevInp = currOctLev;
00744         }
00745       }<span class="comment">//end if decendant of block</span>
00746     }<span class="comment">//end for</span>
00747 
00748     <span class="keywordflow">if</span>(isSortedCompleteLinear &amp;&amp; ((maxLevInp - minLevInp) &lt; 2) ) {
00749       <span class="comment">//Already balanced</span>
00750       out = inp;
00751 
00752       <span class="keywordflow">if</span>(workVecSz) {
00753         <span class="keyword">delete</span> [] workVecSz;
00754         workVecSz = NULL;
00755       }
00756 
00757       <span class="keywordflow">if</span>(workVec) {
00758         <span class="keyword">delete</span> [] workVec;
00759         workVec = NULL;
00760       }
00761 
00762       <a class="code" href="octUtils_8h.html#a51">PROF_BAL_SUBTREE_END</a>
00763     }
00764 
00765     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()); i++) {
00766       workVec[i].resize(workVecSz[i]);
00767       workVecSz[i] = 0;
00768     }
00769 
00770     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inp.size(); i++) {
00771 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
00772 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, inp[i]));
00773 <span class="preprocessor">#endif</span>
00774 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( this-&gt;<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(inp[i]) ) {
00775         workVec[maxDepth - (inp[i].getLevel())][workVecSz[maxDepth - (inp[i].getLevel())]] = inp[i];
00776         workVecSz[maxDepth - (inp[i].getLevel())]++;
00777       }
00778     }<span class="comment">//end for</span>
00779 
00780     <span class="keywordflow">if</span>(workVecSz) {
00781       <span class="keyword">delete</span> [] workVecSz;
00782       workVecSz = NULL;
00783     }
00784 
00785     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmpRoot (<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>(), <a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>());
00786     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>() -1; i++) {
00787       <span class="comment">//This also sorts.</span>
00788       <a class="code" href="namespaceseq.html#a1">seq::makeVectorUnique</a>(workVec[i], <span class="keyword">false</span>);
00789       <span class="comment">//Remove Brothers from a sorted list.</span>
00790       std::vector&lt;TreeNode&gt; tmpList (workVec[i].size());
00791       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpListSz=0;
00792       <span class="keywordflow">if</span>(!workVec[i].empty()) {
00793         tmpList[tmpListSz] = workVec[i][0];
00794         tmpListSz++;
00795       }
00796       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=1;j&lt;workVec[i].size();j++) {
00797         <span class="keywordflow">if</span>(workVec[i][j-1].getParent() != workVec[i][j].getParent()) {
00798           tmpList[tmpListSz] = workVec[i][j];
00799           tmpListSz++;
00800         }
00801       }<span class="comment">//end for j</span>
00802       workVec[i].clear();
00803       tmpList.resize(tmpListSz);
00804       workVec[i] = tmpList;
00805       tmpList.clear();
00806       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldOutSz = out.size();
00807       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newOut = 0;
00808       out.resize(oldOutSz + (workVec[i].size()*(1 &lt;&lt; dim)));
00809       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldNextWsz = workVec[i+1].size();
00810       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newNextW = 0;
00811       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wLen = workVec[i].size();
00812       <span class="keywordflow">if</span>(wLen &gt; 0) {
00813         workVec[i+1].resize(oldNextWsz + (26*(workVec[i].size())));
00814       }
00815       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; wLen; j++) {
00816         out[oldOutSz + newOut]=workVec[i][j];
00817         newOut++;
00818         std::vector&lt;TreeNode&gt; bros;
00819         workVec[i][j].<a class="code" href="classot_1_1TreeNode.html#a1">addBrothers</a>(bros);
00820         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k =0;k&lt; ((1 &lt;&lt; dim)-1);k++) {
00821           out[oldOutSz + newOut]=bros[k];
00822           newOut++;
00823         }<span class="comment">//end for k</span>
00824         bros.clear();
00825 
00826         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  parent = workVec[i][j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
00827         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  tmpNode (<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>(), <a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>());
00828         <span class="comment">//Add all the neighbours of parent to workVec[i+1]</span>
00829 
00830         tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_12">getLeft</a>();
00831         <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {          
00832           <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00833               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00834               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00835             workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00836             newNextW++;
00837           }
00838         }
00839 
00840         tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_15">getRight</a>();
00841         <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {          
00842           <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00843               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00844               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00845             workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00846             newNextW++;
00847           }
00848         }
00849 
00850         tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_18">getTop</a>();
00851         <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {          
00852           <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00853               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00854               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00855             workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00856             newNextW++;
00857           }
00858         } 
00859 
00860         tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_2">getBottom</a>();
00861         <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {          
00862           <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00863               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00864               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00865             workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00866             newNextW++;
00867           }
00868         }    
00869 
00870         tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_11">getFront</a>();
00871         <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {          
00872           <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00873               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00874               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00875             workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00876             newNextW++;
00877           }
00878         }            
00879 
00880         tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_1">getBack</a>(); 
00881         <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {          
00882           <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00883               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00884               (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00885             workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00886             newNextW++;
00887           }
00888         }        
00889         <span class="keywordflow">if</span>(dim == 3 || incCorner) {
00890           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_21">getTopLeft</a>();
00891           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00892             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00893                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00894                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00895               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00896               newNextW++;
00897             }
00898           }     
00899 
00900           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_24">getTopRight</a>();
00901           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00902             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00903                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00904                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00905               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00906               newNextW++;
00907             }
00908           }      
00909 
00910           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_5">getBottomLeft</a>() ; 
00911           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00912             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00913                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00914                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00915               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00916               newNextW++;
00917             }
00918           }    
00919 
00920           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_8">getBottomRight</a>();
00921           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00922             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00923                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00924                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00925               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00926               newNextW++;
00927             }
00928           } 
00929 
00930           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_14">getLeftFront</a>() ;
00931           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00932             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00933                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00934                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00935               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00936               newNextW++;
00937             }
00938           }
00939 
00940           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_17">getRightFront</a>() ;
00941           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00942             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00943                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00944                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00945               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00946               newNextW++;
00947             }
00948           }
00949 
00950           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_20">getTopFront</a>() ;
00951           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00952             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00953                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00954                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00955               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00956               newNextW++;
00957             }
00958           }
00959 
00960           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_4">getBottomFront</a>() ;
00961           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00962             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00963                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00964                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00965               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00966               newNextW++;
00967             }
00968           }
00969           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_13">getLeftBack</a>() ;
00970           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00971             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00972                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00973                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00974               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00975               newNextW++;
00976             }
00977           }
00978 
00979           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_16">getRightBack</a>() ;
00980           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00981             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00982                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00983                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00984               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00985               newNextW++;
00986             }
00987           }
00988 
00989           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_19">getTopBack</a>();
00990           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
00991             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
00992                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
00993                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
00994               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
00995               newNextW++;
00996             }
00997           }
00998 
00999           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_3">getBottomBack</a>();
01000           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01001             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01002                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01003                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01004               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01005               newNextW++;
01006             }
01007           }
01008 
01009 
01010         }<span class="comment">//end if-incCorner or dim=3</span>
01011         <span class="keywordflow">if</span>(incCorner) {
01012           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_23">getTopLeftFront</a>() ;
01013           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01014             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01015                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01016                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01017               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01018               newNextW++;
01019             }
01020           }
01021 
01022           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_26">getTopRightFront</a>(); 
01023           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01024             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01025                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01026                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01027               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01028               newNextW++;
01029             }
01030           }
01031 
01032           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_7">getBottomLeftFront</a>();
01033           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01034             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01035                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01036                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01037               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01038               newNextW++;
01039             }
01040           }
01041 
01042           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_10">getBottomRightFront</a>();
01043           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01044             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01045                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01046                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01047               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01048               newNextW++;
01049             }
01050           }
01051 
01052           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_22">getTopLeftBack</a>();
01053           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01054             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01055                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01056                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01057               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01058               newNextW++;
01059             }
01060           }
01061 
01062           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_25">getTopRightBack</a>();
01063           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01064             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01065                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01066                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01067               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01068               newNextW++;
01069             }
01070           }
01071 
01072           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_6">getBottomLeftBack</a>();
01073           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01074             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01075                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01076                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01077               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01078               newNextW++;
01079             }
01080           }
01081 
01082           tmpNode = parent.<a class="code" href="classot_1_1TreeNode.html#z21_9">getBottomRightBack</a>();
01083           <span class="keywordflow">if</span>(tmpNode &gt; tmpRoot) {                
01084             <span class="keywordflow">if</span>( (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &gt;= this-&gt;m_uiX) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &gt;= this-&gt;m_uiY) &amp;&amp; 
01085                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &gt;= this-&gt;m_uiZ) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p4">m_uiX</a> &lt; maxCornerX) &amp;&amp;
01086                 (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p5">m_uiY</a> &lt; maxCornerY) &amp;&amp; (tmpNode.<a class="code" href="classot_1_1TreeNode.html#p6">m_uiZ</a> &lt; maxCornerZ) ) {
01087 
01088               workVec[i+1][oldNextWsz + newNextW]=tmpNode;
01089               newNextW++;
01090             }
01091           }
01092         }<span class="comment">//end if-incCorner</span>
01093       }<span class="comment">//end for j</span>
01094       workVec[i].clear();
01095       <span class="keywordflow">if</span>(wLen &gt; 0) {
01096         workVec[i+1].resize(oldNextWsz + newNextW);
01097       }
01098     }<span class="comment">//end for i</span>
01099 
01100     <span class="keywordflow">if</span>(workVec) {
01101       <span class="keywordflow">if</span>(!(workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()].empty())) {
01102         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldOutSz = out.size();
01103         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newOut = 0;
01104         out.resize(oldOutSz + (1 &lt;&lt; dim));
01105         out[oldOutSz + newOut]=workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()][0];
01106         newOut++;
01107         std::vector&lt;TreeNode&gt; bros;
01108         workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()][0].<a class="code" href="classot_1_1TreeNode.html#a1">addBrothers</a>(bros);
01109         workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()].clear();
01110         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k =0;k &lt; ((1 &lt;&lt; dim) -1);k++) {
01111           out[oldOutSz + newOut]=bros[k];
01112           newOut++;
01113         }<span class="comment">//end for k</span>
01114 
01115         bros.clear();
01116       }<span class="comment">//end if</span>
01117       <span class="keyword">delete</span> [] workVec;
01118       workVec = NULL;
01119     }
01120 
01121     <span class="comment">//Sort and make unique.</span>
01122     seq::makeVectorUnique&lt;TreeNode&gt;(out,<span class="keyword">false</span>);
01123     <span class="comment">//Remove overlaps.</span>
01124     std::vector&lt;unsigned int&gt; toRem(out.size());
01125     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> remCtr =0;
01126     <span class="comment">//compare i+1 with i</span>
01127     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i&lt;out.size(); i++) {
01128 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
01129 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i-1], out[i]));
01130 <span class="preprocessor">#endif</span>
01131 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(out[i-1].isAncestor(out[i])) {
01132         toRem[remCtr]=(i-1);
01133         remCtr++;
01134       }<span class="comment">//end if</span>
01135     }<span class="comment">//end for i</span>
01136     toRem.resize(remCtr);
01137 
01138     <span class="keywordflow">if</span>(!toRem.empty()) {
01139       <span class="comment">//Note toRem is sorted.</span>
01140       std::vector&lt;TreeNode&gt; tmpRem(out.size()-toRem.size());
01141       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos=0; <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk=0;
01142       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;toRem.size();i++) {
01143         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = pos; j&lt;toRem[i];j++) {
01144           tmpRem[kk]=out[j];
01145           kk++;
01146         }<span class="comment">//end for j</span>
01147         pos = toRem[i]+1;
01148       }<span class="comment">//end for i</span>
01149       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = pos;j &lt; out.size(); j++) {
01150         tmpRem[kk] = out[j];
01151         kk++;
01152       }<span class="comment">//end for j</span>
01153       out = tmpRem;
01154       tmpRem.clear();
01155     }<span class="comment">//end if </span>
01156     toRem.clear();
01157 
01158     <a class="code" href="octUtils_8h.html#a51">PROF_BAL_SUBTREE_END</a>
01159   }<span class="comment">//end function   </span>
01160 
<a name="l01161"></a><a class="code" href="classot_1_1TreeNode.html#a4">01161</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a34">TreeNode ::completeSubtree</a>(std::vector&lt;TreeNode &gt; &amp; inp,
01162       std::vector&lt;TreeNode  &gt; &amp; out )<span class="keyword"> const </span>{
01163 
01164     <a class="code" href="octUtils_8h.html#a13">PROF_COMPLETE_SUBTREE_BEGIN</a>
01165 
01166       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = m_uiDim;
01167     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = m_uiMaxDepth;       
01168 
01169     out.clear();
01170     <span class="keywordflow">if</span>( (maxDepth == 0) || (<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>() == maxDepth) || (inp.empty()) ) {
01171       <span class="comment">//No decendants.</span>
01172       <a class="code" href="octUtils_8h.html#a52">PROF_COMPLETE_SUBTREE_END</a>
01173     }
01174 
01175     std::vector&lt;TreeNode &gt; *workVec = NULL;
01176     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *workVecSz = NULL;
01177 
01178     <span class="keywordflow">if</span>(maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()) {
01179       workVec = <span class="keyword">new</span> std::vector&lt;TreeNode &gt;[maxDepth-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()];        
01180       workVecSz = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> [maxDepth-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()];       
01181     }
01182 
01183     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()); i++) {
01184       workVecSz[i] = 0;
01185     }
01186 
01187     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inp.size(); i++) {
01188 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
01189 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, inp[i]));
01190 <span class="preprocessor">#endif</span>
01191 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( this-&gt;<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(inp[i]) ) {
01192         workVecSz[maxDepth - (inp[i].getLevel())]++;
01193       } <span class="keywordflow">else</span> {
01194         std::cout&lt;&lt;inp[i]&lt;&lt;<span class="stringliteral">" is not a decendant of "</span>&lt;&lt;(*this)&lt;&lt;std::endl;
01195         assert(<span class="keyword">false</span>);
01196       }
01197     }<span class="comment">//end for</span>
01198 
01199     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()); i++) {
01200       workVec[i].resize(workVecSz[i]);
01201       workVecSz[i] = 0;
01202     }
01203 
01204     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inp.size(); i++) {
01205 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
01206 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(*<span class="keyword">this</span>, inp[i]));
01207 <span class="preprocessor">#endif</span>
01208 <span class="preprocessor"></span>      <span class="keywordflow">if</span>( this-&gt;<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(inp[i]) ) {
01209         workVec[maxDepth - (inp[i].getLevel())][workVecSz[maxDepth - (inp[i].getLevel())]] = inp[i];
01210         workVecSz[maxDepth - (inp[i].getLevel())]++;
01211       }
01212     }<span class="comment">//end for</span>
01213 
01214     <span class="keywordflow">if</span>(workVecSz) {
01215       <span class="keyword">delete</span> [] workVecSz;
01216       workVecSz = NULL;
01217     }
01218 
01219     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmpRoot (<a class="code" href="classot_1_1TreeNode.html#p0">m_uiDim</a>, <a class="code" href="classot_1_1TreeNode.html#p2">m_uiMaxDepth</a>);
01220     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (maxDepth - <a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>() -1); i++) {
01221       <span class="comment">//This also sorts.</span>
01222       <a class="code" href="namespaceseq.html#a1">seq::makeVectorUnique</a>(workVec[i], <span class="keyword">false</span>);
01223       <span class="comment">//Remove Brothers from a sorted list.</span>
01224       std::vector&lt;TreeNode&gt; tmpList (workVec[i].size());
01225       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpListSz=0;
01226       <span class="keywordflow">if</span>(!workVec[i].empty()) {
01227         tmpList[tmpListSz] = workVec[i][0];
01228         tmpListSz++;
01229       }
01230       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 1; j &lt; workVec[i].size(); j++) {
01231         <span class="keywordflow">if</span>(workVec[i][j-1].getParent() != workVec[i][j].getParent()) {
01232           tmpList[tmpListSz] = workVec[i][j];
01233           tmpListSz++;
01234         }
01235       }<span class="comment">//end for j</span>
01236       workVec[i].clear();
01237       tmpList.resize(tmpListSz);
01238       workVec[i] = tmpList;
01239       tmpList.clear();
01240       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldOutSz = out.size();
01241       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newOut = 0;
01242       out.resize(oldOutSz + (workVec[i].size()*(1 &lt;&lt; dim)));
01243       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldNextWsz = workVec[i+1].size();
01244       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newNextW = 0;
01245       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wLen = workVec[i].size();
01246       <span class="keywordflow">if</span>(wLen &gt; 0) {
01247         workVec[i+1].resize(oldNextWsz + (7*(workVec[i].size())));
01248       }
01249       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; wLen; j++) {
01250         out[oldOutSz + newOut]=workVec[i][j];
01251         newOut++;
01252         std::vector&lt;TreeNode&gt; bros;
01253         workVec[i][j].<a class="code" href="classot_1_1TreeNode.html#a1">addBrothers</a>(bros);
01254         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k =0;k&lt; ((1 &lt;&lt; dim)-1);k++) {
01255           out[oldOutSz + newOut]=bros[k];
01256           newOut++;
01257         }<span class="comment">//end for k</span>
01258         bros.clear();
01259 
01260         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  parent = workVec[i][j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
01261         parent.<a class="code" href="classot_1_1TreeNode.html#a1">addBrothers</a>(bros);
01262         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k =0;k&lt; ((1 &lt;&lt; dim)-1);k++) {
01263           workVec[i+1][oldNextWsz + newNextW]=bros[k];
01264           newNextW++;
01265         }<span class="comment">//end for k</span>
01266         bros.clear();
01267         <span class="comment">//Add all the brothers of parent to workVec[i+1]</span>
01268       }<span class="comment">//end for j</span>
01269       workVec[i].clear();
01270       <span class="keywordflow">if</span>(wLen &gt; 0) {
01271         workVec[i+1].resize(oldNextWsz + newNextW);
01272       }
01273     }<span class="comment">//end for i</span>
01274 
01275     <span class="keywordflow">if</span>(workVec) {
01276       <span class="keywordflow">if</span>(!(workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()].empty())) {
01277         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldOutSz = out.size();
01278         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> newOut = 0;
01279         out.resize(oldOutSz + (1 &lt;&lt; dim));
01280         out[oldOutSz + newOut]=workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()][0];
01281         newOut++;
01282         std::vector&lt;TreeNode&gt; bros;
01283         workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()][0].<a class="code" href="classot_1_1TreeNode.html#a1">addBrothers</a>(bros);
01284         workVec[maxDepth-1-<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()].clear();
01285         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k =0;k &lt; ((1 &lt;&lt; dim) -1);k++) {
01286           out[oldOutSz + newOut]=bros[k];
01287           newOut++;
01288         }<span class="comment">//end for k</span>
01289 
01290         bros.clear();
01291       }<span class="comment">//end if</span>
01292       <span class="keyword">delete</span> [] workVec;
01293       workVec = NULL;
01294     }
01295 
01296     <span class="comment">//sort and removde dups.</span>
01297     seq::makeVectorUnique&lt;TreeNode&gt;(out, <span class="keyword">false</span>);
01298     <span class="comment">//Remove overlaps.</span>
01299     std::vector&lt;unsigned int&gt; toRem(out.size());
01300     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> remCtr =0;
01301     <span class="comment">//compare i+1 with i</span>
01302     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; out.size(); i++) {
01303 <span class="preprocessor">#ifdef __DEBUG_TN__</span>
01304 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i-1], out[i]));
01305 <span class="preprocessor">#endif</span>
01306 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(out[i-1].isAncestor(out[i])) {
01307         toRem[remCtr]=(i-1);
01308         remCtr++;
01309       }<span class="comment">//end if</span>
01310     }<span class="comment">//end for i</span>
01311     toRem.resize(remCtr);
01312 
01313     <span class="keywordflow">if</span>(!toRem.empty()) {
01314       <span class="comment">//Note toRem is sorted.</span>
01315       std::vector&lt;TreeNode&gt; tmpRem(out.size()-toRem.size());
01316       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = 0;
01317       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> kk=0;
01318       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; toRem.size(); i++) {
01319         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = pos; j &lt; toRem[i]; j++) {
01320           tmpRem[kk]=out[j];
01321           kk++;
01322         }<span class="comment">//end for j</span>
01323         pos = toRem[i]+1;
01324       }<span class="comment">//end for i</span>
01325       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = pos; j &lt; out.size(); j++) {
01326         tmpRem[kk] = out[j];
01327         kk++;
01328       }<span class="comment">//end for j</span>
01329       out = tmpRem;
01330       tmpRem.clear();
01331     }<span class="comment">//end if </span>
01332     toRem.clear();
01333 
01334     <a class="code" href="octUtils_8h.html#a52">PROF_COMPLETE_SUBTREE_END</a>
01335 
01336   }<span class="comment">//end function   </span>
01337 
01338 }<span class="comment">//end namespace</span>
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:31 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
