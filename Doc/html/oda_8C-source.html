<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oda/oda.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000016.html">oda</a></div>
<h1>oda.C</h1><a href="oda_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00008 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="colors_8h.html">colors.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="testUtils_8h.html">testUtils.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="dendro_8h.html">dendro.h</a>"</span>
00013 
00014 <span class="preprocessor">#ifdef __DEBUG__</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA__</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA__</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#ifdef __DEBUG_DA__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA_PUBLIC__</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA_PUBLIC__</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#ifndef __MEASURE_DA__</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#define __MEASURE_DA__</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00031 <span class="preprocessor"></span>
00032 <span class="keyword">namespace </span>ot {
00033 
<a name="l00034"></a><a class="code" href="classot_1_1DA.html#z35_2">00034</a>   <span class="keywordtype">int</span> DA::computeLocalToGlobalElemMappings() {
00035     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> localElemSize = <a class="code" href="classot_1_1DA.html#z31_5">getElementSize</a>();
00036     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> off1, globalOffset;
00037     MPI_Request sendRequest;
00038     MPI_Status status;
00039     <span class="keywordflow">if</span>(m_bIamActive) {
00040       par::Mpi_Scan&lt;DendroIntL&gt;(&amp;localElemSize, &amp;off1, 1, MPI_SUM, m_mpiCommActive); 
00041       <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt; (<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a> - 1)) {
00042         par::Mpi_Issend&lt;DendroIntL&gt;(&amp;off1, 1, <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>+1, 0, m_mpiCommActive, &amp;sendRequest);
00043       }
00044 
00045       <span class="keywordflow">if</span>(m_iRankActive) {
00046         par::Mpi_Recv&lt;DendroIntL&gt;(&amp;globalOffset, 1, <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>-1, 0, m_mpiCommActive, &amp;status );
00047       }<span class="keywordflow">else</span> {
00048         globalOffset = 0;
00049       }
00050     }
00051 
00052     <span class="comment">//Equivalent to createVector: elemental, non-ghosted, 1 dof</span>
00053     std::vector&lt;DendroIntL&gt; gNumNonGhostElems(localElemSize); 
00054 
00055     <span class="keywordflow">for</span>(<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 0; i &lt; localElemSize; i++) {
00056       gNumNonGhostElems[i] = (i+globalOffset);   
00057     }
00058 
00059     vecGetBuffer&lt;DendroIntL&gt;(gNumNonGhostElems,
00060         m_dilpLocalToGlobalElems, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
00061 
00062     <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a> &amp;&amp; (<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt; (<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>-1)) ) {
00063       MPI_Status statusWait;
00064       MPI_Wait(&amp;sendRequest, &amp;statusWait);
00065     }
00066 
00067     ReadFromGhostElemsBegin&lt;DendroIntL&gt;(m_dilpLocalToGlobalElems,1);
00068     ReadFromGhostElemsEnd&lt;DendroIntL&gt;(m_dilpLocalToGlobalElems);
00069 
00070     gNumNonGhostElems.clear();
00071     <a class="code" href="classot_1_1DA.html#p2">m_bComputedLocalToGlobalElems</a> = <span class="keyword">true</span>;
00072 
00073     <span class="keywordflow">return</span> 0;
00074   }<span class="comment">//end function</span>
00075 
<a name="l00076"></a><a class="code" href="classot_1_1DA.html#z35_3">00076</a>   <span class="keywordtype">int</span> DA::computeLocalToGlobalMappings() {
00077     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> localNodeSize = <a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00078     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> off1, globalOffset;
00079     MPI_Request sendRequest;
00080     MPI_Status status;
00081     <span class="keywordflow">if</span>(m_bIamActive) {
00082       par::Mpi_Scan&lt;DendroIntL&gt;(&amp;localNodeSize, &amp;off1, 1, MPI_SUM, m_mpiCommActive); 
00083       <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt; (<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>-1)) {
00084         par::Mpi_Issend&lt;DendroIntL&gt;(&amp;off1, 1, <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>+1, 0, m_mpiCommActive, &amp;sendRequest);
00085       }
00086 
00087       <span class="keywordflow">if</span>(m_iRankActive) {
00088         par::Mpi_Recv&lt;DendroIntL&gt;(&amp;globalOffset, 1, <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>-1, 0, m_mpiCommActive, &amp;status);
00089       }<span class="keywordflow">else</span> {
00090         globalOffset = 0;
00091       }
00092     }
00093 
00094     std::vector&lt;DendroIntL&gt; gNumNonGhostNodes(localNodeSize); 
00095     <span class="keywordflow">for</span>(<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 0; i &lt; localNodeSize; i++) {
00096       gNumNonGhostNodes[i] = (i+globalOffset);   
00097     }
00098 
00099     vecGetBuffer&lt;DendroIntL&gt;(gNumNonGhostNodes, m_dilpLocalToGlobal,
00100         <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
00101 
00102     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a> &amp;&amp; (<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt; (<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>-1))) {
00103       MPI_Status statusWait;
00104       MPI_Wait(&amp;sendRequest, &amp;statusWait);
00105     }
00106 
00107     ReadFromGhostsBegin&lt;DendroIntL&gt;(m_dilpLocalToGlobal,1);
00108     ReadFromGhostsEnd&lt;DendroIntL&gt;(m_dilpLocalToGlobal);
00109 
00110     gNumNonGhostNodes.clear();
00111     <a class="code" href="classot_1_1DA.html#p1">m_bComputedLocalToGlobal</a> = <span class="keyword">true</span>;
00112 
00113     <span class="keywordflow">return</span> 0;
00114   }<span class="comment">//end function</span>
00115 
<a name="l00116"></a><a class="code" href="classot_1_1DA.html#z35_9">00116</a>   <span class="keywordtype">int</span> DA::setValuesInMatrix(Mat mat, std::vector&lt;ot::MatRecord&gt;&amp; records, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof, InsertMode mode) {
00117 
00118     <a class="code" href="oda_8h.html#a17">PROF_SET_MAT_VALUES_BEGIN</a> 
00119 
00120       assert(<a class="code" href="classot_1_1DA.html#p1">m_bComputedLocalToGlobal</a>);
00121     std::vector&lt;PetscScalar&gt; values;
00122     std::vector&lt;PetscInt&gt; colIndices;
00123 
00124     <span class="comment">//Can make it more efficient later.</span>
00125     <span class="keywordflow">if</span>(!records.empty()) {
00126       <span class="comment">//Sort Order: row first, col next, val last</span>
00127       <a class="code" href="Sort_8h.html#a7">std::sort</a>(records.begin(), records.end());
00128 
00129       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currRecord = 0;
00130       <span class="keywordflow">while</span>(currRecord &lt; (records.size()-1)) {
00131         values.push_back(records[currRecord].val);
00132         colIndices.push_back( static_cast&lt;PetscInt&gt;(
00133               (dof*<a class="code" href="classot_1_1DA.html#p4">m_dilpLocalToGlobal</a>[records[currRecord].colIdx]) +
00134               records[currRecord].colDim) );
00135         <span class="keywordflow">if</span>( (records[currRecord].rowIdx != records[currRecord+1].rowIdx) ||
00136             (records[currRecord].rowDim != records[currRecord+1].rowDim) ) {
00137           PetscInt rowId = static_cast&lt;PetscInt&gt;(
00138               (dof*<a class="code" href="classot_1_1DA.html#p4">m_dilpLocalToGlobal</a>[records[currRecord].rowIdx]) + 
00139               records[currRecord].rowDim);
00140           MatSetValues(mat,1,&amp;rowId,colIndices.size(),(&amp;(*colIndices.begin())),
00141               (&amp;(*values.begin())),mode);
00142           colIndices.clear();
00143           values.clear();
00144         }
00145         currRecord++;
00146       }<span class="comment">//end while</span>
00147       PetscInt rowId = static_cast&lt;PetscInt&gt;(
00148           (dof*<a class="code" href="classot_1_1DA.html#p4">m_dilpLocalToGlobal</a>[records[currRecord].rowIdx]) +
00149           records[currRecord].rowDim);
00150       <span class="keywordflow">if</span>(values.empty()) {
00151         <span class="comment">//Last row is different from the previous row</span>
00152         PetscInt colId = static_cast&lt;PetscInt&gt;(
00153             (dof*<a class="code" href="classot_1_1DA.html#p4">m_dilpLocalToGlobal</a>[records[currRecord].colIdx]) + 
00154             records[currRecord].colDim);
00155         PetscScalar value = records[currRecord].val;
00156         MatSetValues(mat,1,&amp;rowId,1,&amp;colId,&amp;value,mode);
00157       }<span class="keywordflow">else</span> {
00158         <span class="comment">//Last row is same as the previous row</span>
00159         values.push_back(records[currRecord].val);
00160         colIndices.push_back( static_cast&lt;PetscInt&gt;(
00161               (dof*<a class="code" href="classot_1_1DA.html#p4">m_dilpLocalToGlobal</a>[records[currRecord].colIdx]) + 
00162               records[currRecord].colDim) );
00163         MatSetValues(mat,1,&amp;rowId,colIndices.size(),(&amp;(*colIndices.begin())),
00164             (&amp;(*values.begin())),mode);
00165         colIndices.clear();
00166         values.clear();
00167       }
00168       records.clear();
00169     }
00170 
00171     <a class="code" href="oda_8h.html#a18">PROF_SET_MAT_VALUES_END</a>
00172   }<span class="comment">//end function</span>
00173 
00174   <span class="comment">//***************Constructor*****************//</span>
<a name="l00175"></a><a class="code" href="classot_1_1DA.html#z29_1">00175</a>   DA::DA(std::vector&lt;ot::TreeNode&gt; &amp;in, MPI_Comm comm, MPI_Comm activeInputComm,
00176       <span class="keywordtype">bool</span> compressLut, <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;* blocksPtr, <span class="keywordtype">bool</span>* iAmActive ) {
00177 
00178 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00179 <span class="preprocessor"></span>    MPI_Barrier(comm);
00180 <span class="preprocessor">#endif</span>
00181 <span class="preprocessor"></span>    <a class="code" href="oda_8h.html#a19">PROF_BUILD_DA_BEGIN</a> 
00182 
00183       <a class="code" href="classot_1_1DA.html#b1">DA_FactoryPart0</a>(in, comm, activeInputComm, compressLut, iAmActive);
00184 
00185     <span class="keywordflow">if</span>(m_bIamActive) {
00186       <a class="code" href="classot_1_1DA.html#b2">DA_FactoryPart1</a>(in);
00187 
00188       <a class="code" href="classot_1_1DA.html#b3">DA_FactoryPart2</a>(in);
00189 
00190       <a class="code" href="classot_1_1DA.html#b4">DA_FactoryPart3</a>(in, comm, compressLut, blocksPtr, iAmActive);
00191     }
00192 
00193     <a class="code" href="oda_8h.html#a20">PROF_BUILD_DA_END</a>
00194   }<span class="comment">//end constructor</span>
00195 
<a name="l00196"></a><a class="code" href="classot_1_1DA.html#z29_0">00196</a>   DA::DA(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dummy, std::vector&lt;ot::TreeNode&gt; &amp;in, MPI_Comm comm,
00197       MPI_Comm activeInputComm, <span class="keywordtype">bool</span> compressLut, 
00198       <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt; * blocksPtr, <span class="keywordtype">bool</span>* iAmActive ) {
00199 
00200 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00201 <span class="preprocessor"></span>    MPI_Barrier(comm);
00202 <span class="preprocessor">#endif</span>
00203 <span class="preprocessor"></span>    <a class="code" href="oda_8h.html#a19">PROF_BUILD_DA_BEGIN</a> 
00204 
00205       <a class="code" href="classot_1_1DA.html#b1">DA_FactoryPart0</a>(in, comm, activeInputComm, compressLut, iAmActive);
00206 
00207     <span class="keywordflow">if</span>(m_bIamActive) {
00208       <a class="code" href="classot_1_1DA.html#b4">DA_FactoryPart3</a>(in, comm, compressLut, blocksPtr, iAmActive);
00209     }
00210 
00211     <a class="code" href="oda_8h.html#a20">PROF_BUILD_DA_END</a>
00212   }<span class="comment">//end constructor</span>
00213 
<a name="l00214"></a><a class="code" href="classot_1_1DA.html#z29_2">00214</a>   DA::~DA() {
00215     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a> != NULL) {
00216       <span class="keyword">delete</span> [] m_ucpOctLevels;
00217       <a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a> = NULL;
00218     }
00219 
00220     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p4">m_dilpLocalToGlobal</a> != NULL) {
00221       <span class="keyword">delete</span> [] m_dilpLocalToGlobal;
00222       <a class="code" href="classot_1_1DA.html#p4">m_dilpLocalToGlobal</a> = NULL;
00223     }
00224 
00225     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p5">m_dilpLocalToGlobalElems</a> != NULL) {
00226       <span class="keyword">delete</span> [] m_dilpLocalToGlobalElems;
00227       <a class="code" href="classot_1_1DA.html#p5">m_dilpLocalToGlobalElems</a> = NULL;
00228     }
00229 
00230     <a class="code" href="classot_1_1DA.html#p24">m_ucpLutRemainders</a>.clear();
00231     <a class="code" href="classot_1_1DA.html#p70">m_uspLutQuotients</a>.clear();
00232     <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>.clear();
00233     <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>.clear();
00234     <a class="code" href="classot_1_1DA.html#p46">m_uiNlist</a>.clear();
00235   }
00236 
00237   <span class="comment">/************** Domain Access ****************/</span>
<a name="l00238"></a><a class="code" href="classot_1_1DA.html#z31_17">00238</a>   <a class="code" href="classPoint.html">Point</a> DA::getNextOffset(<a class="code" href="classPoint.html">Point</a> p, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> d) {
00239 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00240 <span class="preprocessor"></span>    assert(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a>);
00241 <span class="preprocessor">#endif</span>
00242 <span class="preprocessor"></span>
00243     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = (<span class="keywordtype">unsigned</span> int)(1u&lt;&lt;( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d ) );
00244     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len_par = (<span class="keywordtype">unsigned</span> int)(1u&lt;&lt;( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d +1 ) );
00245 
00246     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i,j,k;
00247 
00248     i = p.<a class="code" href="classPoint.html#z52_1">xint</a>(); i %= len_par;
00249     j = p.<a class="code" href="classPoint.html#z52_3">yint</a>(); j %= len_par;
00250     k = p.<a class="code" href="classPoint.html#z52_5">zint</a>(); k %= len_par;
00251     i /= len;
00252     j /= len;
00253     k /= len;
00254 
00255     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> childNum = 4*k + 2*j + i;
00256 
00257     <a class="code" href="classPoint.html">Point</a> p2;
00258     <span class="keywordflow">switch</span> (childNum) {
00259       <span class="keywordflow">case</span> 7:
00260         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>() - len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>() -len;
00261         <span class="keywordflow">return</span> <a class="code" href="classot_1_1DA.html#z31_17">getNextOffset</a>(p2, d-1);
00262       <span class="keywordflow">case</span> 0:
00263         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00264         <span class="keywordflow">break</span>;
00265       <span class="keywordflow">case</span> 1:
00266         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>() +len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00267         <span class="keywordflow">break</span>;
00268       <span class="keywordflow">case</span> 2:
00269         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00270         <span class="keywordflow">break</span>;
00271       <span class="keywordflow">case</span> 3:
00272         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>() - len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>() +len;
00273         <span class="keywordflow">break</span>;
00274       <span class="keywordflow">case</span> 4:
00275         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00276         <span class="keywordflow">break</span>;
00277       <span class="keywordflow">case</span> 5:
00278         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>()+len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00279         <span class="keywordflow">break</span>;
00280       <span class="keywordflow">case</span> 6:
00281         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00282         <span class="keywordflow">break</span>;
00283       <span class="keywordflow">default</span>:
00284         std::cerr &lt;&lt; <span class="stringliteral">"Wrong child number in "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
00285         assert(<span class="keyword">false</span>);
00286         <span class="keywordflow">break</span>;
00287     } <span class="comment">// switch (childNum)</span>
00288 
00289     <span class="keywordflow">return</span> p2;
00290   }
00291 
<a name="l00292"></a><a class="code" href="classot_1_1DA.html#z31_25">00292</a>   <span class="keywordtype">void</span> DA::incrementCurrentOffset() {
00293 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00294 <span class="preprocessor"></span>    assert(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a>);
00295 <span class="preprocessor">#endif</span>
00296 <span class="preprocessor"></span>
00297     <span class="comment">// if it is the first element, simply return the stored offset ...</span>
00298     <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1DA.html#p33">m_uiCurrent</a> == (<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>-1)) {
00299       <a class="code" href="classot_1_1DA.html#p14">m_ptCurrentOffset</a> = m_ptOffset;
00300       <span class="keywordflow">return</span>; 
00301     }
00302 
00303 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00304 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[m_uiCurrent] &amp; ot::TreeNode::BOUNDARY ) {
00305       std::cerr &lt;&lt; <a class="code" href="colors_8h.html#a0">RED</a><span class="stringliteral">"ERROR, Boundary eleme in incre Curr offset"</span><a class="code" href="colors_8h.html#a6">NRM</a> &lt;&lt; std::endl;
00306       assert(<span class="keyword">false</span>);
00307     }
00308 <span class="preprocessor">#endif</span>
00309 <span class="preprocessor"></span>
00310     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> d = (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[m_uiCurrent] &amp; ot::TreeNode::MAX_LEVEL );
00311     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = (<span class="keywordtype">unsigned</span> int)(1u&lt;&lt;( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d ) );
00312     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len_par = (<span class="keywordtype">unsigned</span> int)(1u&lt;&lt;( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d +1 ) );
00313 
00314     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i,j,k;
00315 
00316     i = <a class="code" href="classot_1_1DA.html#p14">m_ptCurrentOffset</a>.<a class="code" href="classPoint.html#z52_1">xint</a>(); 
00317     j = <a class="code" href="classot_1_1DA.html#p14">m_ptCurrentOffset</a>.<a class="code" href="classPoint.html#z52_3">yint</a>(); 
00318     k = <a class="code" href="classot_1_1DA.html#p14">m_ptCurrentOffset</a>.<a class="code" href="classPoint.html#z52_5">zint</a>(); 
00319 
00320     i %= len_par;
00321     j %= len_par;
00322     k %= len_par;
00323 
00324     i /= len;
00325     j /= len;
00326     k /= len;
00327 
00328     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> childNum = 4*k + 2*j + i;
00329 
00330     <a class="code" href="classPoint.html">Point</a> p = m_ptCurrentOffset;
00331     <a class="code" href="classPoint.html">Point</a> p2;
00332     <span class="keywordflow">switch</span> (childNum) {
00333       <span class="keywordflow">case</span> 7:
00334         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>() - len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>() -len;
00335         p2 = <a class="code" href="classot_1_1DA.html#z31_17">getNextOffset</a>(p2, d-1);
00336         <span class="keywordflow">break</span>;
00337       <span class="keywordflow">case</span> 0:
00338         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00339         <span class="keywordflow">break</span>;
00340       <span class="keywordflow">case</span> 1:
00341         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>() +len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00342         <span class="keywordflow">break</span>;
00343       <span class="keywordflow">case</span> 2:
00344         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00345         <span class="keywordflow">break</span>;
00346       <span class="keywordflow">case</span> 3:
00347         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>() - len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>() +len;
00348         <span class="keywordflow">break</span>;
00349       <span class="keywordflow">case</span> 4:
00350         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00351         <span class="keywordflow">break</span>;
00352       <span class="keywordflow">case</span> 5:
00353         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() -len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>()+len; p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00354         <span class="keywordflow">break</span>;
00355       <span class="keywordflow">case</span> 6:
00356         p2.<a class="code" href="classPoint.html#z52_0">x</a>() = p.<a class="code" href="classPoint.html#z52_0">x</a>() +len; p2.<a class="code" href="classPoint.html#z52_2">y</a>() = p.<a class="code" href="classPoint.html#z52_2">y</a>(); p2.<a class="code" href="classPoint.html#z52_4">z</a>() = p.<a class="code" href="classPoint.html#z52_4">z</a>();
00357         <span class="keywordflow">break</span>;
00358       <span class="keywordflow">default</span>:
00359         std::cerr &lt;&lt; <span class="stringliteral">"Wrong child number in "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
00360         assert(<span class="keyword">false</span>);
00361         <span class="keywordflow">break</span>;
00362     } <span class="comment">// switch (childNum)</span>
00363 
00364     <a class="code" href="classot_1_1DA.html#p14">m_ptCurrentOffset</a> = p2;
00365   }
00366 
00367   <span class="comment">//This is for real octants only, pseudo-boundary octants can not be tested</span>
00368   <span class="comment">//using this. </span>
<a name="l00369"></a><a class="code" href="classot_1_1DA.html#z31_27">00369</a>   <span class="keywordtype">bool</span> DA::isBoundaryOctant(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *flags) {
00370 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00371 <span class="preprocessor"></span>    assert(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a>);
00372 <span class="preprocessor">#endif</span>
00373 <span class="preprocessor"></span>
00374     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _flags = 0;
00375     <a class="code" href="classPoint.html">Point</a> pt = <a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00376     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = pt.<a class="code" href="classPoint.html#z52_1">xint</a>();
00377     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = pt.<a class="code" href="classPoint.html#z52_3">yint</a>();
00378     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = pt.<a class="code" href="classPoint.html#z52_5">zint</a>();
00379     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = <a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>())-1;
00380     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD = <a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>()-1;
00381     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len  = (<span class="keywordtype">unsigned</span> int)(1u&lt;&lt;(maxD - d) );
00382     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blen = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; maxD);
00383 
00384     <span class="keywordflow">if</span> (!x) _flags |= ot::TreeNode::X_NEG_BDY;  
00385     <span class="keywordflow">if</span> (!y) _flags |=  ot::TreeNode::Y_NEG_BDY; 
00386     <span class="keywordflow">if</span> (!z) _flags |=   ot::TreeNode::Z_NEG_BDY;
00387 
00388     <span class="keywordflow">if</span> ( (x+len) == blen )  _flags |= ot::TreeNode::X_POS_BDY;
00389     <span class="keywordflow">if</span> ( (y+len) == blen )  _flags |= ot::TreeNode::Y_POS_BDY;
00390     <span class="keywordflow">if</span> ( (z+len) == blen )  _flags |= ot::TreeNode::Z_POS_BDY;
00391 
00392     <span class="keywordflow">if</span>(flags) {
00393       *flags = _flags;
00394     }
00395     <span class="keywordflow">return</span> _flags;
00396   }<span class="comment">//end function</span>
00397 
00398   <span class="comment">/***************** Array Access ********************/</span>
<a name="l00399"></a><a class="code" href="classot_1_1DA.html#z35_6">00399</a>   <span class="keywordtype">int</span> DA::createMatrix(Mat &amp;M, MatType mtype, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof) {
00400     <span class="comment">// first determine the size ...</span>
00401     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00402     <span class="keywordflow">if</span>(m_bIamActive) {
00403       sz = dof*(<a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a> + m_uiBoundaryNodeSize);
00404     }<span class="comment">//end if active</span>
00405 
00406     <span class="comment">// now create the PETSc Mat</span>
00407     PetscTruth isAij, isAijSeq, isAijPrl, isSuperLU, isSuperLU_Dist;
00408     PetscStrcmp(mtype,MATAIJ,&amp;isAij);
00409     PetscStrcmp(mtype,MATSEQAIJ,&amp;isAijSeq);
00410     PetscStrcmp(mtype,MATMPIAIJ,&amp;isAijPrl);
00411     PetscStrcmp(mtype,MATSUPERLU,&amp;isSuperLU);
00412     PetscStrcmp(mtype,MATSUPERLU_DIST,&amp;isSuperLU_Dist);
00413 
00414     MatCreate(<a class="code" href="classot_1_1DA.html#p12">m_mpiCommAll</a>, &amp;M);
00415     MatSetSizes(M, sz,sz, PETSC_DECIDE, PETSC_DECIDE);
00416     MatSetType(M,mtype);
00417 
00418     <span class="keywordflow">if</span>(isAij || isAijSeq || isAijPrl || isSuperLU || isSuperLU_Dist) {
00419       <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p7">m_iNpesAll</a> &gt; 1) {
00420         MatMPIAIJSetPreallocation(M, 53*dof , PETSC_NULL, 53*dof , PETSC_NULL);
00421       }<span class="keywordflow">else</span> {
00422         MatSeqAIJSetPreallocation(M, 53*dof , PETSC_NULL);
00423       }
00424     }
00425 
00426     <span class="keywordflow">return</span> 0;
00427   }<span class="comment">//end function</span>
00428 
<a name="l00429"></a><a class="code" href="classot_1_1DA.html#z35_4">00429</a>   <span class="keywordtype">int</span> DA::createActiveMatrix(Mat &amp;M, MatType mtype, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof) {
00430     <span class="comment">// first determine the size ...</span>
00431     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00432     <span class="keywordflow">if</span>(m_bIamActive) {
00433       sz = dof*(<a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a> + m_uiBoundaryNodeSize);
00434 
00435       <span class="comment">// now create the PETSc Mat</span>
00436       PetscTruth isAij, isAijSeq, isAijPrl, isSuperLU, isSuperLU_Dist;
00437       PetscStrcmp(mtype,MATAIJ,&amp;isAij);
00438       PetscStrcmp(mtype,MATSEQAIJ,&amp;isAijSeq);
00439       PetscStrcmp(mtype,MATMPIAIJ,&amp;isAijPrl);
00440       PetscStrcmp(mtype,MATSUPERLU,&amp;isSuperLU);
00441       PetscStrcmp(mtype,MATSUPERLU_DIST,&amp;isSuperLU_Dist);
00442 
00443       MatCreate(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>, &amp;M);
00444       MatSetSizes(M, sz,sz, PETSC_DECIDE, PETSC_DECIDE);
00445       MatSetType(M,mtype);
00446 
00447       <span class="keywordflow">if</span>(isAij || isAijSeq || isAijPrl || isSuperLU || isSuperLU_Dist) {
00448         <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p7">m_iNpesAll</a> &gt; 1) {
00449           MatMPIAIJSetPreallocation(M, 53*dof , PETSC_NULL, 53*dof , PETSC_NULL);
00450         }<span class="keywordflow">else</span> {
00451           MatSeqAIJSetPreallocation(M, 53*dof , PETSC_NULL);
00452         }
00453       }
00454     }<span class="comment">//end if active</span>
00455 
00456     <span class="keywordflow">return</span> 0;
00457   }<span class="comment">//end function</span>
00458 
<a name="l00459"></a><a class="code" href="classot_1_1DA.html#z35_8">00459</a>   <span class="keywordtype">int</span> DA::createVector(Vec &amp;arr, <span class="keywordtype">bool</span> isElemental, <span class="keywordtype">bool</span> isGhosted, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof) {
00460     <span class="comment">// first determine the length of the vector ...</span>
00461     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00462     <span class="keywordflow">if</span>(m_bIamActive) {
00463       <span class="keywordflow">if</span> (isElemental) {
00464         sz = m_uiElementSize;
00465         <span class="keywordflow">if</span> (isGhosted) {
00466           sz += (m_uiPreGhostElementSize);
00467         }
00468       } <span class="keywordflow">else</span> {
00469         sz = <a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a> + m_uiBoundaryNodeSize;
00470         <span class="keywordflow">if</span> (isGhosted) {
00471           sz += (<a class="code" href="classot_1_1DA.html#p63">m_uiPreGhostNodeSize</a> + <a class="code" href="classot_1_1DA.html#p61">m_uiPreGhostBoundaryNodeSize</a> + m_uiPostGhostNodeSize);
00472         }
00473       }
00474       <span class="comment">// now for dof ...</span>
00475       sz *= dof;
00476     }<span class="comment">//end if active</span>
00477 
00478     <span class="comment">// now create the PETSc Vector</span>
00479     VecCreate(<a class="code" href="classot_1_1DA.html#p12">m_mpiCommAll</a>, &amp;arr);
00480     VecSetSizes(arr, sz, PETSC_DECIDE);
00481     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1DA.html#p7">m_iNpesAll</a> &gt; 1) {
00482       VecSetType(arr,VECMPI);
00483     } <span class="keywordflow">else</span> {
00484       VecSetType(arr,VECSEQ);
00485     }    
00486     <span class="keywordflow">return</span> 0;
00487   }
00488 
<a name="l00489"></a><a class="code" href="classot_1_1DA.html#z35_5">00489</a>   <span class="keywordtype">int</span> DA::createActiveVector(Vec &amp;arr, <span class="keywordtype">bool</span> isElemental, <span class="keywordtype">bool</span> isGhosted, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof) {
00490     <span class="comment">// first determine the length of the vector ...</span>
00491     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00492     <span class="keywordflow">if</span>(m_bIamActive) {
00493       <span class="keywordflow">if</span> (isElemental) {
00494         sz = m_uiElementSize;
00495         <span class="keywordflow">if</span> (isGhosted) {
00496           sz += (m_uiPreGhostElementSize);
00497         }
00498       } <span class="keywordflow">else</span> {
00499         sz = <a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a> + m_uiBoundaryNodeSize;
00500         <span class="keywordflow">if</span> (isGhosted) {
00501           sz += (<a class="code" href="classot_1_1DA.html#p63">m_uiPreGhostNodeSize</a> + <a class="code" href="classot_1_1DA.html#p61">m_uiPreGhostBoundaryNodeSize</a> + m_uiPostGhostNodeSize);
00502         }
00503       }
00504       <span class="comment">// now for dof ...</span>
00505       sz *= dof;
00506 
00507       <span class="comment">// now create the PETSc Vector</span>
00508       VecCreate(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>, &amp;arr);
00509       VecSetSizes(arr, sz, PETSC_DECIDE);
00510       <span class="keywordflow">if</span> (<a class="code" href="classot_1_1DA.html#p7">m_iNpesAll</a> &gt; 1) {
00511         VecSetType(arr,VECMPI);
00512       } <span class="keywordflow">else</span> {
00513         VecSetType(arr,VECSEQ);
00514       }    
00515     }<span class="comment">//end if active</span>
00516 
00517     <span class="keywordflow">return</span> 0;
00518   }
00519 
00520   <span class="comment">// Obtains a ot::index aligned buffer of the Vector</span>
<a name="l00521"></a><a class="code" href="classot_1_1DA.html#z35_11">00521</a>   <span class="keywordtype">int</span> DA::vecGetBuffer(Vec in, PetscScalar* &amp;out, <span class="keywordtype">bool</span> isElemental, <span class="keywordtype">bool</span> isGhosted,
00522       <span class="keywordtype">bool</span> isReadOnly, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof) {
00523     <span class="comment">// Some error checks ... make sure the size of Vec in matches those implied</span>
00524     <span class="comment">// by the other params ...</span>
00525     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00526     <span class="keywordflow">if</span>(m_bIamActive) {
00527       <span class="keywordflow">if</span> (isElemental) {
00528         sz = m_uiElementSize;
00529         <span class="keywordflow">if</span> (isGhosted) {
00530           sz += m_uiPreGhostElementSize;
00531         }
00532       } <span class="keywordflow">else</span> {
00533         sz = <a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a> + m_uiBoundaryNodeSize;
00534         <span class="keywordflow">if</span> (isGhosted) {
00535           sz += (<a class="code" href="classot_1_1DA.html#p63">m_uiPreGhostNodeSize</a> + <a class="code" href="classot_1_1DA.html#p61">m_uiPreGhostBoundaryNodeSize</a> + m_uiPostGhostNodeSize);
00536         }
00537       }
00538       <span class="comment">// now for dof ...</span>
00539       sz *= dof;
00540     }<span class="comment">//end if active</span>
00541 
00542     PetscInt vecSz=0;
00543     VecGetLocalSize(in, &amp;vecSz);
00544 
00545     <span class="keywordflow">if</span> ( sz != vecSz) {
00546       std::cerr  &lt;&lt; <a class="code" href="classot_1_1DA.html#p9">m_iRankAll</a> &lt;&lt; <span class="stringliteral">": In function "</span> &lt;&lt; __func__ &lt;&lt; <span class="stringliteral">" sizes are unequal, sz is  "</span> 
00547         &lt;&lt; sz &lt;&lt; <span class="stringliteral">" and vecSz is "</span> &lt;&lt; vecSz &lt;&lt; std::endl;
00548       std::cerr &lt;&lt; <span class="stringliteral">"Params are: isElem "</span> &lt;&lt; isElemental &lt;&lt; <span class="stringliteral">" isGhosted "</span> &lt;&lt; isGhosted &lt;&lt; std::endl;
00549       assert(<span class="keyword">false</span>);
00550       <span class="keywordflow">return</span> -1;; 
00551     };
00552 
00553     <span class="keywordflow">if</span>(!m_bIamActive) {
00554       assert(<a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a> == 0);
00555       assert(<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> == 0);
00556       assert(<a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a> == 0);
00557       assert(<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> == 0);
00558     }
00559 
00560     <span class="comment">// get the local Petsc Arrray,</span>
00561     PetscScalar *array = NULL;
00562     VecGetArray(in, &amp;array);
00563 
00564     <span class="comment">// allocate except for the case of ghosted-elemental vectors...</span>
00565     <span class="keywordflow">if</span>(isGhosted &amp;&amp; isElemental) {
00566       <span class="comment">//simply copy the pointer</span>
00567       <span class="comment">//This is the only case where the buffer will not be the size of the</span>
00568       <span class="comment">//fullLocalBufferSize. </span>
00569       out = array;
00570     }<span class="keywordflow">else</span> {
00571       <span class="comment">// First let us allocate for the buffer ... the local buffer will be of full</span>
00572       <span class="comment">// length.</span>
00573       sz = dof*m_uiLocalBufferSize;
00574 
00575       <span class="keywordflow">if</span>(sz) {
00576         out = <span class="keyword">new</span> PetscScalar[sz];
00577       }<span class="keywordflow">else</span> {
00578         out = NULL;
00579       }
00580 
00581       <span class="comment">//Zero Entries first if you plan to modify the buffer </span>
00582       <span class="keywordflow">if</span>(!isReadOnly) {
00583         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; sz; i++) {
00584           out[i] = 0.0;
00585         }
00586       }
00587     }
00588 
00589     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vecCnt=0;
00590     <span class="comment">// Now we can populate the out buffer ... and that needs a loop through the</span>
00591     <span class="comment">// elements ...</span>
00592     <span class="keywordflow">if</span> (isGhosted) {
00593       <span class="keywordflow">if</span> (isElemental) {
00594         <span class="comment">//Nothing to be done here.</span>
00595       } <span class="keywordflow">else</span> {
00596         <span class="comment">// now copy ...</span>
00597         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;m_uiLocalBufferSize; i++) {
00598           <span class="comment">// skip the ones that are not nodes ...</span>
00599           <span class="keywordflow">if</span> ( ! (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::NODE ) ) {
00600             <span class="keywordflow">continue</span>;
00601           }
00602           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dof; j++) {
00603             out[dof*i+j] = array[dof*vecCnt + j];
00604           }
00605           vecCnt++;
00606         }<span class="comment">//end for i</span>
00607       }<span class="comment">//end if elemental</span>
00608     } <span class="keywordflow">else</span> {
00609       <span class="keywordflow">if</span> (isElemental) {
00610         <span class="comment">// is a simple copy ...</span>
00611         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementBegin; i &lt; m_uiElementEnd; i++) {
00612           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dof; j++) {
00613             out[dof*i+j] = array[dof*vecCnt + j];
00614           }
00615           vecCnt++;
00616         }<span class="comment">//end for i</span>
00617       } <span class="keywordflow">else</span> {
00618         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementBegin; i &lt; m_uiElementEnd; i++) {
00619           <span class="keywordflow">if</span> ( ! (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::NODE ) ) {
00620             <span class="keywordflow">continue</span>;
00621           }
00622           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dof; j++) {
00623             out[dof*i+j] = array[dof*vecCnt + j];
00624           }
00625           vecCnt++;
00626         }<span class="comment">//end for i</span>
00627         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementEnd; i &lt; m_uiPostGhostBegin; i++) {
00628           <span class="comment">// add the remaining boundary nodes ...</span>
00629           <span class="keywordflow">if</span> ( ! ( (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::NODE ) &amp;&amp;
00630                 (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::BOUNDARY ) ) ) {
00631             <span class="keywordflow">continue</span>;
00632           }
00633           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dof; j++) {
00634             out[dof*i+j] = array[dof*vecCnt + j];
00635           }
00636           vecCnt++;
00637         }<span class="comment">//end for i</span>
00638       }
00639     }
00640 
00641     <span class="keywordflow">if</span>(!(isGhosted &amp;&amp; isElemental)) {
00642       VecRestoreArray(in, &amp;array);
00643     }
00644 
00645     <span class="keywordflow">return</span> 0;
00646   }
00647 
<a name="l00648"></a><a class="code" href="classot_1_1DA.html#z35_13">00648</a>   <span class="keywordtype">int</span> DA::vecRestoreBuffer(Vec in, PetscScalar* out, <span class="keywordtype">bool</span> isElemental, <span class="keywordtype">bool</span> isGhosted, <span class="keywordtype">bool</span> isReadOnly, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof) {
00649     <span class="comment">// Some error checks ... make sure the size of Vec in matches those implied</span>
00650     <span class="comment">// by the other params ...</span>
00651     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 0;
00652     <span class="keywordflow">if</span>(m_bIamActive) {
00653       <span class="keywordflow">if</span> (isElemental) {
00654         sz = m_uiElementSize;
00655         <span class="keywordflow">if</span> (isGhosted) {
00656           sz += m_uiPreGhostElementSize;
00657         }
00658       } <span class="keywordflow">else</span> {
00659         sz = <a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a> + m_uiBoundaryNodeSize;
00660         <span class="keywordflow">if</span> (isGhosted) {
00661           sz += (<a class="code" href="classot_1_1DA.html#p63">m_uiPreGhostNodeSize</a> + <a class="code" href="classot_1_1DA.html#p61">m_uiPreGhostBoundaryNodeSize</a> + m_uiPostGhostNodeSize);
00662         }
00663       }
00664       <span class="comment">// now for dof ...</span>
00665       sz *= dof;
00666     }<span class="comment">//end if active</span>
00667 
00668     PetscInt vecSz=0;
00669     VecGetLocalSize(in, &amp;vecSz);
00670 
00671     <span class="keywordflow">if</span> ( sz != vecSz) {
00672       std::cerr  &lt;&lt; <a class="code" href="colors_8h.html#a0">RED</a>&lt;&lt;<span class="stringliteral">"In function PETSc::"</span> &lt;&lt; __func__ &lt;&lt;
00673         <a class="code" href="colors_8h.html#a6">NRM</a>&lt;&lt;<span class="stringliteral">" sizes are unequal, sz is  "</span> &lt;&lt; sz &lt;&lt; <span class="stringliteral">" and vecSz is "</span> &lt;&lt; vecSz &lt;&lt; std::endl;
00674       std::cerr &lt;&lt; <span class="stringliteral">"Params are: isElem "</span> &lt;&lt; isElemental &lt;&lt; <span class="stringliteral">" isGhosted "</span> &lt;&lt; isGhosted &lt;&lt; std::endl;
00675       assert(<span class="keyword">false</span>);
00676       <span class="keywordflow">return</span> -1;;
00677     }
00678 
00679     <span class="keywordflow">if</span>(!m_bIamActive) {
00680       assert(<a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a> == 0);
00681       assert(<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> == 0);
00682       assert(<a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a> == 0);
00683       assert(<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> == 0);
00684     }
00685 
00686     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vecCnt=0;
00687 
00688     <span class="keywordflow">if</span>(isGhosted &amp;&amp; isElemental) {
00689       <span class="comment">//If it is ghosted and elemental, simply restore the array.</span>
00690       <span class="comment">//out was not allocated expicitly in this case. It was just a copy of the</span>
00691       <span class="comment">//array's pointer. The readOnly flag is immaterial for this case.</span>
00692       VecRestoreArray(in, &amp;out);
00693       out = NULL;
00694     }  <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( isReadOnly ) {
00695       <span class="comment">// no need to write back ... simply clean up and return</span>
00696       <span class="comment">//Since this is not an elemental and ghosted vector, out was allocated</span>
00697       <span class="comment">//explicitly </span>
00698       <span class="keywordflow">if</span>(out) {
00699         <span class="keyword">delete</span> [] out;
00700         out = NULL;
00701       }
00702     } <span class="keywordflow">else</span> {
00703       <span class="comment">//ghosted and elemental is already taken care of. So only need to tackle</span>
00704       <span class="comment">//the other 3 cases.</span>
00705       <span class="comment">// need to write back ...</span>
00706       <span class="comment">// get the local Petsc Arrray,</span>
00707       PetscScalar *array;
00708       VecGetArray(in, &amp;array);
00709 
00710       <span class="keywordflow">if</span> ( isElemental ) {
00711         <span class="comment">//non-ghosted, elemental</span>
00712         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementBegin; i &lt; m_uiElementEnd; i++) {
00713           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dof; j++) {
00714             array[dof*vecCnt + j] = out[dof*i+j];
00715           }
00716           vecCnt++;
00717         }
00718       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( isGhosted ) {
00719         <span class="comment">// nodal and ghosted ...</span>
00720         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;sz; i++) {
00721           <span class="comment">// skip the ones that are not nodes ...</span>
00722           <span class="keywordflow">if</span> ( ! (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::NODE ) ) {
00723             <span class="keywordflow">continue</span>;
00724           }
00725           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dof; j++) {
00726             array[dof*vecCnt + j] = out[dof*i+j];
00727           }
00728           vecCnt++;
00729         }
00730       } <span class="keywordflow">else</span> {
00731         <span class="comment">// nodal non ghosted ...</span>
00732         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementBegin; i &lt; m_uiElementEnd; i++) {
00733           <span class="keywordflow">if</span> ( ! (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::NODE ) ) {
00734             <span class="keywordflow">continue</span>;
00735           }
00736           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dof; j++) {
00737             array[dof*vecCnt + j] = out[dof*i+j];
00738           }
00739           vecCnt++;
00740         }
00741         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementEnd; i &lt; m_uiPostGhostBegin; i++) {
00742           <span class="comment">// add the remaining boundary nodes ...</span>
00743           <span class="keywordflow">if</span> ( ! ( (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::NODE ) &amp;&amp;
00744                 (<a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] &amp; ot::TreeNode::BOUNDARY ) ) ) {
00745             <span class="keywordflow">continue</span>;
00746           }
00747           <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dof; j++) {
00748             array[dof*vecCnt + j] = out[dof*i+j];
00749           }
00750           vecCnt++;
00751         }
00752       }
00753 
00754       VecRestoreArray(in, &amp;array);
00755       <span class="comment">//Since this is not an elemental and ghosted vector, out was allocated</span>
00756       <span class="comment">//explicitly </span>
00757       <span class="keywordflow">if</span>(out) {
00758         <span class="keyword">delete</span> [] out;
00759         out = NULL;
00760       }
00761     }
00762     <span class="keywordflow">return</span> 0;
00763   }
00764 
<a name="l00765"></a><a class="code" href="classot_1_1DA.html#a7">00765</a>   <span class="keywordtype">void</span> DA::updateQuotientCounter() {
00766 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00767 <span class="preprocessor"></span>    assert(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a>);
00768 <span class="preprocessor">#endif</span>
00769 <span class="preprocessor"></span>
00770     <span class="comment">// m_ucpLutRemainders, m_uspLutQuotients.</span>
00771     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _mask = <a class="code" href="classot_1_1DA.html#p23">m_ucpLutMasksPtr</a>[2*m_uiCurrent];
00772 
00773     <span class="comment">// first let us get the offsets ..</span>
00774     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; 8; j++) {
00775       <span class="keywordflow">if</span> ( _mask &amp; (1 &lt;&lt; j ) ) {
00776         <a class="code" href="classot_1_1DA.html#p69">m_uiQuotientCounter</a>++;
00777       }
00778     }
00779   }
00780 
<a name="l00781"></a><a class="code" href="classot_1_1DA.html#z36_5">00781</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> DA::getHangingNodeIndex(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i) {
00782 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00783 <span class="preprocessor"></span>    assert(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a>);
00784 <span class="preprocessor">#endif</span>
00785 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i + 1];
00786   }
00787 
<a name="l00788"></a><a class="code" href="classot_1_1DA.html#z31_26">00788</a>   <span class="keywordtype">void</span> DA::incrementPreGhostOffset() {
00789 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00790 <span class="preprocessor"></span>    assert(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a>);
00791 <span class="preprocessor">#endif</span>
00792 <span class="preprocessor"></span>
00793     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = <a class="code" href="classot_1_1DA.html#p27">m_ucpPreGhostConnectivity</a>[m_uiCurrent];
00794     <span class="keywordflow">if</span> ( c ) {
00795       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> nd = <a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[<a class="code" href="classot_1_1DA.html#p33">m_uiCurrent</a>+1];
00796       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> cd = <a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[m_uiCurrent];
00797       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ns = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - nd ) );
00798       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cs = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - cd ) );
00799 
00800       <a class="code" href="classPoint.html">Point</a> <a class="code" href="classot_1_1DA.html#z36_0">curr</a> = m_ptCurrentOffset;
00801 
00802       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cx = curr.<a class="code" href="classPoint.html#z52_1">xint</a>();
00803       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cy = curr.<a class="code" href="classPoint.html#z52_3">yint</a>();
00804       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cz = curr.<a class="code" href="classPoint.html#z52_5">zint</a>();
00805       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nx = cx;
00806       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ny = cy;
00807       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nz = cz;
00808 
00809       <span class="comment">//_zzyyxxT</span>
00810       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> xFlag = ((c &amp; (3&lt;&lt;1) ) &gt;&gt; 1);
00811       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> yFlag = ((c &amp; (3&lt;&lt;3) ) &gt;&gt; 3);
00812       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> zFlag = ((c &amp; (3&lt;&lt;5) ) &gt;&gt; 5);
00813 
00814       <span class="keywordflow">switch</span> (xFlag) {
00815         <span class="keywordflow">case</span> 0: nx = cx;
00816                 <span class="keywordflow">break</span>;
00817         <span class="keywordflow">case</span> 1: nx = (cx - ns);
00818                 <span class="keywordflow">break</span>;
00819         <span class="keywordflow">case</span> 2: nx = (cx + cs); 
00820                 <span class="keywordflow">break</span>;
00821         <span class="keywordflow">case</span> 3: nx = (cx + cs - ns);
00822                 <span class="keywordflow">break</span>;
00823         <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);
00824       }
00825 
00826       <span class="keywordflow">switch</span> (yFlag) {
00827         <span class="keywordflow">case</span> 0: ny = cy;
00828                 <span class="keywordflow">break</span>;
00829         <span class="keywordflow">case</span> 1: ny = (cy - ns);
00830                 <span class="keywordflow">break</span>;
00831         <span class="keywordflow">case</span> 2: ny = (cy + cs); 
00832                 <span class="keywordflow">break</span>;
00833         <span class="keywordflow">case</span> 3: ny = (cy + cs - ns); 
00834                 <span class="keywordflow">break</span>;
00835         <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);
00836       }
00837 
00838       <span class="keywordflow">switch</span> (zFlag) {
00839         <span class="keywordflow">case</span> 0: nz = cz;
00840                 <span class="keywordflow">break</span>;
00841         <span class="keywordflow">case</span> 1: nz = (cz - ns); 
00842                 <span class="keywordflow">break</span>;
00843         <span class="keywordflow">case</span> 2: nz = (cz + cs); 
00844                 <span class="keywordflow">break</span>;
00845         <span class="keywordflow">case</span> 3: nz = (cz + cs - ns); 
00846                 <span class="keywordflow">break</span>;
00847         <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);
00848       }
00849 
00850       <a class="code" href="classot_1_1DA.html#p14">m_ptCurrentOffset</a> = <a class="code" href="classPoint.html">Point</a>(nx,ny,nz);    
00851 
00852     } <span class="keywordflow">else</span> {
00853       <a class="code" href="classot_1_1DA.html#p14">m_ptCurrentOffset</a> = <a class="code" href="classot_1_1DA.html#p18">m_ptsPreGhostOffsets</a>[<a class="code" href="classot_1_1DA.html#p64">m_uiPreGhostQuotientCnt</a>++];     
00854     }
00855 
00856   }<span class="comment">//end function</span>
00857 
00858 } <span class="comment">// end namespace ot</span>
00859 
00860 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:31 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
