<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/examples/elasticityJac.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">examples</a></div>
<h1>elasticityJac.C</h1><a href="elasticityJac_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "petscmat.h"</span>
00008 <span class="preprocessor">#include "<a class="code" href="omg_8h.html">omg.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="odaUtils_8h.html">odaUtils.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="elasticityJac_8h.html">elasticityJac.h</a>"</span>
00012 
00013 <span class="preprocessor">#ifdef PETSC_USE_LOG</span>
00014 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> elasticityDiagEvent;
00015 <span class="keyword">extern</span> <span class="keywordtype">int</span> elasticityMultEvent;
00016 <span class="keyword">extern</span> <span class="keywordtype">int</span> elasticityFinestDiagEvent;
00017 <span class="keyword">extern</span> <span class="keywordtype">int</span> elasticityFinestMultEvent;
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>
00020 <span class="keyword">extern</span> <span class="keywordtype">double</span>**** LaplacianType2Stencil; 
00021 <span class="keyword">extern</span> <span class="keywordtype">double</span>**** GradDivType2Stencil; 
00022 
<a name="l00023"></a><a class="code" href="elasticityJac_8C.html#a9">00023</a> <span class="keywordtype">void</span> <a class="code" href="elasticityJac_8C.html#a9">getActiveStateAndActiveCommForKSP_Shell_Elas</a>(Mat mat,
00024     <span class="keywordtype">bool</span> &amp; activeState, MPI_Comm &amp; activeComm) {
00025   PetscTruth isshell;
00026   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00027   assert(isshell);
00028   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00029   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;damg));
00030   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;da;
00031   activeState = da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>();
00032   activeComm = da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
00033 }
00034 
<a name="l00035"></a><a class="code" href="elasticityJac_8h.html#a11">00035</a> <span class="keywordtype">void</span> <a class="code" href="elasticityJac_8h.html#a11">getPrivateMatricesForKSP_Shell_Elas</a>(Mat mat,
00036     Mat *AmatPrivate, Mat *PmatPrivate, MatStructure* pFlag) {
00037   PetscTruth isshell;
00038   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00039   assert(isshell);
00040   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00041   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;damg));
00042   <a class="code" href="structElasticityData.html">ElasticityData</a>* data = (static_cast&lt;ElasticityData*&gt;(damg-&gt;user));
00043   *AmatPrivate = data-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>;
00044   *PmatPrivate = data-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>;
00045   *pFlag = DIFFERENT_NONZERO_PATTERN;
00046 }
00047 
<a name="l00048"></a><a class="code" href="elasticityJac_8C.html#a0">00048</a> <span class="preprocessor">#define ELASTICITY_ELEM_DIAG_BLOCK {\</span>
00049 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00050 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00051 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00052 <span class="preprocessor">  double fac = h/2.0;\</span>
00053 <span class="preprocessor">  unsigned int indices[8];\</span>
00054 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00055 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00056 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00057 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00058 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00059 <span class="preprocessor">  for(int k = 0; k &lt; 8; k++) {\</span>
00060 <span class="preprocessor">    if(bdyArr[indices[k]]) {\</span>
00061 <span class="preprocessor">      </span><span class="comment">/*Dirichlet Node*/</span>\
00062       for(int dof = 0; dof &lt; 3; dof++) {\
00063         diagArr[(3*indices[k])+dof] = 1.0;\
00064       } <span class="comment">/*end dof*/</span>\
00065     } else { \
00066       for(int dof = 0; dof &lt; 3; dof++) {\
00067         diagArr[(3*indices[k])+dof] += (fac*(\
00068               (mu*LaplacianType2Stencil[childNum][elemType][k][k])\
00069               + ((mu+lambda)*GradDivType2Stencil[childNum][elemType][(3*k) + dof][(3*k) + dof])));\
00070       } <span class="comment">/*end dof*/</span>\
00071     }\
00072   } <span class="comment">/*end k*/</span>\
00073 }
00074 
<a name="l00075"></a><a class="code" href="elasticityJac_8C.html#a1">00075</a> <span class="preprocessor">#define ELASTICITY_DIAG_BLOCK {\</span>
00076 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00077 <span class="preprocessor">  ElasticityData* data = (static_cast&lt;ElasticityData*&gt;(damg-&gt;user));\</span>
00078 <span class="preprocessor">  iC(VecZeroEntries(diag));\</span>
00079 <span class="preprocessor">  PetscScalar *diagArr = NULL;\</span>
00080 <span class="preprocessor">  unsigned char* bdyArr = data-&gt;bdyArr;\</span>
00081 <span class="preprocessor">  double mu = data-&gt;mu;\</span>
00082 <span class="preprocessor">  double lambda = data-&gt;lambda;\</span>
00083 <span class="preprocessor">  unsigned int maxD;\</span>
00084 <span class="preprocessor">  double hFac;\</span>
00085 <span class="preprocessor">  </span><span class="comment">/*Nodal,Non-Ghosted,Write,3 dof*/</span>\
00086   da-&gt;vecGetBuffer(diag,diagArr,false,false,false,3);\
00087   if(da-&gt;iAmActive()) {\
00088     maxD = (da-&gt;getMaxDepth());\
00089     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\
00090     <span class="comment">/*Loop through All Elements including ghosted*/</span>\
00091     for(da-&gt;init&lt;ot::DA_FLAGS::ALL&gt;();\
00092         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::ALL&gt;();\
00093         da-&gt;next&lt;ot::DA_FLAGS::ALL&gt;()) {\
00094  ELASTICITY_ELEM_DIAG_BLOCK \
00095     } <span class="comment">/*end i*/</span>\
00096   } <span class="comment">/*end if active*/</span>\
00097   da-&gt;vecRestoreBuffer(diag,diagArr,false,false,false,3);\
00098   <span class="comment">/*2 IOP = 1 FLOP. Loop counters are included too.*/</span>\
00099   PetscLogFlops(235*(da-&gt;getGhostedElementSize()));\
00100 }
00101 
<a name="l00102"></a><a class="code" href="elasticityJac_8h.html#a5">00102</a> PetscErrorCode <a class="code" href="elasticityJac_8h.html#a5">ElasticityMatGetDiagonal</a>(Mat J, Vec diag) {
00103   PetscFunctionBegin;
00104 
00105   PetscLogEventBegin(elasticityDiagEvent,diag,0,0,0);
00106 
00107   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00108   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00109 
00110   <span class="keywordtype">bool</span> isFinestLevel = (damg-&gt;nlevels == 1);
00111 
00112   <span class="keywordflow">if</span>(isFinestLevel) {
00113     PetscLogEventBegin(elasticityFinestDiagEvent,diag,0,0,0);
00114   }
00115 
00116   <a class="code" href="elasticityJac_8C.html#a1">ELASTICITY_DIAG_BLOCK</a>  
00117 
00118     <span class="keywordflow">if</span>(isFinestLevel) {
00119       PetscLogEventEnd(elasticityFinestDiagEvent,diag,0,0,0);
00120     }
00121 
00122   PetscLogEventEnd(elasticityDiagEvent,diag,0,0,0);
00123 
00124   PetscFunctionReturn(0);
00125 }
00126 
00127 <span class="preprocessor">#undef ELASTICITY_DIAG_BLOCK </span>
00128 <span class="preprocessor"></span><span class="preprocessor">#undef ELASTICITY_ELEM_DIAG_BLOCK </span>
00129 <span class="preprocessor"></span>
<a name="l00130"></a><a class="code" href="elasticityJac_8C.html#a2">00130</a> <span class="preprocessor">#define ELASTICITY_ELEM_MULT_BLOCK {\</span>
00131 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00132 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00133 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00134 <span class="preprocessor">  double fac = h/2.0;\</span>
00135 <span class="preprocessor">  unsigned int indices[8];\</span>
00136 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00137 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00138 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00139 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00140 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00141 <span class="preprocessor">  for(int k = 0;k &lt; 8;k++) {\</span>
00142 <span class="preprocessor">    if(bdyArr[indices[k]]) {\</span>
00143 <span class="preprocessor">      </span><span class="comment">/*Dirichlet Node Row*/</span>\
00144       for(int dof = 0; dof &lt; 3; dof++) {\
00145         outArr[(3*indices[k]) + dof] =  inArr[(3*indices[k]) + dof];\
00146       }<span class="comment">/*end for dof*/</span>\
00147     } else {\
00148       for(int j=0;j&lt;8;j++) {\
00149         <span class="comment">/*Avoid Dirichlet Node Columns*/</span>\
00150         if(!(bdyArr[indices[j]])) {\
00151           for(int dof = 0; dof &lt; 3; dof++) {\
00152             outArr[(3*indices[k]) + dof] += (mu*fac*LaplacianType2Stencil[childNum][elemType][k][j]\
00153                 *inArr[(3*indices[j]) + dof]);\
00154           }<span class="comment">/*end for dof*/</span>\
00155           for(int dofOut = 0; dofOut &lt; 3; dofOut++) {\
00156             for(int dofIn = 0; dofIn &lt; 3; dofIn++) {\
00157               outArr[(3*indices[k]) + dofOut] += ((mu+lambda)*fac*\
00158                   (GradDivType2Stencil[childNum][elemType][(3*k) + dofIn][(3*j) + dofOut])\
00159                   *inArr[(3*indices[j]) + dofIn]);\
00160             }<span class="comment">/*end for dofIn*/</span>\
00161           }<span class="comment">/*end for dofOut*/</span>\
00162         }\
00163       }<span class="comment">/*end for j*/</span>\
00164     }\
00165   }<span class="comment">/*end for k*/</span>\
00166 }
00167 
<a name="l00168"></a><a class="code" href="elasticityJac_8C.html#a3">00168</a> <span class="preprocessor">#define ELASTICITY_MULT_BLOCK {\</span>
00169 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00170 <span class="preprocessor">  ElasticityData* data = (static_cast&lt;ElasticityData*&gt;(damg-&gt;user));\</span>
00171 <span class="preprocessor">  iC(VecZeroEntries(out));\</span>
00172 <span class="preprocessor">  unsigned int maxD;\</span>
00173 <span class="preprocessor">  double hFac;\</span>
00174 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00175 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
00176 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
00177 <span class="preprocessor">  }\</span>
00178 <span class="preprocessor">  PetscScalar *outArr=NULL;\</span>
00179 <span class="preprocessor">  PetscScalar *inArr=NULL;\</span>
00180 <span class="preprocessor">  unsigned char* bdyArr = data-&gt;bdyArr;\</span>
00181 <span class="preprocessor">  double mu = data-&gt;mu;\</span>
00182 <span class="preprocessor">  double lambda = data-&gt;lambda;\</span>
00183 <span class="preprocessor">  </span><span class="comment">/*Nodal,Non-Ghosted,Read,3 dof*/</span>\
00184   da-&gt;vecGetBuffer(in,inArr,false,false,true,3);\
00185   <span class="comment">/*Nodal,Non-Ghosted,Write,3 dof*/</span>\
00186   da-&gt;vecGetBuffer(out,outArr,false,false,false,3);\
00187   if(da-&gt;iAmActive()) {\
00188     da-&gt;ReadFromGhostsBegin&lt;PetscScalar&gt;(inArr,3);\
00189     <span class="comment">/*Loop through All Independent Elements*/</span>\
00190     for(da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00191         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00192         da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;() ) {\
00193  ELASTICITY_ELEM_MULT_BLOCK \
00194     } <span class="comment">/*end independent*/</span>\
00195     da-&gt;ReadFromGhostsEnd&lt;PetscScalar&gt;(inArr);\
00196     <span class="comment">/*Loop through All Dependent Elements,*/</span>\
00197     <span class="comment">/*i.e. Elements which have atleast one*/</span>\
00198     <span class="comment">/*vertex owned by this processor and at least one*/</span>\
00199     <span class="comment">/*vertex not owned by this processor.*/</span>\
00200     for(da-&gt;init&lt;ot::DA_FLAGS::DEPENDENT&gt;();\
00201         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::DEPENDENT&gt;();\
00202         da-&gt;next&lt;ot::DA_FLAGS::DEPENDENT&gt;() ) {\
00203  ELASTICITY_ELEM_MULT_BLOCK \
00204     } <span class="comment">/*end loop for dependent elems*/</span>\
00205   } <span class="comment">/*end if active*/</span>\
00206   da-&gt;vecRestoreBuffer(in,inArr,false,false,true,3);\
00207   da-&gt;vecRestoreBuffer(out,outArr,false,false,false,3);\
00208   <span class="comment">/*2 IOP = 1 FLOP. Loop counters are included too.*/</span>\
00209   PetscLogFlops(6855*(da-&gt;getGhostedElementSize()));\
00210 }
00211 
<a name="l00212"></a><a class="code" href="elasticityJac_8h.html#a4">00212</a> PetscErrorCode <a class="code" href="elasticityJac_8h.html#a4">ElasticityMatMult</a>(Mat J, Vec in, Vec out)
00213 {
00214   PetscFunctionBegin;
00215 
00216   PetscLogEventBegin(elasticityMultEvent,in,out,0,0);
00217 
00218   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00219   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00220 
00221   <span class="keywordtype">bool</span> isFinestLevel = (damg-&gt;nlevels == 1);
00222 
00223   <span class="keywordflow">if</span>(isFinestLevel) {
00224     PetscLogEventBegin(elasticityFinestMultEvent,in,out,0,0);
00225   }
00226 
00227   <a class="code" href="elasticityJac_8C.html#a3">ELASTICITY_MULT_BLOCK</a> 
00228 
00229     <span class="keywordflow">if</span>(isFinestLevel) {
00230       PetscLogEventEnd(elasticityFinestMultEvent,in,out,0,0);
00231     }
00232 
00233   PetscLogEventEnd(elasticityMultEvent,in,out,0,0);
00234 
00235   PetscFunctionReturn(0);
00236 }
00237 
00238 <span class="preprocessor">#undef ELASTICITY_ELEM_MULT_BLOCK </span>
00239 <span class="preprocessor"></span><span class="preprocessor">#undef ELASTICITY_MULT_BLOCK </span>
00240 <span class="preprocessor"></span>
<a name="l00241"></a><a class="code" href="elasticityJac_8C.html#a4">00241</a> <span class="preprocessor">#define BUILD_FULL_ELASTICITY_ELEM_ADD_BLOCK {\</span>
00242 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00243 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00244 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00245 <span class="preprocessor">  double fac = h/2.0;\</span>
00246 <span class="preprocessor">  unsigned int indices[8];\</span>
00247 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00248 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00249 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00250 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00251 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00252 <span class="preprocessor">  for(int k = 0;k &lt; 8;k++) {\</span>
00253 <span class="preprocessor">    </span><span class="comment">/*Avoid Dirichlet Node Rows during ADD_VALUES loop.*/</span>\
00254     <span class="comment">/*Need a separate INSERT_VALUES loop for those*/</span>\
00255     if(!(bdyArr[indices[k]])) {\
00256       for(int j=0;j&lt;8;j++) {\
00257         if(!(bdyArr[indices[j]])) {\
00258           for(int dof = 0; dof &lt; 3; dof++) {\
00259             ot::MatRecord currRec;\
00260             currRec.rowIdx = indices[k];\
00261             currRec.colIdx = indices[j];\
00262             currRec.rowDim = dof;\
00263             currRec.colDim = dof;\
00264             currRec.val = (mu*fac*\
00265                 LaplacianType2Stencil[childNum][elemType][k][j]);\
00266             records.push_back(currRec);\
00267           } <span class="comment">/*end for dof*/</span>\
00268           for(int dofOut = 0; dofOut &lt; 3; dofOut++) {\
00269             for(int dofIn = 0; dofIn &lt; 3; dofIn++) {\
00270               ot::MatRecord currRec;\
00271               currRec.rowIdx = indices[k];\
00272               currRec.colIdx = indices[j];\
00273               currRec.rowDim = dofOut;\
00274               currRec.colDim = dofIn;\
00275               currRec.val = ((mu+lambda)*fac*\
00276                   GradDivType2Stencil[childNum][elemType][(3*k)+dofIn][(3*j)+dofOut]);\
00277               records.push_back(currRec);\
00278             } <span class="comment">/*end for dofIn*/</span>\
00279           } <span class="comment">/*end for dofOut*/</span>\
00280         }\
00281       } <span class="comment">/*end for j*/</span>\
00282     }\
00283   } <span class="comment">/*end for k*/</span>\
00284   if(records.size() &gt; 1000) {\
00285     <span class="comment">/*records will be cleared inside the function*/</span>\
00286     da-&gt;setValuesInMatrix(B, records, 3, ADD_VALUES);\
00287   }\
00288 }
00289 
<a name="l00290"></a><a class="code" href="elasticityJac_8C.html#a5">00290</a> <span class="preprocessor">#define BUILD_FULL_ELASTICITY_ELEM_INSERT_BLOCK {\</span>
00291 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00292 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00293 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00294 <span class="preprocessor">  double fac = h/2.0;\</span>
00295 <span class="preprocessor">  unsigned int indices[8];\</span>
00296 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00297 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00298 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00299 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00300 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00301 <span class="preprocessor">  for(int k = 0;k &lt; 8;k++) {\</span>
00302 <span class="preprocessor">    </span><span class="comment">/*Insert values for Dirichlet Node Rows only.*/</span>\
00303     if(bdyArr[indices[k]]) {\
00304       for(int dof = 0; dof &lt; 3; dof++) {\
00305         ot::MatRecord currRec;\
00306         currRec.rowIdx = indices[k];\
00307         currRec.colIdx = indices[k];\
00308         currRec.rowDim = dof;\
00309         currRec.colDim = dof;\
00310         currRec.val = 1.0;\
00311         records.push_back(currRec);\
00312       } <span class="comment">/*end for dof*/</span>\
00313     }\
00314   } <span class="comment">/*end for k*/</span>\
00315   if(records.size() &gt; 1000) {\
00316     <span class="comment">/*records will be cleared inside the function*/</span>\
00317     da-&gt;setValuesInMatrix(B, records, 3, INSERT_VALUES);\
00318   }\
00319 }
00320 
<a name="l00321"></a><a class="code" href="elasticityJac_8C.html#a6">00321</a> <span class="preprocessor">#define BUILD_FULL_ELASTICITY_BLOCK {\</span>
00322 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00323 <span class="preprocessor">  MatZeroEntries(B);\</span>
00324 <span class="preprocessor">  std::vector&lt;ot::MatRecord&gt; records;\</span>
00325 <span class="preprocessor">  unsigned int maxD;\</span>
00326 <span class="preprocessor">  double hFac;\</span>
00327 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00328 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
00329 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
00330 <span class="preprocessor">  }\</span>
00331 <span class="preprocessor">  unsigned char* bdyArr = data-&gt;bdyArr;\</span>
00332 <span class="preprocessor">  double mu = data-&gt;mu;\</span>
00333 <span class="preprocessor">  double lambda = data-&gt;lambda;\</span>
00334 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00335 <span class="preprocessor">    for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\</span>
00336 <span class="preprocessor">        da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();\</span>
00337 <span class="preprocessor">        da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\</span>
00338 <span class="preprocessor"> BUILD_FULL_ELASTICITY_ELEM_ADD_BLOCK \</span>
00339 <span class="preprocessor">    } </span><span class="comment">/*end writable*/</span>\
00340   } <span class="comment">/*end if active*/</span>\
00341   da-&gt;setValuesInMatrix(B, records, 3, ADD_VALUES);\
00342   MatAssemblyBegin(B, MAT_FLUSH_ASSEMBLY);\
00343   MatAssemblyEnd(B, MAT_FLUSH_ASSEMBLY);\
00344   if(da-&gt;iAmActive()) {\
00345     for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00346         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00347         da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\
00348  BUILD_FULL_ELASTICITY_ELEM_INSERT_BLOCK \
00349     } <span class="comment">/*end writable*/</span>\
00350   } <span class="comment">/*end if active*/</span>\
00351   da-&gt;setValuesInMatrix(B, records, 3, INSERT_VALUES);\
00352   MatAssemblyBegin(B, MAT_FINAL_ASSEMBLY);\
00353   MatAssemblyEnd(B, MAT_FINAL_ASSEMBLY);\
00354   if(data-&gt;bdyArr) {\
00355     delete [] (data-&gt;bdyArr);\
00356     data-&gt;bdyArr = NULL;\
00357   }\
00358 }
00359 
<a name="l00360"></a><a class="code" href="elasticityJac_8h.html#a3">00360</a> PetscErrorCode <a class="code" href="elasticityJac_8h.html#a3">ComputeElasticityMat</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat J, Mat B) {
00361   <span class="comment">//For matShells nothing to be done here.</span>
00362   PetscFunctionBegin;
00363 
00364   <a class="code" href="structElasticityData.html">ElasticityData</a>* data = (static_cast&lt;ElasticityData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00365 
00366   PetscTruth isshell;
00367   PetscTypeCompare((PetscObject)B, MATSHELL, &amp;isshell);
00368 
00369   assert(J == B);
00370 
00371   <span class="keywordflow">if</span>(isshell) {
00372     <span class="keywordflow">if</span>( data-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a> == NULL ) {
00373       <span class="comment">//inactive processors will return</span>
00374       PetscFunctionReturn(0);
00375     } <span class="keywordflow">else</span> {
00376       J = data-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>;
00377       B = data-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>;
00378     }
00379   }
00380 
00381   PetscTypeCompare((PetscObject)B, MATSHELL, &amp;isshell);
00382 
00383   <span class="keywordflow">if</span>(isshell) {
00384     PetscFunctionReturn(0);
00385   }
00386 
00387   <a class="code" href="elasticityJac_8C.html#a6">BUILD_FULL_ELASTICITY_BLOCK</a>
00388 
00389     PetscFunctionReturn(0);
00390 }
00391 
00392 <span class="preprocessor">#undef BUILD_FULL_ELASTICITY_ELEM_ADD_BLOCK </span>
00393 <span class="preprocessor"></span><span class="preprocessor">#undef BUILD_FULL_ELASTICITY_ELEM_INSERT_BLOCK </span>
00394 <span class="preprocessor"></span><span class="preprocessor">#undef BUILD_FULL_ELASTICITY_BLOCK </span>
00395 <span class="preprocessor"></span>
<a name="l00396"></a><a class="code" href="elasticityJac_8h.html#a0">00396</a> <span class="keywordtype">void</span> <a class="code" href="elasticityJac_8h.html#a0">SetElasticityContexts</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg) {
00397   <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
00398   PetscReal muVal = 1.0;
00399   PetscReal lambdaVal = 1.0;
00400   PetscTruth optFound;
00401   PetscOptionsGetReal(<span class="stringliteral">"elasticity"</span>,<span class="stringliteral">"-_mu"</span>, &amp;muVal, &amp;optFound);
00402   PetscOptionsGetReal(<span class="stringliteral">"elasticity"</span>,<span class="stringliteral">"-_lambda"</span>, &amp;lambdaVal, &amp;optFound);
00403   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
00404     <a class="code" href="structElasticityData.html">ElasticityData</a>* ctx= <span class="keyword">new</span> <a class="code" href="structElasticityData.html">ElasticityData</a>;
00405     ctx-&gt;<a class="code" href="structElasticityData.html#o4">mu</a> = muVal;
00406     ctx-&gt;<a class="code" href="structElasticityData.html#o3">lambda</a> = lambdaVal;
00407     ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a> = NULL;
00408     ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a> = NULL;
00409     ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a> = NULL;
00410     ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a> = NULL;
00411 
00412     std::vector&lt;unsigned char&gt; tmpBdyFlags;
00413     std::vector&lt;unsigned char&gt; tmpBdyFlagsAux;
00414     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bdyArrAux = NULL;
00415 
00416     <span class="comment">//This will create a nodal, non-ghosted, 1 dof array</span>
00417     <a class="code" href="namespaceot.html#a84">assignBoundaryFlags</a>(damg[i]-&gt;da, tmpBdyFlags);
00418     ((damg[i])-&gt;da)-&gt;vecGetBuffer&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(tmpBdyFlags, ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
00419     <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00420       ((damg[i])-&gt;da)-&gt;ReadFromGhostsBegin&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a>, 1);
00421     }
00422 
00423     <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
00424       <a class="code" href="namespaceot.html#a84">assignBoundaryFlags</a>( damg[i]-&gt;da_aux, tmpBdyFlagsAux);
00425       ((damg[i])-&gt;da_aux)-&gt;vecGetBuffer&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(tmpBdyFlagsAux, bdyArrAux,
00426         <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
00427       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00428         ((damg[i])-&gt;da_aux)-&gt;ReadFromGhostsBegin&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(bdyArrAux, 1);
00429       }
00430     }
00431 
00432     tmpBdyFlags.clear();
00433     tmpBdyFlagsAux.clear();
00434 
00435     <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00436       ((damg[i])-&gt;da)-&gt;ReadFromGhostsEnd&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a>);
00437     }
00438 
00439     <span class="keywordflow">if</span>((damg[i])-&gt;da_aux) {
00440       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00441         ((damg[i])-&gt;da_aux)-&gt;ReadFromGhostsEnd&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(bdyArrAux);
00442       }
00443     }
00444 
00445     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> loopCtr = 0; loopCtr &lt; 2; loopCtr++) {
00446       <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = NULL;
00447       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* suppressedDOFptr = NULL;
00448       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bdyArrPtr = NULL;
00449       <span class="keywordflow">if</span>(loopCtr == 0) {
00450         da = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00451         suppressedDOFptr = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a>;
00452         bdyArrPtr = ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a>;
00453       } <span class="keywordflow">else</span> {
00454         da = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>;
00455         suppressedDOFptr = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o16">suppressedDOFaux</a>;
00456         bdyArrPtr = bdyArrAux;
00457       }
00458       <span class="keywordflow">if</span>(da) {
00459         <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00460           <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); 
00461               da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00462               da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;()) {
00463             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00464             da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00465             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00466               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = 0; d &lt; 3; d++) {
00467                 suppressedDOFptr[(3*indices[k]) + d] = bdyArrPtr[indices[k]];
00468               }
00469             }
00470           }
00471         }
00472       }
00473     }
00474 
00475     <span class="keywordflow">if</span>(bdyArrAux) {
00476       <span class="keyword">delete</span> [] bdyArrAux;
00477       bdyArrAux = NULL;
00478     }
00479 
00480     (damg[i])-&gt;user = ctx;
00481   }<span class="comment">//end for i</span>
00482 
00483 }<span class="comment">//end fn.</span>
00484 
<a name="l00485"></a><a class="code" href="elasticityJac_8h.html#a1">00485</a> <span class="keywordtype">void</span> <a class="code" href="elasticityJac_8h.html#a1">DestroyElasticityContexts</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg) {
00486   <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
00487   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
00488     <a class="code" href="structElasticityData.html">ElasticityData</a>* ctx = (static_cast&lt;ElasticityData*&gt;(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00489     <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a>) {
00490       <span class="keyword">delete</span> [] (ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a>);
00491       ctx-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a> = NULL;
00492     }
00493     <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>) {
00494       MatDestroy(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>);
00495       ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a> = NULL;
00496     }
00497     <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a>) {
00498       VecDestroy(ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a>);
00499       ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a> = NULL;
00500     }
00501     <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a>) {
00502       VecDestroy(ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a>);
00503       ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a> = NULL;
00504     }
00505     <span class="keyword">delete</span> ctx;
00506     ctx = NULL;
00507   }
00508 }<span class="comment">//end fn.</span>
00509 
<a name="l00510"></a><a class="code" href="elasticityJac_8h.html#a6">00510</a> PetscErrorCode <a class="code" href="elasticityJac_8h.html#a6">ElasticityShellMatMult</a>(Mat J, Vec in, Vec out)
00511 {
00512   PetscFunctionBegin;
00513 
00514   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00515   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00516 
00517   <a class="code" href="structElasticityData.html">ElasticityData</a>* ctx = (static_cast&lt;ElasticityData*&gt;(damg-&gt;user));
00518 
00519   <span class="keywordflow">if</span>(damg-&gt;da-&gt;iAmActive()) {      
00520     PetscScalar* inArray;
00521     PetscScalar* outArray;
00522 
00523     VecGetArray(in, &amp;inArray);
00524     VecGetArray(out, &amp;outArray);
00525 
00526     VecPlaceArray(ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a>, inArray);
00527     VecPlaceArray(ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a>, outArray);
00528 
00529     MatMult(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>, ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a>, ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a>);
00530 
00531     VecResetArray(ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a>);
00532     VecResetArray(ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a>);
00533 
00534     VecRestoreArray(in, &amp;inArray);
00535     VecRestoreArray(out, &amp;outArray);
00536   }
00537 
00538   PetscFunctionReturn(0);
00539 }
00540 
<a name="l00541"></a><a class="code" href="elasticityJac_8h.html#a2">00541</a> PetscErrorCode <a class="code" href="elasticityJac_8h.html#a2">CreateElasticityMat</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat *jac) {
00542   PetscFunctionBegin;
00543   PetscInt buildFullCoarseMat;
00544   PetscInt buildFullMatAll;
00545   <span class="keywordtype">int</span> totalLevels;
00546   PetscTruth flg;
00547   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullCoarseMat"</span>,&amp;buildFullCoarseMat,&amp;flg);
00548   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullMatAll"</span>,&amp;buildFullMatAll,&amp;flg);
00549   <span class="keywordflow">if</span>(buildFullMatAll) {
00550     buildFullCoarseMat = 1;
00551   }
00552   totalLevels = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o17">totalLevels</a>;
00553   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00554   <span class="keywordtype">int</span> myRank;
00555   MPI_Comm_rank(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(), &amp;myRank);
00556   <span class="keywordflow">if</span>( totalLevels == damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a> ) {
00557     <span class="comment">//This is the coarsest.</span>
00558     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; (buildFullCoarseMat) ) {
00559       std::cout&lt;&lt;<span class="stringliteral">"Building Full elasticity Mat at the coarsest level."</span>&lt;&lt;std::endl;
00560     }
00561     <span class="keywordtype">char</span> matType[30];
00562     <span class="keywordflow">if</span>(buildFullCoarseMat) {
00563       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00564         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00565       }
00566       PetscTruth typeFound;
00567       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00568       <span class="keywordflow">if</span>(!typeFound) {
00569         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full matrix!"</span>&lt;&lt;std::endl;
00570         assert(<span class="keyword">false</span>);
00571       }
00572     }
00573     <span class="keywordtype">bool</span> requirePrivateMats = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>() != da-&gt;<a class="code" href="classot_1_1DA.html#z31_20">getNpesAll</a>());    
00574     <span class="keywordflow">if</span>(requirePrivateMats) {
00575       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00576       m=n=(3*(da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>()));
00577       <a class="code" href="structElasticityData.html">ElasticityData</a>* ctx = (static_cast&lt;ElasticityData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00578       <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00579         <span class="keywordflow">if</span>(buildFullCoarseMat) {
00580           da-&gt;<a class="code" href="classot_1_1DA.html#z35_4">createActiveMatrix</a>(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>, matType, 3);
00581         } <span class="keywordflow">else</span> {
00582           MatCreateShell(da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>(), m ,n, PETSC_DETERMINE,
00583               PETSC_DETERMINE, damg, (&amp;(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>)));
00584 
00585           MatShellSetOperation(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>, MATOP_MULT,
00586               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a12">ElasticityMatMult</a>);
00587 
00588           MatShellSetOperation(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>, MATOP_GET_DIAGONAL,
00589               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a11">ElasticityMatGetDiagonal</a>);
00590 
00591           MatShellSetOperation(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>, MATOP_DESTROY,
00592               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a18">ElasticityMatDestroy</a>);
00593         }
00594         MatGetVecs(ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a>, &amp;(ctx-&gt;<a class="code" href="structElasticityData.html#o1">inTmp</a>), &amp;(ctx-&gt;<a class="code" href="structElasticityData.html#o5">outTmp</a>));
00595       } <span class="keywordflow">else</span> {
00596         ctx-&gt;<a class="code" href="structElasticityData.html#o2">Jmat_private</a> = NULL;
00597       }
00598       <span class="comment">//Need a MATShell wrapper anyway. But, the matvecs are not implemented for</span>
00599       <span class="comment">//this matrix. However, a matmult function is required for compute</span>
00600       <span class="comment">//residuals</span>
00601       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00602       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a18">ElasticityMatDestroy</a>);
00603       MatShellSetOperation(*jac, MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a16">ElasticityShellMatMult</a>);
00604     } <span class="keywordflow">else</span> {
00605       <span class="keywordflow">if</span>(buildFullCoarseMat) {
00606         da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 3);
00607       } <span class="keywordflow">else</span> {
00608         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00609         m=n=(3*(da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>()));
00610         MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00611         MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a12">ElasticityMatMult</a>);
00612         MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a11">ElasticityMatGetDiagonal</a>);
00613         MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a18">ElasticityMatDestroy</a>);
00614       }
00615     }
00616     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; (buildFullCoarseMat) ) {
00617       std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full elasticity Mat at the coarsest level."</span>&lt;&lt;std::endl;
00618     }
00619   }<span class="keywordflow">else</span> {  
00620     <span class="comment">//This is not the coarsest level. No need to bother with KSP_Shell</span>
00621     <span class="keywordflow">if</span>(buildFullMatAll) {
00622       <span class="keywordflow">if</span>( !myRank ) {
00623         std::cout&lt;&lt;<span class="stringliteral">"Building Full elasticity Mat at level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00624       }
00625       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00626         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00627       }
00628       <span class="keywordtype">char</span> matType[30];
00629       PetscTruth typeFound;
00630       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00631       <span class="keywordflow">if</span>(!typeFound) {
00632         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full matrix!"</span>&lt;&lt;std::endl;
00633         assert(<span class="keyword">false</span>);
00634       }
00635       da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 3);
00636       <span class="keywordflow">if</span>(!myRank) {
00637         std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full elasticity Mat at level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00638       }
00639     } <span class="keywordflow">else</span> {
00640       <span class="comment">//Create a MATShell</span>
00641       <span class="comment">//The size this processor owns ( without ghosts).</span>
00642       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00643       m=n=(3*(da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>()));
00644       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00645       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a12">ElasticityMatMult</a>);
00646       MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a11">ElasticityMatGetDiagonal</a>);
00647       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="elasticityJac_8C.html#a18">ElasticityMatDestroy</a>);
00648     }
00649   }
00650   PetscFunctionReturn(0);
00651 }<span class="comment">//end fn.</span>
00652 
<a name="l00653"></a><a class="code" href="elasticityJac_8h.html#a7">00653</a> PetscErrorCode <a class="code" href="elasticityJac_8h.html#a7">ElasticityMatDestroy</a>(Mat J) {
00654   PetscFunctionBegin;
00655   <span class="comment">//Nothing to be done here. No new pointers were created during creation. </span>
00656   PetscFunctionReturn(0);
00657 }
00658 
00659 <span class="comment">//Functions required in order to use BlockDiag PC</span>
00660 
<a name="l00661"></a><a class="code" href="elasticityJac_8h.html#a10">00661</a> <span class="keywordtype">void</span> <a class="code" href="elasticityJac_8h.html#a10">computeInvBlockDiagEntriesForElasticityMat</a>(Mat J, <span class="keywordtype">double</span> **invBlockDiagEntries) {
00662   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00663   MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg));
00664   <a class="code" href="structElasticityData.html">ElasticityData</a>* data = (static_cast&lt;ElasticityData*&gt;(damg-&gt;user));
00665   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;da;
00666   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof = 3;
00667   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeSize = damg-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00668 
00669   <span class="comment">//Initialize</span>
00670   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; (dof*nodeSize); i++ ) {
00671     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; dof; j++) {
00672       invBlockDiagEntries[i][j] = 0.0;
00673     }<span class="comment">//end for j</span>
00674   }<span class="comment">//end for i</span>
00675 
00676   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* bdyArr = data-&gt;<a class="code" href="structElasticityData.html#o0">bdyArr</a>;
00677   <span class="keywordtype">double</span> mu = data-&gt;<a class="code" href="structElasticityData.html#o4">mu</a>;
00678   <span class="keywordtype">double</span> lambda = data-&gt;<a class="code" href="structElasticityData.html#o3">lambda</a>;
00679   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00680   <span class="keywordtype">double</span> hFac;
00681 
00682   std::vector&lt;double&gt; blockDiagVec;
00683   da-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>&lt;<span class="keywordtype">double</span>&gt;(blockDiagVec, <span class="keyword">false</span>, <span class="keyword">false</span>, 9);
00684   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; blockDiagVec.size(); i++) {
00685     blockDiagVec[i] = 0.0;
00686   }
00687 
00688   <span class="keywordtype">double</span> *blockDiagArr;
00689   <span class="comment">/*Nodal,Non-Ghosted,Write,9 dof*/</span>
00690   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(blockDiagVec, blockDiagArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 9);
00691 
00692   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00693     maxD = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>());
00694     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00695     <span class="comment">/*Loop through All Elements including ghosted*/</span>
00696     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;();
00697         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00698         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;()) {
00699       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00700       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx);
00701       <span class="keywordtype">double</span> h = hFac*(1u &lt;&lt; (maxD - lev));
00702       <span class="keywordtype">double</span> fac = h/2.0;
00703       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00704       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00705       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00706       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(idx);
00707       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00708       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00709         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00710           <span class="keywordflow">if</span>(bdyArr[indices[k]]) {
00711             <span class="comment">/*Dirichlet Node*/</span>
00712             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> dof = 0; dof &lt; 3; dof++) {
00713               blockDiagArr[(9*indices[k]) + (3*dof) + dof] = 1.0;
00714             } <span class="comment">/*end dof*/</span>
00715           } <span class="keywordflow">else</span> { 
00716             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> dof = 0; dof &lt; 3; dof++) {
00717               blockDiagArr[(9*indices[k])+(3*dof) + dof] += (mu*fac*
00718                   <a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>[childNum][elemType][k][k]);
00719             } <span class="comment">/*end dof*/</span>
00720             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> dofOut = 0; dofOut &lt; 3; dofOut++) {
00721               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> dofIn = 0; dofIn &lt; 3; dofIn++) {
00722                 blockDiagArr[(9*indices[k]) + (3*dofOut) + dofIn] +=
00723                   ((mu+lambda)*fac*
00724                    <a class="code" href="elasticityJac_8C.html#a8">GradDivType2Stencil</a>[childNum][elemType][(3*k) + dofIn][(3*k) + dofOut]);
00725               }<span class="comment">/*end dofIn*/</span>
00726             } <span class="comment">/*end dofOut*/</span>
00727           }
00728         } <span class="comment">/*end k*/</span>
00729     } <span class="comment">/*end i*/</span>
00730   } <span class="comment">/*end if active*/</span>
00731 
00732   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(blockDiagVec,blockDiagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,9);
00733 
00734   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodeSize; i++) {
00735     <span class="keywordtype">double</span> a11 = blockDiagVec[(9*i)];
00736     <span class="keywordtype">double</span> a12 = blockDiagVec[(9*i)+1];
00737     <span class="keywordtype">double</span> a13 = blockDiagVec[(9*i)+2];
00738     <span class="keywordtype">double</span> a21 = blockDiagVec[(9*i)+3];
00739     <span class="keywordtype">double</span> a22 = blockDiagVec[(9*i)+4];
00740     <span class="keywordtype">double</span> a23 = blockDiagVec[(9*i)+5];
00741     <span class="keywordtype">double</span> a31 = blockDiagVec[(9*i)+6];
00742     <span class="keywordtype">double</span> a32 = blockDiagVec[(9*i)+7];
00743     <span class="keywordtype">double</span> a33 = blockDiagVec[(9*i)+8];
00744 
00745     <span class="keywordtype">double</span> detA = ((a11*a22*a33)-(a11*a23*a32)-(a21*a12*a33)
00746         +(a21*a13*a32)+(a31*a12*a23)-(a31*a13*a22));
00747 
00748     invBlockDiagEntries[3*i][0] = (a22*a33-a23*a32)/detA;
00749 
00750     invBlockDiagEntries[3*i][1] = -(a12*a33-a13*a32)/detA;
00751 
00752     invBlockDiagEntries[3*i][2] = (a12*a23-a13*a22)/detA;
00753 
00754     invBlockDiagEntries[(3*i)+1][0] = -(a21*a33-a23*a31)/detA;
00755 
00756     invBlockDiagEntries[(3*i)+1][1] = (a11*a33-a13*a31)/detA;
00757 
00758     invBlockDiagEntries[(3*i)+1][2] = -(a11*a23-a13*a21)/detA;
00759 
00760     invBlockDiagEntries[(3*i)+2][0] = (a21*a32-a22*a31)/detA;
00761 
00762     invBlockDiagEntries[(3*i)+2][1] = -(a11*a32-a12*a31)/detA;
00763 
00764     invBlockDiagEntries[(3*i)+2][2] = (a11*a22-a12*a21)/detA;
00765   }<span class="comment">//end for i</span>
00766 
00767   blockDiagVec.clear();
00768 }
00769 
00770 
<a name="l00771"></a><a class="code" href="elasticityJac_8h.html#a9">00771</a> <span class="keywordtype">void</span> <a class="code" href="elasticityJac_8h.html#a9">getDofAndNodeSizeForElasticityMat</a>(Mat J, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp; dof, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> &amp; nodeSize) {
00772   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00773   MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg));
00774 
00775   dof = 3;
00776   nodeSize = damg-&gt;da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00777 }
00778 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:23 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
