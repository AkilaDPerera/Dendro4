<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/include/par/search.txx Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000007.html">par</a></div>
<h1>search.txx</h1><a href="search_8txx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="preprocessor">#ifdef __DEBUG__</span>
00003 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_PAR__</span>
00004 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_PAR__</span>
00005 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00006 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00007 <span class="preprocessor"></span>
00014 <span class="keyword">namespace </span>par {
00015         
00016         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00017         <span class="keywordtype">int</span> <a class="code" href="namespaceseq.html#a4">maxLowerBound</a>(<span class="keyword">const</span> std::vector&lt;T&gt; &amp; keys, <span class="keyword">const</span> std::vector&lt;T&gt; &amp; searchList,
00018 std::vector&lt;T&gt; &amp; results, MPI_Comm comm) {
00019                 <a class="code" href="parUtils_8h.html#a5">PROF_SEARCH_BEGIN</a>
00020 
00021                 <span class="keywordtype">int</span> rank, npes;
00022 
00023                 MPI_Comm_size(comm, &amp;npes);
00024                 MPI_Comm_rank(comm, &amp;rank);
00025 
00026                 <span class="comment">// allocate memory for the mins array</span>
00027                 std::vector&lt;T&gt; mins (npes);
00028                 assert(!searchList.empty());
00029 
00030                 par::MPI_Allgather&lt;T&gt;( &amp;(*searchList.begin()), &amp;(*mins.begin()), 1, comm);
00031 
00032                 <span class="comment">//For each key decide which processor to send to</span>
00033                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *part = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keys.size()];
00034                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keys.size(); i++ ) {
00035                         <span class="comment">//maxLB returns the smallest index in a sorted array such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
00036                         <span class="keywordtype">bool</span> found = par::maxLowerBound&lt;T&gt;(mins,keys[i], part+i);
00037                         <span class="keywordflow">if</span> ( !found ) {
00038                                 <span class="comment">//This key is smaller than the mins from every processor.</span>
00039                                 <span class="comment">//No point in searching.</span>
00040                                 part[i] = rank;
00041                         }
00042                 }
00043                 mins.clear();
00044 
00045                 <span class="keywordtype">int</span> *numKeysSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00046                 <span class="keywordtype">int</span> *numKeysRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00047                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;npes; i++ )
00048                         numKeysSend[i] = 0;
00049                 <span class="comment">// calculate the number of keys to send ...</span>
00050                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keys.size(); i++ )
00051                         numKeysSend[part[i]]++;
00052 
00053                 <span class="comment">// Now do an All2All to get numKeysRecv</span>
00054                 par::MPI_Alltoall(numKeysSend, 1, MPI_INT, numKeysRecv, 1, MPI_INT, comm);
00055 
00056                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalKeys=0;       <span class="comment">// total number of local keys ...</span>
00057                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;npes; i++ )
00058                         totalKeys += numKeysRecv[i];
00059 
00060                 <span class="comment">// create the send and recv buffers ...</span>
00061                 std::vector&lt;T&gt; sendK (keys.size());
00062                 std::vector&lt;T&gt; recvK (totalKeys);
00063                 <span class="comment">// the mapping ..</span>
00064                 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * comm_map = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> [keys.size()];
00065 
00066                 <span class="comment">// Now create sendK</span>
00067                 <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; sendOffsets[0] = 0;
00068                 <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; recvOffsets[0] = 0;
00069                 <span class="keywordtype">int</span> *numKeysTmp = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; numKeysTmp[0] = 0; 
00070 
00071                 <span class="comment">// compute offsets ...</span>
00072                 <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=1; i&lt;npes; i++ ) {
00073                         sendOffsets[i] = sendOffsets[i-1] + numKeysSend[i-1];
00074                         recvOffsets[i] = recvOffsets[i-1] + numKeysRecv[i-1];
00075                         numKeysTmp[i] = 0; 
00076                 }
00077 
00078                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; keys.size(); i++ ) {
00079                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmp[part[i]];
00080                         numKeysTmp[part[i]]++;
00081                         <span class="comment">// set entry ...</span>
00082                         sendK[sendOffsets[part[i]] + ni] = keys[i];
00083                         <span class="comment">// save mapping .. will need it later ...</span>
00084                         comm_map[i] = sendOffsets[part[i]] + ni;
00085                 }
00086                 <span class="keyword">delete</span> [] part;
00087                 <span class="keyword">delete</span> [] numKeysTmp;
00088 
00089 
00090                 par::MPI_Alltoallv_sparse((<span class="keywordtype">void</span> *)&amp;(*sendK.begin()), numKeysSend,
00091                 sendOffsets,<a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;::value</a>(), 
00092                 &amp;(*recvK.begin()), numKeysRecv, recvOffsets,
00093                 <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;::value</a>(), comm);
00094 
00095 
00096                 std::vector&lt;T&gt;  resSend (totalKeys);
00097                 std::vector&lt;T&gt;  resRecv (keys.size());
00098 
00099                 <span class="comment">//Final local search.</span>
00100                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;totalKeys;i++) {
00101                         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00102                         <span class="keywordtype">bool</span> found = par::maxLowerBound&lt;T&gt;( searchList, recvK[i], &amp;idx );
00103                         <span class="keywordflow">if</span>(found) {
00104                                 resSend[i] = searchList[idx];
00105                         }
00106                 }<span class="comment">//end for i</span>
00107 
00108                 <span class="comment">//Exchange Results</span>
00109                 <span class="comment">//Return what you received in the earlier communication.</span>
00110                 par::MPI_Alltoallv_sparse((<span class="keywordtype">void</span>*)&amp;(*resSend.begin()), numKeysRecv,
00111                 recvOffsets,<a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;::value</a>(), 
00112                 &amp;(*resRecv.begin()), numKeysSend, sendOffsets,
00113                 <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;::value</a>(), comm);
00114 
00115                 <span class="keyword">delete</span> [] sendOffsets;
00116                 <span class="keyword">delete</span> [] recvOffsets;
00117                 <span class="keyword">delete</span> [] numKeysSend;
00118                 <span class="keyword">delete</span> [] numKeysRecv;
00119 
00120                 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; keys.size(); i++ ) {
00121                         results[i] = resRecv[comm_map[i]];  
00122                 }<span class="comment">//end for</span>
00123 
00124                 <span class="comment">// Clean up ...</span>
00125                 <span class="keyword">delete</span> [] comm_map;
00126 
00127                 <a class="code" href="parUtils_8h.html#a25">PROF_SEARCH_END</a>
00128         }
00129 
00130 
00131 }<span class="comment">//end namespace</span>
00132 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:30 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
