<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /export/home/ilashuk3/Dendro/include/par/parUtils.txx File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_7b6865455b3d16858f39156e6f25b065.html">include</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_b68860295b5b3831a1cd4100df8449c2.html">par</a></div>
<h1>parUtils.txx File Reference</h1>Definitions of the templated functions in the par module. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="binUtils_8h-source.html">binUtils.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="seqUtils_8h-source.html">seqUtils.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="dtypes_8h-source.html">dtypes.h</a>&quot;</code><br>
<code>#include &lt;cassert&gt;</code><br>
<code>#include &lt;iostream&gt;</code><br>
<code>#include &lt;algorithm&gt;</code><br>
<code>#include &quot;<a class="el" href="dendro_8h-source.html">dendro.h</a>&quot;</code><br>

<p>
<a href="parUtils_8txx-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacepar.html">par</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#abbda118df73bcd88110d7cd72703080">par::bitonicSort</a> (std::vector&lt; T &gt; &amp;in, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of parallel bitonic sort that does not expect the number of processors to be a power of 2. In fact, the number of processors can even be odd. Moreover, we do not even expect the length of the vector (neither locally nor globally) to be a power of 2 or even. Moreover, each processor can call this with a different number of elements. However, we do expect that 'in' atleast has 1 element on each processor. This recursively calls the function bitonicSort_binary, followed by a special parallel merge.  <a href="#abbda118df73bcd88110d7cd72703080"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#99bacf5b01b4a98ad3e5e93b119a0ad4">par::bitonicSort_binary</a> (std::vector&lt; T &gt; &amp;in, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">An implementation of parallel bitonic sort that expects the number of processors to be a power of 2. However, unlike most implementations, we do not expect the length of the vector (neither locally nor globally) to be a power of 2 or even. Moreover, each processor can call this with a different number of elements. However, we do expect that 'in' atleast has 1 element on each processor.  <a href="#99bacf5b01b4a98ad3e5e93b119a0ad4"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#b6f02b570ceb5f19c2f3852db91202ba">par::concatenate</a> (std::vector&lt; T &gt; &amp;listA, std::vector&lt; T &gt; &amp;listB, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parallel concatenation function. listB is appended (globally) to listA and the result is stored in listA. An useful application of this function is when listA and listB are individually sorted (globally) and the smallest element in listB is greater than the largest element in listA and we want to create a merged list that is sorted.  <a href="#b6f02b570ceb5f19c2f3852db91202ba"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#2b9164cc2fd85f165a1874ff0b1e0f84">par::defaultWeight</a> (const T *a)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#eb105d8db185d7e48c1dcb3555b5aa18">par::maxLowerBound</a> (const std::vector&lt; T &gt; &amp;keys, const std::vector&lt; T &gt; &amp;searchList, std::vector&lt; T &gt; &amp;results, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parallel search function.  <a href="#eb105d8db185d7e48c1dcb3555b5aa18"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#231eea98a00e94993a6621e2052d3b3f">par::MergeLists</a> (std::vector&lt; T &gt; &amp;listA, std::vector&lt; T &gt; &amp;listB, int KEEP_WHAT)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges lists A, and B, retaining either the low or the High in list A.  <a href="#231eea98a00e94993a6621e2052d3b3f"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#dae14a05794f514ccc020ae405afb371">par::MergeSplit</a> (std::vector&lt; T &gt; &amp;local_list, int which_keys, int partner, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">The main operation in the parallel bitonic sort algorithm. This implements the compare-split operation.  <a href="#dae14a05794f514ccc020ae405afb371"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#f9ec796daad7c69d35a6005b9381ca7f">par::Mpi_Allgather</a> (T *sendbuf, T *recvbuf, int count, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#cf83c7ff0a38de693d3ef658769c743a">par::Mpi_Allgatherv</a> (T *sendbuf, int sendcount, T *recvbuf, int *recvcounts, int *displs, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#7143fd965a1fe6cfdcd8a082b5c4b51e">par::Mpi_Allreduce</a> (T *sendbuf, T *recvbuf, int count, MPI_Op op, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#4afe62b685ee1b5fde8d2ab88811fb7a">par::Mpi_Alltoall</a> (T *sendbuf, T *recvbuf, int count, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#8ce3395260ef83f9a2ae47d700b8e49f">par::Mpi_Alltoallv_dense</a> (T *sendbuf, int *sendcnts, int *sdispls, T *recvbuf, int *recvcnts, int *rdispls, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#bd932c20dd259fb45d1c0d536f64f1f3">par::Mpi_Alltoallv_sparse</a> (T *sendbuf, int *sendcnts, int *sdispls, T *recvbuf, int *recvcnts, int *rdispls, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#8533e4f31bb30d77a773037464f10a98">par::Mpi_Bcast</a> (T *buffer, int count, int root, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#bfd74e908844c05893ca758888c00721">par::Mpi_Gather</a> (T *sendBuffer, T *recvBuffer, int count, int root, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#d17d157a6de1404f4770a8106008658e">par::Mpi_Irecv</a> (T *buf, int count, int source, int tag, MPI_Comm comm, MPI_Request *request)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ac0105e531837271f13e03b706ea217d">par::Mpi_Isend</a> (T *buf, int count, int dest, int tag, MPI_Comm comm, MPI_Request *request)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#61259bd3d4b3d16bf17c85c705bbfe6a">par::Mpi_Issend</a> (T *buf, int count, int dest, int tag, MPI_Comm comm, MPI_Request *request)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#61c98b5cef72b081950598e29dd85ce4">par::Mpi_Recv</a> (T *buf, int count, int source, int tag, MPI_Comm comm, MPI_Status *status)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#bd66dcf96c5d37bf125c529b23ff1496">par::Mpi_Reduce</a> (T *sendbuf, T *recvbuf, int count, MPI_Op op, int root, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#f664fbaf4a215cf147ebbde15c62a8c0">par::Mpi_Scan</a> (T *sendbuf, T *recvbuf, int count, MPI_Op op, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T, typename S&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#ee33f1d52b5c2af657e6c21ee12b44cc">par::Mpi_Sendrecv</a> (T *sendBuf, int sendCount, int dest, int sendTag, S *recvBuf, int recvCount, int source, int recvTag, MPI_Comm comm, MPI_Status *status)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#a9fa34c8c4f36918e262ce835a1c743e">par::Par_bitonic_merge_incr</a> (std::vector&lt; T &gt; &amp;local_list, int proc_set_size, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#c83fd7446c1a17a6a964be4f496e3c76">par::Par_bitonic_sort_decr</a> (std::vector&lt; T &gt; &amp;local_list, int proc_set_size, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#cb9def7b256c3cd6c52bbe546196da60">par::Par_bitonic_sort_incr</a> (std::vector&lt; T &gt; &amp;local_list, int proc_set_size, MPI_Comm comm)</td></tr>

<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#44703b0c0fd421354d6593a6df49f624">par::partitionW</a> (std::vector&lt; T &gt; &amp;vec, unsigned int(*getWeight)(const T *), MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parallel weighted partitioning function. In our implementation, we do not pose any restriction on the input or the number of processors. This function can be used with an odd number of processors as well. Some processors can pass an empty vector as input. The relative ordering of the elements is preserved.  <a href="#44703b0c0fd421354d6593a6df49f624"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#0ae84d08f27a6cc17fd8f6be2ba8f823">par::removeDuplicates</a> (std::vector&lt; T &gt; &amp;nodes, bool isSorted, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Removes duplicates in parallel. If the input is not sorted, sample sort will be called within the function to sort the vector and then duplicates will be removed.  <a href="#0ae84d08f27a6cc17fd8f6be2ba8f823"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#508e54e3c20156811e4eeb3de77b80f7">par::sampleSort</a> (std::vector&lt; T &gt; &amp;in, std::vector&lt; T &gt; &amp;out, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A parallel sample sort implementation. In our implementation, we do not pose any restriction on the input or the number of processors. This function can be used with an odd number of processors as well. Some processors can pass an empty vector as input. If the total number of elements in the vector (globally) is fewer than 10*p^2, where p is the number of processors, then we will use bitonic sort instead of sample sort to sort the vector. We use a paralle bitonic sort to sort the samples in the sample sort algorithm. Hence, the complexity of the algorithm is O(n/p log n/p) + O(p log p). Here, n is the global length of the vector and p is the number of processors.  <a href="#508e54e3c20156811e4eeb3de77b80f7"></a><br></td></tr>
<tr><td class="memTemplParams" nowrap colspan="2">template&lt;typename T&gt; </td></tr>
<tr><td class="memTemplItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacepar.html#e96a0ece3066ab9f4c7e61793c88ce6d">par::scatterValues</a> (std::vector&lt; T &gt; &amp;in, std::vector&lt; T &gt; &amp;out, DendroIntL outSz, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Re-distributes a STL vector, preserving the relative ordering of the elements.  <a href="#e96a0ece3066ab9f4c7e61793c88ce6d"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Definitions of the templated functions in the par module. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Rahul S. Sampath, <a href="mailto:rahul.sampath@gmail.com">rahul.sampath@gmail.com</a> <p>
Hari Sundar, <a href="mailto:hsundar@gmail.com">hsundar@gmail.com</a> <p>
Shravan Veerapaneni, <a href="mailto:shravan@seas.upenn.edu">shravan@seas.upenn.edu</a> <p>
Santi Swaroop Adavani, <a href="mailto:santis@gmail.com">santis@gmail.com</a> </dd></dl>

<p>
Definition in file <a class="el" href="parUtils_8txx-source.html">parUtils.txx</a>.<hr size="1"><address style="align: right;"><small>Generated on Tue Mar 23 19:58:49 2010 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
