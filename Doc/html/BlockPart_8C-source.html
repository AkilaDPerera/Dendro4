<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oct/BlockPart.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">oct</a></div>
<h1>BlockPart.C</h1><a href="BlockPart_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00009 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00011 
00012 <span class="preprocessor">#ifdef __DEBUG__</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_OCT__</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_OCT__</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00017 <span class="preprocessor"></span>
00018 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#ifndef __MEASURE_BPART_COMM__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __MEASURE_BPART_COMM__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span>
00024 <span class="keyword">namespace </span>ot {
00025 
00026   <span class="comment">//Assumes that nodes are sorted.</span>
00027   <span class="comment">//No processor must call this with an empty input.</span>
<a name="l00028"></a><a class="code" href="namespaceot.html#a26">00028</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a26">blockPartStage1_p2o</a>(std::vector&lt;TreeNode&gt; &amp;nodes, std::vector&lt;TreeNode&gt; &amp;blocks,
00029       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth,  MPI_Comm comm) {
00030 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00031 <span class="preprocessor"></span>    MPI_Barrier(comm);
00032 <span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>    <a class="code" href="octUtils_8h.html#a20">PROF_BLKPART1_BEGIN</a>
00034       <span class="keywordtype">int</span> npes, rank;
00035     MPI_Comm_rank(comm, &amp;rank);
00036     MPI_Comm_size(comm, &amp;npes);
00037 
00038     par::partitionW&lt;ot::TreeNode&gt;(nodes, NULL, comm);
00039 
00040     assert(nodes.size() &gt; (1 &lt;&lt; dim) ); 
00041 
00042     <span class="comment">// 1. First compute the localCoarse octree </span>
00043     std::vector&lt;TreeNode&gt; localCoarse;
00044 
00045     <span class="comment">//include both the min and max elements as well  </span>
00046     <span class="comment">//The output will be sorted, unique and linear</span>
00047     <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(nodes[0], nodes[nodes.size()-1], localCoarse, <span class="keyword">true</span>, <span class="keyword">true</span>);
00048 
00049     <span class="comment">// 2. Get local Blocks. These will be input to completeOctree that will</span>
00050     <span class="comment">// produce globalCoarse.</span>
00051     std::vector&lt;TreeNode&gt; localBlocks;
00052 
00053     <span class="comment">//Select all the coarsest blocks and insert them into localBlocks</span>
00054     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minLevel = maxDepth;
00055     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; localCoarse.size(); i++) {
00056       <span class="keywordflow">if</span>(localCoarse[i].getLevel() &lt; minLevel) {
00057         minLevel = localCoarse[i].getLevel();
00058       }
00059     }
00060 
00061     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; localCoarse.size(); i++) {
00062       <span class="keywordflow">if</span>(localCoarse[i].getLevel() == minLevel) {
00063         localBlocks.push_back(localCoarse[i]);
00064       }
00065     }
00066 
00067     localCoarse.clear();
00068 
00069     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; localBlocks.size(); i++) {
00070       localBlocks[i].setWeight(1);
00071     }
00072 
00073     <span class="comment">// 3. Call nodes2Oct on these cells to generate the </span>
00074     <span class="comment">//    globalCoarse octree ...</span>
00075     <span class="comment">//localBlocks will be sorted and linear </span>
00076     <span class="comment">//There is a pathological case which prevents us from asserting that</span>
00077     <span class="comment">//localBlocks will be globally unique. For example, if the last element in the input on processor i</span>
00078     <span class="comment">//is the same as the first element on processor i+1 and if they are both</span>
00079     <span class="comment">//selected in localBlocks.</span>
00080 
00081     <a class="code" href="namespaceot.html#a33">completeOctree</a>(localBlocks, blocks, dim, maxDepth, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, comm);
00082 
00083     localBlocks.clear();
00084 
00085     <a class="code" href="octUtils_8h.html#a59">PROF_BLKPART1_END</a>
00086   } <span class="comment">// end blockPart</span>
00087 
<a name="l00088"></a><a class="code" href="namespaceot.html#a27">00088</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a27">blockPartStage2_p2o</a>(std::vector&lt;TreeNode&gt; &amp;nodes, std::vector&lt;TreeNode&gt; &amp;globalCoarse,
00089       std::vector&lt;ot::TreeNode&gt;&amp; minsAllBlocks, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth,
00090       MPI_Comm comm) {
00091 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00092 <span class="preprocessor"></span>    MPI_Barrier(comm);
00093 <span class="preprocessor">#endif</span>
00094 <span class="preprocessor"></span>    <a class="code" href="octUtils_8h.html#a21">PROF_BLKPART2_BEGIN</a>
00095 
00096       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> rootNode (dim,maxDepth);
00097 
00098     <span class="keywordtype">int</span> npes, rank;
00099     MPI_Comm_rank(comm,&amp;rank);
00100     MPI_Comm_size(comm,&amp;npes);
00101 
00102     <span class="keywordtype">int</span> *sendCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00103     <span class="keywordtype">int</span> *recvCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00104     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00105     <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00106 
00107     <span class="comment">//1. Now compute the wts of these cells ...</span>
00108     <span class="comment">//    a. Get the min and max nodes at each processor.</span>
00109     std::vector&lt;TreeNode&gt; _mins_maxs(2*npes);
00110 
00111     <span class="comment">// communicate ...</span>
00112     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> sendMinMax[2];
00113 
00114     <span class="keywordflow">if</span> (!nodes.empty()) {
00115       sendMinMax[0] =  nodes[0];
00116       sendMinMax[1] =  nodes[nodes.size()-1];
00117     } <span class="keywordflow">else</span> {
00118       sendMinMax[0] = rootNode;
00119       sendMinMax[1] = rootNode;
00120     }
00121 
00122     par::Mpi_Allgather&lt;ot::TreeNode&gt;(sendMinMax, &amp;(*_mins_maxs.begin()), 2, comm);
00123 
00124     std::vector&lt;std::vector&lt;TreeNode&gt; &gt; sendNodes(npes);
00125     std::vector&lt;std::vector&lt;unsigned int&gt; &gt; keymap(npes);
00126 
00127     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00128       sendCnt[i] = 0;
00129     }
00130 
00131     <span class="comment">//    b. Now compute which cells go to which cells ...</span>
00132     <span class="comment">//       logic is that if the coarse cell is between the min and max at a</span>
00133     <span class="comment">//       processor or if it is an ancestor of min, then it is sent to that</span>
00134     <span class="comment">//       processor.</span>
00135     <span class="comment">//Naive Logic:</span>
00136     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;globalCoarse.size(); i++) {
00137       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p=0;p&lt;npes;p++) {
00138 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00139 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(globalCoarse[i], _mins_maxs[2*p]));
00140 <span class="preprocessor">#endif</span>
00141 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( (globalCoarse[i].isAncestor(_mins_maxs[2*p])) ||
00142             ( (globalCoarse[i] &gt;= _mins_maxs[2*p]) &amp;&amp; (globalCoarse[i] &lt;=_mins_maxs[(2*p)+1]) ) ) {
00143           sendNodes[p].push_back(globalCoarse[i]);
00144           <span class="comment">// save keymap so that we can assign weights back to globalCoarse.</span>
00145           keymap[p].push_back(i);    
00146           sendCnt[p]++;
00147         }<span class="comment">//end if</span>
00148       }<span class="comment">//end for</span>
00149     }<span class="comment">//end for</span>
00150 
00151     _mins_maxs.clear();
00152 
00153     <span class="comment">//2. Send nodes to all cells to compute the wts ... locally ...</span>
00154 
00155     <span class="comment">//    a. Communicate how many you'll be sending and how many will be</span>
00156     <span class="comment">//       received.</span>
00157 
00158     <span class="comment">// Now do an All2All to get numKeysRecv</span>
00159     par::Mpi_Alltoall&lt;int&gt;( sendCnt, recvCnt, 1, comm);
00160 
00161     <span class="comment">//    b. Concatenate all nodes into one single Carray ...</span>
00162     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalSend = 0;
00163     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalRecv = 0;
00164 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00165 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsSendI = 0;
00166     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsRecvI = 0;
00167 <span class="preprocessor">#endif</span>
00168 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00169       totalSend+= sendCnt[i];
00170       totalRecv+= recvCnt[i];
00171 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00172 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(sendCnt[i]) {
00173         numProcsSendI++;
00174       }
00175       <span class="keywordflow">if</span>(recvCnt[i]) {
00176         numProcsRecvI++;
00177       }
00178 <span class="preprocessor">#endif</span>
00179 <span class="preprocessor"></span>    }
00180 
00181     <span class="comment">// create the send and recv buffers ...</span>
00182     std::vector&lt;ot::TreeNode&gt; sendK (totalSend);
00183     std::vector&lt;ot::TreeNode&gt; recvK (totalRecv);
00184 
00185     <span class="comment">// Now create sendK</span>
00186     sendOffsets[0] = 0;
00187     recvOffsets[0] = 0;
00188 
00189     <span class="comment">// compute offsets ...</span>
00190     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;npes; i++) {
00191       sendOffsets[i] = sendOffsets[i-1] + sendCnt[i-1];
00192       recvOffsets[i] = recvOffsets[i-1] + recvCnt[i-1];
00193     }
00194 
00195     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00196       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;sendCnt[i]; j++) {
00197         sendK[sendOffsets[i] + j] = sendNodes[i][j];
00198       }<span class="comment">//end for j</span>
00199     }<span class="comment">//end for i</span>
00200 
00201     <span class="comment">//3. send and receive all keys ...</span>
00202 
00203     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKptr = NULL;
00204     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKptr = NULL;
00205     <span class="keywordflow">if</span>(!sendK.empty()) {
00206       sendKptr = &amp;(*(sendK.begin()));
00207     }
00208     <span class="keywordflow">if</span>(!recvK.empty()) {
00209       recvKptr = &amp;(*(recvK.begin()));
00210     }
00211 
00212     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;(sendKptr, sendCnt, sendOffsets,      
00213         recvKptr, recvCnt, recvOffsets, comm);
00214 
00215     sendK.clear();
00216 
00217 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00218 <span class="preprocessor"></span>    MPI_Barrier(comm);
00219     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalSendI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00220     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecvI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00221     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsSendI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00222     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsRecvI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes]; 
00223     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalSend, allTotalSendI, 1, 0, comm);
00224     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalRecv, allTotalRecvI, 1, 0, comm);
00225     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsSendI, allNumProcsSendI, 1, 0, comm);
00226     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsRecvI, allNumProcsRecvI, 1, 0, comm);
00227     <span class="keywordflow">if</span>(!rank) {
00228       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00229         std::cout&lt;&lt;<span class="stringliteral">" allTotalSendI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalSendI[i]&lt;&lt;std::endl;
00230         std::cout&lt;&lt;<span class="stringliteral">" allTotalRecvI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalRecvI[i]&lt;&lt;std::endl;
00231         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsSendI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsSendI[i]&lt;&lt;std::endl;
00232         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsRecvI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsRecvI[i]&lt;&lt;std::endl;
00233       }
00234     }
00235     <span class="keyword">delete</span> [] allTotalSendI;
00236     <span class="keyword">delete</span> [] allTotalRecvI;
00237     <span class="keyword">delete</span> [] allNumProcsSendI;
00238     <span class="keyword">delete</span> [] allNumProcsRecvI;
00239     MPI_Barrier(comm);
00240 <span class="preprocessor">#endif</span>
00241 <span class="preprocessor"></span>
00242     <span class="comment">//4. Now compute the wts of the locally received nodes ...</span>
00243     <span class="comment">//    a. loop through nodes and update the wts of the local chunks ...</span>
00244     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *wts = NULL;
00245     <span class="keywordflow">if</span>(totalRecv) {
00246       wts = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> [totalRecv];
00247     }
00248     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;totalRecv; i++) {
00249       wts[i] = 0;
00250     }
00251 
00252     <span class="comment">//decendants and chunks are both sorted at this point.</span>
00253     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextPt = 0;
00254     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextNode = 0;
00255     <span class="comment">//Every element in nodes is inside some element in recvK.</span>
00256     <span class="keywordflow">while</span> (nextPt &lt; nodes.size()) {
00257       <span class="comment">//The first pt. lies in some block.</span>
00258 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00259 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(recvK[nextNode], nodes[nextPt]));
00260 <span class="preprocessor">#endif</span>
00261 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ((recvK[nextNode].isAncestor(nodes[nextPt])) ||
00262           (recvK[nextNode] == nodes[nextPt])) {
00263         wts[nextNode]++;
00264         nextPt++;
00265       } <span class="keywordflow">else</span> {
00266         nextNode++;
00267         <span class="keywordflow">if</span> (nextNode == totalRecv) {
00268           <span class="comment">//If this fails then either recvK and nodes are not sorted or</span>
00269           <span class="comment">//Some pt in nodes is not in any of recvK</span>
00270           assert(<span class="keyword">false</span>);
00271         }
00272       }<span class="comment">//end if-else</span>
00273     }<span class="comment">//end while</span>
00274 
00275     recvK.clear();
00276 
00277     <span class="comment">//5. Now communicate the wts back to the procs ...</span>
00278     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *recvWts = NULL;
00279     <span class="keywordflow">if</span>(totalSend) {
00280       recvWts = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[totalSend];
00281     }
00282 
00283     par::Mpi_Alltoallv_sparse&lt;unsigned int&gt;( wts, recvCnt, recvOffsets, 
00284         recvWts, sendCnt, sendOffsets, comm);
00285 
00286     <span class="comment">//6. Now map them back to the blocks ...</span>
00287     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;globalCoarse.size();i++) {
00288       globalCoarse[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(0);
00289     }
00290 
00291     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00292       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;sendCnt[i]; j++) {
00293         globalCoarse[keymap[i][j]].<a class="code" href="classot_1_1TreeNode.html#z19_0">addWeight</a>(recvWts[sendOffsets[i] + j]);
00294       }
00295     }
00296 
00297     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00298       keymap[i].clear();
00299       sendNodes[i].clear();
00300     }
00301     sendNodes.clear();
00302     keymap.clear();
00303 
00304     <span class="keywordflow">if</span>(recvWts) {
00305       <span class="keyword">delete</span> [] recvWts;
00306       recvWts = NULL;
00307     }
00308 
00309     <span class="keywordflow">if</span>(wts) {
00310       <span class="keyword">delete</span> [] wts;
00311       wts = NULL;
00312     }
00313 
00314     par::partitionW&lt;ot::TreeNode&gt;(globalCoarse,getNodeWeight,comm);
00315 
00316     <span class="comment">//Reset weights</span>
00317     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;globalCoarse.size(); i++) {
00318       globalCoarse[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
00319     }
00320 
00321     <span class="comment">// Now communicate the nodes ...</span>
00322 
00323     <span class="comment">//7. Determine locally which keys to send to which proc ...</span>
00324     <span class="comment">//Compute Dist on globalCoarse....</span>
00325 
00326     std::vector&lt;TreeNode&gt; vtkDist(npes);
00327 
00328     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> *sendMin = NULL;
00329     <span class="keywordflow">if</span> (!globalCoarse.empty()) {
00330       sendMin = (<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> *)&amp;(*(globalCoarse.begin()));
00331     } <span class="keywordflow">else</span> {
00332       sendMin = &amp;(rootNode);
00333     }
00334 
00335     par::Mpi_Allgather&lt;ot::TreeNode&gt;(sendMin, &amp;(* vtkDist.begin()), 1, comm);
00336 
00337     minsAllBlocks.clear();
00338     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; npes; j++) {
00339       <span class="keywordflow">if</span>(vtkDist[j] != rootNode) {
00340         minsAllBlocks.push_back(vtkDist[j]);
00341       }
00342     }<span class="comment">//end for j</span>
00343 
00344     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 1; j &lt; npes ; j++) {
00345       <span class="keywordflow">if</span> (vtkDist[j] == rootNode) {
00346         vtkDist[j] = vtkDist[j-1];
00347       }
00348     }<span class="comment">//end for j</span>
00349 
00350     <span class="comment">// correct dist ...</span>
00351     <span class="keywordflow">if</span> (npes&gt;1) {
00352       <span class="keywordflow">if</span> (vtkDist[npes-1] == vtkDist[npes-2]) {
00353         vtkDist[npes-1] = rootNode;
00354       }<span class="comment">//end if</span>
00355 
00356       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=npes-2; i&gt;0; i--) {
00357         <span class="keywordflow">if</span> (vtkDist[i] == vtkDist[i-1]) {
00358           vtkDist[i] = vtkDist[i+1];
00359         }<span class="comment">//end if</span>
00360       }<span class="comment">//end for</span>
00361     }<span class="comment">//end if npes &gt; 1</span>
00362 
00363     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *part = NULL;
00364     <span class="keywordflow">if</span>(!nodes.empty()) {
00365       part = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nodes.size()];
00366     }
00367 
00368     <span class="keywordflow">if</span> (npes &gt; 1) {
00369       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pCnt=0;
00370       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; nodes.size(); i++) {
00371         <span class="keywordflow">if</span> ( (nodes[i] &gt;= vtkDist[pCnt]) &amp;&amp; ( (pCnt == (npes-1)) 
00372               || ( nodes[i] &lt; vtkDist[pCnt+1] ) || (vtkDist[pCnt+1] == rootNode) ) ) {
00373           part[i] = pCnt;
00374         } <span class="keywordflow">else</span> {
00375           <span class="keywordflow">while</span> ( (pCnt &lt; (npes -1)) &amp;&amp; (nodes[i] &gt;= vtkDist[pCnt+1])
00376               &amp;&amp; (vtkDist[pCnt+1] != rootNode)  ) {
00377             pCnt++;
00378           }<span class="comment">//end while</span>
00379           part[i] = pCnt;
00380         }<span class="comment">//end if-else</span>
00381       }<span class="comment">//end for i</span>
00382     }<span class="comment">//end if np&gt;1</span>
00383 
00384     vtkDist.clear();
00385     <span class="comment">//_________________________________________________________________________</span>
00386     <span class="comment">// Now the partitions should be contiguous since the two lists are globally</span>
00387     <span class="comment">// sorted ... and it's simply a shift between the two.</span>
00388     <span class="comment">//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
00389 
00390     <span class="comment">//compute the total number of nodes being sent to each proc ...</span>
00391     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00392       sendCnt[i]=0;
00393       recvCnt[i]=0;
00394     }
00395 
00396     <span class="keywordflow">if</span> (npes &gt; 1) {
00397       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
00398         sendCnt[part[i]]++;
00399       }<span class="comment">//end for i</span>
00400     } <span class="keywordflow">else</span> {
00401       sendCnt[0] += (nodes.size());
00402     }<span class="comment">//end if-else</span>
00403 
00404     <span class="keywordflow">if</span>(part) {
00405       <span class="keyword">delete</span> [] part;
00406       part = NULL;
00407     }
00408 
00409     <span class="comment">// communicate with other procs how many you shall be sending and get how</span>
00410     <span class="comment">// many to recieve from whom.</span>
00411 
00412     par::Mpi_Alltoall&lt;int&gt;( sendCnt, recvCnt, 1, comm);
00413 
00414     totalRecv=0;
00415     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00416       totalRecv += recvCnt[i];
00417     }<span class="comment">//end for i</span>
00418 
00419     sendOffsets[0] = 0;
00420     recvOffsets[0] = 0;
00421 
00422     <span class="comment">// compute offsets ...</span>
00423     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;npes; i++) {
00424       sendOffsets[i] = sendOffsets[i-1] + sendCnt[i-1];
00425       recvOffsets[i] = recvOffsets[i-1] + recvCnt[i-1];
00426     }<span class="comment">//end for i</span>
00427 
00428     <span class="comment">// Allocate for new array ...</span>
00429     std::vector&lt;ot::TreeNode &gt; newNodes(totalRecv);
00430 
00431     <span class="comment">// perform All2Allv</span>
00432     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* nodesPtr = NULL;
00433     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* newNodesPtr = NULL;
00434     <span class="keywordflow">if</span>(!nodes.empty()) {
00435       nodesPtr = &amp;(*(nodes.begin()));
00436     }
00437     <span class="keywordflow">if</span>(!newNodes.empty()) {
00438       newNodesPtr = &amp;(*(newNodes.begin()));
00439     }
00440 
00441 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00442 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalSendSize = nodes.size();
00443     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalRecvSize = newNodes.size();
00444     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsSendF = 0;
00445     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsRecvF = 0;
00446     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00447       <span class="keywordflow">if</span>(sendCnt[i]) {
00448         numProcsSendF++;
00449       }
00450       <span class="keywordflow">if</span>(recvCnt[i]) {
00451         numProcsRecvF++;
00452       }
00453     }
00454 <span class="preprocessor">#endif</span>
00455 <span class="preprocessor"></span>
00456     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( nodesPtr, sendCnt, sendOffsets,      
00457         newNodesPtr, recvCnt, recvOffsets, comm);
00458 
00459     <span class="comment">// reset the pointer ...</span>
00460     nodes = newNodes;
00461     newNodes.clear();
00462 
00463     <span class="comment">// clean up ...</span>
00464     <span class="keyword">delete</span> [] sendCnt;
00465     sendCnt = NULL;
00466 
00467     <span class="keyword">delete</span> [] recvCnt;
00468     recvCnt = NULL;
00469 
00470     <span class="keyword">delete</span> [] sendOffsets;
00471     sendOffsets = NULL;
00472 
00473     <span class="keyword">delete</span> [] recvOffsets;
00474     recvOffsets = NULL;
00475 
00476 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00477 <span class="preprocessor"></span>    MPI_Barrier(comm);
00478     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalSendF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00479     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecvF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00480     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsSendF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00481     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsRecvF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes]; 
00482     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalSendSize, allTotalSendF, 1, 0, comm);
00483     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalRecvSize, allTotalRecvF, 1, 0, comm);
00484     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsSendF, allNumProcsSendF, 1, 0, comm);
00485     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsRecvF, allNumProcsRecvF, 1, 0, comm);
00486     <span class="keywordflow">if</span>(!rank) {
00487       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00488         std::cout&lt;&lt;<span class="stringliteral">" allTotalSendF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalSendF[i]&lt;&lt;std::endl;
00489         std::cout&lt;&lt;<span class="stringliteral">" allTotalRecvF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalRecvF[i]&lt;&lt;std::endl;
00490         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsSendF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsSendF[i]&lt;&lt;std::endl;
00491         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsRecvF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsRecvF[i]&lt;&lt;std::endl;
00492       }
00493     }
00494     <span class="keyword">delete</span> [] allTotalSendF;
00495     <span class="keyword">delete</span> [] allTotalRecvF;
00496     <span class="keyword">delete</span> [] allNumProcsSendF;
00497     <span class="keyword">delete</span> [] allNumProcsRecvF;
00498     MPI_Barrier(comm);
00499 <span class="preprocessor">#endif</span>
00500 <span class="preprocessor"></span>
00501     <a class="code" href="octUtils_8h.html#a60">PROF_BLKPART2_END</a>
00502   } <span class="comment">// end blockPart</span>
00503 
00504 
00505   <span class="comment">//Assumes that nodes are globally sorted, linear, complete, unique.</span>
00506   <span class="comment">//No processor must call this with an empty input.</span>
<a name="l00507"></a><a class="code" href="namespaceot.html#a28">00507</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a28">blockPartStage1</a>(std::vector&lt;TreeNode&gt; &amp;nodes, std::vector&lt;TreeNode&gt; &amp;blocks,
00508       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth,  MPI_Comm comm) {
00509 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00510 <span class="preprocessor"></span>    MPI_Barrier(comm);
00511 <span class="preprocessor">#endif</span>
00512 <span class="preprocessor"></span>    <a class="code" href="octUtils_8h.html#a20">PROF_BLKPART1_BEGIN</a>
00513       <span class="keywordtype">int</span> npes, rank;
00514     <span class="keyword">const</span> <span class="keywordtype">double</span> thFac = 0.5;
00515     MPI_Comm_rank(comm,&amp;rank);
00516     MPI_Comm_size(comm,&amp;npes);
00517 
00518     par::partitionW&lt;ot::TreeNode&gt;(nodes, NULL,comm);
00519 
00520     assert(nodes.size() &gt; (1 &lt;&lt; dim) ); 
00521 
00522 <span class="preprocessor">#ifdef __BLOCK_PART_EQUALS_MORTON_PART__</span>
00523 <span class="preprocessor"></span>
00524     blocks.clear();
00525 
00526     <span class="comment">//include both the min and max elements as well  </span>
00527     <span class="comment">//The output will be sorted, unique and linear</span>
00528     <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(nodes[0], nodes[nodes.size()-1], blocks, <span class="keyword">true</span>, <span class="keyword">true</span>);
00529 
00530 <span class="preprocessor">#else</span>
00531 <span class="preprocessor"></span>
00532     <span class="comment">// 1. First compute the localCoarse octree </span>
00533     std::vector&lt;TreeNode&gt; localCoarse;
00534     <span class="comment">//include both the min and max elements as well  </span>
00535     <span class="comment">//The output will be sorted, unique and linear</span>
00536     <a class="code" href="namespaceot.html#a38">appendCompleteRegion</a>(nodes[0], nodes[nodes.size()-1], localCoarse, <span class="keyword">true</span>, <span class="keyword">true</span>);
00537 
00538     <span class="comment">// 2. Get local Blocks. These will be input to completeOctree that will</span>
00539     <span class="comment">// produce globalCoarse.</span>
00540 
00541     std::vector&lt;TreeNode&gt; localBlocks;
00542 
00543     <span class="comment">//Logic: Use bPartComparator to assign priorities and pick the ones</span>
00544     <span class="comment">//with high priority. The number to be picked is determined by a percentage</span>
00545     <span class="comment">//of the total local wt.</span>
00546 
00547     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; localCoarse.size(); i++) {
00548       localCoarse[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(0);
00549     }
00550 
00551     <span class="comment">//decendants and chunks are both sorted at this point.</span>
00552     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextPt = 0;
00553     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextNode = 0;
00554     <span class="comment">//Every element in nodes is inside some element in localCoarse.</span>
00555     <span class="keywordflow">while</span> (nextPt &lt; nodes.size()) {
00556       <span class="comment">//The first pt. lies in some block.</span>
00557 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00558 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(localCoarse[nextNode], nodes[nextPt]));
00559 <span class="preprocessor">#endif</span>
00560 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ((localCoarse[nextNode].isAncestor(nodes[nextPt])) ||
00561           (localCoarse[nextNode] == nodes[nextPt])) {
00562         localCoarse[nextNode].<a class="code" href="classot_1_1TreeNode.html#z19_0">addWeight</a>(1);
00563         nextPt++;
00564       } <span class="keywordflow">else</span> {
00565         nextNode++;
00566         <span class="keywordflow">if</span> (nextNode == localCoarse.size()) {
00567           <span class="comment">//If this fails then either the lists are not sorted</span>
00568           <span class="comment">//or there is some node which is not inside any block </span>
00569           assert(<span class="keyword">false</span>);
00570         }
00571       }<span class="comment">//end if-else</span>
00572     }<span class="comment">//end while</span>
00573 
00574     <a class="code" href="Sort_8h.html#a7">sort</a>(localCoarse.begin(), localCoarse.end(), ot::bPartComparator);
00575 
00576     <span class="keywordtype">long</span> localWt = 0;
00577     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cnt = 0;
00578     <span class="keywordflow">while</span> ( ( cnt &lt; localCoarse.size() ) &amp;&amp;
00579         (localWt &lt;= ( (long)( thFac*( (double)(nodes.size()) ) ) ) ) ) {
00580       localBlocks.push_back(localCoarse[cnt]);
00581       localWt += (long)(localCoarse[cnt].getWeight());
00582       cnt++;
00583     }<span class="comment">//end while</span>
00584 
00585     localCoarse.clear();
00586 
00587     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; localBlocks.size(); i++) {
00588       localBlocks[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
00589     }
00590 
00591     <span class="comment">//Sorting is necessary here since bPartcomparator is different from &lt;.</span>
00592     <a class="code" href="Sort_8h.html#a7">sort</a>(localBlocks.begin(), localBlocks.end());
00593 
00594     <span class="comment">// 3. Call nodes2Oct on these cells to generate the </span>
00595     <span class="comment">//    globalCoarse octree ...</span>
00596     <span class="comment">//localBlocks will be sorted, linear and unique at this point </span>
00597     <span class="comment">//localBlocks will not be empty on any processor</span>
00598 
00599     <a class="code" href="namespaceot.html#a33">completeOctree</a>(localBlocks, blocks, dim, maxDepth, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, comm);
00600 
00601     localBlocks.clear();
00602 
00603 <span class="preprocessor">#endif</span>
00604 <span class="preprocessor"></span>
00605     <a class="code" href="octUtils_8h.html#a59">PROF_BLKPART1_END</a>
00606   } <span class="comment">// end blockPart</span>
00607 
<a name="l00608"></a><a class="code" href="namespaceot.html#a29">00608</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a29">blockPartStage2</a>(std::vector&lt;TreeNode&gt; &amp;nodes, std::vector&lt;TreeNode&gt; &amp;globalCoarse,
00609       std::vector&lt;ot::TreeNode&gt;&amp; minsAllBlocks, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth,
00610       MPI_Comm comm) {
00611 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00612 <span class="preprocessor"></span>    MPI_Barrier(comm);
00613 <span class="preprocessor">#endif</span>
00614 <span class="preprocessor"></span>    <a class="code" href="octUtils_8h.html#a21">PROF_BLKPART2_BEGIN</a>
00615 
00616       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> rootNode (dim,maxDepth);
00617 
00618     <span class="keywordtype">int</span> npes, rank;
00619     MPI_Comm_rank(comm,&amp;rank);
00620     MPI_Comm_size(comm,&amp;npes);
00621 
00622 <span class="preprocessor">#ifdef __BLOCK_PART_EQUALS_MORTON_PART__</span>
00623 <span class="preprocessor"></span>    <span class="comment">//Just set minsAllBlocks. nodes and globalCoarse are already aligned.</span>
00624     <span class="comment">//We will not do weighted partitioning here.</span>
00625 
00626     std::vector&lt;TreeNode&gt; vtkDist(npes);
00627 
00628     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> *sendMin = NULL;
00629     <span class="keywordflow">if</span> (!globalCoarse.empty()) {
00630       sendMin = (<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> *)&amp;(*(globalCoarse.begin()));
00631     } <span class="keywordflow">else</span> {
00632       sendMin = &amp;(rootNode);
00633     }
00634 
00635     par::Mpi_Allgather&lt;ot::TreeNode&gt;(sendMin, &amp;(* vtkDist.begin()), 1, comm);
00636 
00637     minsAllBlocks.clear();
00638     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; npes; j++) {
00639       <span class="keywordflow">if</span>(vtkDist[j] != rootNode) {
00640         minsAllBlocks.push_back(vtkDist[j]);
00641       }
00642     }<span class="comment">//end for j</span>
00643 
00644 <span class="preprocessor">#else</span>
00645 <span class="preprocessor"></span>
00646     <span class="keywordtype">int</span> *sendCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00647     <span class="keywordtype">int</span> *recvCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00648     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00649     <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00650 
00651     <span class="comment">//1. Now compute the wts of these cells ...</span>
00652     <span class="comment">//    a. Get the min and max nodes at each processor.</span>
00653     std::vector&lt;TreeNode&gt; _mins_maxs(2*npes);
00654 
00655     <span class="comment">// communicate ...</span>
00656     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> sendMinMax[2];
00657 
00658     <span class="keywordflow">if</span> (!nodes.empty()) {
00659       sendMinMax[0] =  nodes[0];
00660       sendMinMax[1] =  nodes[nodes.size()-1];
00661     } <span class="keywordflow">else</span> {
00662       sendMinMax[0] = rootNode;
00663       sendMinMax[1] = rootNode;
00664     }
00665 
00666     par::Mpi_Allgather&lt;ot::TreeNode&gt;(sendMinMax, &amp;(*_mins_maxs.begin()), 2, comm);
00667 
00668     std::vector&lt;std::vector&lt;TreeNode&gt; &gt; sendNodes(npes);
00669     std::vector&lt;std::vector&lt;unsigned int&gt; &gt; keymap(npes);
00670 
00671     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00672       sendCnt[i] = 0;
00673     }
00674 
00675     <span class="comment">//    b. Now compute which cells go to which cells ...</span>
00676     <span class="comment">//       logic is that if the coarse cell is between the min and max at a</span>
00677     <span class="comment">//       processor or if it is an ancestor of min, then it is sent to that</span>
00678     <span class="comment">//       processor.</span>
00679     <span class="comment">//Naive Logic:</span>
00680     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;globalCoarse.size(); i++) {
00681       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> p=0;p&lt;npes;p++) {
00682 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00683 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(globalCoarse[i], _mins_maxs[2*p]));
00684 <span class="preprocessor">#endif</span>
00685 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ( (globalCoarse[i].isAncestor(_mins_maxs[2*p])) ||
00686             ( (globalCoarse[i] &gt;= _mins_maxs[2*p]) &amp;&amp; (globalCoarse[i] &lt;=_mins_maxs[(2*p)+1]) ) ) {
00687           sendNodes[p].push_back(globalCoarse[i]);
00688           <span class="comment">// save keymap so that we can assign weights back to globalCoarse.</span>
00689           keymap[p].push_back(i);    
00690           sendCnt[p]++;
00691         }<span class="comment">//end if</span>
00692       }<span class="comment">//end for</span>
00693     }<span class="comment">//end for</span>
00694 
00695     _mins_maxs.clear();
00696 
00697     <span class="comment">//2. Send nodes to all cells to compute the wts ... locally ...</span>
00698 
00699     <span class="comment">//    a. Communicate how many you'll be sending and how many will be</span>
00700     <span class="comment">//       received.</span>
00701 
00702     <span class="comment">// Now do an All2All to get numKeysRecv</span>
00703     par::Mpi_Alltoall&lt;int&gt;( sendCnt, recvCnt, 1, comm);
00704 
00705     <span class="comment">//    b. Concatenate all nodes into one single Carray ...</span>
00706     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalSend = 0;
00707     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalRecv = 0;
00708 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00709 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsSendI = 0;
00710     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsRecvI = 0;
00711 <span class="preprocessor">#endif</span>
00712 <span class="preprocessor"></span>    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00713       totalSend+= sendCnt[i];
00714       totalRecv+= recvCnt[i];
00715 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00716 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(sendCnt[i]) {
00717         numProcsSendI++;
00718       }
00719       <span class="keywordflow">if</span>(recvCnt[i]) {
00720         numProcsRecvI++;
00721       }
00722 <span class="preprocessor">#endif</span>
00723 <span class="preprocessor"></span>    }
00724 
00725     <span class="comment">// create the send and recv buffers ...</span>
00726     std::vector&lt;ot::TreeNode&gt; sendK (totalSend);
00727     std::vector&lt;ot::TreeNode&gt; recvK (totalRecv);
00728 
00729     <span class="comment">// Now create sendK</span>
00730     sendOffsets[0] = 0;
00731     recvOffsets[0] = 0;
00732 
00733     <span class="comment">// compute offsets ...</span>
00734     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;npes; i++) {
00735       sendOffsets[i] = sendOffsets[i-1] + sendCnt[i-1];
00736       recvOffsets[i] = recvOffsets[i-1] + recvCnt[i-1];
00737     }
00738 
00739     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00740       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;sendCnt[i]; j++) {
00741         sendK[sendOffsets[i] + j] = sendNodes[i][j];
00742       }<span class="comment">//end for j</span>
00743     }<span class="comment">//end for i</span>
00744 
00745     <span class="comment">//3. send and receive all keys ...</span>
00746 
00747     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKptr = NULL;
00748     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKptr = NULL;
00749     <span class="keywordflow">if</span>(!sendK.empty()) {
00750       sendKptr = &amp;(*(sendK.begin()));
00751     }
00752     <span class="keywordflow">if</span>(!recvK.empty()) {
00753       recvKptr = &amp;(*(recvK.begin()));
00754     }
00755 
00756     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;(sendKptr, sendCnt, sendOffsets,      
00757         recvKptr, recvCnt, recvOffsets, comm);
00758 
00759     sendK.clear();
00760 
00761 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00762 <span class="preprocessor"></span>    MPI_Barrier(comm);
00763     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalSendI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00764     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecvI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00765     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsSendI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00766     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsRecvI = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes]; 
00767     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalSend, allTotalSendI, 1, 0, comm);
00768     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalRecv, allTotalRecvI, 1, 0, comm);
00769     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsSendI, allNumProcsSendI, 1, 0, comm);
00770     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsRecvI, allNumProcsRecvI, 1, 0, comm);
00771     <span class="keywordflow">if</span>(!rank) {
00772       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00773         std::cout&lt;&lt;<span class="stringliteral">" allTotalSendI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalSendI[i]&lt;&lt;std::endl;
00774         std::cout&lt;&lt;<span class="stringliteral">" allTotalRecvI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalRecvI[i]&lt;&lt;std::endl;
00775         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsSendI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsSendI[i]&lt;&lt;std::endl;
00776         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsRecvI["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsRecvI[i]&lt;&lt;std::endl;
00777       }
00778     }
00779     <span class="keyword">delete</span> [] allTotalSendI;
00780     <span class="keyword">delete</span> [] allTotalRecvI;
00781     <span class="keyword">delete</span> [] allNumProcsSendI;
00782     <span class="keyword">delete</span> [] allNumProcsRecvI;
00783     MPI_Barrier(comm);
00784 <span class="preprocessor">#endif</span>
00785 <span class="preprocessor"></span>
00786     <span class="comment">//4. Now compute the wts of the locally received nodes ...</span>
00787     <span class="comment">//    a. loop through nodes and update the wts of the local chunks ...</span>
00788     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *wts = NULL;
00789     <span class="keywordflow">if</span>(totalRecv) {
00790       wts = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> [totalRecv];
00791     }
00792     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;totalRecv; i++) {
00793       wts[i] = 0;
00794     }
00795 
00796     <span class="comment">//decendants and chunks are both sorted at this point.</span>
00797     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextPt = 0;
00798     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextNode = 0;
00799     <span class="comment">//Every element in nodes is inside some element in recvK.</span>
00800     <span class="keywordflow">while</span> (nextPt &lt; nodes.size()) {
00801       <span class="comment">//The first pt. lies in some block.</span>
00802 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00803 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(recvK[nextNode], nodes[nextPt]));
00804 <span class="preprocessor">#endif</span>
00805 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ((recvK[nextNode].isAncestor(nodes[nextPt])) ||
00806           (recvK[nextNode] == nodes[nextPt])) {
00807         wts[nextNode]++;
00808         nextPt++;
00809       } <span class="keywordflow">else</span> {
00810         nextNode++;
00811         <span class="keywordflow">if</span> (nextNode == totalRecv) {
00812           <span class="comment">//If this fails then either recvK and nodes are not sorted or</span>
00813           <span class="comment">//Some pt in nodes is not in any of recvK</span>
00814           assert(<span class="keyword">false</span>);
00815         }
00816       }<span class="comment">//end if-else</span>
00817     }<span class="comment">//end while</span>
00818 
00819     recvK.clear();
00820 
00821     <span class="comment">//5. Now communicate the wts back to the procs ...</span>
00822     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *recvWts = NULL;
00823     <span class="keywordflow">if</span>(totalSend) {
00824       recvWts = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[totalSend];
00825     }
00826 
00827     par::Mpi_Alltoallv_sparse&lt;unsigned int&gt;( wts, recvCnt, recvOffsets, 
00828         recvWts, sendCnt, sendOffsets, comm);
00829 
00830     <span class="comment">//6. Now map them back to the blocks ...</span>
00831     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;globalCoarse.size();i++) {
00832       globalCoarse[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(0);
00833     }
00834 
00835     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00836       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;sendCnt[i]; j++) {
00837         globalCoarse[keymap[i][j]].<a class="code" href="classot_1_1TreeNode.html#z19_0">addWeight</a>(recvWts[sendOffsets[i] + j]);
00838       }
00839     }
00840 
00841     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00842       keymap[i].clear();
00843       sendNodes[i].clear();
00844     }
00845     sendNodes.clear();
00846     keymap.clear();
00847 
00848     <span class="keywordflow">if</span>(recvWts) {
00849       <span class="keyword">delete</span> [] recvWts;
00850       recvWts = NULL;
00851     }
00852 
00853     <span class="keywordflow">if</span>(wts) {
00854       <span class="keyword">delete</span> [] wts;
00855       wts = NULL;
00856     }
00857 
00858     par::partitionW&lt;ot::TreeNode&gt;(globalCoarse,getNodeWeight,comm);
00859 
00860     <span class="comment">//Reset weights</span>
00861     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;globalCoarse.size(); i++) {
00862       globalCoarse[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
00863     }
00864 
00865     <span class="comment">// Now communicate the nodes ...</span>
00866 
00867     <span class="comment">//7. Determine locally which keys to send to which proc ...</span>
00868     <span class="comment">//Compute Dist on globalCoarse....</span>
00869 
00870     std::vector&lt;TreeNode&gt; vtkDist(npes);
00871 
00872     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> *sendMin = NULL;
00873     <span class="keywordflow">if</span> (!globalCoarse.empty()) {
00874       sendMin = (<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> *)&amp;(*(globalCoarse.begin()));
00875     } <span class="keywordflow">else</span> {
00876       sendMin = &amp;(rootNode);
00877     }
00878 
00879     par::Mpi_Allgather&lt;ot::TreeNode&gt;(sendMin, &amp;(* vtkDist.begin()), 1, comm);
00880 
00881     minsAllBlocks.clear();
00882     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; npes; j++) {
00883       <span class="keywordflow">if</span>(vtkDist[j] != rootNode) {
00884         minsAllBlocks.push_back(vtkDist[j]);
00885       }
00886     }<span class="comment">//end for j</span>
00887 
00888     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 1; j &lt; npes ; j++) {
00889       <span class="keywordflow">if</span> (vtkDist[j] == rootNode) {
00890         vtkDist[j] = vtkDist[j-1];
00891       }
00892     }<span class="comment">//end for j</span>
00893 
00894     <span class="comment">// correct dist ...</span>
00895     <span class="keywordflow">if</span> (npes&gt;1) {
00896       <span class="keywordflow">if</span> (vtkDist[npes-1] == vtkDist[npes-2]) {
00897         vtkDist[npes-1] = rootNode;
00898       }<span class="comment">//end if</span>
00899 
00900       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=npes-2; i&gt;0; i--) {
00901         <span class="keywordflow">if</span> (vtkDist[i] == vtkDist[i-1]) {
00902           vtkDist[i] = vtkDist[i+1];
00903         }<span class="comment">//end if</span>
00904       }<span class="comment">//end for</span>
00905     }<span class="comment">//end if npes &gt; 1</span>
00906 
00907     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *part = NULL;
00908     <span class="keywordflow">if</span>(!nodes.empty()) {
00909       part = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[nodes.size()];
00910     }
00911 
00912     <span class="keywordflow">if</span> (npes &gt; 1) {
00913       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pCnt=0;
00914       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; nodes.size(); i++) {
00915         <span class="keywordflow">if</span> ( (nodes[i] &gt;= vtkDist[pCnt]) &amp;&amp; ( (pCnt == (npes-1)) 
00916               || ( nodes[i] &lt; vtkDist[pCnt+1] ) || (vtkDist[pCnt+1] == rootNode) ) ) {
00917           part[i] = pCnt;
00918         } <span class="keywordflow">else</span> {
00919           <span class="keywordflow">while</span> ( (pCnt &lt; (npes -1)) &amp;&amp; (nodes[i] &gt;= vtkDist[pCnt+1])
00920               &amp;&amp; (vtkDist[pCnt+1] != rootNode)  ) {
00921             pCnt++;
00922           }<span class="comment">//end while</span>
00923           part[i] = pCnt;
00924         }<span class="comment">//end if-else</span>
00925       }<span class="comment">//end for i</span>
00926     }<span class="comment">//end if np&gt;1</span>
00927 
00928     vtkDist.clear();
00929     <span class="comment">//_________________________________________________________________________</span>
00930     <span class="comment">// Now the partitions should be contiguous since the two lists are globally</span>
00931     <span class="comment">// sorted ... and it's simply a shift between the two.</span>
00932     <span class="comment">//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
00933 
00934     <span class="comment">//compute the total number of nodes being sent to each proc ...</span>
00935     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00936       sendCnt[i]=0;
00937       recvCnt[i]=0;
00938     }
00939 
00940     <span class="keywordflow">if</span> (npes &gt; 1) {
00941       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
00942         sendCnt[part[i]]++;
00943       }<span class="comment">//end for i</span>
00944     } <span class="keywordflow">else</span> {
00945       sendCnt[0] += (nodes.size());
00946     }<span class="comment">//end if-else</span>
00947 
00948     <span class="keywordflow">if</span>(part) {
00949       <span class="keyword">delete</span> [] part;
00950       part = NULL;
00951     }
00952 
00953     <span class="comment">// communicate with other procs how many you shall be sending and get how</span>
00954     <span class="comment">// many to recieve from whom.</span>
00955 
00956     par::Mpi_Alltoall&lt;int&gt;( sendCnt, recvCnt, 1, comm);
00957 
00958     totalRecv=0;
00959     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00960       totalRecv += recvCnt[i];
00961     }<span class="comment">//end for i</span>
00962 
00963     sendOffsets[0] = 0;
00964     recvOffsets[0] = 0;
00965 
00966     <span class="comment">// compute offsets ...</span>
00967     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;npes; i++) {
00968       sendOffsets[i] = sendOffsets[i-1] + sendCnt[i-1];
00969       recvOffsets[i] = recvOffsets[i-1] + recvCnt[i-1];
00970     }<span class="comment">//end for i</span>
00971 
00972     <span class="comment">// Allocate for new array ...</span>
00973     std::vector&lt;ot::TreeNode &gt; newNodes(totalRecv);
00974 
00975     <span class="comment">// perform All2Allv</span>
00976     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* nodesPtr = NULL;
00977     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* newNodesPtr = NULL;
00978     <span class="keywordflow">if</span>(!nodes.empty()) {
00979       nodesPtr = &amp;(*(nodes.begin()));
00980     }
00981     <span class="keywordflow">if</span>(!newNodes.empty()) {
00982       newNodesPtr = &amp;(*(newNodes.begin()));
00983     }
00984 
00985 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
00986 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalSendSize = nodes.size();
00987     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalRecvSize = newNodes.size();
00988     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsSendF = 0;
00989     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsRecvF = 0;
00990     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00991       <span class="keywordflow">if</span>(sendCnt[i]) {
00992         numProcsSendF++;
00993       }
00994       <span class="keywordflow">if</span>(recvCnt[i]) {
00995         numProcsRecvF++;
00996       }
00997     }
00998 <span class="preprocessor">#endif</span>
00999 <span class="preprocessor"></span>
01000     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( nodesPtr, sendCnt, sendOffsets,      
01001         newNodesPtr, recvCnt, recvOffsets, comm);
01002 
01003     <span class="comment">// reset the pointer ...</span>
01004     nodes = newNodes;
01005     newNodes.clear();
01006 
01007     <span class="comment">// clean up ...</span>
01008     <span class="keyword">delete</span> [] sendCnt;
01009     sendCnt = NULL;
01010 
01011     <span class="keyword">delete</span> [] recvCnt;
01012     recvCnt = NULL;
01013 
01014     <span class="keyword">delete</span> [] sendOffsets;
01015     sendOffsets = NULL;
01016 
01017     <span class="keyword">delete</span> [] recvOffsets;
01018     recvOffsets = NULL;
01019 
01020 <span class="preprocessor">#ifdef __MEASURE_BPART_COMM__</span>
01021 <span class="preprocessor"></span>    MPI_Barrier(comm);
01022     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalSendF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
01023     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecvF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
01024     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsSendF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
01025     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsRecvF = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes]; 
01026     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalSendSize, allTotalSendF, 1, 0, comm);
01027     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalRecvSize, allTotalRecvF, 1, 0, comm);
01028     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsSendF, allNumProcsSendF, 1, 0, comm);
01029     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsRecvF, allNumProcsRecvF, 1, 0, comm);
01030     <span class="keywordflow">if</span>(!rank) {
01031       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01032         std::cout&lt;&lt;<span class="stringliteral">" allTotalSendF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalSendF[i]&lt;&lt;std::endl;
01033         std::cout&lt;&lt;<span class="stringliteral">" allTotalRecvF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allTotalRecvF[i]&lt;&lt;std::endl;
01034         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsSendF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsSendF[i]&lt;&lt;std::endl;
01035         std::cout&lt;&lt;<span class="stringliteral">" allNumProcsRecvF["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in Bpart: "</span>&lt;&lt;allNumProcsRecvF[i]&lt;&lt;std::endl;
01036       }
01037     }
01038     <span class="keyword">delete</span> [] allTotalSendF;
01039     <span class="keyword">delete</span> [] allTotalRecvF;
01040     <span class="keyword">delete</span> [] allNumProcsSendF;
01041     <span class="keyword">delete</span> [] allNumProcsRecvF;
01042     MPI_Barrier(comm);
01043 <span class="preprocessor">#endif</span>
01044 <span class="preprocessor"></span>
01045 <span class="preprocessor">#endif</span>
01046 <span class="preprocessor"></span>
01047     <a class="code" href="octUtils_8h.html#a60">PROF_BLKPART2_END</a>
01048   } <span class="comment">// end blockPart</span>
01049 
01050 }<span class="comment">//end namespace</span>
01051 
01052 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:31 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
