<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oda/private/odaFactory.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000016.html">oda</a>&nbsp;/&nbsp;<a class="el" href="dir_000017.html">private</a></div>
<h1>odaFactory.C</h1><a href="odaFactory_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00008 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="colors_8h.html">colors.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="testUtils_8h.html">testUtils.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="dendro_8h.html">dendro.h</a>"</span>
00012 
00013 <span class="preprocessor">#ifdef __DEBUG__</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA__</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA__</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span>
00019 <span class="preprocessor">#ifdef __DEBUG_DA__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA_PUBLIC__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA_PUBLIC__</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span>
00025 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#ifndef __MEASURE_DA__</span>
00027 <span class="preprocessor"></span><span class="preprocessor">#define __MEASURE_DA__</span>
00028 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00030 <span class="preprocessor"></span>
00031 <span class="keyword">namespace </span>ot {
00032 
<a name="l00033"></a><a class="code" href="odaFactory_8C.html#a0">00033</a> <span class="preprocessor">#define RESET_DA_BLOCK {\</span>
00034 <span class="preprocessor">  </span><span class="comment">/*Initialize Member Data*/</span>\
00035   m_ucpOctLevels = NULL;\
00036   m_bComputedLocalToGlobal = false;\
00037   m_bComputedLocalToGlobalElems = false;\
00038   m_tnBlocks.clear();\
00039   m_tnMinAllBlocks.clear();\
00040   m_uiNlist.clear();\
00041   m_uiNlistPtr = NULL;\
00042   m_dilpLocalToGlobal = NULL;\
00043   m_dilpLocalToGlobalElems = NULL;\
00044   m_ucpLutRemainders.clear();\
00045   m_ucpLutRemaindersPtr = NULL;\
00046   m_ucpSortOrders.clear();\
00047   m_ucpSortOrdersPtr = NULL;\
00048   m_uspLutQuotients.clear();\
00049   m_uspLutQuotientsPtr = NULL;\
00050   m_ucpLutMasks.clear();\
00051   m_ucpLutMasksPtr = NULL;\
00052   m_ucpPreGhostConnectivity.clear();\
00053   m_ucpPreGhostConnectivityPtr = NULL;\
00054   m_ptsPreGhostOffsets.clear();\
00055   m_ptsPreGhostOffsetsPtr = NULL;\
00056   PreGhostAnchors.clear();\
00057   m_uiQuotientCounter = 0;\
00058   m_uiPreGhostQuotientCnt = 0;\
00059   m_uiElementQuotient = 0;\
00060   m_uiIndependentElementQuotient = 0;\
00061   m_uiNodeSize = 0;\
00062   m_uiBoundaryNodeSize = 0;\
00063   m_uiElementSize = 0;\
00064   m_uiIndependentElementSize = 0;\
00065   m_uiPreGhostElementSize = 0;\
00066   m_uiPreGhostNodeSize = 0;\
00067   m_uiPreGhostBoundaryNodeSize = 0;\
00068   m_uiPostGhostNodeSize = 0;\
00069   m_uiLocalBufferSize = 0;\
00070   m_uiElementBegin = 0;\
00071   m_uiElementEnd = 0;\
00072   m_uiPostGhostBegin = 0;\
00073   m_uiIndependentElementBegin = 0;\
00074   m_uiIndependentElementEnd = 0;\
00075   m_uiCurrent = 0;\
00076   m_uiDimension = 0;\
00077   m_uiMaxDepth = 0;\
00078   m_uipScatterMap.clear();\
00079   m_uipSendProcs.clear();\
00080   m_uipSendOffsets.clear();\
00081   m_uipSendCounts.clear();\
00082   m_uipElemScatterMap.clear();\
00083   m_uipElemSendProcs.clear();\
00084   m_uipElemSendOffsets.clear();\
00085   m_uipElemSendCounts.clear();\
00086   m_uipRecvProcs.clear();\
00087   m_uipRecvOffsets.clear();\
00088   m_uipRecvCounts.clear();\
00089   m_uipElemRecvProcs.clear();\
00090   m_uipElemRecvOffsets.clear();\
00091   m_uipElemRecvCounts.clear();\
00092   m_mpiContexts.clear();\
00093   m_bCompressLut = compressLut;\
00094   m_uiCommTag = 1;\
00095   m_mpiCommAll = comm;\
00096   MPI_Comm_size(m_mpiCommAll,&amp;m_iNpesAll);\
00097   MPI_Comm_rank(m_mpiCommAll,&amp;m_iRankAll);\
00098 }
00099 
<a name="l00100"></a><a class="code" href="classot_1_1DA.html#b1">00100</a> <span class="keywordtype">void</span> DA::DA_FactoryPart0(std::vector&lt;ot::TreeNode&gt;&amp; in, MPI_Comm comm,
00101     MPI_Comm activeInputComm, <span class="keywordtype">bool</span> compressLut, <span class="keywordtype">bool</span>* iAmActive) {
00102   <a class="code" href="odaFactory_8C.html#a0">RESET_DA_BLOCK</a>
00103     <a class="code" href="classot_1_1DA.html#p43">m_uiInputSize</a> = static_cast&lt;unsigned int&gt;(in.size());
00104 
00105   <span class="comment">//The default is NULL. </span>
00106   <span class="keywordflow">if</span>(iAmActive != NULL) {
00107     (*iAmActive) = (!(in.empty())); 
00108     <a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a> = (*iAmActive);    
00109   }<span class="keywordflow">else</span> {
00110     <span class="comment">//Don't care for active state.</span>
00111     <a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a> = (!(in.empty()));
00112   }
00113 
00114 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00115 <span class="preprocessor"></span>  MPI_Comm expectedActiveInputComm;
00116   <span class="keywordtype">int</span> commCompareResult;
00117   <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(<a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a>, &amp;expectedActiveInputComm, comm);
00118   <span class="keywordflow">if</span>(m_bIamActive) {
00119     MPI_Comm_compare(activeInputComm, expectedActiveInputComm, &amp;commCompareResult);
00120     assert( (commCompareResult == MPI_CONGRUENT) || (commCompareResult == MPI_IDENT) );
00121   }
00122 <span class="preprocessor">#endif</span>
00123 <span class="preprocessor"></span>
00124   <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a> = activeInputComm;
00125 
00126   <span class="keywordflow">if</span>(m_bIamActive) {
00127     MPI_Comm_size(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>, &amp;<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>);
00128     MPI_Comm_rank(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>, &amp;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
00129   } <span class="keywordflow">else</span> {
00130     <a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a> = 0;
00131     <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> = 0;
00132   }
00133 
00134   <span class="keywordflow">if</span>(!m_bIamActive) {
00135     <span class="keywordflow">return</span>;
00136   } <span class="keywordflow">else</span> {
00137     assert(!in.empty());
00138     <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a> = in[0].getDim();
00139     <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>  = in[0].getMaxDepth();
00140   }
00141 }<span class="comment">//end function</span>
00142 
<a name="l00143"></a><a class="code" href="classot_1_1DA.html#b2">00143</a> <span class="keywordtype">void</span> DA::DA_FactoryPart1(std::vector&lt;ot::TreeNode&gt;&amp; in) {
00144 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00145 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00146 <span class="preprocessor">#endif</span>
00147 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a25">PROF_BUILD_DA_STAGE1_BEGIN</a>
00148 
00149     assert(!in.empty());
00150 
00151   <span class="comment">// first generate the boundary nodes ...</span>
00152   std::vector&lt;ot::TreeNode&gt; positiveBoundaryOctants;
00153   <span class="comment">//Assumption: in is globally sorted to begin with. </span>
00154   <span class="comment">//Guarantee: in remains globally sorted in the end.</span>
00155   <span class="comment">//positiveBoundaryOctants need not be globally sorted, in fact I don't think</span>
00156   <span class="comment">//it will be sorted even on 1 processor.</span>
00157   <a class="code" href="namespaceot.html#a61">addBoundaryNodesType1</a>(in, positiveBoundaryOctants, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00158 
00159   <span class="comment">// Update the maxDepth ...</span>
00160   <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> = <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> + 1;
00161 
00162   <span class="comment">//Most processors will not add any positive boundaries. So, there is no need</span>
00163   <span class="comment">//to unnecessarily distribute positive boundaries on all procs just for</span>
00164   <span class="comment">//sorting. So only the few processors touching the positive boundary will</span>
00165   <span class="comment">//participate in the parallel sort</span>
00166   MPI_Comm bdyComm;
00167   <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>((positiveBoundaryOctants.empty()), &amp;bdyComm, m_mpiCommActive);
00168 
00169   <span class="keywordflow">if</span>(!(positiveBoundaryOctants.empty())) {
00170     <span class="comment">//Call Sample Sort  </span>
00171     std::vector&lt;ot::TreeNode &gt; tmpVecTN;
00172     par::sampleSort&lt;ot::TreeNode&gt;(positiveBoundaryOctants, tmpVecTN, bdyComm);
00173     positiveBoundaryOctants = tmpVecTN;
00174     tmpVecTN.clear();
00175   }
00176 
00177   par::concatenate&lt;ot::TreeNode&gt;(in, positiveBoundaryOctants, m_mpiCommActive);
00178   positiveBoundaryOctants.clear();
00179 
00180   <a class="code" href="oda_8h.html#a26">PROF_BUILD_DA_STAGE1_END</a>
00181 }<span class="comment">//end function</span>
00182 
<a name="l00183"></a><a class="code" href="classot_1_1DA.html#b3">00183</a> <span class="keywordtype">void</span> DA::DA_FactoryPart2(std::vector&lt;ot::TreeNode&gt;&amp; in) {
00184 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00185 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00186 <span class="preprocessor">#endif</span>
00187 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a27">PROF_BUILD_DA_STAGE2_BEGIN</a>
00188 
00189     assert(!in.empty());
00190   <span class="comment">//Marks regular nodes. MUST be called before DA_blockPartStage2</span>
00191   <span class="comment">//Assumption: in is globally sorted at this point, including positive</span>
00192   <span class="comment">//boundaries </span>
00193 
00194   <a class="code" href="namespaceot.html#a64">flagNodesType3</a>(in, <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00195 
00196   <a class="code" href="oda_8h.html#a28">PROF_BUILD_DA_STAGE2_END</a>
00197 }<span class="comment">//end function</span>
00198 
<a name="l00199"></a><a class="code" href="classot_1_1DA.html#b4">00199</a> <span class="keywordtype">void</span> DA::DA_FactoryPart3(std::vector&lt;ot::TreeNode&gt;&amp; in, MPI_Comm comm, <span class="keywordtype">bool</span> compressLut,
00200     <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;* blocksPtr, <span class="keywordtype">bool</span>* iAmActive) {
00201 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00202 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00203 <span class="preprocessor">#endif</span>
00204 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a29">PROF_BUILD_DA_STAGE3_BEGIN</a>
00205 
00206     assert(!in.empty());
00207   <span class="comment">//  1. First repartition  </span>
00208 
00209   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> localSizeBefore = in.size();
00210   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> globalSizeBefore; 
00211   par::Mpi_Allreduce&lt;DendroIntL&gt;(&amp;localSizeBefore, &amp;globalSizeBefore, 1, MPI_SUM, m_mpiCommActive);
00212 
00213   <span class="comment">//Partition in and create blocks (blocks must be globally sorted).</span>
00214   std::vector&lt;ot::TreeNode&gt; blocks;
00215   <span class="keywordflow">if</span>(blocksPtr == NULL) {
00216 
00217     <span class="comment">//min grain size = 1000</span>
00218     <span class="keyword">const</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a> THOUSAND = 1000;
00219     <span class="keywordflow">if</span> (globalSizeBefore &lt; (THOUSAND*m_iNpesActive)) {
00220       <span class="keywordtype">int</span> splittingSize = (globalSizeBefore/THOUSAND); 
00221       <span class="keywordflow">if</span>(splittingSize == 0) {
00222         splittingSize = 1; 
00223       }
00224 
00225       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> avgLoad = (globalSizeBefore / splittingSize);
00226       <span class="keywordtype">int</span> leftOvers = (globalSizeBefore % splittingSize);
00227 
00228       std::vector&lt;TreeNode&gt; tmpIn;
00229       <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &gt;= splittingSize) {
00230         par::scatterValues&lt;ot::TreeNode&gt;(in, tmpIn, 0, m_mpiCommActive);
00231       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt; leftOvers) {
00232         par::scatterValues&lt;ot::TreeNode&gt;(in, tmpIn, (avgLoad+1), m_mpiCommActive);
00233       }<span class="keywordflow">else</span> {
00234         par::scatterValues&lt;ot::TreeNode&gt;(in, tmpIn, avgLoad, m_mpiCommActive);
00235       }
00236       in = tmpIn;
00237       tmpIn.clear();
00238 
00239       MPI_Comm newComm;
00240       <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(splittingSize, &amp;newComm, <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00241       <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a> = newComm;
00242       MPI_Comm_size(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>,&amp;<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>);
00243       MPI_Comm_rank(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>,&amp;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
00244 
00245 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
00246 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(!m_iRankActive) {
00247         std::cout&lt;&lt;<span class="stringliteral">" input to DA constructor is small("</span>&lt;&lt;globalSizeBefore
00248           &lt;&lt;<span class="stringliteral">") npes = "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>&lt;&lt;<span class="stringliteral">" splitting comm."</span>&lt;&lt;std::endl;
00249       }
00250 <span class="preprocessor">#endif</span>
00251 <span class="preprocessor"></span>
00252       <a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a> = (!in.empty());   
00253       <span class="keywordflow">if</span>(iAmActive != NULL) {   
00254         <span class="comment">//Want the active state returned</span>
00255         (*iAmActive) = m_bIamActive;
00256       }
00257       <span class="keywordflow">if</span>(!m_bIamActive) {
00258         <a class="code" href="odaFactory_8C.html#a0">RESET_DA_BLOCK</a>
00259           <a class="code" href="oda_8h.html#a30">PROF_BUILD_DA_STAGE3_END</a>
00260           <span class="keywordflow">return</span>;
00261       }
00262     }<span class="comment">//end check if total size is too small</span>
00263 
00264     <a class="code" href="odaUtils_8h.html#a0">PROF_DA_BPART1_BEGIN</a>
00265 
00266       <a class="code" href="namespaceot.html#a28">ot::blockPartStage1</a>(in, blocks, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);    
00267 
00268     <a class="code" href="odaUtils_8h.html#a1">PROF_DA_BPART1_END</a>
00269 
00270       <a class="code" href="odaUtils_8h.html#a2">PROF_DA_BPART2_BEGIN</a>
00271 
00272       <a class="code" href="namespaceot.html#a74">DA_blockPartStage2</a>(in, blocks, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00273 
00274     <a class="code" href="odaUtils_8h.html#a3">PROF_DA_BPART2_END</a>
00275   } <span class="keywordflow">else</span> {
00276     blocks = *blocksPtr;
00277   }
00278 
00279   <a class="code" href="odaUtils_8h.html#a4">PROF_DA_BPART3_BEGIN</a>
00280 
00281     <a class="code" href="namespaceot.html#a75">DA_blockPartStage3</a>(in, blocks, <a class="code" href="classot_1_1DA.html#p21">m_tnMinAllBlocks</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00282 
00283   <a class="code" href="odaUtils_8h.html#a5">PROF_DA_BPART3_END</a>
00284 
00285     <span class="comment">//Store Blocks. </span>
00286     <a class="code" href="classot_1_1DA.html#p20">m_tnBlocks</a> = blocks;
00287 
00288   <span class="comment">//we must split comm if new empty procs were created in blockPartStage2</span>
00289   <span class="comment">//empty procs are created using partW and 0 wts and so all empty procs should</span>
00290   <span class="comment">//be contiguous and only the last few procs should be empty</span>
00291   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p21">m_tnMinAllBlocks</a>.size() != m_iNpesActive) {
00292     <a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a> = (!in.empty());   
00293     <span class="keywordflow">if</span>(iAmActive != NULL) {     
00294       <span class="comment">//Want the active state returned</span>
00295       (*iAmActive) = m_bIamActive;
00296     }
00297     assert( <a class="code" href="classot_1_1DA.html#p3">m_bIamActive</a> == (<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt; <a class="code" href="classot_1_1DA.html#p21">m_tnMinAllBlocks</a>.size()) );
00298 
00299     MPI_Comm tmpComm;
00300     <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(static_cast&lt;int&gt;(<a class="code" href="classot_1_1DA.html#p21">m_tnMinAllBlocks</a>.size()),
00301         &amp;tmpComm, m_mpiCommActive);
00302     <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a> = tmpComm;
00303 
00304 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
00305 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(!m_iRankActive) {
00306       std::cout&lt;&lt;<span class="stringliteral">" splitComm: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>&lt;&lt;<span class="stringliteral">" -&gt; "</span>&lt;&lt;
00307         (<a class="code" href="classot_1_1DA.html#p21">m_tnMinAllBlocks</a>.size())&lt;&lt;<span class="stringliteral">" after bPart in DA constructor. "</span>&lt;&lt;std::endl;
00308     }
00309 <span class="preprocessor">#endif</span>
00310 <span class="preprocessor"></span>
00311     <span class="keywordflow">if</span>(m_bIamActive) {
00312       MPI_Comm_size(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>,&amp;<a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>);
00313       MPI_Comm_rank(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>,&amp;m_iRankActive);
00314     } <span class="keywordflow">else</span> {
00315       <a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a> = 0;
00316       m_iRankActive = 0;
00317     }
00318 
00319     <span class="keywordflow">if</span>(!m_bIamActive) {
00320       <a class="code" href="odaFactory_8C.html#a0">RESET_DA_BLOCK</a>
00321         <a class="code" href="oda_8h.html#a30">PROF_BUILD_DA_STAGE3_END</a>
00322         <span class="keywordflow">return</span>;
00323     }
00324   }<span class="comment">//end if new empty procs after bPart</span>
00325 
00326   <a class="code" href="oda_8h.html#a30">PROF_BUILD_DA_STAGE3_END</a>
00327 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00328 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00329 <span class="preprocessor">#endif</span>
00330 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a31">PROF_BUILD_DA_STAGE4_BEGIN</a>
00331 
00332     <span class="comment">// Set the Local offset</span>
00333     assert(!in.empty());
00334   assert(<a class="code" href="classot_1_1DA.html#p21">m_tnMinAllBlocks</a>.size() == m_iNpesActive);
00335 
00336   <a class="code" href="classot_1_1DA.html#p17">m_ptOffset</a> = in[0].getAnchor();
00337 
00338 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00339 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00340   <span class="comment">//Check that block Part did the right job.</span>
00341   <span class="comment">//1. Ensure that in is globally sorted and unique.</span>
00342   assert(par::test::isUniqueAndSorted(in, <a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>));
00343 
00344   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00345   <span class="comment">//2. Ensure that the global size before and after block part has not</span>
00346   <span class="comment">//changed. So we don't miss out octants</span>
00347   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> localSizeAfter = in.size();
00348   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> globalSizeAfter; 
00349   par::Mpi_Allreduce&lt;DendroIntL&gt;(&amp;localSizeAfter, &amp;globalSizeAfter, 1,
00350       MPI_SUM, m_mpiCommActive);
00351 
00352   assert(globalSizeAfter == globalSizeBefore);
00353 
00354   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00355 
00356   <span class="comment">//3. Locally check that if an anchor is hanging then the parent's first</span>
00357   <span class="comment">// child exists.</span>
00358   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; in.size(); i++) {
00359     <span class="keywordflow">if</span>( !(in[i].getFlag() &amp; ot::TreeNode::NODE) ) {
00360       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> anchorOfParent = in[i].getParent().getDFD();
00361       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idxOfParent;
00362       <span class="keywordtype">bool</span> foundAnchorOfParent = seq::maxLowerBound&lt;ot::TreeNode&gt;(in, anchorOfParent, idxOfParent, NULL, NULL);
00363       <span class="keywordflow">if</span>(!foundAnchorOfParent) {
00364         std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" failing for: "</span>&lt;&lt;in[i]&lt;&lt;std::endl&lt;&lt;
00365           <span class="stringliteral">"Expected to find: "</span>&lt;&lt;
00366           anchorOfParent.getAncestor(in[i].<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>())&lt;&lt;std::endl;
00367         assert(<span class="keyword">false</span>);
00368       }
00369       <span class="keywordflow">if</span>( anchorOfParent.getAnchor() != in[idxOfParent].getAnchor() ) {
00370         std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" failing for: "</span>&lt;&lt;in[i]&lt;&lt;std::endl&lt;&lt;
00371           <span class="stringliteral">"Expected to find: "</span>&lt;&lt;
00372           anchorOfParent.getAncestor(in[i].<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>())&lt;&lt;std::endl;
00373         assert(<span class="keyword">false</span>);
00374       }
00375       <span class="keywordflow">if</span>( in[idxOfParent].getParent() != in[i].getParent() ) {
00376         std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" failing for: "</span>&lt;&lt;in[i]&lt;&lt;std::endl&lt;&lt;
00377           <span class="stringliteral">"Expected to find: "</span>&lt;&lt;
00378           anchorOfParent.getAncestor(in[i].<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>())&lt;&lt;std::endl;
00379         assert(<span class="keyword">false</span>);
00380       }
00381     }
00382   }
00383 
00384   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00385 
00386   <span class="keywordflow">if</span>(!m_iRankActive) {
00387     std::cout&lt;&lt;<span class="stringliteral">"Partition is correct."</span>&lt;&lt;std::endl;
00388   }
00389 
00390   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00391 <span class="preprocessor">#endif</span>
00392 <span class="preprocessor"></span>
00393   <span class="comment">//  2. Obtain all ghost octants.</span>
00394 
00395 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00396 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00397   <span class="keywordflow">if</span>(!m_iRankActive) {
00398     std::cout&lt;&lt;<span class="stringliteral">"Pick Inter-Processor Boundary Nodes "</span>&lt;&lt;std::endl;
00399   }
00400   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00401 <span class="preprocessor">#endif</span>
00402 <span class="preprocessor"></span>
00403   <span class="comment">// first let's pick boundary nodes on each proc.</span>
00404   std::vector&lt;ot::TreeNode&gt; allBoundaryLeaves;
00405 
00406   <a class="code" href="namespaceot.html#a65">pickInterProcessorBoundaryNodes</a>(in, allBoundaryLeaves, blocks[0], blocks[blocks.size() - 1]);
00407 
00408   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> myFirstOctant = in[0];
00409   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> myLastOctant = in[in.size() - 1];
00410 
00411   <a class="code" href="namespaceot.html#a85">includeSiblingsOfBoundary</a>(allBoundaryLeaves, myFirstOctant, myLastOctant);
00412 
00413   <a class="code" href="oda_8h.html#a32">PROF_BUILD_DA_STAGE4_END</a>
00414 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00415 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00416 <span class="preprocessor">#endif</span>
00417 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a33">PROF_BUILD_DA_STAGE5_BEGIN</a>
00418 
00419 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00420 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00421   <span class="keywordflow">if</span>(!m_iRankActive) {
00422     std::cout&lt;&lt;<span class="stringliteral">"Selected Extra Ghost Candidates. Now Checking "</span>&lt;&lt;std::endl;      
00423   }
00424 
00425   assert(seq::test::isUniqueAndSorted&lt;ot::TreeNode&gt;(allBoundaryLeaves));
00426 
00427   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allBoundaryLeavesSize = allBoundaryLeaves.size();
00428   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxBndSz;
00429   par::Mpi_Reduce&lt;unsigned int&gt;(&amp;allBoundaryLeavesSize,&amp;maxBndSz,1,MPI_MAX,0,m_mpiCommActive);
00430 
00431   <span class="keywordflow">if</span>(!m_iRankActive) {
00432     std::cout&lt;&lt;<span class="stringliteral">"Max Bnd Size:  "</span>&lt;&lt;maxBndSz&lt;&lt;std::endl;      
00433   }
00434 
00435   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00436 <span class="preprocessor">#endif</span>
00437 <span class="preprocessor"></span>
00438   <a class="code" href="oda_8h.html#a34">PROF_BUILD_DA_STAGE5_END</a>
00439 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00440 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00441 <span class="preprocessor">#endif</span>
00442 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a35">PROF_BUILD_DA_STAGE6_BEGIN</a>
00443 
00444     <span class="comment">//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
00445 
00446     <span class="comment">// 4. Loop through all local boundary nodes and determine which processors</span>
00447     <span class="comment">// need to be aware of those nodes. Create lists that shall be sent.</span>
00448     <span class="comment">//</span>
00449 
00450     <span class="keywordtype">int</span> *sendCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00451   <span class="keywordtype">int</span> *recvCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00452   <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00453   <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00454 
00455   std::vector&lt; std::vector&lt;unsigned int&gt; &gt; sendNodes;
00456 
00457   <a class="code" href="namespaceot.html#a87">prepareAprioriCommMessagesInDAtype2</a>(in, allBoundaryLeaves, blocks, <a class="code" href="classot_1_1DA.html#p21">m_tnMinAllBlocks</a>,
00458       <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>, <a class="code" href="classot_1_1DA.html#p6">m_iNpesActive</a>, sendCnt, sendNodes);
00459 
00460   allBoundaryLeaves.clear();
00461   blocks.clear();
00462 
00463 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00464 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00465   <span class="keywordflow">if</span>(!m_iRankActive) {
00466     std::cout&lt;&lt;<span class="stringliteral">"Picked Octants for Apriori Comm. "</span>&lt;&lt;std::endl;
00467   }
00468   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00469 <span class="preprocessor">#endif</span>
00470 <span class="preprocessor"></span>
00471   <span class="comment">// 5. Actual send/recv. to exchange nodes.</span>
00472   <span class="comment">//</span>
00473   <span class="comment">// 5a.</span>
00474   <span class="comment">// Now do an All2All to get numKeysRecv</span>
00475   par::Mpi_Alltoall&lt;int&gt;( sendCnt, recvCnt, 1, m_mpiCommActive);
00476 
00477   <span class="comment">// 5b. Concatenate all nodes into one single Carray ...</span>
00478   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalSend=0;
00479   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalRecv=0;
00480   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; m_iNpesActive; i++) {
00481     totalSend+= sendCnt[i];
00482     totalRecv+= recvCnt[i];
00483   }
00484 
00485   <span class="comment">// create the send and recv buffers ...</span>
00486   std::vector&lt;ot::TreeNode&gt; sendK (totalSend);
00487   std::vector&lt;ot::TreeNode&gt; recvK (totalRecv);
00488 
00489   <span class="comment">// Now create sendK</span>
00490   sendOffsets[0] = 0;
00491   recvOffsets[0] = 0;   
00492 
00493   <span class="comment">// compute offsets ...</span>
00494   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i &lt; m_iNpesActive; i++) {
00495     sendOffsets[i] = sendOffsets[i-1] + sendCnt[i-1];
00496     recvOffsets[i] = recvOffsets[i-1] + recvCnt[i-1];
00497   }
00498 
00499   <span class="keywordtype">int</span> myOff = recvOffsets[m_iRankActive];
00500 
00501 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00502 <span class="preprocessor"></span>  assert(sendCnt[<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>] == 0);
00503 <span class="preprocessor">#endif</span>
00504 <span class="preprocessor"></span>
00505   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; m_iNpesActive; i++) {
00506     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;sendCnt[i]; j++) {
00507       sendK[sendOffsets[i] + j] = in[sendNodes[i][j]];
00508       <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.push_back(sendNodes[i][j] + myOff);
00509     }
00510   }
00511 
00512 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00513 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00514   <span class="keywordflow">if</span>(!m_iRankActive) {
00515     std::cout&lt;&lt;<span class="stringliteral">"Built Primary ScatterMap. "</span>&lt;&lt;std::endl;
00516   }
00517   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00518 <span class="preprocessor">#endif</span>
00519 <span class="preprocessor"></span>
00520   <span class="comment">// 5c. Perform SendRecv to send and receive all keys ...</span>
00521 
00522   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKptr = NULL;
00523   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKptr = NULL;
00524   <span class="keywordflow">if</span>(!sendK.empty()) {
00525     sendKptr = &amp;(*(sendK.begin()));
00526   }
00527   <span class="keywordflow">if</span>(!recvK.empty()) {
00528     recvKptr = &amp;(*(recvK.begin()));
00529   }
00530 
00531   par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKptr, sendCnt, sendOffsets, 
00532       recvKptr, recvCnt, recvOffsets, m_mpiCommActive);
00533 
00534   sendK.clear();
00535   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; m_iNpesActive; i++) {
00536     sendNodes[i].clear();
00537   }
00538   sendNodes.clear();
00539 
00540   <span class="comment">// Let's store the counts for later synchronizations  ...</span>
00541   <span class="comment">//The offsets will be computed just before compression, After primary and</span>
00542   <span class="comment">//secondary scatterMaps are merged.</span>
00543   <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; m_iNpesActive; i++) {
00544     <span class="keywordflow">if</span> ( sendCnt[i] ) {
00545       <a class="code" href="classot_1_1DA.html#p68">m_uipSendProcs</a>.push_back(i);
00546       <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>.push_back(sendCnt[i]);
00547 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00548 <span class="preprocessor"></span>      assert(i != m_iRankActive);
00549 <span class="preprocessor">#endif</span>
00550 <span class="preprocessor"></span>    }
00551     <span class="keywordflow">if</span> ( recvCnt[i] ) {
00552       <a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>.push_back(i);
00553       <a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>.push_back(recvCnt[i]);
00554 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00555 <span class="preprocessor"></span>      assert(i != m_iRankActive);
00556 <span class="preprocessor">#endif</span>
00557 <span class="preprocessor"></span>    }
00558   }
00559 
00560   <span class="comment">//Free some memory...</span>
00561   <span class="keyword">delete</span> [] sendCnt;
00562   <span class="keyword">delete</span> [] recvCnt;
00563   <span class="keyword">delete</span> [] sendOffsets;
00564   <span class="keyword">delete</span> [] recvOffsets;
00565 
00566   <a class="code" href="oda_8h.html#a36">PROF_BUILD_DA_STAGE6_END</a>
00567 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00568 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00569 <span class="preprocessor">#endif</span>
00570 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a37">PROF_BUILD_DA_STAGE7_BEGIN</a>
00571 
00572     <span class="comment">//Now that we have the ghost nodes (in recvK), we can merge this with the</span>
00573     <span class="comment">//input nodes, and all tag all of these as elements. While merging we shall</span>
00574     <span class="comment">//also set the right offsets into the global vector.</span>
00575 
00576 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__        </span>
00577 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00578   <span class="comment">//std::cout &lt;&lt; "Now Merging recv ghosts with own octants, recvK size is " &lt;&lt; recvK.size() &lt;&lt; std::endl;</span>
00579   <span class="comment">//std::cout &lt;&lt; "In size is " &lt;&lt; in.size() &lt;&lt; std::endl;</span>
00580   assert(seq::test::isSorted&lt;ot::TreeNode&gt; (recvK));
00581   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00582 <span class="preprocessor">#endif        </span>
00583 <span class="preprocessor"></span>
00584   <span class="comment">// Lets store offsets demarcating the global domain spanned by this</span>
00585   <span class="comment">// processor.</span>
00586 
00587   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> globalMin, globalMax;
00588   globalMin = in[0];
00589 
00590 
00591   <span class="comment">// Since recvK is sorted, and so are the 'global' nodes, we can merge</span>
00592   <span class="comment">// effectively. We also mark them as being elements.  </span>
00593 
00594   <span class="comment">//Merge (In-place) recieved octants with local octants....</span>
00595   std::vector &lt; ot::TreeNode &gt; localOcts(recvK.size() + in.size() );
00596 
00597 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00598 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00599   <span class="keywordflow">if</span>(!m_iRankActive) {
00600     std::cout&lt;&lt;<span class="stringliteral">"Merging ghosts and own octants into the buffer. "</span>&lt;&lt;std::endl;
00601   }
00602   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00603 <span class="preprocessor">#endif</span>
00604 <span class="preprocessor"></span>
00605 
00606   <span class="comment">//Note this is an inplace insertion. This is done to preserve the sorted</span>
00607   <span class="comment">//order. Each recvK[i] is independently sorted. Also, since the intial</span>
00608   <span class="comment">//blocks were globally sorted and since the elements on each processor are</span>
00609   <span class="comment">//only decendants of these blocks, hence recvK[i][j] &lt; recvK[i+][k] for all i,j</span>
00610   <span class="comment">//and k.</span>
00611   <span class="comment">// PreGhost ....</span>
00612   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;myOff; i++) {
00613     localOcts[i] = recvK[i];
00614     <span class="keywordflow">if</span> (!(localOcts[i].getFlag() &amp; ot::TreeNode::BOUNDARY) ) {
00615       <a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a>++;
00616     }
00617   }
00618 
00619   <span class="comment">//Mine ...</span>
00620   <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> = myOff;
00621   <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a> = myOff;
00622   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=myOff; i&lt;myOff+in.size(); i++) {
00623     localOcts[i] = in[i-myOff];
00624     <span class="keywordflow">if</span> (!(localOcts[i].getFlag() &amp; ot::TreeNode::BOUNDARY) ) {
00625       <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>++;
00626     } 
00627   }
00628   <a class="code" href="classot_1_1DA.html#p38">m_uiElementSize</a> = (<a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a> - m_uiElementBegin);
00629 
00630   <span class="comment">//PostGhosts....</span>
00631   <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> = myOff + static_cast&lt;unsigned int&gt;(in.size());
00632   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=myOff+in.size(); i&lt;localOcts.size(); i++) {
00633     localOcts[i] = recvK[i-in.size()];
00634   }
00635 
00636   <span class="comment">// all indices should be set at this stage ...</span>
00637   <span class="comment">// free up some memory.</span>
00638   in.clear();
00639   recvK.clear();
00640 
00641   <a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a> = static_cast&lt;unsigned int&gt;(localOcts.size());
00642 
00643   <a class="code" href="oda_8h.html#a38">PROF_BUILD_DA_STAGE7_END</a>
00644 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00645 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00646 <span class="preprocessor">#endif</span>
00647 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a39">PROF_BUILD_DA_STAGE8_BEGIN</a>
00648 
00649     <span class="comment">// Now for the big step. Perform searches to build the look-up table.</span>
00650     <span class="comment">// LocalOcts will be modified inside buildNodeList.</span>
00651     <span class="comment">// All counters will be reset inside the function.</span>
00652     <span class="comment">// The list will continue to remain sorted.</span>
00653 
00654 
00655 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00656 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00657   assert(seq::test::isUniqueAndSorted(localOcts));
00658   <span class="keywordflow">if</span>(!m_iRankActive) {
00659     std::cout&lt;&lt;<span class="stringliteral">" Entering BuildNodeList. "</span>&lt;&lt;std::endl;
00660   }    
00661   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00662 <span class="preprocessor">#endif</span>
00663 <span class="preprocessor"></span>
00664   <a class="code" href="classot_1_1DA.html#b0">buildNodeList</a>(localOcts);
00665 
00666 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00667 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00668   <span class="keywordflow">if</span>(!m_iRankActive) {
00669     std::cout&lt;&lt;<span class="stringliteral">" Leaving BuildNodeList. "</span>&lt;&lt;std::endl;
00670   }
00671   assert(seq::test::isUniqueAndSorted(localOcts));
00672   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00673 <span class="preprocessor">#endif</span>
00674 <span class="preprocessor"></span>
00675   <a class="code" href="oda_8h.html#a40">PROF_BUILD_DA_STAGE8_END</a>
00676 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00677 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00678 <span class="preprocessor">#endif</span>
00679 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a41">PROF_BUILD_DA_STAGE9_BEGIN</a>
00680 
00681     <span class="comment">// Set the global offset </span>
00682     <a class="code" href="classot_1_1DA.html#p15">m_ptGhostedOffset</a> = localOcts[0].getAnchor();
00683 
00684   <span class="comment">//Compute pre-ghost offsets</span>
00685 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00686 <span class="preprocessor"></span>  <span class="keywordflow">if</span> ( m_uiElementBegin) {
00687     <a class="code" href="classot_1_1DA.html#p72">PreGhostAnchors</a>.push_back( localOcts[0].getAnchor());
00688   }
00689 <span class="preprocessor">#endif</span>
00690 <span class="preprocessor"></span>
00691   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; m_uiElementBegin; i++) {
00692     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> touchConfig = <a class="code" href="namespaceot.html#a82">getTouchConfig</a>(localOcts[i-1],
00693         localOcts[i], <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00694     <a class="code" href="classot_1_1DA.html#p27">m_ucpPreGhostConnectivity</a>.push_back(touchConfig);
00695     <span class="keywordflow">if</span> (!touchConfig) {
00696       <a class="code" href="classot_1_1DA.html#p18">m_ptsPreGhostOffsets</a>.push_back( localOcts[i].getAnchor() );
00697     }
00698 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00699 <span class="preprocessor"></span>    <a class="code" href="classot_1_1DA.html#p72">PreGhostAnchors</a>.push_back( localOcts[i].getAnchor());
00700 <span class="preprocessor">#endif</span>
00701 <span class="preprocessor"></span>  }
00702 
00703   <span class="comment">// Finally compress the octree, clean up and we are all set.</span>
00704 
00705   <span class="comment">// we simply retain the oct levels ...</span>
00706   <span class="keywordflow">if</span>(!localOcts.empty()) {
00707     <a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a> = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> [localOcts.size()];
00708   } <span class="keywordflow">else</span> {
00709     <a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a> = NULL;
00710   }
00711 
00712   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; localOcts.size(); i++) {
00713     <a class="code" href="classot_1_1DA.html#p26">m_ucpOctLevels</a>[i] = localOcts[i].getFlag();
00714   }
00715 
00716   <span class="comment">// clean up ...</span>
00717   localOcts.clear();
00718 
00719   <span class="comment">// Set pointers ....</span>
00720   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#p24">m_ucpLutRemainders</a>.empty()) {
00721     <a class="code" href="classot_1_1DA.html#p25">m_ucpLutRemaindersPtr</a> = &amp;(*<a class="code" href="classot_1_1DA.html#p24">m_ucpLutRemainders</a>.begin());
00722   } <span class="keywordflow">else</span> {
00723     <a class="code" href="classot_1_1DA.html#p25">m_ucpLutRemaindersPtr</a> = NULL;
00724   }
00725 
00726   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#p70">m_uspLutQuotients</a>.empty()) {
00727     <a class="code" href="classot_1_1DA.html#p71">m_uspLutQuotientsPtr</a> = &amp;(*<a class="code" href="classot_1_1DA.html#p70">m_uspLutQuotients</a>.begin());
00728   } <span class="keywordflow">else</span> {
00729     <a class="code" href="classot_1_1DA.html#p71">m_uspLutQuotientsPtr</a> = NULL;
00730   }
00731 
00732   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>.empty()) {
00733     <a class="code" href="classot_1_1DA.html#p23">m_ucpLutMasksPtr</a> = &amp;(*<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>.begin());
00734   } <span class="keywordflow">else</span> {
00735     <a class="code" href="classot_1_1DA.html#p23">m_ucpLutMasksPtr</a> = NULL;
00736   }
00737 
00738   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>.empty()) {
00739     <a class="code" href="classot_1_1DA.html#p30">m_ucpSortOrdersPtr</a> = &amp;(*<a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>.begin());
00740   } <span class="keywordflow">else</span> {
00741     <a class="code" href="classot_1_1DA.html#p30">m_ucpSortOrdersPtr</a> = NULL;
00742   }
00743 
00744   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#p46">m_uiNlist</a>.empty()) {
00745     <a class="code" href="classot_1_1DA.html#p47">m_uiNlistPtr</a> = &amp;(*<a class="code" href="classot_1_1DA.html#p46">m_uiNlist</a>.begin());
00746   } <span class="keywordflow">else</span> {
00747     <a class="code" href="classot_1_1DA.html#p47">m_uiNlistPtr</a> = NULL;
00748   }
00749 
00750   <a class="code" href="oda_8h.html#a42">PROF_BUILD_DA_STAGE9_END</a>
00751 
00752 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00753 <span class="preprocessor"></span>    <span class="comment">//Check Loops</span>
00754     MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00755   <span class="keywordflow">for</span>( init&lt;ot::DA_FLAGS::WRITABLE&gt;(); <a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; end&lt;ot::DA_FLAGS::WRITABLE&gt;();
00756       next&lt;ot::DA_FLAGS::WRITABLE&gt;() ) {
00757     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &gt;= m_uiElementBegin);
00758     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>);
00759     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00760     <a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00761     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = 0; vtxId &lt; 8; vtxId++) {
00762       assert(indices[vtxId] &gt;= m_uiElementBegin);
00763       assert(indices[vtxId] &lt; <a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a>);             
00764     }
00765   }
00766   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00767   <span class="keywordflow">if</span>(!m_iRankActive) {
00768     std::cout&lt;&lt;<span class="stringliteral">" Finished checking WRITABLE."</span>&lt;&lt;std::endl;
00769   }
00770   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00771 
00772   <span class="keywordflow">for</span>( init&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); <a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();
00773       next&lt;ot::DA_FLAGS::INDEPENDENT&gt;() ) {
00774     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &gt;= m_uiElementBegin);
00775     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>);
00776     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00777     <a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00778     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = 0; vtxId &lt; 8; vtxId++) {
00779       assert(indices[vtxId] &gt;= m_uiElementBegin);       
00780       assert(indices[vtxId] &lt; <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>);              
00781     }
00782   }
00783 
00784   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00785 
00786   <span class="keywordflow">if</span>(!m_iRankActive) {
00787     std::cout&lt;&lt;<span class="stringliteral">" Finished checking INDEPENDENT."</span>&lt;&lt;std::endl;
00788   }
00789 
00790   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00791 
00792   <span class="keywordflow">for</span>( init&lt;ot::DA_FLAGS::DEPENDENT&gt;(); <a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; end&lt;ot::DA_FLAGS::DEPENDENT&gt;();
00793       next&lt;ot::DA_FLAGS::DEPENDENT&gt;() ) {
00794     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>);
00795     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00796     <a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00797     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numLocal = 0;
00798     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = 0; vtxId &lt; 8; vtxId++) {
00799       assert(indices[vtxId] &lt; <a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a>);
00800       <span class="keywordflow">if</span>( (indices[vtxId] &gt;= m_uiElementBegin) &amp;&amp;  (indices[vtxId] &lt; m_uiPostGhostBegin) ) {
00801         numLocal++;
00802       }         
00803     }
00804     assert(numLocal &gt; 0);
00805     assert(numLocal &lt; 8);
00806   }
00807 
00808   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00809 
00810   <span class="keywordflow">if</span>(!m_iRankActive) {
00811     std::cout&lt;&lt;<span class="stringliteral">" Finished checking DEPENDENT."</span>&lt;&lt;std::endl;
00812   }
00813   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00814 
00815   <span class="keywordflow">for</span>( init&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(); <a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; end&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();
00816       next&lt;ot::DA_FLAGS::W_DEPENDENT&gt;() ) {
00817     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &gt;= m_uiElementBegin);
00818     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>);
00819     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00820     <a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00821     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numLocal = 0;
00822     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = 0; vtxId &lt; 8; vtxId++) {
00823       assert(indices[vtxId] &gt;= m_uiElementBegin);       
00824       assert(indices[vtxId] &lt; <a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a>);             
00825       <span class="keywordflow">if</span>( (indices[vtxId] &gt;= m_uiElementBegin) &amp;&amp;  (indices[vtxId] &lt; m_uiPostGhostBegin) ) {
00826         numLocal++;
00827       }         
00828     }
00829     assert(numLocal &gt; 0);
00830     assert(numLocal &lt; 8);
00831   }
00832 
00833   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00834 
00835   <span class="keywordflow">if</span>(!m_iRankActive) {
00836     std::cout&lt;&lt;<span class="stringliteral">" Finished checking W_DEPENDENT."</span>&lt;&lt;std::endl;
00837   }
00838 
00839   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00840 
00841   <span class="keywordflow">for</span>( init&lt;ot::DA_FLAGS::ALL&gt;(); 
00842       <a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; end&lt;ot::DA_FLAGS::ALL&gt;();
00843       next&lt;ot::DA_FLAGS::ALL&gt;() ) {
00844     assert(<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>);
00845     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00846     <a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices);
00847     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = 0; vtxId &lt; 8; vtxId++) {
00848       assert(indices[vtxId] &lt; <a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a>);             
00849     }
00850   }
00851 
00852   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00853 
00854   <span class="keywordflow">if</span>(!m_iRankActive) {
00855     std::cout&lt;&lt;<span class="stringliteral">" Finished checking ALL."</span>&lt;&lt;std::endl;
00856   }
00857 
00858   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00859 
00860 <span class="preprocessor">#endif</span>
00861 <span class="preprocessor"></span>
00862 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
00863 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00864   <span class="keywordflow">if</span>(!m_iRankActive) {
00865     std::cout&lt;&lt;<span class="stringliteral">" Just At End of DA...."</span>&lt;&lt;std::endl&lt;&lt;std::endl;
00866   }
00867   <span class="comment">//std::cout&lt;&lt;m_iRankActive&lt;&lt;" "&lt;&lt;m_uiPreGhostNodeSize&lt;&lt;" "&lt;&lt;m_uiPreGhostBoundaryNodeSize&lt;&lt;" "&lt;&lt;m_uiPostGhostNodeSize&lt;&lt;" "&lt;&lt;m_uiNodeSize&lt;&lt;" "&lt;&lt;m_uiBoundaryNodeSize&lt;&lt;std::endl&lt;&lt;std::endl;</span>
00868   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00869 <span class="preprocessor">#endif</span>
00870 <span class="preprocessor"></span>
00871 }<span class="comment">//end function</span>
00872 
00873 <span class="preprocessor">#undef RESET_DA_BLOCK</span>
00874 <span class="preprocessor"></span>
00875 }<span class="comment">//end namespace</span>
00876 
00877 
00878 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:32 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
