<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/include/test/testUtils.txx Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000012.html">test</a></div>
<h1>testUtils.txx</h1><a href="testUtils_8txx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "<a class="code" href="dtypes_8h.html">dtypes.h</a>"</span>
00008 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00010 <span class="preprocessor">#include &lt;iostream&gt;</span>
00011 
00012 <span class="keyword">namespace </span>seq { 
00013   <span class="keyword">namespace </span>test {
00014 
00015     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00016"></a><a class="code" href="namespaceseq_1_1test.html#a0">00016</a>       <span class="keywordtype">bool</span> <a class="code" href="namespacepar_1_1test.html#a0">isSorted</a>(<span class="keyword">const</span> std::vector&lt;T &gt; &amp; nodes) {
00017         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; nodes.size(); i++) {
00018           <span class="keywordflow">if</span> ( nodes[i] &lt; nodes[i-1] ) {
00019             std::cout&lt;&lt;<span class="stringliteral">"\n Local Sort Check failed for: "</span>&lt;&lt;nodes[i]&lt;&lt;<span class="stringliteral">" and "</span>
00020               &lt;&lt;nodes[i-1]&lt;&lt;std::endl&lt;&lt;std::endl;
00021             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00022           }
00023         }
00024         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00025       }
00026 
00027     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00028"></a><a class="code" href="namespaceseq_1_1test.html#a1">00028</a>       <span class="keywordtype">bool</span> <a class="code" href="namespacepar_1_1test.html#a0">isSorted</a>(T* nodes, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz) {
00029         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; sz; i++) {
00030           <span class="keywordflow">if</span> ( nodes[i] &lt; nodes[i-1] ) {
00031             std::cout&lt;&lt;<span class="stringliteral">"\n Local Sort Check failed for: "</span>&lt;&lt;nodes[i]&lt;&lt;<span class="stringliteral">" and "</span>
00032               &lt;&lt;nodes[i-1]&lt;&lt;std::endl&lt;&lt;std::endl;
00033             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00034           }
00035         }
00036         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00037       }
00038 
00039     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00040"></a><a class="code" href="namespaceseq_1_1test.html#a2">00040</a>       <span class="keywordtype">bool</span> <a class="code" href="namespacepar_1_1test.html#a1">isUniqueAndSorted</a>(<span class="keyword">const</span> std::vector&lt;T &gt; &amp; nodes) {
00041         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; nodes.size(); i++) {
00042           <span class="keywordflow">if</span> ( nodes[i] &lt;= nodes[i-1] ) {
00043             std::cout&lt;&lt;<span class="stringliteral">"\n Local Sort+Unique Check failed for: "</span>&lt;&lt;nodes[i]&lt;&lt;<span class="stringliteral">" and "</span>
00044               &lt;&lt;nodes[i-1]&lt;&lt;std::endl;
00045             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00046           }
00047         }
00048         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00049       }
00050 
00051     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00052"></a><a class="code" href="namespaceseq_1_1test.html#a3">00052</a>       <span class="keywordtype">bool</span> <a class="code" href="namespacepar_1_1test.html#a1">isUniqueAndSorted</a>(T* nodes, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz) {
00053         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; sz; i++) {
00054           <span class="keywordflow">if</span> ( nodes[i] &lt;= nodes[i-1] ) {
00055             std::cout&lt;&lt;<span class="stringliteral">"\n Local Sort+Unique Check failed for: "</span>&lt;&lt;nodes[i]&lt;&lt;<span class="stringliteral">" and "</span>
00056               &lt;&lt;nodes[i-1]&lt;&lt;std::endl;
00057             <span class="keywordflow">return</span> <span class="keyword">false</span>;
00058           }
00059         }
00060         <span class="keywordflow">return</span> <span class="keyword">true</span>;
00061       }
00062 
00063   }<span class="comment">//end namespace</span>
00064 }<span class="comment">//end namespace</span>
00065 
00066 <span class="keyword">namespace </span>par { 
00067   <span class="keyword">namespace </span>test {
00068 
00069     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00070"></a><a class="code" href="namespacepar_1_1test.html#a0">00070</a>       <span class="keywordtype">bool</span> <a class="code" href="namespacepar_1_1test.html#a0">isSorted</a>(<span class="keyword">const</span> std::vector&lt;T &gt; &amp;nodes, MPI_Comm comm) {
00071         <span class="keywordtype">bool</span> localPassed = par::test::isSorted&lt;T&gt;(nodes);
00072         <span class="keywordtype">bool</span> allLocalsPassed;
00073 
00074         par::Mpi_Allreduce&lt;bool&gt;(&amp;localPassed, &amp;allLocalsPassed, 1,
00075             <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;bool&gt;::LAND</a>(), comm);
00076 
00077         <span class="keywordflow">if</span>(allLocalsPassed) {
00078           <span class="keywordtype">bool</span> failedParCheck = <span class="keyword">false</span>;
00079 
00080           MPI_Comm new_comm;
00081           <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(nodes.empty(), new_comm, comm);
00082 
00083           <span class="keywordflow">if</span>(!nodes.empty()) {
00084             <span class="keywordtype">int</span> rank;
00085             <span class="keywordtype">int</span> npes;
00086             MPI_Request request;
00087             MPI_Status status;
00088             MPI_Comm_rank(new_comm,&amp;rank);
00089             MPI_Comm_size(new_comm,&amp;npes);
00090 
00091             <span class="comment">//Send last to the next proc.</span>
00092             T end = nodes[nodes.size()-1];                              
00093             <span class="keywordflow">if</span>(rank &lt; (npes -1)) {
00094               par::Mpi_Issend&lt;T&gt;(&amp;end, 1, rank+1, 0, new_comm, &amp;request );
00095             }
00096 
00097             T prev, me;
00098             me = nodes[0];
00099 
00100             <span class="comment">//Recv prev from the prev proc.d</span>
00101             <span class="keywordflow">if</span>(rank) {
00102               par::Mpi_Recv&lt;T&gt;( &amp;prev, 1, rank-1, 0, new_comm, &amp;status );
00103               <span class="keywordflow">if</span>(prev &gt; me) {
00104                 failedParCheck = <span class="keyword">true</span>;                          
00105               }
00106             }
00107 
00108             <span class="keywordflow">if</span>(rank &lt; (npes-1)) {
00109               MPI_Status statusWait;
00110               MPI_Wait(&amp;request, &amp;statusWait);
00111             }
00112           }<span class="comment">//end if nodes not empty     </span>
00113 
00114           <span class="keywordtype">bool</span> anyProcFailed;
00115           par::Mpi_Allreduce&lt;bool&gt;(&amp;failedParCheck, &amp;anyProcFailed, 1,
00116               <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;bool&gt;::LOR</a>(), comm);
00117 
00118           <span class="keywordflow">return</span> (!anyProcFailed);
00119         }
00120 
00121         <span class="keywordflow">return</span> allLocalsPassed;     
00122       }
00123     <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00124"></a><a class="code" href="namespacepar_1_1test.html#a1">00124</a>       <span class="keywordtype">bool</span> <a class="code" href="namespacepar_1_1test.html#a1">isUniqueAndSorted</a>(<span class="keyword">const</span> std::vector&lt;T &gt; &amp;nodes, MPI_Comm comm) {
00125         <span class="keywordtype">bool</span> localPassed = seq::test::isUniqueAndSorted&lt;T&gt;(nodes);
00126         <span class="keywordtype">bool</span> allLocalsPassed;
00127 
00128         par::Mpi_Allreduce&lt;bool&gt;(&amp;localPassed, &amp;allLocalsPassed, 1,
00129             <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;bool&gt;::LAND</a>(), comm);
00130 
00131         <span class="keywordflow">if</span>(allLocalsPassed) {
00132           <span class="keywordtype">bool</span> failedParCheck = <span class="keyword">false</span>;
00133 
00134           MPI_Comm new_comm;
00135           <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(nodes.empty(), &amp;new_comm, comm);
00136 
00137           <span class="keywordflow">if</span>(!nodes.empty()) {
00138             <span class="keywordtype">int</span> rank;
00139             <span class="keywordtype">int</span> npes;
00140             MPI_Request request;
00141             MPI_Status status;
00142             MPI_Comm_rank(new_comm,&amp;rank);
00143             MPI_Comm_size(new_comm,&amp;npes);
00144 
00145             <span class="comment">//Send last to the next proc.</span>
00146             T end = nodes[nodes.size()-1];                              
00147             <span class="keywordflow">if</span>(rank &lt; (npes-1)) {
00148               par::Mpi_Issend&lt;T&gt;(&amp;end, 1, rank+1, 0, new_comm, &amp;request );
00149             }
00150 
00151             T prev, me;
00152             me = nodes[0];
00153 
00154             <span class="comment">//Recv prev from the prev proc.</span>
00155             <span class="keywordflow">if</span>(rank) {
00156               par::Mpi_Recv&lt;T&gt;( &amp;prev, 1, rank-1, 0, new_comm, &amp;status );
00157               <span class="keywordflow">if</span>(prev &gt;= me) {
00158                 failedParCheck = <span class="keyword">true</span>;                          
00159               }
00160             }
00161 
00162             <span class="keywordflow">if</span>(rank &lt; (npes-1)) {
00163               MPI_Status statusWait;
00164               MPI_Wait(&amp;request, &amp;statusWait);
00165             }
00166           }<span class="comment">//end if nodes not empty     </span>
00167 
00168           <span class="keywordtype">bool</span> anyProcFailed;
00169           par::Mpi_Allreduce&lt;bool&gt;(&amp;failedParCheck, &amp;anyProcFailed, 1,
00170               <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;bool&gt;::LOR</a>(), comm);
00171 
00172           <span class="keywordflow">return</span> (!anyProcFailed);
00173         }
00174 
00175         <span class="keywordflow">return</span> allLocalsPassed;     
00176       }
00177 
00178   }<span class="comment">//end namespace</span>
00179 }<span class="comment">//end namespace</span>
00180 
00181 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:30 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
