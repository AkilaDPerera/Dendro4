<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oct/Balance.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">oct</a></div>
<h1>Balance.C</h1><a href="Balance_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00009 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="TreeNodePointer_8h.html">TreeNodePointer.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="testUtils_8h.html">testUtils.h</a>"</span>
00014 <span class="preprocessor">#include "<a class="code" href="dendro_8h.html">dendro.h</a>"</span>
00015 
00016 <span class="preprocessor">#ifdef __DEBUG__</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_OCT__</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_OCT__</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#ifndef __MEASURE_BAL_COMM__</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#define __MEASURE_BAL_COMM__</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
<a name="l00028"></a><a class="code" href="namespaceot.html">00028</a> <span class="keyword">namespace </span>ot {
00029 
00030   <span class="comment">//Assumption: in is globally sorted, linear and complete.</span>
<a name="l00031"></a><a class="code" href="namespaceot.html#a10">00031</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a10">balanceOctree</a> (std::vector&lt;TreeNode &gt; &amp;in, std::vector&lt;TreeNode &gt; &amp;out,
00032       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, <span class="keywordtype">bool</span> incCorner,
00033       MPI_Comm comm, MPI_Comm* newCommPtr, <span class="keywordtype">bool</span>* iAmActive) {
00034 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00035 <span class="preprocessor"></span>    MPI_Barrier(comm);
00036 <span class="preprocessor">#endif</span>
00037 <span class="preprocessor"></span>    <a class="code" href="octUtils_8h.html#a11">PROF_BAL_BEGIN</a>
00038 
00039       <span class="keywordtype">int</span> rank, size;
00040     MPI_Comm_size(comm,&amp;size);
00041     out.clear();
00042 
00043     <span class="keywordflow">if</span>(newCommPtr) {
00044       *newCommPtr = comm;
00045     }
00046 
00047     <span class="keywordflow">if</span>(iAmActive) {
00048       *iAmActive = <span class="keyword">true</span>;
00049     }
00050 
00052     <span class="comment">//Check if it is a single processor...</span>
00053     <span class="keywordflow">if</span> (size == 1) {
00054 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
00055 <span class="preprocessor"></span>      std::cout&lt;&lt;<span class="stringliteral">"Balance Octree. inpSize: "</span>&lt;&lt;in.size()&lt;&lt;<span class="stringliteral">" activeNpes: 1"</span>&lt;&lt;std::endl; 
00056 <span class="preprocessor">#endif</span>
00057 <span class="preprocessor"></span>
00058       out = in;
00059       in.clear();
00060       <a class="code" href="namespaceot.html#a11">comboRipple</a>(out, incCorner);
00061       <a class="code" href="octUtils_8h.html#a50">PROF_BAL_END</a>
00062     }
00063 
00064     MPI_Comm_rank(comm,&amp;rank);
00065 
00066     <span class="comment">//Check if the input is too small...</span>
00067     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> locSize = in.size();
00068     <a class="code" href="dendro_8h.html#a0">DendroIntL</a> globSize;
00069     <a class="code" href="octUtils_8h.html#a0">PROF_BAL_COMM_BEGIN</a>
00070 
00071       par::Mpi_Allreduce&lt;DendroIntL&gt;(&amp;locSize, &amp;globSize, 1, MPI_SUM, comm);
00072 
00073     <a class="code" href="octUtils_8h.html#a36">PROF_BAL_COMM_END</a>
00074 
00075       <span class="comment">//min grain size = 1000</span>
00076       <span class="keyword">const</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a> THOUSAND = 1000;
00077     <span class="keywordflow">if</span> (globSize &lt; (THOUSAND*size)) {
00078       <span class="keywordtype">int</span> splittingSize = (globSize/THOUSAND); 
00079       <span class="keywordflow">if</span>(splittingSize == 0) {
00080         splittingSize = 1; 
00081       }
00082 
00083       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> avgLoad = (globSize/splittingSize);
00084       <span class="keywordtype">int</span> leftOvers = (globSize - (splittingSize*avgLoad));
00085 
00086       <a class="code" href="octUtils_8h.html#a1">PROF_BAL_SCATTER_BEGIN</a>
00087 
00088         std::vector&lt;TreeNode&gt; tmpIn;
00089       <span class="keywordflow">if</span>(rank &gt;= splittingSize) {
00090         par::scatterValues&lt;ot::TreeNode&gt;(in, tmpIn, 0, comm);
00091       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(rank &lt; leftOvers) {
00092         par::scatterValues&lt;ot::TreeNode&gt;(in, tmpIn, (avgLoad+1), comm);
00093       }<span class="keywordflow">else</span> {
00094         par::scatterValues&lt;ot::TreeNode&gt;(in, tmpIn, avgLoad, comm);
00095       }
00096 
00097       <a class="code" href="octUtils_8h.html#a37">PROF_BAL_SCATTER_END</a>
00098 
00099         in.clear();
00100 
00101       <a class="code" href="octUtils_8h.html#a2">PROF_BAL_SPLIT_COMM_BEGIN</a>
00102 
00103         MPI_Comm newComm;
00104       <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(splittingSize, &amp;newComm, comm);
00105 
00106       <a class="code" href="octUtils_8h.html#a38">PROF_BAL_SPLIT_COMM_END</a>
00107 
00108 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
00109 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!rank) {
00110           std::cout&lt;&lt;<span class="stringliteral">"Input to Balance is small ("</span>&lt;&lt;globSize
00111             &lt;&lt;<span class="stringliteral">"). npes = "</span>&lt;&lt;size&lt;&lt;<span class="stringliteral">" Splitting Comm. "</span>&lt;&lt;std::endl;
00112         }
00113 <span class="preprocessor">#endif</span>
00114 <span class="preprocessor"></span>
00115       <span class="keywordflow">if</span>(rank &lt; splittingSize) {
00116         <a class="code" href="namespaceot.html#a10">balanceOctree</a> (tmpIn, out, dim, maxDepth, incCorner, newComm, NULL, NULL);
00117       } <span class="keywordflow">else</span> {
00118         <span class="keywordflow">if</span>(iAmActive) {
00119           *iAmActive = <span class="keyword">false</span>;
00120         }
00121       }
00122       tmpIn.clear();
00123 
00124       <span class="keywordflow">if</span>(newCommPtr) {
00125         *newCommPtr = newComm;
00126       }
00127 
00128       <a class="code" href="octUtils_8h.html#a50">PROF_BAL_END</a>
00129     }<span class="comment">//end if reduce procs</span>
00130 
00131 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
00132 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(!rank) {
00133       std::cout&lt;&lt;<span class="stringliteral">"Balance Octree. inpSize: "</span>&lt;&lt;globSize &lt;&lt;<span class="stringliteral">" activeNpes: "</span>&lt;&lt;size&lt;&lt;std::endl; 
00134     }
00135 <span class="preprocessor">#endif</span>
00136 <span class="preprocessor"></span>
00138     <span class="comment">//Partition in and create blocks (blocks must be globally sorted).</span>
00139     <span class="comment">//Prepare for blockPart.</span>
00140 
00141     std::vector&lt;ot::TreeNode&gt; blocks;    
00142     std::vector&lt;ot::TreeNode&gt; minsAllBlocks;
00143 
00144 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00145 <span class="preprocessor"></span>    MPI_Barrier(comm);
00146 <span class="preprocessor">#endif</span>
00147 <span class="preprocessor"></span>    <a class="code" href="octUtils_8h.html#a3">PROF_BAL_BPART1_BEGIN</a>
00148 
00149       <a class="code" href="namespaceot.html#a28">blockPartStage1</a>(in, blocks, dim, maxDepth, comm);            
00150 
00151     <a class="code" href="octUtils_8h.html#a39">PROF_BAL_BPART1_END</a>
00152 
00153 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00154 <span class="preprocessor"></span>      MPI_Barrier(comm);
00155 <span class="preprocessor">#endif</span>
00156 <span class="preprocessor"></span>
00157     <a class="code" href="octUtils_8h.html#a4">PROF_BAL_BPART2_BEGIN</a>
00158 
00159       <a class="code" href="namespaceot.html#a29">blockPartStage2</a>(in, blocks, minsAllBlocks, dim, maxDepth, comm);
00160 
00161     <a class="code" href="octUtils_8h.html#a35">PROF_BAL_BPART2_END</a>
00162 
00163       <span class="comment">//blocks will be sorted.</span>
00164 
00165       assert(!blocks.empty());
00166     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> myFirstBlock = blocks[0];
00167     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> myLastBlock = blocks[blocks.size()-1];
00168 
00169 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00170 <span class="preprocessor"></span>    assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(myFirstBlock, in[0]));
00171     assert(myFirstBlock.<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(in[0]) || myFirstBlock == in[0]);
00172 <span class="preprocessor">#endif</span>
00173 <span class="preprocessor"></span>
00174 <span class="preprocessor">#ifdef __USE_AGV_FOR_BAL__</span>
00175 <span class="preprocessor"></span>    <span class="comment">// 1. locally assign wgts to all blocks. The wgts are set to the rank of</span>
00176     <span class="comment">// the processor so that the owner of the block can be easily identified.</span>
00177     <span class="comment">//We don't need to reset the weights of blocks later since weights are not</span>
00178     <span class="comment">//used anywhere else. All comparisons are based only on the Morton</span>
00179     <span class="comment">//ordering.</span>
00180     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; blocks.size(); i++) {
00181       blocks[i].setWeight(rank);
00182     }
00183 
00184     <span class="comment">// 2. Communicate the blocks to all processors.</span>
00185     <span class="keywordtype">int</span> totalSize=0;
00186     <span class="keywordtype">int</span> *blockSizes = <span class="keyword">new</span> <span class="keywordtype">int</span> [size];
00187     <span class="keywordtype">int</span> *blockDisps = <span class="keyword">new</span> <span class="keywordtype">int</span> [size];
00188 
00189     <span class="keywordtype">int</span> localBlockSize = blocks.size();
00190     <a class="code" href="octUtils_8h.html#a0">PROF_BAL_COMM_BEGIN</a>
00191 
00192       par::Mpi_Allgather&lt;int&gt;(&amp;localBlockSize, blockSizes, 1, comm);
00193 
00194     <a class="code" href="octUtils_8h.html#a36">PROF_BAL_COMM_END</a>
00195 
00196       totalSize += blockSizes[0];
00197     blockDisps[0] = 0;
00198     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt; size; i++) {
00199       totalSize += blockSizes[i];
00200       blockDisps[i] = blockDisps[i-1] + blockSizes[i-1];
00201     }<span class="comment">//end for i</span>
00202 
00203     <span class="comment">// allocate for the blocks ...</span>
00204     std::vector&lt;TreeNode&gt; allBlocks(totalSize);
00205 
00206     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* blocksPtr = NULL;
00207     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* allBlocksPtr = NULL;
00208     <span class="keywordflow">if</span>(!blocks.empty()) {
00209       blocksPtr = &amp;(*(blocks.begin()));
00210     }
00211     <span class="keywordflow">if</span>(!allBlocks.empty()) {
00212       allBlocksPtr = &amp;(*(allBlocks.begin()));
00213     }
00214     <a class="code" href="octUtils_8h.html#a0">PROF_BAL_COMM_BEGIN</a>
00215 
00216       par::Mpi_Allgatherv&lt;ot::TreeNode&gt;( blocksPtr, blockSizes[rank],
00217           allBlocksPtr, blockSizes, blockDisps, comm );
00218 
00219     <a class="code" href="octUtils_8h.html#a36">PROF_BAL_COMM_END</a>
00220 
00221 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
00222 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(!rank) {
00223         std::cout&lt;&lt;<span class="stringliteral">"# AllBlocks: "</span>&lt;&lt;allBlocks.size()&lt;&lt;std::endl;
00224         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00225           std::cout&lt;&lt;<span class="stringliteral">"blockSizes["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;blockSizes[i]&lt;&lt;std::endl;
00226         }
00227         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; allBlocks.size(); i++) {
00228           std::cout&lt;&lt;<span class="stringliteral">"allBlocks["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"].Wt() = "</span>&lt;&lt;(allBlocks[i].getWeight())&lt;&lt;std::endl;
00229         }
00230       }
00231 <span class="preprocessor">#endif</span>
00232 <span class="preprocessor"></span>
00233 <span class="preprocessor">#endif</span>
00234 <span class="preprocessor"></span>
00236     <span class="comment">//Local Balancing</span>
00237 
00238     <span class="comment">//Block Balance</span>
00239     std::vector&lt;ot::TreeNode&gt; allBoundaryLeaves;
00240     std::vector&lt;unsigned int&gt; maxBlockBndVec;
00241 
00242     <a class="code" href="namespaceot.html#a12">balanceBlocks</a>(in, blocks, out, allBoundaryLeaves, incCorner, &amp;maxBlockBndVec);
00243     in.clear();
00244 
00245 <span class="preprocessor">#ifdef __USE_AGV_FOR_BAL__</span>
00246 <span class="preprocessor"></span>    std::vector&lt;TreeNode&gt; myNhBlocks;
00247     <a class="code" href="namespaceot.html#a18">selectNeighboringBlocks</a>(allBlocks, blocks, maxBlockBndVec, rank, myNhBlocks);
00248 
00249     allBlocks.clear();
00250 
00251 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00252 <span class="preprocessor"></span>    MPI_Barrier(comm);
00253     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localMyNhBlocksSize = myNhBlocks.size();
00254     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* globalMyNhBlocksSize = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00255     par::Mpi_Gather&lt;unsigned int&gt;(&amp;localMyNhBlocksSize, globalMyNhBlocksSize, 1, 0, comm);
00256     <span class="keywordflow">if</span>(!rank) {
00257       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00258         std::cout&lt;&lt;<span class="stringliteral">"globalMyNhBlocksSize["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;globalMyNhBlocksSize[i]&lt;&lt;std::endl;
00259       }<span class="comment">//end for i</span>
00260     }
00261     <span class="keyword">delete</span> [] globalMyNhBlocksSize;
00262     MPI_Barrier(comm);
00263 <span class="preprocessor">#endif</span>
00264 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00265 <span class="preprocessor"></span>
00266     blocks.clear();
00267     maxBlockBndVec.clear();
00268 
00269 <span class="preprocessor">#ifdef __USE_AGV_FOR_BAL__</span>
00270 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(!myNhBlocks.empty()) {
00271       <span class="comment">//Merge (result must remain sorted and linear) our local</span>
00272       <span class="comment">//boundary leaves and myNhBlocks. We need to perform the</span>
00273       <span class="comment">//intra-processor local balance on this</span>
00274       <span class="comment">//combined list. Note, this step is slightly different from </span>
00275       <span class="comment">//what was described in the 2:1 balancing paper. In the algorithm, descibed</span>
00276       <span class="comment">//in the paper the blocks from other processors are not taken into account</span>
00277       <span class="comment">//for this step. By taking these blocks into account as well, we expect</span>
00278       <span class="comment">//to identify some very large octants early on and hence reduce the</span>
00279       <span class="comment">//insulation layer sizes before the actual 2-stage inter-processor step</span>
00280       std::vector&lt;ot::TreeNode&gt; boundaryAndOtherBlocks;
00281 
00282       <span class="comment">//Three Mutually Exclusive Cases:</span>
00283       <span class="keywordflow">if</span>(myNhBlocks[myNhBlocks.size()-1] &lt; myFirstBlock) {
00284         <span class="comment">//1) All myNhBlocks are &lt; myFirstBlock</span>
00285 
00286         boundaryAndOtherBlocks.insert(boundaryAndOtherBlocks.end(),
00287             myNhBlocks.begin(), myNhBlocks.end());
00288 
00289         boundaryAndOtherBlocks.insert(boundaryAndOtherBlocks.end(),
00290             allBoundaryLeaves.begin(), allBoundaryLeaves.end());
00291 
00292       } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(myNhBlocks[0] &gt; myLastBlock) {
00293         <span class="comment">//2) All myNhBlocks are &gt; myLastBlock</span>
00294 
00295         boundaryAndOtherBlocks.insert(boundaryAndOtherBlocks.end(),
00296             allBoundaryLeaves.begin(), allBoundaryLeaves.end());
00297 
00298         boundaryAndOtherBlocks.insert(boundaryAndOtherBlocks.end(),
00299             myNhBlocks.begin(), myNhBlocks.end());
00300 
00301       } <span class="keywordflow">else</span> {
00302         <span class="comment">//3 some myNhBlocks are &lt; myFirstBlock and some are &gt; myLastBlock</span>
00303 
00304         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myStIdxInNhBlocks = 0;
00305         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myEndIdxInNhBlocks = 0;
00306 
00307         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; myNhBlocks.size(); i++) {
00308           <span class="keywordflow">if</span>(myNhBlocks[i] &gt; myFirstBlock) {
00309             myStIdxInNhBlocks = i;
00310             <span class="keywordflow">break</span>;
00311           }
00312         }
00313 
00314         <span class="comment">//We don't need to use DLD here for comparison since there can not be</span>
00315         <span class="comment">//any overlap between our blocks/octants and myNhBlocks </span>
00316         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = myNhBlocks.size(); i &gt; 0; i--) {
00317           <span class="keywordflow">if</span>(myNhBlocks[i-1] &lt; myLastBlock) {
00318             myEndIdxInNhBlocks = i;
00319             <span class="keywordflow">break</span>;
00320           }
00321         }
00322 
00323         boundaryAndOtherBlocks.insert(boundaryAndOtherBlocks.begin(),
00324             myNhBlocks.begin(), (myNhBlocks.begin() + myStIdxInNhBlocks));
00325 
00326         boundaryAndOtherBlocks.insert(boundaryAndOtherBlocks.end(),
00327             allBoundaryLeaves.begin(), allBoundaryLeaves.end());
00328 
00329         boundaryAndOtherBlocks.insert(boundaryAndOtherBlocks.end(),
00330             (myNhBlocks.begin() + myEndIdxInNhBlocks), myNhBlocks.end());
00331 
00332       }
00333 
00334       allBoundaryLeaves.clear();
00335 
00336       <span class="comment">//Intra-processor Balance</span>
00337       <a class="code" href="namespaceot.html#a13">ripple</a>(boundaryAndOtherBlocks, incCorner);
00338 
00339       <span class="comment">//Extract the local boundary elements</span>
00340       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myStartIdx = 0;
00341       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myEndIdx = 0;
00342 
00343       <span class="keywordtype">bool</span> foundFirst = <span class="keyword">false</span>;
00344       <span class="keywordtype">bool</span> foundLast = <span class="keyword">false</span>;
00345       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; boundaryAndOtherBlocks.size(); i++) {
00346         <span class="keywordflow">if</span>(boundaryAndOtherBlocks[i] &gt;= myFirstBlock) {
00347           myStartIdx = i;
00348           foundFirst = <span class="keyword">true</span>;
00349           <span class="keywordflow">break</span>;
00350         }
00351       }
00352 
00353       <span class="comment">//We need DLD here since we need to account for descendants of</span>
00354       <span class="comment">//myLastBlock as well</span>
00355       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = boundaryAndOtherBlocks.size(); i &gt; 0; i--) {
00356         <span class="keywordflow">if</span>(boundaryAndOtherBlocks[i-1] &lt;= myLastBlock.<a class="code" href="classot_1_1TreeNode.html#a7">getDLD</a>()) {
00357           myEndIdx = i;
00358           foundLast = <span class="keyword">true</span>;
00359           <span class="keywordflow">break</span>;
00360         }
00361       }
00362 
00363 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00364 <span class="preprocessor"></span>      <span class="comment">//There must be at least one element belonging to our processor </span>
00365       assert(foundFirst &amp;&amp; foundLast);
00366 <span class="preprocessor">#endif</span>
00367 <span class="preprocessor"></span>
00368       allBoundaryLeaves.insert(allBoundaryLeaves.begin(),
00369           boundaryAndOtherBlocks.begin() + myStartIdx, 
00370           boundaryAndOtherBlocks.begin() + myEndIdx);
00371 
00372       boundaryAndOtherBlocks.clear();
00373 
00374     } <span class="keywordflow">else</span> {
00375       <span class="comment">//Intra-processor Balance</span>
00376       <a class="code" href="namespaceot.html#a13">ripple</a>(allBoundaryLeaves, incCorner);
00377     }<span class="comment">//end if myNhBlocks is empty</span>
00378     myNhBlocks.clear();
00379 <span class="preprocessor">#else</span>
00380 <span class="preprocessor"></span>    <span class="comment">//Intra-processor Balance</span>
00381     <a class="code" href="namespaceot.html#a13">ripple</a>(allBoundaryLeaves, incCorner);
00382 <span class="preprocessor">#endif</span>
00383 <span class="preprocessor"></span>
00384     <a class="code" href="namespaceot.html#a19">mergeComboBalAndPickBoundary</a>(out, allBoundaryLeaves, myFirstBlock, myLastBlock);
00385 
00386 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00387 <span class="preprocessor"></span>    MPI_Barrier(comm);
00388     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localAllBndSize = allBoundaryLeaves.size();
00389     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* globalAllBndSize = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00390     par::Mpi_Gather&lt;unsigned int&gt;(&amp;localAllBndSize, globalAllBndSize, 1, 0, comm);
00391     <span class="keywordflow">if</span>(!rank) {
00392       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00393         std::cout&lt;&lt;<span class="stringliteral">" globalAllBndSize["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"]= "</span>&lt;&lt;globalAllBndSize[i]&lt;&lt;std::endl;
00394       }<span class="comment">//end for i</span>
00395     }
00396     <span class="keyword">delete</span> [] globalAllBndSize;
00397     MPI_Barrier(comm);
00398 <span class="preprocessor">#endif</span>
00399 <span class="preprocessor"></span>
00400     <span class="comment">//There is no need to sort, the lists are already sorted.</span>
00401 
00403     <span class="comment">//Preparation for inter-processor balance....</span>
00404     <span class="comment">//First Stage of Communication...</span>
00405     std::vector&lt;TreeNode&gt; * sendNodes = <span class="keyword">new</span> std::vector&lt;TreeNode&gt; [size];
00406     std::vector&lt;unsigned int&gt; * sentToPid = NULL;
00407 
00408     std::vector&lt;ot::TreeNode&gt; sendK;
00409     <span class="keywordtype">int</span> *sendCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[size];
00410     <span class="keywordtype">int</span> *recvCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[size];
00411     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[size];
00412 
00413     <span class="comment">// 3. Loop through all local boundary nodes and determine which processors</span>
00414     <span class="comment">// need to be aware of those nodes. Create lists that shall be sent.</span>
00415 
00416     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00417       sendCnt[i] = 0;
00418       sendNodes[i].clear();
00419     }
00420 
00421     <span class="keywordflow">if</span>(!allBoundaryLeaves.empty()) {
00422       sentToPid = <span class="keyword">new</span> std::vector&lt;unsigned int&gt; [allBoundaryLeaves.size()];
00423     } <span class="keywordflow">else</span> {
00424       sentToPid = NULL;
00425     }
00426 
00427     <span class="comment">//create sendNodes</span>
00428     <a class="code" href="namespaceot.html#a25">prepareBalComm1MessagesType2</a>(allBoundaryLeaves, minsAllBlocks, rank, dim, maxDepth,
00429         sendNodes, sentToPid, sendCnt);
00430 
00431     <span class="comment">// 4. Actual send/recv. to exchange nodes.</span>
00432     <span class="comment">//</span>
00433     <span class="comment">// 4a.</span>
00434     <span class="comment">// Now do an All2All to get numKeysRecv</span>
00435     <a class="code" href="octUtils_8h.html#a0">PROF_BAL_COMM_BEGIN</a>
00436 
00437       par::Mpi_Alltoall&lt;int&gt;(sendCnt, recvCnt, 1, comm);
00438 
00439     <a class="code" href="octUtils_8h.html#a36">PROF_BAL_COMM_END</a>
00440 
00441 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00442 <span class="preprocessor"></span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsSend1 = 0;
00443     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsRecv1 = 0;
00444 <span class="preprocessor">#endif</span>
00445 <span class="preprocessor"></span>
00446     <span class="comment">// 4b. Concatenate all nodes into one single Carray ...</span>
00447     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalSend = 0;
00448     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalRecv = 0;
00449     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00450       totalSend += sendCnt[i];
00451       totalRecv += recvCnt[i];
00452 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00453 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(sendCnt[i]) {
00454         numProcsSend1++;
00455       }
00456       <span class="keywordflow">if</span>(recvCnt[i]) {
00457         numProcsRecv1++;
00458       }
00459 <span class="preprocessor">#endif</span>
00460 <span class="preprocessor"></span>    }<span class="comment">//end for i</span>
00461 
00462     <span class="comment">// create the send and recv buffers ...</span>
00463 
00464     <span class="keywordtype">int</span> *recvOffsets1 = <span class="keyword">new</span> <span class="keywordtype">int</span>[size];
00465 
00466     <span class="comment">// Now create sendK</span>
00467     sendOffsets[0] = 0;
00468     recvOffsets1[0] = 0;
00469 
00470     <span class="comment">// compute offsets ...</span>
00471     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; size; i++) {
00472       sendOffsets[i] = sendOffsets[i-1] + sendCnt[i-1];
00473       recvOffsets1[i] = recvOffsets1[i-1] + recvCnt[i-1];
00474     }<span class="comment">//end for i</span>
00475 
00476     sendK.resize(totalSend);
00477     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00478 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00479 <span class="preprocessor"></span>      assert(seq::test::isUniqueAndSorted(sendNodes[i]));
00480 <span class="preprocessor">#endif</span>
00481 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; sendCnt[i]; j++) {
00482         sendK[sendOffsets[i] + j] = sendNodes[i][j];
00483       }<span class="comment">//end for j</span>
00484     }<span class="comment">//end for i</span>
00485 
00486     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00487       sendNodes[i].clear();
00488     }
00489 
00490     <span class="comment">// 4c. Perform SendRecv to send and receive all keys ...</span>
00491     std::vector&lt;ot::TreeNode&gt; recvK1(totalRecv);
00492 
00493     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKptr = NULL;
00494     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvK1ptr = NULL;
00495     <span class="keywordflow">if</span>(!sendK.empty()) {
00496       sendKptr = &amp;(*(sendK.begin()));
00497     }
00498     <span class="keywordflow">if</span>(!recvK1.empty()) {
00499       recvK1ptr = &amp;(*(recvK1.begin()));
00500     }
00501 
00502     <a class="code" href="octUtils_8h.html#a0">PROF_BAL_COMM_BEGIN</a>
00503 
00504       par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;(sendKptr, sendCnt, sendOffsets,        
00505           recvK1ptr, recvCnt, recvOffsets1, comm);
00506 
00507     <a class="code" href="octUtils_8h.html#a36">PROF_BAL_COMM_END</a>
00508 
00509       sendK.clear();
00510 
00511 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00512 <span class="preprocessor"></span>    MPI_Barrier(comm);
00513     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalSend1 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00514     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecv1 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00515     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsSend1 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00516     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsRecv1 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00517     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalSend, allTotalSend1, 1, 0, comm);
00518     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalRecv, allTotalRecv1, 1, 0, comm);
00519     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsSend1, allNumProcsSend1, 1, 0, comm);
00520     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsRecv1, allNumProcsRecv1, 1, 0, comm);
00521     <span class="keywordflow">if</span>(!rank) {
00522       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00523         std::cout&lt;&lt;<span class="stringliteral">"allTotalSend1["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allTotalSend1[i]&lt;&lt;std::endl; 
00524         std::cout&lt;&lt;<span class="stringliteral">"allTotalRecv1["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allTotalRecv1[i]&lt;&lt;std::endl; 
00525         std::cout&lt;&lt;<span class="stringliteral">"allNumProcsSend1["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allNumProcsSend1[i]&lt;&lt;std::endl; 
00526         std::cout&lt;&lt;<span class="stringliteral">"allNumProcsRecv1["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allNumProcsRecv1[i]&lt;&lt;std::endl; 
00527       }
00528     }
00529     <span class="keyword">delete</span> [] allTotalSend1;
00530     <span class="keyword">delete</span> [] allTotalRecv1;
00531     <span class="keyword">delete</span> [] allNumProcsSend1;
00532     <span class="keyword">delete</span> [] allNumProcsRecv1;
00533     MPI_Barrier(comm);
00534 <span class="preprocessor">#endif</span>
00535 <span class="preprocessor"></span>
00537     <span class="comment">//Second Stage of Communication...</span>
00538     <span class="comment">// 5. Loop through all local boundary nodes and determine which processors</span>
00539     <span class="comment">// need to be aware of those nodes. Create lists that shall be sent.</span>
00540 
00541     std::vector&lt;ot::TreeNode&gt; wList;
00542     std::vector&lt;std::vector&lt;unsigned int&gt; &gt; wListRanks; 
00543 
00544     <a class="code" href="namespaceot.html#a22">prepareWlistInBal</a>(recvK1, recvCnt, size, myFirstBlock, myLastBlock, wList, wListRanks);
00545 
00546     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00547       sendCnt[i] = 0;
00548       sendNodes[i].clear();
00549     }
00550 
00551     <a class="code" href="namespaceot.html#a23">prepareBalComm2Messages</a>(allBoundaryLeaves, wList, wListRanks, 
00552         sendNodes, sentToPid, sendCnt);
00553 
00554     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; allBoundaryLeaves.size(); i++) {
00555       sentToPid[i].clear();
00556     }
00557 
00558     <span class="keywordflow">if</span>(sentToPid) {
00559       <span class="keyword">delete</span> [] sentToPid;
00560       sentToPid = NULL;
00561     }
00562 
00563     <span class="comment">// 6. Actual send/recv. to exchange nodes.</span>
00564     <span class="comment">//</span>
00565     <span class="comment">// 6a.</span>
00566     <span class="comment">// Now do an All2All to get numKeysRecv</span>
00567     <a class="code" href="octUtils_8h.html#a0">PROF_BAL_COMM_BEGIN</a>
00568 
00569       par::Mpi_Alltoall&lt;int&gt;(sendCnt, recvCnt, 1, comm);
00570 
00571     <a class="code" href="octUtils_8h.html#a36">PROF_BAL_COMM_END</a>
00572 
00573 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00574 <span class="preprocessor"></span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsSend2 = 0;
00575     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numProcsRecv2 = 0;
00576 <span class="preprocessor">#endif</span>
00577 <span class="preprocessor"></span>    <span class="comment">// 6b. Concatenate all nodes into one single Carray ...</span>
00578     totalSend = 0;
00579     totalRecv = 0;
00580     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00581       totalSend+= sendCnt[i];
00582       totalRecv+= recvCnt[i];
00583 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00584 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(sendCnt[i]) {
00585         numProcsSend2++;
00586       }
00587       <span class="keywordflow">if</span>(recvCnt[i]) {
00588         numProcsRecv2++;
00589       }
00590 <span class="preprocessor">#endif</span>
00591 <span class="preprocessor"></span>    }<span class="comment">//end for i</span>
00592 
00593     <span class="comment">// create the send and recv buffers ...</span>
00594 
00595     <span class="keywordtype">int</span> *recvOffsets2 = <span class="keyword">new</span> <span class="keywordtype">int</span>[size];
00596     <span class="comment">// Now create sendK</span>
00597     sendOffsets[0] = 0;
00598     recvOffsets2[0] = 0;
00599 
00600     <span class="comment">// compute offsets ...</span>
00601     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;size; i++) {
00602       sendOffsets[i] = sendOffsets[i-1] + sendCnt[i-1];
00603       recvOffsets2[i] = recvOffsets2[i-1] + recvCnt[i-1];
00604     }<span class="comment">//end for i</span>
00605 
00606     sendK.resize(totalSend);
00607     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;size; i++) {
00608 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00609 <span class="preprocessor"></span>      assert(seq::test::isUniqueAndSorted(sendNodes[i]));
00610 <span class="preprocessor">#endif</span>
00611 <span class="preprocessor"></span>      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; sendCnt[i]; j++) {
00612         sendK[sendOffsets[i] + j] = sendNodes[i][j];
00613       }<span class="comment">//end for j</span>
00614     }<span class="comment">//end for i</span>
00615 
00616     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00617       sendNodes[i].clear();
00618     }
00619 
00620     <span class="keyword">delete</span> [] sendNodes;
00621     sendNodes = NULL;
00622 
00623     std::vector&lt;ot::TreeNode&gt; recvK2(totalRecv);
00624 
00625     sendKptr = NULL;
00626     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvK2ptr = NULL;
00627     <span class="keywordflow">if</span>(!sendK.empty()) {
00628       sendKptr = &amp;(*(sendK.begin()));
00629     }
00630     <span class="keywordflow">if</span>(!recvK2.empty()) {
00631       recvK2ptr = &amp;(*(recvK2.begin()));
00632     }
00633 
00634     <a class="code" href="octUtils_8h.html#a0">PROF_BAL_COMM_BEGIN</a>
00635 
00636       par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;(sendKptr, sendCnt, sendOffsets,        
00637           recvK2ptr, recvCnt, recvOffsets2, comm);
00638 
00639     <a class="code" href="octUtils_8h.html#a36">PROF_BAL_COMM_END</a>
00640 
00641       sendK.clear();
00642 
00643     <span class="keyword">delete</span> [] sendCnt;
00644     sendCnt = NULL;
00645 
00646     <span class="keyword">delete</span> [] recvCnt;
00647     recvCnt = NULL;
00648 
00649     <span class="keyword">delete</span> [] sendOffsets;
00650     sendOffsets = NULL;
00651 
00652 
00653 <span class="preprocessor">#ifdef __MEASURE_BAL_COMM__</span>
00654 <span class="preprocessor"></span>    MPI_Barrier(comm);
00655     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalSend2 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00656     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecv2 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00657     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsSend2 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00658     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allNumProcsRecv2 = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[size];
00659     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalSend, allTotalSend2, 1, 0, comm);
00660     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalRecv, allTotalRecv2, 1, 0, comm);
00661     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsSend2, allNumProcsSend2, 1, 0, comm);
00662     par::Mpi_Gather&lt;unsigned int&gt;(&amp;numProcsRecv2, allNumProcsRecv2, 1, 0, comm);
00663     <span class="keywordflow">if</span>(!rank) {
00664       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; size; i++) {
00665         std::cout&lt;&lt;<span class="stringliteral">"allTotalSend2["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allTotalSend2[i]&lt;&lt;std::endl; 
00666         std::cout&lt;&lt;<span class="stringliteral">"allTotalRecv2["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allTotalRecv2[i]&lt;&lt;std::endl; 
00667         std::cout&lt;&lt;<span class="stringliteral">"allNumProcsSend2["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allNumProcsSend2[i]&lt;&lt;std::endl; 
00668         std::cout&lt;&lt;<span class="stringliteral">"allNumProcsRecv2["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] in bal: "</span>&lt;&lt;allNumProcsRecv2[i]&lt;&lt;std::endl; 
00669       }
00670     }
00671     <span class="keyword">delete</span> [] allTotalSend2;
00672     <span class="keyword">delete</span> [] allTotalRecv2;
00673     <span class="keyword">delete</span> [] allNumProcsSend2;
00674     <span class="keyword">delete</span> [] allNumProcsRecv2;
00675     MPI_Barrier(comm);
00676 <span class="preprocessor">#endif</span>
00677 <span class="preprocessor"></span>
00679 
00680     <span class="comment">//7.a.Merge (In-place) recieved keys from both stages of communication....</span>
00681     std::vector&lt;ot::TreeNode&gt; recvK;
00682 
00683     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myOff1 = recvOffsets1[rank];
00684     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myOff2 = recvOffsets2[rank];
00685     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myOff = myOff1 + myOff2;
00686 
00687     <a class="code" href="namespaceot.html#a24">mergeRecvKeysInBal</a>(recvK1, recvOffsets1, recvK2, recvOffsets2, size, recvK);
00688 
00689     <span class="keyword">delete</span> [] recvOffsets1;
00690     recvOffsets1 = NULL;
00691 
00692     recvK1.clear();
00693 
00694     <span class="keyword">delete</span> [] recvOffsets2;
00695     recvOffsets2 = NULL;
00696 
00697     recvK2.clear();
00698 
00699     <span class="comment">//7.b.Merge (In-place) recieved octants with local octants....</span>
00700     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = static_cast&lt;unsigned int&gt;(allBoundaryLeaves.size());
00701     std::vector &lt;TreeNode &gt; nodes( recvK.size() + n );
00702 
00703     <span class="comment">//Note this is an inplace insertion. This is done to preserve the sorted</span>
00704     <span class="comment">//order. Each recvK[i] is independently sorted. Also, since the intial</span>
00705     <span class="comment">//blocks were globally sorted and since the elements on each processor are</span>
00706     <span class="comment">//only decendants of these blocks, hence recvK[i][j] &lt; recvK[i+][k] for all i,j</span>
00707     <span class="comment">//and k.</span>
00708     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; myOff; i++) {
00709       nodes[i] = recvK[i];
00710     }
00711     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = myOff; i &lt; myOff + n; i++) {
00712       nodes[i] = allBoundaryLeaves[i - myOff];
00713     }
00714     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = myOff + n; i &lt; nodes.size(); i++) {
00715       nodes[i] = recvK[i - n];
00716     }
00717     recvK.clear();
00718     allBoundaryLeaves.clear();
00719 
00721 
00722     <span class="comment">// 8. Now perform seq. balance on the new list of local nodes.</span>
00723     <a class="code" href="namespaceot.html#a13">ripple</a>(nodes, incCorner);
00724 
00726     <span class="comment">// 9. Discard all nodes that do not belong to the original domain. This can</span>
00727     <span class="comment">// easily be obtained from the mins of blocks. </span>
00728     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myStIdxInNodes = 0;
00729     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myEndIdxInNodes = 0;
00730     <span class="keywordtype">bool</span> foundStart = <span class="keyword">false</span>;
00731     <span class="keywordtype">bool</span> foundEnd = <span class="keyword">false</span>;
00732     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodes.size(); i++) {
00733       <span class="keywordflow">if</span>(nodes[i] &gt;= myFirstBlock) {
00734         myStIdxInNodes = i;
00735         foundStart = <span class="keyword">true</span>;
00736         <span class="keywordflow">break</span>;
00737       }
00738     }
00739 
00740     <span class="comment">//We need DLD here since we need to account for descendants of</span>
00741     <span class="comment">//myLastBlock as well</span>
00742     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = nodes.size(); i &gt; 0; i--) {
00743       <span class="keywordflow">if</span>(nodes[i-1] &lt;= myLastBlock.<a class="code" href="classot_1_1TreeNode.html#a7">getDLD</a>()) {
00744         myEndIdxInNodes = i;
00745         foundEnd = <span class="keyword">true</span>;
00746         <span class="keywordflow">break</span>;
00747       }
00748     }
00749 
00750 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00751 <span class="preprocessor"></span>    assert(foundStart &amp;&amp; foundEnd);
00752 <span class="preprocessor">#endif</span>
00753 <span class="preprocessor"></span>
00754     allBoundaryLeaves.insert(allBoundaryLeaves.begin(),
00755         (nodes.begin() + myStIdxInNodes), (nodes.begin() + myEndIdxInNodes));
00756 
00757     nodes.clear();
00758 
00759     <span class="comment">//10.Merge (In-place) results from all three stages....</span>
00760     <a class="code" href="namespaceot.html#a20">finalMergeInBal</a>(out, allBoundaryLeaves);
00761 
00762     <a class="code" href="octUtils_8h.html#a50">PROF_BAL_END</a>
00763   }<span class="comment">//end function</span>
00764 
00765   <span class="comment">//Assumption: in is sorted, linear and the morton space between the first and</span>
00766   <span class="comment">//last elements is complete.</span>
<a name="l00767"></a><a class="code" href="namespaceot.html#a11">00767</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a11">comboRipple</a>(std::vector&lt;TreeNode&gt; &amp; in, <span class="keywordtype">bool</span> incCorner, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxNum) {
00768     <a class="code" href="octUtils_8h.html#a23">PROF_COMBO_RIPPLE_BEGIN</a>
00769 
00770       <span class="keywordflow">if</span> (in.size() &lt; 2) {
00771         <a class="code" href="octUtils_8h.html#a62">PROF_COMBO_RIPPLE_END</a>
00772       }
00773 
00774     std::vector&lt;ot::TreeNode&gt; blocks;
00775     std::vector&lt;ot::TreeNode&gt; out;
00776     std::vector&lt;ot::TreeNode&gt; allBoundaryLeaves;
00777 
00778     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> nca = <a class="code" href="namespaceot.html#a47">getNCA</a>(in[0],in[in.size()-1]);
00779     nca.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(blocks);
00780 
00781     assert(maxNum &gt; 0);
00782 
00783     <span class="keywordflow">if</span> (in.size() &gt; maxNum) {
00784       std::vector&lt;TreeNode&gt; *splitInp = NULL;
00785 
00786       <span class="keywordflow">if</span>(!blocks.empty()) {
00787         splitInp = <span class="keyword">new</span> std::vector&lt;TreeNode&gt; [blocks.size()];
00788       }
00789 
00790       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextPt = 0;
00791       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextNode = 0;
00792       <span class="comment">//All elements of inp are inside some element in blocks.</span>
00793       <span class="keywordflow">while</span> (nextPt &lt; in.size()) {
00794         <span class="comment">//The first pt must be inside some block.</span>
00795 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00796 <span class="preprocessor"></span>        assert(nextNode &lt; blocks.size());
00797         assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(blocks[nextNode], in[nextPt]));
00798 <span class="preprocessor">#endif</span>
00799 <span class="preprocessor"></span>        <span class="keywordflow">if</span> ((blocks[nextNode].isAncestor(in[nextPt])) ||
00800             (blocks[nextNode] == in[nextPt])) {
00801           splitInp[nextNode].push_back(in[nextPt]);
00802           nextPt++;
00803         } <span class="keywordflow">else</span> {
00804           nextNode++;
00805           <span class="keywordflow">if</span> (nextNode == blocks.size()) {
00806             assert(<span class="keyword">false</span>);
00807           }
00808         }
00809       }<span class="comment">//end while</span>
00810       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; blocks.size(); i++) {
00811         <a class="code" href="namespaceot.html#a11">comboRipple</a>(splitInp[i], incCorner, maxNum);
00812       }<span class="comment">//end for i</span>
00813 
00814       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allBoundarySz = 0;
00815       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blockOutSize = 0;
00816 
00817       std::vector&lt;TreeNode&gt; *blockBoundaries = NULL;
00818 
00819       <span class="keywordflow">if</span>(!blocks.empty()) {
00820         blockBoundaries = <span class="keyword">new</span> std::vector&lt;TreeNode&gt;[blocks.size()];
00821       }
00822 
00823       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numEmptyBlocks=0;
00824       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bi = 0; bi &lt; blocks.size(); bi++) {
00825         <span class="keywordflow">if</span> (splitInp[bi].empty()) {
00826           <span class="keywordflow">continue</span>; 
00827         }
00828         blockOutSize += splitInp[bi].size();
00829         <span class="keywordflow">if</span> (splitInp[bi].size() &gt; 1) {
00830           blocks[bi].<a class="code" href="classot_1_1TreeNode.html#a20">pickInternalBoundaryCells</a>(splitInp[bi], blockBoundaries[bi]);
00831         }
00832         <span class="keywordflow">if</span> (blockBoundaries[bi].empty()) {
00833           <span class="comment">//the case where splitInp[bi] = blocks[bi].</span>
00834           blockBoundaries[bi].push_back(blocks[bi]);  
00835           numEmptyBlocks++;
00836         }
00837         allBoundarySz += blockBoundaries[bi].size();
00838       }<span class="comment">//end for bi</span>
00839 
00840       <span class="comment">//Concatenate the lists into out and allBoundaryLeaves</span>
00841       out.resize(blockOutSize);
00842       allBoundaryLeaves.resize(allBoundarySz);
00843       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeCtr = 0;
00844       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> boundaryCtr = 0;
00845       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bi = 0; bi &lt; blocks.size(); bi++) {
00846         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bj = 0; bj &lt; splitInp[bi].size(); bj++) {
00847           out[nodeCtr] = splitInp[bi][bj];
00848           nodeCtr++;
00849         }
00850         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bj = 0; bj &lt; blockBoundaries[bi].size(); bj++) {
00851           allBoundaryLeaves[boundaryCtr] = blockBoundaries[bi][bj];
00852           boundaryCtr++;
00853         }
00854       }<span class="comment">//end for bi</span>
00855       <span class="keyword">delete</span> [] splitInp;
00856       splitInp = NULL;
00857 
00858       <span class="keyword">delete</span> [] blockBoundaries;
00859       blockBoundaries = NULL;
00860     } <span class="keywordflow">else</span> {
00861       <a class="code" href="namespaceot.html#a12">balanceBlocks</a> (in, blocks, out, allBoundaryLeaves, incCorner); 
00862     }
00863 
00864     in.clear();
00865 
00866     <span class="comment">//Inter-Block Balance</span>
00867     <a class="code" href="namespaceot.html#a13">ripple</a>(allBoundaryLeaves, incCorner);
00868 
00869     <span class="comment">//Merge (in-place) results from the two stages....</span>
00870     in.resize(out.size() + allBoundaryLeaves.size());
00871     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpLsz=0;
00872     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bndCnt=0;
00873     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =0;i&lt;out.size();i++) {
00874       <span class="keywordflow">if</span> ( bndCnt &lt; allBoundaryLeaves.size() ) {
00875         <span class="keywordflow">if</span> ( out[i] == allBoundaryLeaves[bndCnt] ) {
00876           in[tmpLsz++] = out[i];
00877           bndCnt++;
00878         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (out[i] &lt; allBoundaryLeaves[bndCnt] ) {
00879 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00880 <span class="preprocessor"></span>          assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], allBoundaryLeaves[bndCnt]));
00881 <span class="preprocessor">#endif</span>
00882 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (out[i].isAncestor(allBoundaryLeaves[bndCnt]) ) {
00883             <span class="keywordflow">while</span> ( (bndCnt &lt; allBoundaryLeaves.size()) &amp;&amp; 
00884                 out[i].isAncestor(allBoundaryLeaves[bndCnt]) ) {
00885               in[tmpLsz++] = allBoundaryLeaves[bndCnt++];
00886 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00887 <span class="preprocessor"></span>              <span class="keywordflow">if</span>(bndCnt &lt; allBoundaryLeaves.size()) {
00888                 assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], allBoundaryLeaves[bndCnt]));
00889               }
00890 <span class="preprocessor">#endif</span>
00891 <span class="preprocessor"></span>            }
00892           } <span class="keywordflow">else</span> {
00893             in[tmpLsz++] = out[i];
00894           }
00895         } <span class="keywordflow">else</span> {
00896           <span class="comment">// nodes[i] &gt; allBdy .. so insert </span>
00897           in[tmpLsz++] = allBoundaryLeaves[bndCnt++];
00898         }
00899       } <span class="keywordflow">else</span> {
00900         in[tmpLsz++] = out[i];
00901       }
00902     }<span class="comment">//end for i</span>
00903 
00904     in.resize(tmpLsz);
00905     out.clear();
00906 
00907     <span class="comment">//There is no need to sort, the lists are already sorted.</span>
00908     <a class="code" href="octUtils_8h.html#a62">PROF_COMBO_RIPPLE_END</a>
00909   }<span class="comment">//end function</span>
00910 
00911   <span class="comment">//Assumption: All elements of inp are inside some unique element in blocks.</span>
<a name="l00912"></a><a class="code" href="namespaceot.html#a12">00912</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a12">balanceBlocks</a> (<span class="keyword">const</span> std::vector&lt;TreeNode&gt; &amp;inp,
00913       <span class="keyword">const</span> std::vector&lt;TreeNode&gt; &amp;blocks, std::vector&lt;TreeNode&gt; &amp;nodes,
00914       std::vector&lt;TreeNode&gt; &amp;allBoundaryLeaves, <span class="keywordtype">bool</span> incCorner, 
00915       std::vector&lt;unsigned int&gt; *maxBlockBndVec ) {
00916     <a class="code" href="octUtils_8h.html#a24">PROF_CON_BAL_BEGIN</a>
00917 
00918       <span class="keywordflow">if</span> (inp.empty()) {
00919         nodes.clear();
00920         allBoundaryLeaves.clear();
00921         <span class="keywordflow">if</span> (maxBlockBndVec != NULL) {
00922           maxBlockBndVec-&gt;clear();
00923         }
00924         <a class="code" href="octUtils_8h.html#a63">PROF_CON_BAL_END</a>
00925       }
00926 
00927     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextPt;
00928     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextNode;
00929 
00930     assert(!blocks.empty());
00931     std::vector&lt;TreeNode&gt; *blockOut = <span class="keyword">new</span> std::vector&lt;TreeNode&gt; [blocks.size()];
00932     std::vector&lt;TreeNode&gt; *splitInp = <span class="keyword">new</span> std::vector&lt;TreeNode&gt; [blocks.size()];
00933 
00934     nextPt =0;
00935     nextNode=0;
00936     <span class="comment">//All elements of inp are inside some element in blocks.</span>
00937     <span class="keywordflow">while</span> (nextPt&lt;inp.size()) {
00938       <span class="comment">//The first pt must be inside some block.</span>
00939 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00940 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(blocks[nextNode], inp[nextPt]));
00941 <span class="preprocessor">#endif</span>
00942 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ((blocks[nextNode].isAncestor(inp[nextPt])) ||
00943           (blocks[nextNode] == inp[nextPt])) {
00944         splitInp[nextNode].push_back(inp[nextPt]);
00945         nextPt++;
00946       } <span class="keywordflow">else</span> {
00947         nextNode++;
00948         <span class="keywordflow">if</span> (nextNode == blocks.size()) {
00949           assert(<span class="keyword">false</span>);
00950         }
00951       }
00952     }<span class="comment">//end while</span>
00953 
00954     <span class="comment">//Create Local Trees</span>
00955     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bi=0;bi&lt;blocks.size();bi++) {
00956       <span class="comment">//This also sorts and makes the vector unique inside.</span>
00957       blocks[bi].<a class="code" href="classot_1_1TreeNode.html#a3">balanceSubtree</a>(splitInp[bi],blockOut[bi],incCorner,<span class="keyword">true</span>);
00958 
00959       splitInp[bi].clear();
00960       <span class="comment">//This tackles the case where blocks[bi] has no decendants.</span>
00961       <span class="keywordflow">if</span> (blockOut[bi].empty()) {
00962         blockOut[bi].push_back(blocks[bi]);
00963       }
00964     }<span class="comment">//end for bi</span>
00965 
00966     <span class="keyword">delete</span> [] splitInp; 
00967     splitInp = NULL;
00968 
00969     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allBoundarySz = 0;
00970     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> blockOutSize = 0;
00971 
00972     std::vector&lt;TreeNode&gt; *blockBoundaries = 
00973       <span class="keyword">new</span> std::vector&lt;TreeNode&gt;[blocks.size()];
00974 
00975     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numEmptyBlocks=0;
00976     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bi = 0; bi &lt; blocks.size(); bi++) {
00977       blockOutSize += blockOut[bi].size();
00978       <span class="keywordflow">if</span> (blockOut[bi].size() &gt; 1) {
00979         blocks[bi].<a class="code" href="classot_1_1TreeNode.html#a20">pickInternalBoundaryCells</a>(blockOut[bi],blockBoundaries[bi]);
00980       }
00981       <span class="keywordflow">if</span> (blockBoundaries[bi].empty()) {
00982         <span class="comment">//the case where blockOut[bi] = blocks[bi].</span>
00983         blockBoundaries[bi].push_back(blocks[bi]);  
00984         numEmptyBlocks++;
00985       }
00986       allBoundarySz += blockBoundaries[bi].size();
00987     }<span class="comment">//end for bi</span>
00988 
00989     <span class="comment">//Concatenate the lists into nodes and allBoundaryLeaves</span>
00990     nodes.resize(blockOutSize);
00991     allBoundaryLeaves.resize(allBoundarySz);
00992     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nodeCtr = 0;
00993     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> boundaryCtr = 0;
00994 
00995     <span class="keywordflow">if</span> (maxBlockBndVec != NULL) {
00996       maxBlockBndVec-&gt;resize(blocks.size());
00997       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth;
00998       <span class="keywordflow">if</span> (!blocks.empty()) {
00999         maxDepth = blocks[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();  
01000       }
01001       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bi = 0; bi &lt; blocks.size(); bi++) {
01002         (*maxBlockBndVec)[bi] = 0;
01003         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bj = 0; bj &lt; blockOut[bi].size(); bj++) {
01004           nodes[nodeCtr] = blockOut[bi][bj];
01005           nodeCtr++;
01006         }<span class="comment">//end for bj</span>
01007         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bj = 0; bj &lt; blockBoundaries[bi].size(); bj++) {
01008           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = (1u&lt;&lt;(maxDepth - (blockBoundaries[bi][bj].getLevel())));
01009           <span class="keywordflow">if</span> (len &gt; ((*maxBlockBndVec)[bi])) {
01010             (*maxBlockBndVec)[bi] = len;
01011           }
01012           allBoundaryLeaves[boundaryCtr] = blockBoundaries[bi][bj];
01013           boundaryCtr++;
01014         }<span class="comment">//end for bj</span>
01015       }<span class="comment">//end for bi</span>
01016     } <span class="keywordflow">else</span> {
01017       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bi = 0; bi &lt; blocks.size(); bi++) {
01018         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bj = 0; bj &lt; blockOut[bi].size(); bj++) {
01019           nodes[nodeCtr] = blockOut[bi][bj];
01020           nodeCtr++;
01021         }<span class="comment">//end for bj</span>
01022         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bj = 0; bj &lt; blockBoundaries[bi].size(); bj++) {
01023           allBoundaryLeaves[boundaryCtr] = blockBoundaries[bi][bj];
01024           boundaryCtr++;
01025         }<span class="comment">//end for bj</span>
01026       }<span class="comment">//end for bi</span>
01027     }
01028 
01029     <span class="keyword">delete</span> [] blockOut;
01030     blockOut = NULL;
01031 
01032     <span class="keyword">delete</span> [] blockBoundaries;
01033     blockBoundaries = NULL;
01034 
01035     <a class="code" href="octUtils_8h.html#a63">PROF_CON_BAL_END</a>
01036   }<span class="comment">//end function</span>
01037 
01038   <span class="comment">/*</span>
01039 <span class="comment">  //New implementation of the ripple algorithm. Implemented on Dec 22, 2007.</span>
01040 <span class="comment">  int ripple(std::vector&lt;TreeNode&gt; &amp; nodes, bool incCorners) {</span>
01041 <span class="comment">  PROF_RIPPLE_BAL_BEGIN </span>
01042 <span class="comment"></span>
01043 <span class="comment">  if (!nodes.size()) {</span>
01044 <span class="comment">  PROF_RIPPLE_BAL_END </span>
01045 <span class="comment">  }</span>
01046 <span class="comment"></span>
01047 <span class="comment">  unsigned int dim = nodes[0].getDim();</span>
01048 <span class="comment">  unsigned int maxDepth = nodes[0].getMaxDepth();</span>
01049 <span class="comment">  TreeNode root(dim,maxDepth);</span>
01050 <span class="comment"></span>
01051 <span class="comment">  unsigned int maxLev = 1;</span>
01052 <span class="comment">  for (unsigned int i=0;i&lt;nodes.size();i++) {</span>
01053 <span class="comment">  if (nodes[i].getLevel() &gt; maxLev) {</span>
01054 <span class="comment">  maxLev = nodes[i].getLevel();</span>
01055 <span class="comment">  }</span>
01056 <span class="comment">  }//end for </span>
01057 <span class="comment"></span>
01058 <span class="comment">  for (unsigned int lev = maxLev; lev &gt; 2; lev--) {</span>
01059 <span class="comment">  unsigned int mLev = maxDepth;</span>
01060 <span class="comment">  for (unsigned int i=0;i&lt;nodes.size();i++) {</span>
01061 <span class="comment">  if (nodes[i].getLevel() &lt; mLev) {</span>
01062 <span class="comment">  mLev = nodes[i].getLevel();</span>
01063 <span class="comment">  }</span>
01064 <span class="comment">  }//end for </span>
01065 <span class="comment"></span>
01066 <span class="comment">  if (mLev &gt;= (lev-1)) {</span>
01067 <span class="comment">//Difference between min and max levels is less than 2 .</span>
01068 <span class="comment">break;</span>
01069 <span class="comment">}</span>
01070 <span class="comment"></span>
01071 <span class="comment">std::vector&lt;TreeNode&gt; wList;      </span>
01072 <span class="comment">unsigned int wLen = 0;</span>
01073 <span class="comment">wList.resize(nodes.size());</span>
01074 <span class="comment">//Pick leaves at a particular level</span>
01075 <span class="comment">for (int i =0;i&lt;nodes.size();i++) {</span>
01076 <span class="comment">if (nodes[i].getLevel() == lev) {</span>
01077 <span class="comment">wList[wLen++] = nodes[i];</span>
01078 <span class="comment">}</span>
01079 <span class="comment">}//end for i</span>
01080 <span class="comment">wList.resize(wLen);</span>
01081 <span class="comment"></span>
01082 <span class="comment">std::vector&lt;std::vector&lt;TreeNode&gt; &gt; tList(wLen);</span>
01083 <span class="comment">for (unsigned int i=0; i &lt; wLen; i++) {</span>
01084 <span class="comment">tList[i] = wList[i].getSearchKeys(incCorners);        </span>
01085 <span class="comment">}//end for i</span>
01086 <span class="comment">wList.clear();</span>
01087 <span class="comment"></span>
01088 <span class="comment">std::vector&lt;TreeNode&gt; allKeys;</span>
01089 <span class="comment">for (unsigned int i=0; i &lt; wLen; i++) {</span>
01090 <span class="comment">for(unsigned int j=0; j &lt; tList[i].size(); j++) {</span>
01091 <span class="comment">if(tList[i][j] &gt; root) {</span>
01092 <span class="comment">allKeys.push_back(tList[i][j]);</span>
01093 <span class="comment">}</span>
01094 <span class="comment">}</span>
01095 <span class="comment">}    </span>
01096 <span class="comment">tList.clear();</span>
01097 <span class="comment"></span>
01098 <span class="comment">par::makeVectorUnique&lt;ot::TreeNode&gt;(allKeys, false);</span>
01099 <span class="comment">unsigned int keyLen = allKeys.size();</span>
01100 <span class="comment"></span>
01101 <span class="comment">std::vector&lt;std::vector&lt;TreeNode&gt; &gt; seedList(nodes.size());</span>
01102 <span class="comment">unsigned int lastIdx = 0;</span>
01103 <span class="comment">for (int i = 0; i &lt; keyLen; i++) {</span>
01104 <span class="comment">unsigned int idx;</span>
01105 <span class="comment">//assumes nodes is sorted and unique.          </span>
01106 <span class="comment">bool flag = par::maxLowerBound&lt;TreeNode&gt;(nodes, allKeys[i], idx, &amp;lastIdx, NULL);</span>
01107 <span class="comment">if (flag) {</span>
01108 <span class="comment">lastIdx = idx;</span>
01109 <span class="comment">if (nodes[idx].isAncestor(allKeys[i])) {</span>
01110 <span class="comment">  if (lev &gt; (nodes[idx].getLevel() + 1 )) {</span>
01111 <span class="comment">    seedList[idx].push_back(allKeys[i].getAncestor(lev-1));                </span>
01112 <span class="comment">  }//end if correct result</span>
01113 <span class="comment">}</span>
01114 <span class="comment">} //end if flag</span>
01115 <span class="comment">}//end for i   </span>
01116 <span class="comment">allKeys.clear();</span>
01117 <span class="comment"></span>
01118 <span class="comment">//Include the new octants in the octree</span>
01119 <span class="comment">//while preserving linearity and sorted order</span>
01120 <span class="comment"></span>
01121 <span class="comment">//Seedlist may have duplicates. Seedlist </span>
01122 <span class="comment">// will be sorted.</span>
01123 <span class="comment"></span>
01124 <span class="comment">std::vector&lt;TreeNode&gt; tmpList;</span>
01125 <span class="comment">std::vector&lt;std::vector&lt;TreeNode&gt; &gt;allInternalLeaves(nodes.size());</span>
01126 <span class="comment">unsigned int tmpSz = 0;</span>
01127 <span class="comment">for (unsigned int i=0;i&lt;nodes.size();i++) {                </span>
01128 <span class="comment">  par::makeVectorUnique&lt;TreeNode&gt;(seedList[i],true);</span>
01129 <span class="comment">  if (!seedList[i].empty()) {</span>
01130 <span class="comment">    nodes[i].completeSubtree(seedList[i], allInternalLeaves[i]);</span>
01131 <span class="comment">  }</span>
01132 <span class="comment">  tmpSz += allInternalLeaves[i].size();</span>
01133 <span class="comment">  if (allInternalLeaves[i].empty()) {</span>
01134 <span class="comment">    tmpSz++;</span>
01135 <span class="comment">  }</span>
01136 <span class="comment">  seedList[i].clear();</span>
01137 <span class="comment">}//end for i</span>
01138 <span class="comment"></span>
01139 <span class="comment">seedList.clear();</span>
01140 <span class="comment">tmpList.resize(tmpSz);</span>
01141 <span class="comment">tmpSz=0;</span>
01142 <span class="comment">for (unsigned int i=0;i&lt;nodes.size();i++) {</span>
01143 <span class="comment">  if (!allInternalLeaves[i].empty()) {</span>
01144 <span class="comment">    for (int k=0;k&lt;allInternalLeaves[i].size();k++) {</span>
01145 <span class="comment">      tmpList[tmpSz++] = allInternalLeaves[i][k];</span>
01146 <span class="comment">    }//end for k</span>
01147 <span class="comment">    allInternalLeaves[i].clear();</span>
01148 <span class="comment">  } else {</span>
01149 <span class="comment">    tmpList[tmpSz++] = nodes[i];</span>
01150 <span class="comment">  }</span>
01151 <span class="comment">}//end for i</span>
01152 <span class="comment">allInternalLeaves.clear();</span>
01153 <span class="comment">nodes = tmpList;</span>
01154 <span class="comment">tmpList.clear();</span>
01155 <span class="comment">}//end for lev</span>
01156 <span class="comment"></span>
01157 <span class="comment">PROF_RIPPLE_BAL_END </span>
01158 <span class="comment">}//end function</span>
01159 <span class="comment">*/</span>
01160 
01161 <span class="comment">//Original implementation of the ripple algorithm</span>
<a name="l01162"></a><a class="code" href="namespaceot.html#a13">01162</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a13">ripple</a>(std::vector&lt;TreeNode&gt; &amp; nodes, <span class="keywordtype">bool</span> incCorners) {
01163   <a class="code" href="octUtils_8h.html#a25">PROF_RIPPLE_BAL_BEGIN</a> 
01164 
01165     <span class="keywordflow">if</span> (!nodes.size()) {
01166       <a class="code" href="octUtils_8h.html#a64">PROF_RIPPLE_BAL_END</a> 
01167     }
01168 
01169   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = nodes[0].<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
01170   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = nodes[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
01171   <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root(dim,maxDepth);
01172 
01173   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxLev = 1;
01174   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) {
01175     <span class="keywordflow">if</span> (nodes[i].getLevel() &gt; maxLev) {
01176       maxLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01177     }
01178   }<span class="comment">//end for </span>
01179 
01180   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = maxLev; lev &gt; 2; lev--) {
01181     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mLev = maxDepth;
01182     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) {
01183       <span class="keywordflow">if</span> (nodes[i].getLevel() &lt; mLev) {
01184         mLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01185       }
01186     }<span class="comment">//end for </span>
01187 
01188     <span class="keywordflow">if</span> (mLev &gt;= (lev-1)) {
01189       <span class="comment">//Difference between min and max levels is less than 2 .</span>
01190       <span class="keywordflow">break</span>;
01191     }
01192 
01193     std::vector&lt;TreeNode&gt; wList;
01194     std::vector&lt;std::vector&lt;TreeNode&gt; &gt; seedList(nodes.size());
01195     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wLen = 0;
01196     wList.resize(nodes.size());
01197 
01198     <span class="comment">//Pick leaves at a particular level</span>
01199     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i =0;i&lt;nodes.size();i++) {
01200       <span class="keywordflow">if</span> (nodes[i].getLevel() == lev) {
01201         wList[wLen++] = nodes[i];
01202       }
01203     }<span class="comment">//end for i</span>
01204     wList.resize(wLen);
01205 
01206     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wList.size(); i++) {
01207       std::vector&lt;TreeNode&gt; tList = wList[i].<a class="code" href="classot_1_1TreeNode.html#a10">getSearchKeys</a>(incCorners);
01208       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;tList.size(); j++) {
01209         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01210         <span class="comment">//assumes nodes is sorted and unique.          </span>
01211         <span class="keywordtype">bool</span> flag = seq::maxLowerBound&lt;TreeNode&gt;(nodes, tList[j], idx,NULL,NULL);
01212         <span class="keywordflow">if</span> (flag) {
01213 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01214 <span class="preprocessor"></span>          assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(nodes[idx], tList[j]));
01215 <span class="preprocessor">#endif</span>
01216 <span class="preprocessor"></span>          <span class="keywordflow">if</span> (nodes[idx].isAncestor(tList[j])) {
01217             <span class="keywordflow">if</span> (wList[i].getLevel() &gt; (nodes[idx].getLevel() + 1 )) {
01218               nodes[idx].<a class="code" href="classot_1_1TreeNode.html#a0">addBalancingDescendants</a>(wList[i],
01219                   seedList[idx], incCorners);
01220             }<span class="comment">//end if failing balance</span>
01221           }<span class="comment">//end if valid result</span>
01222         } <span class="comment">//end if flag</span>
01223       }<span class="comment">//end for j</span>
01224       tList.clear();
01225     }<span class="comment">//end for i</span>
01226 
01227     wList.clear();
01228     std::vector&lt;TreeNode&gt; tmpList;
01229     std::vector&lt;std::vector&lt;TreeNode&gt; &gt;allInternalLeaves(nodes.size());
01230     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSz = 0;
01231     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) {
01232       seq::makeVectorUnique&lt;TreeNode&gt;(seedList[i],<span class="keyword">false</span>);
01233       <span class="keywordflow">if</span> (!seedList[i].empty()) {
01234         <span class="keywordflow">if</span> (seedList[i][0] == root) {
01235           seedList[i].erase(seedList[i].begin());
01236         }
01237       }
01238       <span class="keywordflow">if</span> (!seedList[i].empty()) {
01239         nodes[i].<a class="code" href="classot_1_1TreeNode.html#a4">completeSubtree</a>(seedList[i], allInternalLeaves[i]);
01240       }
01241       tmpSz += allInternalLeaves[i].size();
01242       <span class="keywordflow">if</span> (allInternalLeaves[i].empty()) {
01243         tmpSz++;
01244       }
01245       seedList[i].clear();
01246     }<span class="comment">//end for i</span>
01247     seedList.clear();
01248     tmpList.resize(tmpSz);
01249     tmpSz=0;
01250     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) {
01251       <span class="keywordflow">if</span> (!allInternalLeaves[i].empty()) {
01252         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;allInternalLeaves[i].size();k++) {
01253           tmpList[tmpSz++] = allInternalLeaves[i][k];
01254         }<span class="comment">//end for k</span>
01255         allInternalLeaves[i].clear();
01256       } <span class="keywordflow">else</span> {
01257         tmpList[tmpSz++] = nodes[i];
01258       }
01259     }<span class="comment">//end for i</span>
01260     allInternalLeaves.clear();
01261     nodes = tmpList;
01262     tmpList.clear();
01263   }<span class="comment">//end for lev</span>
01264 
01265   <a class="code" href="octUtils_8h.html#a64">PROF_RIPPLE_BAL_END</a> 
01266 }<span class="comment">//end function</span>
01267 
01268 
<a name="l01269"></a><a class="code" href="namespaceot.html#a14">01269</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a14">pointerBasedRipple</a>(std::vector&lt;ot::TreeNode&gt; &amp; nodes, <span class="keywordtype">bool</span> incCorners) {
01270   <a class="code" href="octUtils_8h.html#a26">PROF_PTR_RIPPLE_BAL_BEGIN</a>
01271 
01272     <span class="keywordflow">if</span> (!nodes.size()) {
01273       <a class="code" href="octUtils_8h.html#a65">PROF_PTR_RIPPLE_BAL_END</a> 
01274     }
01275 
01276   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = nodes[0].<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
01277   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = nodes[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
01278   <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root(dim,maxDepth);
01279 
01280   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxLev = 1;
01281   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodes.size(); i++) {
01282     <span class="keywordflow">if</span> (nodes[i].getLevel() &gt; maxLev) {
01283       maxLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01284     }
01285   }<span class="comment">//end for i</span>
01286 
01287   <a class="code" href="structot_1_1TreeNodePointer.html">TreeNodePointer</a> ptrOctree;
01288 
01289   <a class="code" href="namespaceot.html#a69">convertLinearToPointer</a>(nodes, ptrOctree);
01290 
01291   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = maxLev; lev &gt; 2; lev--) {
01292 
01293     <span class="comment">//Traverse the tree, select octants at level = lev and process them</span>
01294 
01295     std::vector&lt;ot::TreeNode&gt; wList;
01296 
01297     <a class="code" href="namespaceot.html#a68">appendOctantsAtLevel</a>(ptrOctree, wList, lev);
01298 
01299     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; wList.size(); i++) {
01300       std::vector&lt;TreeNode&gt; tList = wList[i].<a class="code" href="classot_1_1TreeNode.html#a10">getSearchKeys</a>(incCorners);
01301       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; tList.size(); j++) {
01302         <a class="code" href="structot_1_1TreeNodePointer.html">TreeNodePointer</a>* searchResult = NULL;
01303         <a class="code" href="namespaceot.html#a71">findOctantOrFinestAncestor</a>(ptrOctree, tList[j], searchResult);
01304 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01305 <span class="preprocessor"></span>        assert(searchResult);
01306         assert( ((searchResult-&gt;<a class="code" href="structot_1_1TreeNodePointer.html#o0">m_tnMe</a>).isAncestor(tList[j]))
01307             || ((searchResult-&gt;<a class="code" href="structot_1_1TreeNodePointer.html#o0">m_tnMe</a>) == tList[j]) );
01308         assert( (searchResult-&gt;<a class="code" href="structot_1_1TreeNodePointer.html#o1">m_tnpMyChildren</a>) == NULL );
01309 <span class="preprocessor">#endif</span>
01310 <span class="preprocessor"></span>        <span class="comment">//Check balance constraint</span>
01311         <span class="keywordflow">if</span>( ((searchResult-&gt;<a class="code" href="structot_1_1TreeNodePointer.html#o0">m_tnMe</a>).getLevel()) &lt; (lev - 1) ) {
01312           <a class="code" href="namespaceot.html#a70">addOctantToTreeNodePointer</a>((*searchResult),
01313               (tList[j].getAncestor((lev - 1))));
01314         }
01315       }<span class="comment">//end for j</span>
01316       tList.clear();
01317     }<span class="comment">//end for i</span>
01318 
01319     wList.clear();
01320 
01321   }<span class="comment">//end for lev</span>
01322 
01323   std::vector&lt;ot::TreeNode&gt; linOct;
01324 
01325   <a class="code" href="namespaceot.html#a72">convertPointerToLinear</a>(linOct, ptrOctree);
01326 
01327   <span class="comment">//Select only those octants from linOct, which are either present in nodes or</span>
01328   <span class="comment">//are decendants of octants in nodes.</span>
01329   <span class="comment">//assumes nodes is sorted, linear and unique.          </span>
01330   std::vector&lt;ot::TreeNode&gt; finalOct;
01331   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lCtr = 0;
01332   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nodes.size(); i++) {
01333     <span class="keywordflow">while</span>( (lCtr &lt; linOct.size()) &amp;&amp; (linOct[lCtr] &lt; nodes[i]) ) {
01334       lCtr++;
01335     }
01336     <span class="keywordflow">if</span>(lCtr &lt; linOct.size()) {
01337       <span class="keywordflow">if</span>(linOct[lCtr] == nodes[i]) {
01338         finalOct.push_back(nodes[i]);
01339       } <span class="keywordflow">else</span> {
01340 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01341 <span class="preprocessor"></span>        assert(nodes[i].isAncestor(linOct[lCtr]));
01342 <span class="preprocessor">#endif</span>
01343 <span class="preprocessor"></span>        <span class="keywordflow">while</span>( (lCtr &lt; linOct.size()) &amp;&amp;
01344             (nodes[i].isAncestor(linOct[lCtr])) ) {
01345           finalOct.push_back(linOct[lCtr]);
01346           lCtr++;
01347         }
01348       }
01349     } <span class="keywordflow">else</span> {
01350       <span class="comment">//Can't exhaust linOct before exhausting nodes</span>
01351       assert(<span class="keyword">false</span>);
01352     }
01353   }
01354 
01355   nodes = finalOct;
01356 
01357   finalOct.clear();
01358   linOct.clear();
01359 
01360   <a class="code" href="namespaceot.html#a73">deleteTreeNodePointer</a>(ptrOctree);
01361 
01362   <a class="code" href="octUtils_8h.html#a65">PROF_PTR_RIPPLE_BAL_END</a>
01363 }<span class="comment">//end function</span>
01364 
<a name="l01365"></a><a class="code" href="namespaceot.html#a15">01365</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a15">parallelRippleType3</a>(std::vector&lt;TreeNode&gt; &amp; nodes,
01366     <span class="keywordtype">bool</span> incCorners, <span class="keywordtype">bool</span> checkBailOut, <span class="keywordtype">bool</span> rePart,
01367     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, MPI_Comm comm)
01368 {
01369   <a class="code" href="octUtils_8h.html#a27">PROF_PAR_RIPPLE_TYPE3_BEGIN</a> 
01370 
01371     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root(dim,maxDepth);
01372 
01373   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxLev = 1;
01374   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
01375     <span class="keywordflow">if</span> (nodes[i].getLevel() &gt; maxLev) {
01376       maxLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01377     }
01378   }<span class="comment">//end for </span>
01379 
01380   <span class="keywordtype">int</span> rank,npes;
01381   MPI_Comm_rank(comm,&amp;rank);
01382   MPI_Comm_size(comm,&amp;npes);
01383 
01384 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01385 <span class="preprocessor"></span>  MPI_Barrier(comm);    
01386   <span class="keywordflow">if</span>(!rank) {
01387     std::cout&lt;&lt;<span class="stringliteral">"Computed local maxLev."</span>&lt;&lt;std::endl;
01388   }
01389   MPI_Barrier(comm);    
01390 <span class="preprocessor">#endif</span>
01391 <span class="preprocessor"></span>
01392   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMaxLev = maxLev;
01393   par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;maxLev, &amp;globalMaxLev, 1, MPI_MAX, comm);
01394 
01395 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01396 <span class="preprocessor"></span>  MPI_Barrier(comm);    
01397   <span class="keywordflow">if</span>(!rank) {
01398     std::cout&lt;&lt;<span class="stringliteral">"Global maxLev: "</span>&lt;&lt;globalMaxLev&lt;&lt;std::endl;
01399   }
01400   MPI_Barrier(comm);    
01401 <span class="preprocessor">#endif</span>
01402 <span class="preprocessor"></span>
01403   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = globalMaxLev; lev &gt; 2; lev--)
01404   {
01405 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01406 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01407     <span class="keywordflow">if</span>(!rank) {
01408       std::cout&lt;&lt;<span class="stringliteral">"Lev: "</span>&lt;&lt;lev&lt;&lt;std::endl;
01409     }
01410     MPI_Barrier(comm);  
01411 <span class="preprocessor">#endif</span>
01412 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(checkBailOut) {
01413       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minLev = maxDepth;
01414       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
01415         <span class="keywordflow">if</span> (nodes[i].getLevel() &lt; minLev) {
01416           minLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01417         }
01418       }<span class="comment">//end for i</span>
01419 
01420       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMinLev = minLev;
01421       par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;minLev, &amp;globalMinLev, 1, MPI_MIN, comm);
01422 
01423       <span class="keywordflow">if</span> (globalMinLev &gt;= (lev-1)) {
01424         <span class="comment">//Difference between min and </span>
01425         <span class="comment">//max levels is less than 2 .</span>
01426         <span class="keywordflow">break</span>;
01427       }
01428     }<span class="comment">//end if check to bail out</span>
01429 
01430 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01431 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01432     <span class="keywordflow">if</span>(!rank) {
01433       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 1."</span>&lt;&lt;std::endl;
01434     }
01435     MPI_Barrier(comm);  
01436 <span class="preprocessor">#endif</span>
01437 <span class="preprocessor"></span>
01438     std::vector&lt;TreeNode&gt; wList;
01439     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wLen = 0;
01440     wList.resize(nodes.size());
01441     <span class="comment">//Pick leaves at a particular level</span>
01442     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
01443       <span class="keywordflow">if</span> (nodes[i].getLevel() == lev) {
01444         wList[wLen] = nodes[i];
01445         wLen++;
01446       }
01447     }<span class="comment">//end for i</span>
01448     wList.resize(wLen);
01449 
01450 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01451 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01452     <span class="keywordflow">if</span>(!rank) {
01453       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 2."</span>&lt;&lt;std::endl;
01454     }
01455     MPI_Barrier(comm);  
01456 <span class="preprocessor">#endif</span>
01457 <span class="preprocessor"></span>
01458     std::vector&lt;std::vector&lt;TreeNode&gt; &gt;tList(wLen);
01459     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wLen; i++) {
01460       tList[i] = wList[i].<a class="code" href="classot_1_1TreeNode.html#a10">getSearchKeys</a>(incCorners);        
01461     }<span class="comment">//end for i</span>
01462 
01463     wList.clear();
01464 
01465 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01466 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01467     <span class="keywordflow">if</span>(!rank) {
01468       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 3."</span>&lt;&lt;std::endl;
01469     }
01470     MPI_Barrier(comm);  
01471 <span class="preprocessor">#endif</span>
01472 <span class="preprocessor"></span>
01473     std::vector&lt;TreeNode&gt; allKeys;
01474     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wLen; i++) {
01475       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; tList[i].size(); j++) {
01476         <span class="keywordflow">if</span>(tList[i][j] &gt; root) {
01477           allKeys.push_back(tList[i][j]);
01478         }
01479       }
01480     }    
01481     tList.clear();
01482 
01483 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01484 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01485     <span class="keywordflow">if</span>(!rank) {
01486       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 4."</span>&lt;&lt;std::endl;
01487     }
01488     std::cout&lt;&lt;rank&lt;&lt;<span class="stringliteral">": allKeys.size(): "</span>
01489       &lt;&lt;allKeys.size()&lt;&lt;std::endl;
01490     MPI_Barrier(comm);  
01491 <span class="preprocessor">#endif</span>
01492 <span class="preprocessor"></span>
01493     <span class="comment">//</span>
01494     <span class="comment">//Parallel searches and subsequent processing      </span>
01495     <span class="comment">//1. Compute the ranges controlled by each processor</span>
01496     <span class="comment">//2. Compare the keys with the ranges and </span>
01497     <span class="comment">//send the keys to the appropriate processors.</span>
01498     <span class="comment">//3. Perform local searches using the keys</span>
01499     <span class="comment">//recieved. </span>
01500     <span class="comment">//4. Compute the balancing descendants for the results</span>
01501     <span class="comment">//and create the 'seedList' vector. Note,</span>
01502     <span class="comment">//we process one level at a time. So all the keys</span>
01503     <span class="comment">//were generated by octants at the same level. The </span>
01504     <span class="comment">//corresponding balancing descendants are simply the</span>
01505     <span class="comment">//ancestors of the keys at one level lower than this</span>
01506     <span class="comment">//level.</span>
01507     <span class="comment">//</span>
01508 
01509     seq::makeVectorUnique&lt;TreeNode&gt;(allKeys,<span class="keyword">false</span>);     
01510 
01511     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keyLen = allKeys.size();
01512 
01513 
01514     <span class="comment">//First Get the mins from each processor.</span>
01515 
01516     <span class="comment">// allocate memory for the mins array</span>
01517     std::vector&lt;ot::TreeNode&gt; mins (npes); 
01518 
01519     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> sendMin;
01520     <span class="keywordflow">if</span>(!nodes.empty()) {
01521       sendMin = nodes[0]; <span class="comment">//local min</span>
01522     }<span class="keywordflow">else</span> {
01523       sendMin = root;
01524     }
01525 
01526     par::Mpi_Allgather&lt;ot::TreeNode&gt;(&amp;sendMin, &amp;(*mins.begin()), 1, comm);    
01527 
01528 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01529 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01530     <span class="keywordflow">if</span>(!rank) {
01531       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 5."</span>&lt;&lt;std::endl;
01532     }
01533     MPI_Barrier(comm);  
01534 <span class="preprocessor">#endif</span>
01535 <span class="preprocessor"></span>
01536     <span class="comment">//Now determine the processors which own these keys.</span>
01537 
01538     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partKeys = NULL;
01539 
01540     <span class="keywordflow">if</span>(keyLen) {
01541       partKeys = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keyLen];    
01542     }
01543 
01544     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keyLen; i++) {
01545       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01546       <span class="comment">//maxLB returns the last index in a </span>
01547       <span class="comment">//sorted array such that a[ind] &lt;= key </span>
01548       <span class="comment">//and  a[index +1] &gt; key</span>
01549       <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(mins,
01550           allKeys[i], idx, NULL, NULL);
01551       <span class="keywordflow">if</span> (!found ) {
01552         <span class="comment">//Can happen on incomplete domains</span>
01553         partKeys[i] = rank;
01554       } <span class="keywordflow">else</span> {
01555         partKeys[i] = idx;
01556       }
01557     }<span class="comment">//end for i</span>
01558 
01559     mins.clear();
01560 
01561 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01562 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01563     <span class="keywordflow">if</span>(!rank) {
01564       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 6."</span>&lt;&lt;std::endl;
01565     }
01566     MPI_Barrier(comm);  
01567 <span class="preprocessor">#endif</span>
01568 <span class="preprocessor"></span>
01569     <span class="keywordtype">int</span> *numKeysSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01570     <span class="keywordtype">int</span> *numKeysRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];    
01571 
01572     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
01573       numKeysSend[i] = 0;
01574     }
01575 
01576     <span class="comment">// calculate the number of keys to send ...</span>
01577     <span class="comment">//and create the send buffer.</span>
01578     std::vector&lt;std::vector&lt;unsigned int&gt; &gt;sendKtmp(npes);
01579 
01580     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keyLen; i++) {
01581       numKeysSend[partKeys[i]]++;
01582       sendKtmp[partKeys[i]].push_back(i);      
01583     }
01584 
01585     <span class="comment">// Now do an All2All to get numKeysRecv</span>
01586 
01587     par::Mpi_Alltoall&lt;int&gt;(numKeysSend, numKeysRecv, 1, comm);
01588 
01589     <span class="comment">// Pre-processing for sending</span>
01590 
01591     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01592     sendOffsets[0] = 0;
01593     <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01594     recvOffsets[0] = 0;
01595 
01596     <span class="comment">// compute offsets ...</span>
01597 
01598     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; npes; i++) {
01599       sendOffsets[i] = sendOffsets[i-1] + 
01600         numKeysSend[i-1];
01601       recvOffsets[i] = recvOffsets[i-1] +
01602         numKeysRecv[i-1];
01603     }
01604 
01605     std::vector&lt;ot::TreeNode&gt; sendK(sendOffsets[npes-1] + numKeysSend[npes-1]);
01606 
01607     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01608 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01609 <span class="preprocessor"></span>      assert(sendKtmp[i].size() == numKeysSend[i]);
01610 <span class="preprocessor">#endif</span>
01611 <span class="preprocessor"></span>      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numKeysSend[i]; j++) {
01612         sendK[sendOffsets[i] + j] = allKeys[sendKtmp[i][j]];
01613       }<span class="comment">//end for j</span>
01614     }<span class="comment">//end for i</span>
01615 
01616     <span class="keywordflow">if</span>(partKeys) {
01617       <span class="keyword">delete</span> [] partKeys;
01618       partKeys = NULL;
01619     }
01620 
01621     allKeys.clear();
01622     sendKtmp.clear();
01623 
01624     std::vector&lt;ot::TreeNode&gt; recvK(recvOffsets[npes-1] + numKeysRecv[npes-1]);
01625 
01626     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKptr = NULL;
01627     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKptr = NULL;
01628     <span class="keywordflow">if</span>(!sendK.empty()) {
01629       sendKptr = &amp;(*(sendK.begin()));
01630     }
01631     <span class="keywordflow">if</span>(!recvK.empty()) {
01632       recvKptr = &amp;(*(recvK.begin()));
01633     }
01634     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKptr, numKeysSend, sendOffsets,        
01635         recvKptr, numKeysRecv, recvOffsets, comm);
01636 
01637 
01638     sendK.clear();
01639 
01640     <span class="keyword">delete</span> [] sendOffsets;
01641     sendOffsets = NULL;
01642 
01643     <span class="keyword">delete</span> [] recvOffsets;
01644     recvOffsets = NULL;
01645 
01646     <span class="keyword">delete</span> [] numKeysSend;
01647     numKeysSend = NULL;
01648 
01649     <span class="keyword">delete</span> [] numKeysRecv;
01650     numKeysRecv = NULL;
01651 
01652     seq::makeVectorUnique&lt;TreeNode&gt;(recvK,<span class="keyword">false</span>);       
01653 
01654     keyLen = recvK.size();
01655 
01656 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01657 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01658     <span class="keywordflow">if</span>(!rank) {
01659       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 7."</span>&lt;&lt;std::endl;
01660     }
01661     MPI_Barrier(comm);  
01662 <span class="preprocessor">#endif</span>
01663 <span class="preprocessor"></span>
01664     <span class="comment">//Local searches and creating seedList      </span>
01665 
01666     std::vector&lt;std::vector&lt;TreeNode&gt; &gt; seedList(nodes.size());
01667     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastIdx = 0;
01668     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; keyLen; i++) {
01669       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01670       <span class="comment">//assumes nodes is sorted and unique.          </span>
01671       <span class="keywordtype">bool</span> flag = seq::maxLowerBound&lt;TreeNode&gt;(nodes, recvK[i], idx, &amp;lastIdx,NULL);
01672       <span class="keywordflow">if</span> (flag) {
01673         lastIdx = idx;
01674 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01675 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(nodes[idx], recvK[i]));
01676 <span class="preprocessor">#endif</span>
01677 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (nodes[idx].isAncestor(recvK[i])) {
01678           <span class="keywordflow">if</span> (lev &gt; (nodes[idx].getLevel() + 1)) {
01679             seedList[idx].push_back(recvK[i].getAncestor(lev-1));                
01680           }
01681         }<span class="comment">//end if correct result</span>
01682       }<span class="comment">//end if flag        </span>
01683     }<span class="comment">//end for i</span>
01684 
01685     recvK.clear();
01686 
01687 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01688 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01689     <span class="keywordflow">if</span>(!rank) {
01690       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 8."</span>&lt;&lt;std::endl;
01691     }
01692     MPI_Barrier(comm);  
01693 <span class="preprocessor">#endif</span>
01694 <span class="preprocessor"></span>
01695     <span class="comment">//Include the new octants in the octree</span>
01696     <span class="comment">//while preserving linearity and sorted order</span>
01697 
01698     <span class="comment">//Seedlist may have duplicates. Seedlist will be sorted.</span>
01699 
01700     std::vector&lt;TreeNode&gt; tmpList;
01701     std::vector&lt;std::vector&lt;TreeNode&gt; &gt;allInternalLeaves(nodes.size());
01702     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSz = 0;
01703     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) { 
01704       seq::makeVectorUnique&lt;TreeNode&gt;(seedList[i],<span class="keyword">true</span>);        
01705       <span class="keywordflow">if</span> (!seedList[i].empty()) {
01706         nodes[i].<a class="code" href="classot_1_1TreeNode.html#a4">completeSubtree</a>(seedList[i], allInternalLeaves[i]);
01707       }
01708       tmpSz += allInternalLeaves[i].size();
01709       <span class="keywordflow">if</span> (allInternalLeaves[i].empty()) {
01710         tmpSz++;
01711       }
01712       seedList[i].clear();
01713     }<span class="comment">//end for i</span>
01714 
01715 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01716 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01717     <span class="keywordflow">if</span>(!rank) {
01718       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 9."</span>&lt;&lt;std::endl;
01719     }
01720     MPI_Barrier(comm);  
01721 <span class="preprocessor">#endif</span>
01722 <span class="preprocessor"></span>
01723     seedList.clear();
01724     tmpList.resize(tmpSz);
01725     tmpSz=0;
01726     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) {
01727       <span class="keywordflow">if</span> (!allInternalLeaves[i].empty()) {
01728         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;allInternalLeaves[i].size();k++) {
01729           tmpList[tmpSz++] = allInternalLeaves[i][k];
01730         }<span class="comment">//end for k</span>
01731         allInternalLeaves[i].clear();
01732       } <span class="keywordflow">else</span> {
01733         tmpList[tmpSz++] = nodes[i];
01734       }
01735     }<span class="comment">//end for i</span>
01736     allInternalLeaves.clear();
01737     nodes = tmpList;
01738     tmpList.clear();
01739 
01740 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01741 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01742     <span class="keywordflow">if</span>(!rank) {
01743       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 10."</span>&lt;&lt;std::endl;
01744     }
01745     MPI_Barrier(comm);  
01746 <span class="preprocessor">#endif</span>
01747 <span class="preprocessor"></span>
01748     <span class="keywordflow">if</span>(rePart) {
01749       par::partitionW&lt;ot::TreeNode&gt;(nodes, NULL,comm);
01750     }
01751 
01752 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01753 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01754     <span class="keywordflow">if</span>(!rank) {
01755       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 11."</span>&lt;&lt;std::endl;
01756     }
01757     MPI_Barrier(comm);  
01758 <span class="preprocessor">#endif</span>
01759 <span class="preprocessor"></span>
01760   }<span class="comment">//end for lev</span>
01761 
01762   <a class="code" href="octUtils_8h.html#a66">PROF_PAR_RIPPLE_TYPE3_END</a> 
01763 }<span class="comment">//end function</span>
01764 
01765 
<a name="l01766"></a><a class="code" href="namespaceot.html#a16">01766</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a16">parallelRippleType2</a>(std::vector&lt;TreeNode&gt; &amp; nodes,
01767     <span class="keywordtype">bool</span> incCorners, <span class="keywordtype">bool</span> checkBailOut, <span class="keywordtype">bool</span> rePart,
01768     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, MPI_Comm comm)
01769 {
01770   <a class="code" href="octUtils_8h.html#a28">PROF_PAR_RIPPLE_TYPE2_BEGIN</a> 
01771 
01772     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root(dim,maxDepth);
01773 
01774   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxLev = 1;
01775   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
01776     <span class="keywordflow">if</span> (nodes[i].getLevel() &gt; maxLev) {
01777       maxLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01778     }
01779   }<span class="comment">//end for </span>
01780 
01781   <span class="keywordtype">int</span> rank,npes;
01782   MPI_Comm_rank(comm,&amp;rank);
01783   MPI_Comm_size(comm,&amp;npes);
01784 
01785 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01786 <span class="preprocessor"></span>  MPI_Barrier(comm);    
01787   <span class="keywordflow">if</span>(!rank) {
01788     std::cout&lt;&lt;<span class="stringliteral">"Computed local maxLev."</span>&lt;&lt;std::endl;
01789   }
01790   MPI_Barrier(comm);    
01791 <span class="preprocessor">#endif</span>
01792 <span class="preprocessor"></span>
01793   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMaxLev = maxLev;
01794   par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;maxLev, &amp;globalMaxLev, 1, MPI_MAX, comm);
01795 
01796 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01797 <span class="preprocessor"></span>  MPI_Barrier(comm);    
01798   <span class="keywordflow">if</span>(!rank) {
01799     std::cout&lt;&lt;<span class="stringliteral">"Global maxLev: "</span>&lt;&lt;globalMaxLev&lt;&lt;std::endl;
01800   }
01801   MPI_Barrier(comm);    
01802 <span class="preprocessor">#endif</span>
01803 <span class="preprocessor"></span>
01804   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = globalMaxLev; lev &gt; 2; lev--)
01805   {
01806 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01807 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01808     <span class="keywordflow">if</span>(!rank) {
01809       std::cout&lt;&lt;<span class="stringliteral">"Lev: "</span>&lt;&lt;lev&lt;&lt;std::endl;
01810     }
01811     MPI_Barrier(comm);  
01812 <span class="preprocessor">#endif</span>
01813 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(checkBailOut) {
01814       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minLev = maxDepth;
01815       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
01816         <span class="keywordflow">if</span> (nodes[i].getLevel() &lt; minLev) {
01817           minLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01818         }
01819       }<span class="comment">//end for i</span>
01820 
01821       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMinLev = minLev;
01822       par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;minLev, &amp;globalMinLev, 1, MPI_MIN, comm);
01823 
01824       <span class="keywordflow">if</span> (globalMinLev &gt;= (lev-1)) {
01825         <span class="comment">//Difference between min and </span>
01826         <span class="comment">//max levels is less than 2 .</span>
01827         <span class="keywordflow">break</span>;
01828       }
01829     }<span class="comment">//end if check to bail out</span>
01830 
01831 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01832 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01833     <span class="keywordflow">if</span>(!rank) {
01834       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 1."</span>&lt;&lt;std::endl;
01835     }
01836     MPI_Barrier(comm);  
01837 <span class="preprocessor">#endif</span>
01838 <span class="preprocessor"></span>
01839     std::vector&lt;TreeNode&gt; wList;
01840     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wLen = 0;
01841     wList.resize(nodes.size());
01842     <span class="comment">//Pick leaves at a particular level</span>
01843     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
01844       <span class="keywordflow">if</span> (nodes[i].getLevel() == lev) {
01845         wList[wLen] = nodes[i];
01846         wLen++;
01847       }
01848     }<span class="comment">//end for i</span>
01849     wList.resize(wLen);
01850 
01851 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01852 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01853     <span class="keywordflow">if</span>(!rank) {
01854       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 2."</span>&lt;&lt;std::endl;
01855     }
01856     MPI_Barrier(comm);  
01857 <span class="preprocessor">#endif</span>
01858 <span class="preprocessor"></span>
01859     std::vector&lt;std::vector&lt;TreeNode&gt; &gt;tList(wLen);
01860     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wLen; i++) {
01861       tList[i] = wList[i].<a class="code" href="classot_1_1TreeNode.html#a10">getSearchKeys</a>(incCorners);        
01862     }<span class="comment">//end for i</span>
01863 
01864     wList.clear();
01865 
01866 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01867 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01868     <span class="keywordflow">if</span>(!rank) {
01869       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 3."</span>&lt;&lt;std::endl;
01870     }
01871     MPI_Barrier(comm);  
01872 <span class="preprocessor">#endif</span>
01873 <span class="preprocessor"></span>
01874     std::vector&lt;TreeNode&gt; allKeys;
01875     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wLen; i++) {
01876       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; tList[i].size(); j++) {
01877         <span class="keywordflow">if</span>(tList[i][j] &gt; root) {
01878           allKeys.push_back(tList[i][j]);
01879         }
01880       }
01881     }    
01882     tList.clear();
01883 
01884 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01885 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01886     <span class="keywordflow">if</span>(!rank) {
01887       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 4."</span>&lt;&lt;std::endl;
01888     }
01889     std::cout&lt;&lt;rank&lt;&lt;<span class="stringliteral">": allKeys.size(): "</span>
01890       &lt;&lt;allKeys.size()&lt;&lt;std::endl;
01891     MPI_Barrier(comm);  
01892 <span class="preprocessor">#endif</span>
01893 <span class="preprocessor"></span>
01894     <span class="comment">//</span>
01895     <span class="comment">//Parallel searches and subsequent processing      </span>
01896     <span class="comment">//1. Compute the ranges controlled by each processor</span>
01897     <span class="comment">//2. Compare the keys with the ranges and </span>
01898     <span class="comment">//send the keys to the appropriate processors.</span>
01899     <span class="comment">//3. Perform local searches using the keys</span>
01900     <span class="comment">//recieved. </span>
01901     <span class="comment">//4. Compute the balancing descendants for the results</span>
01902     <span class="comment">//and create the 'seedList' vector. Note,</span>
01903     <span class="comment">//we process one level at a time. So all the keys</span>
01904     <span class="comment">//were generated by octants at the same level. The </span>
01905     <span class="comment">//corresponding balancing descendants are simply the</span>
01906     <span class="comment">//ancestors of the keys at one level lower than this</span>
01907     <span class="comment">//level.</span>
01908     <span class="comment">//</span>
01909 
01910     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keyLen = allKeys.size();
01911 
01912 
01913     <span class="comment">//First Get the mins from each processor.</span>
01914 
01915     <span class="comment">// allocate memory for the mins array</span>
01916     std::vector&lt;ot::TreeNode&gt; mins (npes); 
01917 
01918     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> sendMin;
01919     <span class="keywordflow">if</span>(!nodes.empty()) {
01920       sendMin = nodes[0]; <span class="comment">//local min</span>
01921     }<span class="keywordflow">else</span> {
01922       sendMin = root;
01923     }
01924 
01925     par::Mpi_Allgather&lt;ot::TreeNode&gt;(&amp;sendMin, &amp;(*mins.begin()), 1, comm);    
01926 
01927 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01928 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01929     <span class="keywordflow">if</span>(!rank) {
01930       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 5."</span>&lt;&lt;std::endl;
01931     }
01932     MPI_Barrier(comm);  
01933 <span class="preprocessor">#endif</span>
01934 <span class="preprocessor"></span>
01935     <span class="comment">//Now determine the processors which own these keys.</span>
01936 
01937     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partKeys = NULL;
01938 
01939     <span class="keywordflow">if</span>(keyLen) {
01940       partKeys = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keyLen];    
01941     }
01942 
01943     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keyLen; i++) {
01944       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01945       <span class="comment">//maxLB returns the last index in a </span>
01946       <span class="comment">//sorted array such that a[ind] &lt;= key </span>
01947       <span class="comment">//and  a[index +1] &gt; key</span>
01948       <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(mins,
01949           allKeys[i], idx, NULL, NULL);
01950       <span class="keywordflow">if</span> (!found ) {
01951         <span class="comment">//Can happen on incomplete domains</span>
01952         partKeys[i] = rank;
01953       } <span class="keywordflow">else</span> {
01954         partKeys[i] = idx;
01955       }
01956     }<span class="comment">//end for i</span>
01957 
01958     mins.clear();
01959 
01960 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
01961 <span class="preprocessor"></span>    MPI_Barrier(comm);  
01962     <span class="keywordflow">if</span>(!rank) {
01963       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 6."</span>&lt;&lt;std::endl;
01964     }
01965     MPI_Barrier(comm);  
01966 <span class="preprocessor">#endif</span>
01967 <span class="preprocessor"></span>
01968     <span class="keywordtype">int</span> *numKeysSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01969     <span class="keywordtype">int</span> *numKeysRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];    
01970 
01971     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
01972       numKeysSend[i] = 0;
01973     }
01974 
01975     <span class="comment">// calculate the number of keys to send ...</span>
01976     <span class="comment">//and create the send buffer.</span>
01977     std::vector&lt;std::vector&lt;unsigned int&gt; &gt;sendKtmp(npes);
01978 
01979     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keyLen; i++) {
01980       numKeysSend[partKeys[i]]++;
01981       sendKtmp[partKeys[i]].push_back(i);      
01982     }
01983 
01984     <span class="comment">// Now do an All2All to get numKeysRecv</span>
01985 
01986     par::Mpi_Alltoall&lt;int&gt;(numKeysSend, numKeysRecv, 1, comm);
01987 
01988     <span class="comment">// Pre-processing for sending</span>
01989 
01990     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01991     sendOffsets[0] = 0;
01992     <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01993     recvOffsets[0] = 0;
01994 
01995     <span class="comment">// compute offsets ...</span>
01996 
01997     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; npes; i++) {
01998       sendOffsets[i] = sendOffsets[i-1] + 
01999         numKeysSend[i-1];
02000       recvOffsets[i] = recvOffsets[i-1] +
02001         numKeysRecv[i-1];
02002     }
02003 
02004     std::vector&lt;ot::TreeNode&gt; sendK(sendOffsets[npes-1] + numKeysSend[npes-1]);
02005 
02006     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
02007 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02008 <span class="preprocessor"></span>      assert(sendKtmp[i].size() == numKeysSend[i]);
02009 <span class="preprocessor">#endif</span>
02010 <span class="preprocessor"></span>      <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numKeysSend[i]; j++) {
02011         sendK[sendOffsets[i] + j] = allKeys[sendKtmp[i][j]];
02012       }<span class="comment">//end for j</span>
02013     }<span class="comment">//end for i</span>
02014 
02015     <span class="keywordflow">if</span>(partKeys) {
02016       <span class="keyword">delete</span> [] partKeys;
02017       partKeys = NULL;
02018     }
02019 
02020     allKeys.clear();
02021     sendKtmp.clear();
02022 
02023     std::vector&lt;ot::TreeNode&gt; recvK(recvOffsets[npes-1] + numKeysRecv[npes-1]);
02024 
02025     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKptr = NULL;
02026     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKptr = NULL;
02027     <span class="keywordflow">if</span>(!sendK.empty()) {
02028       sendKptr = &amp;(*(sendK.begin()));
02029     }
02030     <span class="keywordflow">if</span>(!recvK.empty()) {
02031       recvKptr = &amp;(*(recvK.begin()));
02032     }
02033     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;(sendKptr, numKeysSend, sendOffsets,        
02034         recvKptr, numKeysRecv,recvOffsets, comm);
02035 
02036     sendK.clear();
02037 
02038     <span class="keyword">delete</span> [] sendOffsets;
02039     sendOffsets = NULL;
02040 
02041     <span class="keyword">delete</span> [] recvOffsets;
02042     recvOffsets = NULL;
02043 
02044     <span class="keyword">delete</span> [] numKeysSend;
02045     numKeysSend = NULL;
02046 
02047     <span class="keyword">delete</span> [] numKeysRecv;
02048     numKeysRecv = NULL;
02049 
02050     keyLen = recvK.size();
02051 
02052 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02053 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02054     <span class="keywordflow">if</span>(!rank) {
02055       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 7."</span>&lt;&lt;std::endl;
02056     }
02057     MPI_Barrier(comm);  
02058 <span class="preprocessor">#endif</span>
02059 <span class="preprocessor"></span>
02060     <span class="comment">//Local searches and creating seedList      </span>
02061 
02062     std::vector&lt;std::vector&lt;TreeNode&gt; &gt; seedList(nodes.size());
02063     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; keyLen; i++) {
02064       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
02065       <span class="comment">//assumes nodes is sorted and unique.          </span>
02066       <span class="keywordtype">bool</span> flag = seq::maxLowerBound&lt;TreeNode&gt;(nodes, recvK[i], idx,NULL,NULL);
02067       <span class="keywordflow">if</span> (flag) {
02068 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02069 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(nodes[idx], recvK[i]));
02070 <span class="preprocessor">#endif</span>
02071 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (nodes[idx].isAncestor(recvK[i])) {
02072           <span class="keywordflow">if</span> (lev &gt; (nodes[idx].getLevel() + 1)) {
02073             seedList[idx].push_back(recvK[i].getAncestor(lev-1));                
02074           }
02075         }<span class="comment">//end if correct result</span>
02076       }<span class="comment">//end if flag        </span>
02077     }<span class="comment">//end for i</span>
02078 
02079     recvK.clear();
02080 
02081 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02082 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02083     <span class="keywordflow">if</span>(!rank) {
02084       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 8."</span>&lt;&lt;std::endl;
02085     }
02086     MPI_Barrier(comm);  
02087 <span class="preprocessor">#endif</span>
02088 <span class="preprocessor"></span>
02089     <span class="comment">//Include the new octants in the octree</span>
02090     <span class="comment">//while preserving linearity and sorted order</span>
02091 
02092     <span class="comment">//Seedlist may have duplicates. Seedlist </span>
02093     <span class="comment">// may not be sorted.</span>
02094 
02095     std::vector&lt;TreeNode&gt; tmpList;
02096     std::vector&lt;std::vector&lt;TreeNode&gt; &gt;allInternalLeaves(nodes.size());
02097     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSz = 0;
02098     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) { 
02099       seq::makeVectorUnique&lt;TreeNode&gt;(seedList[i],<span class="keyword">false</span>);       
02100       <span class="keywordflow">if</span> (!seedList[i].empty()) {
02101         nodes[i].<a class="code" href="classot_1_1TreeNode.html#a4">completeSubtree</a>(seedList[i], allInternalLeaves[i]);
02102       }
02103       tmpSz += allInternalLeaves[i].size();
02104       <span class="keywordflow">if</span> (allInternalLeaves[i].empty()) {
02105         tmpSz++;
02106       }
02107       seedList[i].clear();
02108     }<span class="comment">//end for i</span>
02109 
02110 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02111 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02112     <span class="keywordflow">if</span>(!rank) {
02113       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 9."</span>&lt;&lt;std::endl;
02114     }
02115     MPI_Barrier(comm);  
02116 <span class="preprocessor">#endif</span>
02117 <span class="preprocessor"></span>
02118     seedList.clear();
02119     tmpList.resize(tmpSz);
02120     tmpSz=0;
02121     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) {
02122       <span class="keywordflow">if</span> (!allInternalLeaves[i].empty()) {
02123         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;allInternalLeaves[i].size();k++) {
02124           tmpList[tmpSz++] = allInternalLeaves[i][k];
02125         }<span class="comment">//end for k</span>
02126         allInternalLeaves[i].clear();
02127       } <span class="keywordflow">else</span> {
02128         tmpList[tmpSz++] = nodes[i];
02129       }
02130     }<span class="comment">//end for i</span>
02131     allInternalLeaves.clear();
02132     nodes = tmpList;
02133     tmpList.clear();
02134 
02135 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02136 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02137     <span class="keywordflow">if</span>(!rank) {
02138       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 10."</span>&lt;&lt;std::endl;
02139     }
02140     MPI_Barrier(comm);  
02141 <span class="preprocessor">#endif</span>
02142 <span class="preprocessor"></span>
02143     <span class="keywordflow">if</span>(rePart) {
02144       par::partitionW&lt;ot::TreeNode&gt;(nodes, NULL,comm);
02145     }
02146 
02147 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02148 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02149     <span class="keywordflow">if</span>(!rank) {
02150       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 11."</span>&lt;&lt;std::endl;
02151     }
02152     MPI_Barrier(comm);  
02153 <span class="preprocessor">#endif</span>
02154 <span class="preprocessor"></span>
02155   }<span class="comment">//end for lev</span>
02156 
02157   <a class="code" href="octUtils_8h.html#a67">PROF_PAR_RIPPLE_TYPE2_END</a> 
02158 }<span class="comment">//end function</span>
02159 
<a name="l02160"></a><a class="code" href="namespaceot.html#a17">02160</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a17">parallelRippleType1</a>(std::vector&lt;TreeNode&gt; &amp; nodes,
02161     <span class="keywordtype">bool</span> incCorners, <span class="keywordtype">bool</span> checkBailOut, <span class="keywordtype">bool</span> rePart,
02162     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, MPI_Comm comm)
02163 {
02164   <a class="code" href="octUtils_8h.html#a29">PROF_PAR_RIPPLE_TYPE1_BEGIN</a> 
02165 
02166     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root(dim,maxDepth);
02167 
02168   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxLev = 1;
02169   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
02170     <span class="keywordflow">if</span> (nodes[i].getLevel() &gt; maxLev) {
02171       maxLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
02172     }
02173   }<span class="comment">//end for </span>
02174 
02175   <span class="keywordtype">int</span> rank,npes;
02176   MPI_Comm_rank(comm,&amp;rank);
02177   MPI_Comm_size(comm,&amp;npes);
02178 
02179 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02180 <span class="preprocessor"></span>  MPI_Barrier(comm);    
02181   <span class="keywordflow">if</span>(!rank) {
02182     std::cout&lt;&lt;<span class="stringliteral">"Computed local maxLev."</span>&lt;&lt;std::endl;
02183   }
02184   MPI_Barrier(comm);    
02185 <span class="preprocessor">#endif</span>
02186 <span class="preprocessor"></span>
02187   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMaxLev = maxLev;
02188   par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;maxLev,&amp;globalMaxLev, 1, MPI_MAX, comm);
02189 
02190 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02191 <span class="preprocessor"></span>  MPI_Barrier(comm);    
02192   <span class="keywordflow">if</span>(!rank) {
02193     std::cout&lt;&lt;<span class="stringliteral">"Global maxLev: "</span>&lt;&lt;globalMaxLev&lt;&lt;std::endl;
02194   }
02195   MPI_Barrier(comm);    
02196 <span class="preprocessor">#endif</span>
02197 <span class="preprocessor"></span>
02198   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev = globalMaxLev; lev &gt; 2; lev--)
02199   {
02200 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02201 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02202     <span class="keywordflow">if</span>(!rank) {
02203       std::cout&lt;&lt;<span class="stringliteral">"Lev: "</span>&lt;&lt;lev&lt;&lt;std::endl;
02204     }
02205     MPI_Barrier(comm);  
02206 <span class="preprocessor">#endif</span>
02207 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(checkBailOut) {
02208       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> minLev = maxDepth;
02209       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
02210         <span class="keywordflow">if</span> (nodes[i].getLevel() &lt; minLev) {
02211           minLev = nodes[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
02212         }
02213       }<span class="comment">//end for i</span>
02214 
02215       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMinLev = minLev;
02216       par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;minLev, &amp;globalMinLev, 1, MPI_MIN, comm);
02217 
02218       <span class="keywordflow">if</span> (globalMinLev &gt;= (lev-1)) {
02219         <span class="comment">//Difference between min and </span>
02220         <span class="comment">//max levels is less than 2 .</span>
02221         <span class="keywordflow">break</span>;
02222       }
02223     }<span class="comment">//end if check to bail out</span>
02224 
02225 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02226 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02227     <span class="keywordflow">if</span>(!rank) {
02228       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 1."</span>&lt;&lt;std::endl;
02229     }
02230     MPI_Barrier(comm);  
02231 <span class="preprocessor">#endif</span>
02232 <span class="preprocessor"></span>
02233     std::vector&lt;TreeNode&gt; wList;
02234     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wLen = 0;
02235     wList.resize(nodes.size());
02236     <span class="comment">//Pick leaves at a particular level</span>
02237     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;nodes.size(); i++) {
02238       <span class="keywordflow">if</span> (nodes[i].getLevel() == lev) {
02239         wList[wLen] = nodes[i];
02240         wLen++;
02241       }
02242     }<span class="comment">//end for i</span>
02243     wList.resize(wLen);
02244 
02245 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02246 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02247     <span class="keywordflow">if</span>(!rank) {
02248       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 2."</span>&lt;&lt;std::endl;
02249     }
02250     MPI_Barrier(comm);  
02251 <span class="preprocessor">#endif</span>
02252 <span class="preprocessor"></span>
02253     std::vector&lt;std::vector&lt;TreeNode&gt; &gt;tList(wLen);
02254     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wLen; i++) {
02255       tList[i] = wList[i].<a class="code" href="classot_1_1TreeNode.html#a10">getSearchKeys</a>(incCorners);        
02256     }<span class="comment">//end for i</span>
02257 
02258     wList.clear();
02259 
02260 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02261 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02262     <span class="keywordflow">if</span>(!rank) {
02263       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 3."</span>&lt;&lt;std::endl;
02264     }
02265     MPI_Barrier(comm);  
02266 <span class="preprocessor">#endif</span>
02267 <span class="preprocessor"></span>
02268     std::vector&lt;TreeNode&gt; allKeys;
02269     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; wLen; i++) {
02270       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; tList[i].size(); j++) {
02271         <span class="keywordflow">if</span>(tList[i][j] &gt; root) {
02272           allKeys.push_back(tList[i][j]);
02273         }
02274       }
02275     }    
02276     tList.clear();
02277 
02278 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02279 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02280     <span class="keywordflow">if</span>(!rank) {
02281       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 4."</span>&lt;&lt;std::endl;
02282     }
02283     std::cout&lt;&lt;rank&lt;&lt;<span class="stringliteral">": allKeys.size(): "</span>
02284       &lt;&lt;allKeys.size()&lt;&lt;std::endl;
02285     MPI_Barrier(comm);  
02286 <span class="preprocessor">#endif</span>
02287 <span class="preprocessor"></span>
02288     <span class="comment">//</span>
02289     <span class="comment">//Parallel searches and subsequent processing</span>
02290     <span class="comment">//1. Make the list of keys unique globally.</span>
02291     <span class="comment">//2. Compute the ranges controlled by each processor</span>
02292     <span class="comment">//3. Compare the keys with the ranges and </span>
02293     <span class="comment">//send the keys to the appropriate processors.</span>
02294     <span class="comment">//4. Perform local searches using the keys</span>
02295     <span class="comment">//recieved. Use the fact that the keys are</span>
02296     <span class="comment">// sorted to do this efficiently.</span>
02297     <span class="comment">//5. Compute the balancing descendants for the results</span>
02298     <span class="comment">//and create the 'seedList' vector. Note,</span>
02299     <span class="comment">//we process one level at a time. So all the keys</span>
02300     <span class="comment">//were generated by octants at the same level. The </span>
02301     <span class="comment">//corresponding balancing descendants are simply the</span>
02302     <span class="comment">//ancestors of the keys at one level lower than this</span>
02303     <span class="comment">//level.</span>
02304     <span class="comment">//</span>
02305 
02306     par::removeDuplicates&lt;ot::TreeNode&gt;(allKeys,
02307         <span class="keyword">false</span>,comm);
02308     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keyLen = allKeys.size();
02309 
02310 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02311 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02312     <span class="keywordflow">if</span>(!rank) {
02313       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 5."</span>&lt;&lt;std::endl;
02314     }
02315     MPI_Barrier(comm);  
02316 <span class="preprocessor">#endif</span>
02317 <span class="preprocessor"></span>
02318     <span class="comment">//First Get the mins from each processor.</span>
02319 
02320     <span class="comment">// allocate memory for the mins array</span>
02321     std::vector&lt;ot::TreeNode&gt; mins (npes); 
02322 
02323     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> sendMin;
02324     <span class="keywordflow">if</span>(!nodes.empty()) {
02325       sendMin = nodes[0]; <span class="comment">//local min</span>
02326     }<span class="keywordflow">else</span> {
02327       sendMin = root;
02328     }
02329 
02330     par::Mpi_Allgather&lt;ot::TreeNode&gt;(&amp;sendMin, &amp;(*mins.begin()), 1, comm);    
02331 
02332 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02333 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02334     <span class="keywordflow">if</span>(!rank) {
02335       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 6."</span>&lt;&lt;std::endl;
02336     }
02337     MPI_Barrier(comm);  
02338 <span class="preprocessor">#endif</span>
02339 <span class="preprocessor"></span>
02340     <span class="comment">//Now determine the processors which own these keys.</span>
02341 
02342     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partKeys = NULL;
02343 
02344     <span class="keywordflow">if</span>(keyLen) {
02345       partKeys = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keyLen];    
02346     }
02347 
02348     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keyLen; i++) {
02349       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
02350       <span class="comment">//maxLB returns the last index in a </span>
02351       <span class="comment">//sorted array such that a[ind] &lt;= key </span>
02352       <span class="comment">//and  a[index +1] &gt; key</span>
02353       <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(mins,
02354           allKeys[i], idx, NULL, NULL);
02355       <span class="keywordflow">if</span> (!found ) {
02356         <span class="comment">//Can happen on incomplete domains</span>
02357         partKeys[i] = rank;
02358       } <span class="keywordflow">else</span> {
02359         partKeys[i] = idx;
02360       }
02361     }<span class="comment">//end for i</span>
02362 
02363     mins.clear();
02364 
02365 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02366 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02367     <span class="keywordflow">if</span>(!rank) {
02368       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 7."</span>&lt;&lt;std::endl;
02369     }
02370     MPI_Barrier(comm);  
02371 <span class="preprocessor">#endif</span>
02372 <span class="preprocessor"></span>
02373     <span class="keywordtype">int</span> *numKeysSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
02374     <span class="keywordtype">int</span> *numKeysRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];    
02375 
02376     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
02377       numKeysSend[i] = 0;
02378     }
02379 
02380     <span class="comment">// calculate the number of keys to send ...</span>
02381     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keyLen; i++) {
02382       numKeysSend[partKeys[i]]++;      
02383     }
02384 
02385     <span class="comment">// Now do an All2All to get numKeysRecv</span>
02386 
02387     par::Mpi_Alltoall&lt;int&gt;(numKeysSend, numKeysRecv, 1, comm);
02388 
02389     <span class="comment">// Pre-processing for sending</span>
02390 
02391     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
02392     sendOffsets[0] = 0;
02393     <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
02394     recvOffsets[0] = 0;
02395 
02396 
02397     <span class="comment">// compute offsets ...</span>
02398 
02399     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; npes; i++) {
02400       sendOffsets[i] = sendOffsets[i-1] + 
02401         numKeysSend[i-1];
02402       recvOffsets[i] = recvOffsets[i-1] +
02403         numKeysRecv[i-1];
02404     }
02405 
02406     <span class="comment">//Since, allKeys is sorted globally in this case</span>
02407     <span class="comment">// allKeys must be the same as sendK. So,</span>
02408     <span class="comment">//there is no need to create </span>
02409     <span class="comment">//a separate send buffer.</span>
02410 
02411     std::vector&lt;ot::TreeNode&gt; recvK(recvOffsets[npes-1] 
02412         + numKeysRecv[npes-1]);
02413 
02414     <span class="keywordflow">if</span>(partKeys) {
02415       <span class="keyword">delete</span> [] partKeys;
02416       partKeys = NULL;
02417     }
02418 
02419     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* allKeysPtr = NULL;
02420     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKptr = NULL;
02421     <span class="keywordflow">if</span>(!allKeys.empty()) {
02422       allKeysPtr = &amp;(*(allKeys.begin()));
02423     }
02424     <span class="keywordflow">if</span>(!recvK.empty()) {
02425       recvKptr = &amp;(*(recvK.begin()));
02426     }
02427     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;(allKeysPtr, numKeysSend, sendOffsets, 
02428         recvKptr, numKeysRecv, recvOffsets, comm);
02429 
02430     allKeys.clear();
02431 
02432     <span class="keyword">delete</span> [] sendOffsets;
02433     sendOffsets = NULL;
02434 
02435     <span class="keyword">delete</span> [] recvOffsets;
02436     recvOffsets = NULL;
02437 
02438     <span class="keyword">delete</span> [] numKeysSend;
02439     numKeysSend = NULL;
02440 
02441     <span class="keyword">delete</span> [] numKeysRecv;
02442     numKeysRecv = NULL;
02443 
02444     keyLen = recvK.size();
02445 
02446 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02447 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02448     <span class="keywordflow">if</span>(!rank) {
02449       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 8."</span>&lt;&lt;std::endl;
02450     }
02451     MPI_Barrier(comm);  
02452 <span class="preprocessor">#endif</span>
02453 <span class="preprocessor"></span>
02454     <span class="comment">//Local searches and creating seedList</span>
02455     <span class="comment">//recvK will be sorted. </span>
02456     <span class="comment">//since, recvK is sorted, we can pass the previous</span>
02457     <span class="comment">// result as a lower bound for subsequent </span>
02458     <span class="comment">//searches instead of NULL for everything. This</span>
02459     <span class="comment">//should reduce the constant a bit.</span>
02460 
02461     std::vector&lt;std::vector&lt;TreeNode&gt; &gt; seedList(nodes.size());
02462     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastIdx = 0;   
02463     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; keyLen; i++) {
02464       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
02465       <span class="comment">//assumes nodes is sorted and unique.          </span>
02466       <span class="keywordtype">bool</span> flag = seq::maxLowerBound&lt;TreeNode&gt;(nodes,
02467           recvK[i], idx,&amp;lastIdx,NULL);
02468       <span class="keywordflow">if</span> (flag) {
02469         lastIdx = idx;  
02470 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02471 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(nodes[idx], recvK[i]));
02472 <span class="preprocessor">#endif</span>
02473 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (nodes[idx].isAncestor(recvK[i])) {
02474           <span class="keywordflow">if</span> (lev &gt; (nodes[idx].getLevel() + 1)) {
02475             seedList[idx].push_back(
02476                 recvK[i].getAncestor(lev-1));                
02477           }
02478         }<span class="comment">//end if correct result</span>
02479       }<span class="comment">//end if flag        </span>
02480     }<span class="comment">//end for i</span>
02481 
02482     recvK.clear();
02483 
02484 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02485 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02486     <span class="keywordflow">if</span>(!rank) {
02487       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 9."</span>&lt;&lt;std::endl;
02488     }
02489     MPI_Barrier(comm);  
02490 <span class="preprocessor">#endif</span>
02491 <span class="preprocessor"></span>
02492     <span class="comment">//Include the new octants in the octree</span>
02493     <span class="comment">//while preserving linearity and sorted order</span>
02494 
02495     <span class="comment">//Seedlist may have duplicates. Seedlist </span>
02496     <span class="comment">// will be sorted.</span>
02497 
02498     std::vector&lt;TreeNode&gt; tmpList;
02499     std::vector&lt;std::vector&lt;TreeNode&gt; &gt;allInternalLeaves(nodes.size());
02500     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSz = 0;
02501     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) { 
02502       seq::makeVectorUnique&lt;TreeNode&gt;(seedList[i],<span class="keyword">true</span>);        
02503       <span class="keywordflow">if</span> (!seedList[i].empty()) {
02504         nodes[i].<a class="code" href="classot_1_1TreeNode.html#a4">completeSubtree</a>(seedList[i], allInternalLeaves[i]);
02505       }
02506       tmpSz += allInternalLeaves[i].size();
02507       <span class="keywordflow">if</span> (allInternalLeaves[i].empty()) {
02508         tmpSz++;
02509       }
02510       seedList[i].clear();
02511     }<span class="comment">//end for i</span>
02512 
02513 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02514 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02515     <span class="keywordflow">if</span>(!rank) {
02516       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 10."</span>&lt;&lt;std::endl;
02517     }
02518     MPI_Barrier(comm);  
02519 <span class="preprocessor">#endif</span>
02520 <span class="preprocessor"></span>
02521     seedList.clear();
02522     tmpList.resize(tmpSz);
02523     tmpSz=0;
02524     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nodes.size();i++) {
02525       <span class="keywordflow">if</span> (!allInternalLeaves[i].empty()) {
02526         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=0;k&lt;allInternalLeaves[i].size();k++) {
02527           tmpList[tmpSz++] = allInternalLeaves[i][k];
02528         }<span class="comment">//end for k</span>
02529         allInternalLeaves[i].clear();
02530       } <span class="keywordflow">else</span> {
02531         tmpList[tmpSz++] = nodes[i];
02532       }
02533     }<span class="comment">//end for i</span>
02534     allInternalLeaves.clear();
02535     nodes = tmpList;
02536     tmpList.clear();
02537 
02538 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02539 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02540     <span class="keywordflow">if</span>(!rank) {
02541       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 11."</span>&lt;&lt;std::endl;
02542     }
02543     MPI_Barrier(comm);  
02544 <span class="preprocessor">#endif</span>
02545 <span class="preprocessor"></span>
02546     <span class="keywordflow">if</span>(rePart) {
02547       par::partitionW&lt;ot::TreeNode&gt;(nodes, NULL,comm);
02548     }
02549 
02550 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02551 <span class="preprocessor"></span>    MPI_Barrier(comm);  
02552     <span class="keywordflow">if</span>(!rank) {
02553       std::cout&lt;&lt;<span class="stringliteral">"Passed Step 12."</span>&lt;&lt;std::endl;
02554     }
02555     MPI_Barrier(comm);  
02556 <span class="preprocessor">#endif</span>
02557 <span class="preprocessor"></span>
02558   }<span class="comment">//end for lev</span>
02559 
02560   <a class="code" href="octUtils_8h.html#a68">PROF_PAR_RIPPLE_TYPE1_END</a> 
02561 }<span class="comment">//end function</span>
02562 
02563 <span class="comment">//myNhBlocks is automatically sorted and unique at the end of the loop.</span>
<a name="l02564"></a><a class="code" href="namespaceot.html#a18">02564</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a18">selectNeighboringBlocks</a>(<span class="keyword">const</span> std::vector&lt;TreeNode&gt;&amp; allBlocks, 
02565     <span class="keyword">const</span> std::vector&lt;TreeNode&gt;&amp; blocks, <span class="keyword">const</span> std::vector&lt;unsigned int&gt;&amp; maxBlockBndVec,
02566     <span class="keywordtype">int</span> myRank, std::vector&lt;TreeNode&gt;&amp; myNhBlocks) {
02567   <a class="code" href="octUtils_8h.html#a7">PROF_PICK_NH_BLOCKS_BEGIN</a>
02568 
02569     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; allBlocks.size(); k++) {
02570       <span class="keywordflow">if</span> (allBlocks[k].getWeight() == myRank) {
02571         <span class="comment">//Only need to send to other processors.</span>
02572         <span class="keywordflow">continue</span>;
02573       }
02574 
02575       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMinX = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
02576       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMinY = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
02577       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMinZ = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
02578       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMaxX = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
02579       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMaxY = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
02580       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMaxZ = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
02581 
02582       <span class="comment">//Even if allBlocks[k] interescts the region of influence of any of the</span>
02583       <span class="comment">//local blocks, it is included in the neighbour list.</span>
02584       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; blocks.size(); j++) {
02585         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myLen = maxBlockBndVec[j];
02586         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinX = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
02587         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinY = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
02588         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinZ = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
02589         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxX = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
02590         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxY = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
02591         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxZ = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
02592         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xlow = ( (myMinX &gt;= myLen) ? (myMinX - myLen) : myMinX );
02593         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ylow = ( (myMinY &gt;= myLen) ? (myMinY - myLen) : myMinY );
02594         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zlow = ( (myMinZ &gt;= myLen) ? (myMinZ - myLen) : myMinZ );
02595         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xhigh = ( myMaxX + myLen );
02596         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yhigh = ( myMaxY + myLen );
02597         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zhigh = ( myMaxZ + myLen );
02598 
02599         <span class="keywordflow">if</span> ( (othMinX &lt; xhigh) &amp;&amp; (othMinY &lt; yhigh) &amp;&amp; (othMinZ &lt; zhigh)
02600             &amp;&amp; (othMaxX &gt; xlow) &amp;&amp; (othMaxY &gt; ylow) &amp;&amp; (othMaxZ &gt; zlow) ) {
02601           myNhBlocks.push_back(allBlocks[k]);
02602           <span class="keywordflow">break</span>;
02603         }<span class="comment">//end if to be sent</span>
02604       }<span class="comment">//end for j</span>
02605     }<span class="comment">//end for k   </span>
02606 
02607   <a class="code" href="octUtils_8h.html#a46">PROF_PICK_NH_BLOCKS_END</a>
02608 }<span class="comment">//end function</span>
02609 
<a name="l02610"></a><a class="code" href="namespaceot.html#a19">02610</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a19">mergeComboBalAndPickBoundary</a>(std::vector&lt;ot::TreeNode&gt;&amp; out, 
02611     std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves, 
02612     <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; firstBlock, <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; lastBlock) {
02613   <a class="code" href="octUtils_8h.html#a6">PROF_MERGE_COMBO_BAL_BEGIN</a>
02614 
02615     <span class="comment">//Merge (in-place) results from the two stages, i.e. blockBalance and</span>
02616     <span class="comment">//intra-processor rippleBalance..</span>
02617     std::vector&lt;TreeNode&gt; tmpNodeList(out.size() + allBoundaryLeaves.size());
02618 
02619   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpLsz = 0;
02620   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bndCnt = 0;
02621   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bndSz = allBoundaryLeaves.size();
02622 
02623   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;i &lt; out.size();i++) {
02624     <span class="keywordflow">if</span> ( bndCnt &lt; allBoundaryLeaves.size() ) {
02625       <span class="keywordflow">if</span> ( out[i] == allBoundaryLeaves[bndCnt] ) {
02626         tmpNodeList[tmpLsz] = out[i];
02627         tmpLsz++;
02628         bndCnt++;
02629       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (out[i] &lt; allBoundaryLeaves[bndCnt] ) {
02630 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02631 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], allBoundaryLeaves[bndCnt]));
02632 <span class="preprocessor">#endif</span>
02633 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (out[i].isAncestor(allBoundaryLeaves[bndCnt]) ) {
02634           <span class="keywordflow">while</span> ( (bndCnt &lt; bndSz) &amp;&amp; 
02635               out[i].isAncestor(allBoundaryLeaves[bndCnt]) ) {
02636             tmpNodeList[tmpLsz] = allBoundaryLeaves[bndCnt];
02637             tmpLsz++;
02638             bndCnt++;
02639 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02640 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(bndCnt &lt; bndSz) {
02641               assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], allBoundaryLeaves[bndCnt]));
02642             }
02643 <span class="preprocessor">#endif</span>
02644 <span class="preprocessor"></span>          }
02645         } <span class="keywordflow">else</span> {
02646           tmpNodeList[tmpLsz] = out[i];
02647           tmpLsz++;
02648         }
02649       } <span class="keywordflow">else</span> {
02650         <span class="comment">// nodes[i] &gt; allBdy .. so insert</span>
02651         tmpNodeList[tmpLsz] = allBoundaryLeaves[bndCnt];
02652         tmpLsz++;
02653         bndCnt++;
02654       }
02655     } <span class="keywordflow">else</span> {
02656       tmpNodeList[tmpLsz] = out[i];
02657       tmpLsz++;
02658     }
02659   }<span class="comment">//end for i</span>
02660 
02661   tmpNodeList.resize(tmpLsz);
02662   out = tmpNodeList;
02663 
02664   tmpNodeList = allBoundaryLeaves;
02665   <a class="code" href="namespaceot.html#a66">pickInterProcessorBoundaryNodes</a>(tmpNodeList, allBoundaryLeaves,
02666       firstBlock, lastBlock);
02667   tmpNodeList.clear();
02668 
02669   <a class="code" href="octUtils_8h.html#a45">PROF_MERGE_COMBO_BAL_END</a> 
02670 }<span class="comment">//end function</span>
02671 
<a name="l02672"></a><a class="code" href="namespaceot.html#a20">02672</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a20">finalMergeInBal</a>(std::vector&lt;ot::TreeNode&gt;&amp; out, std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves) {
02673   <a class="code" href="octUtils_8h.html#a5">PROF_FINAL_MERGE_IN_BAL_BEGIN</a>
02674 
02675     std::vector&lt;ot::TreeNode&gt; tmpNodeList(out.size() + allBoundaryLeaves.size());
02676 
02677   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpLsz = 0;
02678   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bndSz = allBoundaryLeaves.size();
02679   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bndCnt = 0;
02680   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; out.size(); i++) {
02681     <span class="keywordflow">if</span> ( bndCnt &lt; bndSz ) {
02682       <span class="keywordflow">if</span> ( out[i] == allBoundaryLeaves[bndCnt] ) {
02683         tmpNodeList[tmpLsz++] = out[i];
02684         bndCnt++;
02685       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (out[i] &lt; allBoundaryLeaves[bndCnt] ) {
02686 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02687 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], allBoundaryLeaves[bndCnt]));
02688 <span class="preprocessor">#endif</span>
02689 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (out[i].isAncestor(allBoundaryLeaves[bndCnt]) ) {
02690           <span class="keywordflow">while</span> ( (bndCnt &lt; bndSz ) &amp;&amp; out[i].isAncestor(allBoundaryLeaves[bndCnt]) ) {
02691             tmpNodeList[tmpLsz++] = allBoundaryLeaves[bndCnt++];
02692 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02693 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(bndCnt &lt; bndSz) {
02694               assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(out[i], allBoundaryLeaves[bndCnt]));
02695             }
02696 <span class="preprocessor">#endif</span>
02697 <span class="preprocessor"></span>          }
02698         } <span class="keywordflow">else</span> {
02699           tmpNodeList[tmpLsz++] = out[i];
02700         }
02701       } <span class="keywordflow">else</span> {
02702         <span class="comment">// nodes[i] &gt; allBdy .. so insert</span>
02703         tmpNodeList[tmpLsz++] = allBoundaryLeaves[bndCnt++];
02704       }
02705     } <span class="keywordflow">else</span> {
02706       tmpNodeList[tmpLsz++] = out[i];
02707     }
02708   }<span class="comment">//end for i</span>
02709 
02710   tmpNodeList.resize(tmpLsz);
02711   out = tmpNodeList;
02712   tmpNodeList.clear();
02713   allBoundaryLeaves.clear();
02714 
02715   <a class="code" href="octUtils_8h.html#a44">PROF_FINAL_MERGE_IN_BAL_END</a>
02716 }<span class="comment">//end function</span>
02717 
<a name="l02718"></a><a class="code" href="namespaceot.html#a21">02718</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a21">prepareBalComm1MessagesType1</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves, 
02719     <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; myNhBlocks, <span class="keywordtype">int</span> npes, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, 
02720     std::vector&lt;TreeNode&gt;* sendNodes, std::vector&lt;unsigned int&gt;* sentToPid, <span class="keywordtype">int</span>* sendCnt) {
02721   <a class="code" href="octUtils_8h.html#a31">PROF_PREP_BAL_COMM1_MSSG_BEGIN</a> 
02722 
02723     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allBndSz = allBoundaryLeaves.size();
02724   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; allBndSz; j++) {
02725     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myLen = (1u &lt;&lt; (maxDepth - (allBoundaryLeaves[j].getLevel())));
02726     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinX = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
02727     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinY = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
02728     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinZ = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
02729     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xlow = ( (myMinX &gt;= myLen) ? (myMinX - myLen) : myMinX );
02730     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ylow = ( (myMinY &gt;= myLen) ? (myMinY - myLen) : myMinY );
02731     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zlow = ( (myMinZ &gt;= myLen) ? (myMinZ - myLen) : myMinZ );
02732     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xhigh = ( myMinX + (2*myLen) );
02733     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yhigh = ( myMinY + (2*myLen) );
02734     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zhigh = ( myMinZ + (2*myLen) );
02735 
02736     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastP = npes;
02737     <span class="comment">//Each node could be sent to multiple processors. So must check with</span>
02738     <span class="comment">//different blocks. All the blocks from the same processor are</span>
02739     <span class="comment">//contiguous.</span>
02740     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; myNhBlocks.size(); k++) {
02741       <span class="keywordflow">if</span> (myNhBlocks[k].getWeight() == lastP) {
02742         <span class="comment">//Already sent to this processor. It doesn't matter if there are</span>
02743         <span class="comment">//multiple blocks on the same processor in the region of influence of</span>
02744         <span class="comment">//the same node.</span>
02745         <span class="keywordflow">continue</span>;
02746       }<span class="comment">//end if sent already.</span>
02747 
02748       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMinX = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
02749       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMinY = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
02750       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMinZ = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
02751       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMaxX = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
02752       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMaxY = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
02753       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> othMaxZ = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
02754 
02755       <span class="keywordflow">if</span> ( (othMinX &lt; xhigh) &amp;&amp; (othMinY &lt; yhigh) &amp;&amp; (othMinZ &lt; zhigh)
02756           &amp;&amp; (othMaxX &gt; xlow) &amp;&amp; (othMaxY &gt; ylow) &amp;&amp; (othMaxZ &gt; zlow) ) {
02757         sendNodes[myNhBlocks[k].getWeight()].push_back(allBoundaryLeaves[j]);
02758         sentToPid[j].push_back(myNhBlocks[k].getWeight());
02759         sendCnt[myNhBlocks[k].getWeight()]++;
02760         lastP = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>();
02761       }<span class="comment">//end if to be sent</span>
02762     }<span class="comment">//end for k   </span>
02763   }<span class="comment">//end for j</span>
02764 
02765   <a class="code" href="octUtils_8h.html#a43">PROF_PREP_BAL_COMM1_MSSG_END</a> 
02766 }<span class="comment">//end function</span>
02767 
<a name="l02768"></a><a class="code" href="namespaceot.html#a22">02768</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a22">prepareWlistInBal</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; recvK1, 
02769     <span class="keyword">const</span> <span class="keywordtype">int</span>* recvCnt, <span class="keywordtype">int</span> npes, <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; myFirstBlock,
02770     <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; myLastBlock, std::vector&lt;TreeNode&gt;&amp; wList,
02771     std::vector&lt;std::vector&lt;unsigned int&gt; &gt;&amp; wListRanks) {
02772   <a class="code" href="octUtils_8h.html#a32">PROF_PREP_BAL_WLIST_BEGIN</a>
02773 
02774     std::vector&lt;ot::TreeNode&gt; recvKtemp = recvK1;
02775 
02776   <span class="keywordtype">int</span> counter = 0;
02777   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
02778     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = counter; j &lt; (counter + recvCnt[i]); j++) {
02779       recvKtemp[j].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(i);
02780     }<span class="comment">//end for j</span>
02781     counter += recvCnt[i];
02782   }<span class="comment">//end for i</span>
02783 
02784   std::vector&lt;std::vector&lt;ot::TreeNode&gt; &gt; wListTmp(recvKtemp.size());
02785   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; recvKtemp.size(); i++) {
02786     std::vector&lt;TreeNode&gt; myNh =  recvKtemp[i].<a class="code" href="classot_1_1TreeNode.html#z21_0">getAllNeighbours</a>();
02787     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myNhSz = myNh.size();
02788     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; myNhSz; k++) {
02789       <span class="comment">//Those that overlap the local domain...</span>
02790       <span class="comment">//There are only 3 types of overlaps between octants A and B.</span>
02791       <span class="comment">//a) A is an ancestor of B</span>
02792       <span class="comment">//b) B is an ancestor of A</span>
02793       <span class="comment">//c) A and B are the same.</span>
02794       <span class="comment">//Any octant &gt;= myFirstBlock and &lt;= myLastBlock.DLD if and only if it</span>
02795       <span class="comment">//lies on my processor and it is either a decendant of one of my blocks or equal to</span>
02796       <span class="comment">//one of my blocks. </span>
02797       <span class="comment">//Fact: If A is an ancestor of B, then A must also be the ancestor of</span>
02798       <span class="comment">//any octant &gt; A and &lt; B. So, if myNh[k] is not an ancestor of</span>
02799       <span class="comment">//myFirstBlock, then it can be an ancestor of some octant &gt; myFirstBlock only</span>
02800       <span class="comment">//if myNh[k] &gt;= myFirstBlock</span>
02801 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02802 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(myNh[k], myFirstBlock));
02803 <span class="preprocessor">#endif</span>
02804 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( (myNh[k].isAncestor(myFirstBlock)) ||
02805           ( (myNh[k] &gt;= myFirstBlock) &amp;&amp; (myNh[k] &lt;= myLastBlock.<a class="code" href="classot_1_1TreeNode.html#a7">getDLD</a>()) ) ) {
02806         myNh[k].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(recvKtemp[i].getWeight());
02807         wListTmp[i].push_back(myNh[k]);
02808       }
02809     }<span class="comment">//end for k</span>
02810     myNh.clear();
02811   }<span class="comment">//end for i</span>
02812 
02813   recvKtemp.clear();
02814 
02815   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0;i &lt; wListTmp.size(); i++) {
02816     wList.insert(wList.end(), wListTmp[i].begin(), wListTmp[i].end());
02817     wListTmp[i].clear();
02818   }
02819   wListTmp.clear();
02820 
02821   <a class="code" href="Sort_8h.html#a7">std::sort</a>(wList.begin(),wList.end());
02822 
02823   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wCtr=0;
02824   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wListSz = wList.size();
02825   <span class="keywordflow">if</span> (wCtr &lt; wListSz) {
02826     std::vector&lt;unsigned int&gt; tmpWr;
02827     tmpWr.push_back(wList[0].getWeight());
02828     wList[0].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
02829     wListRanks.push_back (tmpWr);
02830     tmpWr.clear();
02831     wCtr++;
02832   }
02833 
02834   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> rowCtr = 0;
02835   <span class="keywordflow">while</span> (wCtr &lt; wListSz) {
02836     <span class="keywordflow">if</span> (wList[wCtr] == wList[wCtr-1]) {
02837       wListRanks[rowCtr].push_back(wList[wCtr].getWeight());
02838       wList[wCtr].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
02839     } <span class="keywordflow">else</span> {
02840       seq::makeVectorUnique&lt;unsigned int&gt;(wListRanks[rowCtr],<span class="keyword">false</span>);
02841       std::vector&lt;unsigned int&gt; tmpWr;
02842       tmpWr.push_back(wList[wCtr].getWeight());
02843       wList[wCtr].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
02844       wListRanks.push_back(tmpWr);
02845       tmpWr.clear();
02846       rowCtr++;
02847     }
02848     wCtr++;
02849   }<span class="comment">//end while</span>
02850 
02851   seq::makeVectorUnique&lt;TreeNode&gt;(wList, <span class="keyword">true</span>);
02852 
02853   <a class="code" href="octUtils_8h.html#a42">PROF_PREP_BAL_WLIST_END</a>
02854 }<span class="comment">//end function</span>
02855 
02856 <span class="comment">/*</span>
02857 <span class="comment">   Some Facts: allBoundaryLeaves is linear, sorted,unique, incomplete</span>
02858 <span class="comment">   wList is not linear (overlaps are allowed), it is sorted, unique and incomplete.</span>
02859 <span class="comment">   All elements in wList are in the domain controlled by this processor.</span>
02860 <span class="comment">   wList and wListRanks are in sync always.</span>
02861 <span class="comment">   Each element in allBoundaryLeaves can overlap with multiple elements in wList and vice-versa.</span>
02862 <span class="comment">   Important Property: If A &lt; B &lt; C and if A and B do not overlap then A and C also do not overlap.</span>
02863 <span class="comment">   This can be proved by contradiction, Suppose A and C overlap,</span>
02864 <span class="comment">   then either A is an ancestor of C or C is an ancestor of A or both are equal.</span>
02865 <span class="comment">   The third is automatically ruled out. The second is not possible since C &gt; A.</span>
02866 <span class="comment">   If A was an ancestor of C then A has to be an ancestor of B as well and since this </span>
02867 <span class="comment">   is not the case, A and C can't overlap.</span>
02868 <span class="comment">   */</span>
<a name="l02869"></a><a class="code" href="namespaceot.html#a23">02869</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a23">prepareBalComm2Messages</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves,
02870     <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; wList,
02871     <span class="keyword">const</span> std::vector&lt;std::vector&lt;unsigned int&gt; &gt;&amp; wListRanks,
02872     std::vector&lt;TreeNode&gt;* sendNodes, std::vector&lt;unsigned int&gt;* sentToPid, <span class="keywordtype">int</span>* sendCnt) {
02873   <a class="code" href="octUtils_8h.html#a33">PROF_PREP_BAL_COMM2_MSSG_BEGIN</a> 
02874 
02875     <span class="comment">/*</span>
02876 <span class="comment">       Why is sendNodes[i] sorted at the end of this loop?</span>
02877 <span class="comment">       1. For each processor, the blocks (W) corresponding to that</span>
02878 <span class="comment">       processor are visited in a sorted order.</span>
02879 <span class="comment"></span>
02880 <span class="comment">       2. For any given processor say W1 is visited before W2 =&gt; W1 &lt; W2.</span>
02881 <span class="comment"></span>
02882 <span class="comment">       3. Either W1 is an ancestor of W2 or W1 and W2 do not overlap</span>
02883 <span class="comment"></span>
02884 <span class="comment">       4. All bnd sent to W1 are sent in a sorted order.</span>
02885 <span class="comment"></span>
02886 <span class="comment">       5. Let B1 be the list of elements that overlap with W1 and </span>
02887 <span class="comment">       let B2 be the ones that overlap with W2.</span>
02888 <span class="comment"></span>
02889 <span class="comment">       6. There are only two possibilites: either B2 is a subset of B1 or</span>
02890 <span class="comment">       B1 and B2 have no common elements and min(B2) &gt; max(B1).</span>
02891 <span class="comment"></span>
02892 <span class="comment">       7. IF W2 is a decendant of W1, then clearly any ancestor of W2 or</span>
02893 <span class="comment">       decendant of W2 also overlaps W1, thus B2 is a subset of B1. Since, all </span>
02894 <span class="comment">       of these were sent already they will not be sent to the same processor </span>
02895 <span class="comment">       again and thus they will not disturb the order.</span>
02896 <span class="comment"></span>
02897 <span class="comment">       8. If W2 &gt; W1 and W2 and W1 do not overlap, then the only octants that overlap both</span>
02898 <span class="comment">       W1 and W2 are the common ancestors.</span>
02899 <span class="comment"></span>
02900 <span class="comment">       9. If there is a common ancestor of both in allBnd, it will be sent during the comparison</span>
02901 <span class="comment">       with W1 and no other elements in allBnd will overlap either W1 or W2. In this case B1=B2.</span>
02902 <span class="comment"></span>
02903 <span class="comment">       10. If there are no common ancestors then B1 and B2 have no common elements.</span>
02904 <span class="comment"></span>
02905 <span class="comment">       11. Since W2 &gt;W1 any octant that overlaps W2 but not W1 has to be &gt; all decendants of W1.</span>
02906 <span class="comment">       Hence, min(B2) &gt; max(B1).</span>
02907 <span class="comment">       */</span>
02908 
02909     <span class="keywordtype">int</span> lastStart = 0;
02910   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> wListSz = wList.size();
02911   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allBndSz = allBoundaryLeaves.size();
02912   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> ii = 0; ii &lt; wListSz; ii++) {
02913     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = lastStart; j &lt; allBndSz; j++) {
02914       <span class="comment">//Each node could be sent to multiple processors.</span>
02915 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
02916 <span class="preprocessor"></span>      assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(wList[ii], allBoundaryLeaves[j]));
02917 <span class="preprocessor">#endif</span>
02918 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ((wList[ii] == allBoundaryLeaves[j]) || (wList[ii].isAncestor(allBoundaryLeaves[j]))
02919           || (allBoundaryLeaves[j].isAncestor(wList[ii]))) {
02920         <span class="comment">//Overlap...</span>
02921         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> jj = 0; jj &lt; wListRanks[ii].size(); jj++) {
02922           <span class="keywordtype">bool</span> sentAlready = <span class="keyword">false</span>;
02923           <span class="keywordflow">for</span> (<span class="keywordtype">int</span> kk = 0; kk &lt; sentToPid[j].size(); kk++) {
02924             <span class="comment">//loopCtr++;</span>
02925             <span class="keywordflow">if</span> (sentToPid[j][kk] == wListRanks[ii][jj]) {
02926               sentAlready = <span class="keyword">true</span>;
02927               <span class="keywordflow">break</span>;
02928             }
02929           }<span class="comment">//end for kk</span>
02930           <span class="keywordflow">if</span> (!sentAlready) {
02931             sendNodes[wListRanks[ii][jj]].push_back(allBoundaryLeaves[j]);
02932             sendCnt[wListRanks[ii][jj]]++;
02933             sentToPid[j].push_back(wListRanks[ii][jj]);
02934           }
02935         }<span class="comment">//end for jj</span>
02936       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (wList[ii] &lt; allBoundaryLeaves[j]) {
02937         <span class="comment">//No overlap w &lt; allBnd</span>
02938         <span class="comment">//Since, W does not intersect this it will not intersect any element that follows.</span>
02939         <span class="comment">//This is the justification for early termination.</span>
02940         <span class="keywordflow">break</span>;
02941       } <span class="keywordflow">else</span> {
02942         <span class="comment">//No overlap allBnd &lt; w</span>
02943         <span class="comment">//Since, allBnd does not intersect this w, it will not intersect any</span>
02944         <span class="comment">//element in w that follows. So subsequent w need not be compared</span>
02945         <span class="comment">//against this.</span>
02946         lastStart++;
02947       }<span class="comment">//end if-else overlaps</span>
02948     }<span class="comment">//end for j</span>
02949   }<span class="comment">//end for ii</span>
02950 
02951   <a class="code" href="octUtils_8h.html#a41">PROF_PREP_BAL_COMM2_MSSG_END</a> 
02952 }<span class="comment">//end function</span>
02953 
<a name="l02954"></a><a class="code" href="namespaceot.html#a24">02954</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a24">mergeRecvKeysInBal</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; recvK1, <span class="keyword">const</span> <span class="keywordtype">int</span>* recvOffsets1,
02955     <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; recvK2, <span class="keyword">const</span> <span class="keywordtype">int</span>* recvOffsets2, 
02956     <span class="keywordtype">int</span> npes, std::vector&lt;ot::TreeNode&gt;&amp; recvK) {
02957   <a class="code" href="octUtils_8h.html#a34">PROF_MERGE_RECV_KEYS_BAL_BEGIN</a> 
02958 
02959     recvK.resize(recvK1.size() + recvK2.size());
02960 
02961   <span class="comment">//Note, you only recieve from other processors and not from yourself.</span>
02962   <span class="comment">//Merge recvK1 and recvK2 inplace....</span>
02963 
02964   <span class="comment">//Basic idea... All elements from processor i are less than those from i+1.</span>
02965   <span class="comment">//The elements in recvK1 and recvK2 are independently sorted.</span>
02966   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> recvKcnt = 0;
02967   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
02968     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextFrom1 = recvOffsets1[i];
02969     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nextFrom2 = recvOffsets2[i];
02970     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end1 = ((i &lt;(npes - 1)) ? recvOffsets1[i+1] : recvK1.size());
02971     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end2 = ((i &lt;(npes - 1)) ? recvOffsets2[i+1] : recvK2.size());
02972     <span class="keywordflow">while</span> ( (nextFrom1 &lt; end1) || (nextFrom2 &lt; end2) ) {
02973 
02974       <span class="keywordflow">if</span> (nextFrom1 &lt; end1 &amp;&amp; nextFrom2 &lt; end2) {
02975         <span class="keywordflow">while</span> (recvK1[nextFrom1] &lt;= recvK2[nextFrom2]) {
02976           recvK[recvKcnt++] = recvK1[nextFrom1];
02977           nextFrom1++;
02978           <span class="keywordflow">if</span> (nextFrom1 &gt;= end1) {
02979             <span class="keywordflow">break</span>;
02980           }
02981         }
02982       }
02983 
02984       <span class="keywordflow">if</span> (nextFrom1 &lt; end1 &amp;&amp; nextFrom2 &lt; end2) {
02985         <span class="keywordflow">while</span> (recvK1[nextFrom1] &gt; recvK2[nextFrom2]) {
02986           recvK[recvKcnt++] = recvK2[nextFrom2];
02987           nextFrom2++;
02988           <span class="keywordflow">if</span> (nextFrom2 &gt;= end2) {
02989             <span class="keywordflow">break</span>;
02990           }
02991         }
02992       }
02993 
02994       <span class="keywordflow">if</span> (nextFrom2 &gt;= end2) {
02995         <span class="keywordflow">while</span> (nextFrom1 &lt; end1) {
02996           recvK[recvKcnt++] = recvK1[nextFrom1];
02997           nextFrom1++;
02998         }
02999       }
03000 
03001       <span class="keywordflow">if</span> (nextFrom1 &gt;= end1) {
03002         <span class="keywordflow">while</span> (nextFrom2 &lt; end2) {
03003           recvK[recvKcnt++] = recvK2[nextFrom2];
03004           nextFrom2++;
03005         }
03006       }
03007 
03008     }
03009   }<span class="comment">//end for i</span>
03010 
03011   <a class="code" href="octUtils_8h.html#a40">PROF_MERGE_RECV_KEYS_BAL_END</a> 
03012 }<span class="comment">//end function</span>
03013 
<a name="l03014"></a><a class="code" href="namespaceot.html#a25">03014</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a25">prepareBalComm1MessagesType2</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves, 
03015     <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; minsAllBlocks, <span class="keywordtype">int</span> rank, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, 
03016     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, std::vector&lt;TreeNode&gt;* sendNodes,
03017     std::vector&lt;unsigned int&gt;* sentToPid, <span class="keywordtype">int</span>* sendCnt) {
03018   <a class="code" href="octUtils_8h.html#a31">PROF_PREP_BAL_COMM1_MSSG_BEGIN</a> 
03019 
03020     <span class="comment">//Each octant must be sent to all processors which overlap its insulation</span>
03021     <span class="comment">//layer. So we generate all the neighbours (nh) of this octant at this level and</span>
03022     <span class="comment">//find all processors that lie in between maxLowerBound(DFD(nh(i))) and</span>
03023     <span class="comment">//maxLowerBound(DLD(nh(i))) for all i</span>
03024 
03025     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allBndSz = allBoundaryLeaves.size();
03026   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> rootNode(dim, maxDepth);
03027   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; allBndSz; j++) {
03028     std::vector&lt;ot::TreeNode&gt; myNh = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#z21_0">getAllNeighbours</a>();
03029 
03030     seq::makeVectorUnique&lt;ot::TreeNode&gt;(myNh, <span class="keyword">false</span>);
03031     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stIdx = ( (myNh[0] == rootNode) ? 1 : 0 );
03032 
03033     std::vector&lt;unsigned int&gt; pIds;
03034     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = stIdx; i &lt; myNh.size(); i++) {
03035       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx1;
03036       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx2;
03037       seq::maxLowerBound&lt;ot::TreeNode&gt;(minsAllBlocks, myNh[i].getDFD(), idx1, NULL, NULL);
03038       seq::maxLowerBound&lt;ot::TreeNode&gt;(minsAllBlocks, myNh[i].getDLD(), idx2, NULL, NULL);
03039       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = idx1; k &lt;= idx2; k++) {
03040         pIds.push_back(k);
03041       }<span class="comment">//end for k</span>
03042     }<span class="comment">//end for i</span>
03043 
03044 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
03045 <span class="preprocessor"></span>    <span class="comment">//myNh is explicitly sorted. Moreover, no two elements of myNh overlap and since</span>
03046     <span class="comment">//myNh(i) &lt; myNh(i+1) this implies that</span>
03047     <span class="comment">//myNh(i).getDFD() &lt;= myNh(i).getDLD() &lt; myNh(i+1).getDFD() &lt;=</span>
03048     <span class="comment">//myNh(i+1).getDLD() </span>
03049     <span class="comment">//If a &lt; b then MLB(a) &lt;= MLB(b). So uniqueness if not guaranteed.</span>
03050     assert(seq::test::isSorted&lt;unsigned int&gt;(pIds));
03051 <span class="preprocessor">#endif</span>
03052 <span class="preprocessor"></span>
03053     seq::makeVectorUnique&lt;unsigned int&gt;(pIds, <span class="keyword">true</span>);
03054 
03055     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; pIds.size(); i++) {
03056       <span class="keywordflow">if</span>(pIds[i] != rank) {
03057         sendNodes[pIds[i]].push_back(allBoundaryLeaves[j]);
03058         sentToPid[j].push_back(pIds[i]);
03059         sendCnt[pIds[i]]++;
03060       }
03061     }<span class="comment">//end for i</span>
03062   }<span class="comment">//end for j</span>
03063 
03064   <a class="code" href="octUtils_8h.html#a43">PROF_PREP_BAL_COMM1_MSSG_END</a> 
03065 }<span class="comment">//end function</span>
03066 
03067 }<span class="comment">//end namespace</span>
03068 
03069 
03070 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:30 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
