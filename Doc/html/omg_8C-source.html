<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/omg/omg.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000018.html">omg</a></div>
<h1>omg.C</h1><a href="omg_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "<a class="code" href="dtypes_8h.html">dtypes.h</a>"</span>
00008 <span class="preprocessor">#include "petscmat.h"</span>
00009 <span class="preprocessor">#include "<a class="code" href="omg_8h.html">omg.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00011 <span class="preprocessor">#include "petscmg.h"</span>
00012 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00013 <span class="preprocessor">#include &lt;iostream&gt;</span>
00014 <span class="preprocessor">#include "<a class="code" href="dendro_8h.html">dendro.h</a>"</span>
00015 
00016 <span class="preprocessor">#ifndef iC</span>
<a name="l00017"></a><a class="code" href="omg_8C.html#a0">00017</a> <span class="preprocessor"></span><span class="preprocessor">#define iC(fun) {CHKERRQ(fun);}</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#ifdef __DEBUG__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_MG__</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_MG__</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="keyword">namespace </span>ot {
00027 
00028   <span class="keyword">extern</span> <span class="keywordtype">double</span> ***** RmatType1Stencil;
00029   <span class="keyword">extern</span> <span class="keywordtype">double</span> **** RmatType2Stencil;
00030   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>**** VtxMap1; 
00031   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>***** VtxMap2; 
00032   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>***** VtxMap3; 
00033   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>****** VtxMap4; 
00034 
00035   <span class="keyword">extern</span> void (*getPrivateMatricesForKSP_Shell)(Mat mat,
00036       Mat *AmatPrivate, Mat *PmatPrivate, MatStructure* pFlag);
00037 
00038   <span class="comment">//Public Functions</span>
00039 
<a name="l00040"></a><a class="code" href="namespaceot.html#a88">00040</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a88">DAMGCreateSuppressedDOFs</a>(<a class="code" href="structot_1_1__p__DAMG.html">DAMG</a>* damg) {
00041     <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
00042     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o5">dof</a>;
00043     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
00044       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = (dof*(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a2">getLocalBufferSize</a>()));
00045       <span class="keywordflow">if</span>(sz) {
00046         damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a> = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[sz];
00047       }
00048 
00049       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
00050         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz2 = (dof*(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#a2">getLocalBufferSize</a>()));
00051         <span class="keywordflow">if</span>(sz2) {
00052           damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o16">suppressedDOFaux</a> = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[sz2];
00053         }
00054       }
00055     }
00056     <span class="keywordflow">return</span> 1;
00057   }
00058 
<a name="l00059"></a><a class="code" href="namespaceot.html#a89">00059</a>   PetscErrorCode <a class="code" href="namespaceot.html#a89">DAMG_Initialize</a>(MPI_Comm comm) {
00060     <a class="code" href="omg_8h.html#a12">PROF_MG_INIT_BEGIN</a>  
00061 
00062 <span class="preprocessor">#ifdef __USE_MG_INIT_TYPE3__</span>
00063 <span class="preprocessor"></span>      <a class="code" href="namespaceot.html#a90">ot::DAMG_InitPrivateType3</a>(comm);
00064 <span class="preprocessor">#else</span>
00065 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_MG_INIT_TYPE2__</span>
00066 <span class="preprocessor"></span>    <a class="code" href="namespaceot.html#a91">ot::DAMG_InitPrivateType2</a>(comm);
00067 <span class="preprocessor">#else</span>
00068 <span class="preprocessor"></span>    <a class="code" href="namespaceot.html#a92">ot::DAMG_InitPrivateType1</a>(comm);
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00071 <span class="preprocessor"></span>
00072     <a class="code" href="omg_8h.html#a13">PROF_MG_INIT_END</a>  
00073   }
00074 
<a name="l00075"></a><a class="code" href="namespaceot.html#a90">00075</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a90">DAMG_InitPrivateType3</a>(MPI_Comm comm) {
00076 
00077     <span class="keywordtype">int</span> rank;
00078     MPI_Comm_rank(comm, &amp;rank);
00079 
00080     <a class="code" href="namespaceot.html#a121">IreadRmatType1Stencil</a>(<a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>, rank);
00081     <a class="code" href="namespaceot.html#a124">IreadRmatType2Stencil</a>(<a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>, rank);
00082     <a class="code" href="namespaceot.html#a127">IreadVtxMaps</a>(<a class="code" href="namespaceot.html#a2">VtxMap1</a>, <a class="code" href="namespaceot.html#a3">VtxMap2</a>, <a class="code" href="namespaceot.html#a4">VtxMap3</a>, <a class="code" href="namespaceot.html#a5">VtxMap4</a>, rank);
00083 
00084   }
00085 
<a name="l00086"></a><a class="code" href="namespaceot.html#a91">00086</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a91">DAMG_InitPrivateType2</a>(MPI_Comm comm) {
00087 
00088     <span class="keywordtype">int</span> rank, npes;
00089     MPI_Comm_rank(comm, &amp;rank);
00090     MPI_Comm_size(comm, &amp;npes);
00091 
00092     <span class="keyword">const</span> <span class="keywordtype">int</span> THOUSAND = 1000;
00093     <span class="keywordtype">int</span> numGroups = (npes/THOUSAND);
00094     <span class="keywordflow">if</span>( (numGroups*THOUSAND) &lt; npes) {
00095       numGroups++;
00096     }
00097 
00098     MPI_Comm newComm;
00099 
00100     <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npes];
00101     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numGroups; i++) {
00102       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; (j &lt; (i*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00103         isEmptyList[j] = <span class="keyword">true</span>;
00104       }
00105       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = (i*THOUSAND); (j &lt; ((i+1)*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00106         isEmptyList[j] = <span class="keyword">false</span>;
00107       }
00108       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = ((i + 1)*THOUSAND); j &lt; npes; j++) {
00109         isEmptyList[j] = <span class="keyword">true</span>;
00110       }
00111       MPI_Comm tmpComm;
00112       <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(isEmptyList, &amp;tmpComm, comm);
00113       <span class="keywordflow">if</span>(!(isEmptyList[rank])) {
00114         newComm = tmpComm;
00115       }
00116     }<span class="comment">//end for i</span>
00117     <span class="keyword">delete</span> [] isEmptyList;
00118 
00119     <span class="keywordflow">if</span>( (rank % THOUSAND) == 0) {
00120       <a class="code" href="namespaceot.html#a121">IreadRmatType1Stencil</a>(<a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>, (rank/THOUSAND));
00121       <a class="code" href="namespaceot.html#a124">IreadRmatType2Stencil</a>(<a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>, (rank/THOUSAND));
00122       <a class="code" href="namespaceot.html#a127">IreadVtxMaps</a>(<a class="code" href="namespaceot.html#a2">VtxMap1</a>, <a class="code" href="namespaceot.html#a3">VtxMap2</a>, <a class="code" href="namespaceot.html#a4">VtxMap3</a>, <a class="code" href="namespaceot.html#a5">VtxMap4</a>, (rank/THOUSAND));
00123     } <span class="keywordflow">else</span> {
00124       <span class="comment">//Other processors simply allocate the required amount of memory</span>
00125       <span class="keyword">typedef</span> <span class="keywordtype">double</span>**** double4Ptr;
00126       <span class="keyword">typedef</span> <span class="keywordtype">double</span>*** double3Ptr;
00127       <span class="keyword">typedef</span> <span class="keywordtype">double</span>** double2Ptr;
00128       <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00129 
00130       <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a> = <span class="keyword">new</span> double4Ptr[8];
00131       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00132         <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i] = <span class="keyword">new</span> double3Ptr[8];
00133         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00134           <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j] = <span class="keyword">new</span> double2Ptr[18];
00135           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00136             <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k] = <span class="keyword">new</span> doublePtr[8];
00137             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00138               <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k][l] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00139             }<span class="comment">//end for l</span>
00140           }<span class="comment">//end for k</span>
00141         }<span class="comment">//end for j</span>
00142       }<span class="comment">//end for i</span>
00143 
00144       <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>  = <span class="keyword">new</span> double3Ptr[8];
00145       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00146         <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j] = <span class="keyword">new</span> double2Ptr[18];
00147         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00148           <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k] = <span class="keyword">new</span> doublePtr[8];
00149           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00150             <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k][l] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00151           }<span class="comment">//end for l</span>
00152         }<span class="comment">//end for k</span>
00153       }<span class="comment">//end for j</span>
00154 
00155       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>***** us5Ptr;
00156       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>**** us4Ptr;
00157       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*** us3Ptr;
00158       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>** us2Ptr;
00159       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* usPtr;
00160 
00161       <a class="code" href="namespaceot.html#a2">VtxMap1</a> = <span class="keyword">new</span> us3Ptr[8];
00162       <a class="code" href="namespaceot.html#a3">VtxMap2</a> = <span class="keyword">new</span> us4Ptr[8];
00163       <a class="code" href="namespaceot.html#a4">VtxMap3</a> = <span class="keyword">new</span> us4Ptr[7];
00164       <a class="code" href="namespaceot.html#a5">VtxMap4</a> = <span class="keyword">new</span> us5Ptr[7];
00165       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00166         <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i] = <span class="keyword">new</span> us2Ptr[8];
00167         <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i] = <span class="keyword">new</span> us3Ptr[8];
00168         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00169           <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j] = <span class="keyword">new</span> usPtr[18];
00170           <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j] = <span class="keyword">new</span> us2Ptr[8];
00171           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00172             <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j][k] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00173           }
00174           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00175             <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k] = <span class="keyword">new</span> usPtr[18];
00176             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00177               <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k][l] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00178             }<span class="comment">//end for l</span>
00179           }<span class="comment">//end for k</span>
00180         }<span class="comment">//end for j</span>
00181       }<span class="comment">//end for i</span>
00182 
00183       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00184         <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i] = <span class="keyword">new</span> us3Ptr[2];
00185         <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i] = <span class="keyword">new</span> us4Ptr[2];
00186         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00187           <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j] = <span class="keyword">new</span> us2Ptr[8];
00188           <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j] = <span class="keyword">new</span> us3Ptr[8]; 
00189           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00190             <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k] = <span class="keyword">new</span> usPtr[18];
00191             <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k] = <span class="keyword">new</span> us2Ptr[8];
00192             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00193               <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k][l] =<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00194             }
00195             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00196               <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l] = <span class="keyword">new</span> usPtr[18];
00197               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 18; m++) {
00198                 <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l][m] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00199               }
00200             }<span class="comment">//end for l</span>
00201           }<span class="comment">//end for k</span>
00202         }<span class="comment">//end for j</span>
00203       }<span class="comment">//end for i</span>
00204 
00205     }<span class="comment">//end if processor reads</span>
00206 
00207     <span class="comment">//Processor 0 in each comm  Broadcasts to other processors in the comm</span>
00208     <span class="comment">//doubles ...</span>
00209     <span class="comment">//RmatType1[8][8][18][8][8]: 73728</span>
00210     <span class="comment">//RmatType2[8][18][8][8]: 9216</span>
00211     <span class="keywordtype">double</span> * tmpRmats = <span class="keyword">new</span> <span class="keywordtype">double</span> [82944];
00212 
00213     <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00214       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00215       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00216         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00217           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00218             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00219               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00220                 tmpRmats[ctr] = <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k][l][m];
00221                 ctr++;
00222               }<span class="comment">//end for m</span>
00223             }<span class="comment">//end for l</span>
00224           }<span class="comment">//end for k</span>
00225         }<span class="comment">//end for j</span>
00226       }<span class="comment">//end for i</span>
00227       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00228         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00229           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00230             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00231               tmpRmats[ctr] = <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k][l][m];
00232               ctr++;
00233             }<span class="comment">//end for m</span>
00234           }<span class="comment">//end for l</span>
00235         }<span class="comment">//end for k</span>
00236       }<span class="comment">//end for j</span>
00237     }
00238 
00239     par::Mpi_Bcast&lt;double&gt;(tmpRmats, 82944, 0, newComm);
00240 
00241     <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
00242       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00243       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00244         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00245           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00246             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00247               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00248                 <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k][l][m] = tmpRmats[ctr];
00249                 ctr++;
00250               }<span class="comment">//end for m</span>
00251             }<span class="comment">//end for l</span>
00252           }<span class="comment">//end for k</span>
00253         }<span class="comment">//end for j</span>
00254       }<span class="comment">//end for i</span>
00255       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00256         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00257           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00258             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00259               <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k][l][m] = tmpRmats[ctr];
00260               ctr++;
00261             }<span class="comment">//end for m</span>
00262           }<span class="comment">//end for l</span>
00263         }<span class="comment">//end for k</span>
00264       }<span class="comment">//end for j</span>
00265     }
00266 
00267     <span class="keyword">delete</span> [] tmpRmats;
00268 
00269     <span class="comment">//unsigned shorts...</span>
00270     <span class="comment">//map1[8][8][18][8]: 9216</span>
00271     <span class="comment">//map2[8][8][8][18][8]: 73728</span>
00272     <span class="comment">//map3[7][2][8][18][8]: 16128</span>
00273     <span class="comment">//map4[7][2][8][8][18][8]: 129024</span>
00274     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> * tmpVtxMaps = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[228096];
00275 
00276     <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00277       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00278       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00279         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00280           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00281             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00282               tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j][k][l]; 
00283               ctr++;
00284             }<span class="comment">//end for l</span>
00285           }<span class="comment">//end for k</span>
00286         }<span class="comment">//end for j</span>
00287       }<span class="comment">//end for i</span>
00288       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00289         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00290           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00291             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00292               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00293                 tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k][l][m]; 
00294                 ctr++;
00295               }<span class="comment">//end for m</span>
00296             }<span class="comment">//end for l</span>
00297           }<span class="comment">//end for k</span>
00298         }<span class="comment">//end for j</span>
00299       }<span class="comment">//end for i</span>
00300       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00301         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00302           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00303             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00304               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00305                 tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k][l][m]; 
00306                 ctr++;
00307               }<span class="comment">//end for m</span>
00308             }<span class="comment">//end for l</span>
00309           }<span class="comment">//end for k</span>
00310         }<span class="comment">//end for j</span>
00311       }<span class="comment">//end for i</span>
00312       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00313         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00314           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00315             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00316               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 18; m++) {
00317                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; 8; n++) {
00318                   tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l][m][n]; 
00319                   ctr++;
00320                 }<span class="comment">//end for n</span>
00321               }<span class="comment">//end for m</span>
00322             }<span class="comment">//end for l</span>
00323           }<span class="comment">//end for k</span>
00324         }<span class="comment">//end for j</span>
00325       }<span class="comment">//end for i</span>
00326     }
00327 
00328     par::Mpi_Bcast&lt;unsigned short&gt;(tmpVtxMaps, 228096, 0, newComm);
00329 
00330     <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
00331       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00332       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00333         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00334           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00335             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00336               <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j][k][l] = tmpVtxMaps[ctr]; 
00337               ctr++;
00338             }<span class="comment">//end for l</span>
00339           }<span class="comment">//end for k</span>
00340         }<span class="comment">//end for j</span>
00341       }<span class="comment">//end for i</span>
00342       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00343         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00344           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00345             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00346               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00347                 <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k][l][m] = tmpVtxMaps[ctr]; 
00348                 ctr++;
00349               }<span class="comment">//end for m</span>
00350             }<span class="comment">//end for l</span>
00351           }<span class="comment">//end for k</span>
00352         }<span class="comment">//end for j</span>
00353       }<span class="comment">//end for i</span>
00354       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00355         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00356           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00357             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00358               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00359                 <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k][l][m] = tmpVtxMaps[ctr]; 
00360                 ctr++;
00361               }<span class="comment">//end for m</span>
00362             }<span class="comment">//end for l</span>
00363           }<span class="comment">//end for k</span>
00364         }<span class="comment">//end for j</span>
00365       }<span class="comment">//end for i</span>
00366       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00367         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00368           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00369             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00370               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 18; m++) {
00371                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; 8; n++) {
00372                   <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l][m][n] = tmpVtxMaps[ctr]; 
00373                   ctr++;
00374                 }<span class="comment">//end for n</span>
00375               }<span class="comment">//end for m</span>
00376             }<span class="comment">//end for l</span>
00377           }<span class="comment">//end for k</span>
00378         }<span class="comment">//end for j</span>
00379       }<span class="comment">//end for i</span>
00380     }
00381 
00382     <span class="keyword">delete</span> [] tmpVtxMaps;
00383 
00384   }
00385 
<a name="l00386"></a><a class="code" href="namespaceot.html#a92">00386</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a92">DAMG_InitPrivateType1</a>(MPI_Comm comm) {
00387 
00388     <span class="keywordtype">int</span> rank;
00389     MPI_Comm_rank(comm, &amp;rank);
00390 
00391     <span class="keywordflow">if</span>(!rank) {
00392       <span class="comment">//Processor 0 reads the stencils</span>
00393       <a class="code" href="namespaceot.html#a120">readRmatType1Stencil</a>(<a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>);
00394       <a class="code" href="namespaceot.html#a123">readRmatType2Stencil</a>(<a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>);
00395       <a class="code" href="namespaceot.html#a126">readVtxMaps</a>(<a class="code" href="namespaceot.html#a2">VtxMap1</a>, <a class="code" href="namespaceot.html#a3">VtxMap2</a>, <a class="code" href="namespaceot.html#a4">VtxMap3</a>, <a class="code" href="namespaceot.html#a5">VtxMap4</a>);
00396     } <span class="keywordflow">else</span> {
00397       <span class="comment">//Other processors simply allocate the required amount of memory</span>
00398       <span class="keyword">typedef</span> <span class="keywordtype">double</span>**** double4Ptr;
00399       <span class="keyword">typedef</span> <span class="keywordtype">double</span>*** double3Ptr;
00400       <span class="keyword">typedef</span> <span class="keywordtype">double</span>** double2Ptr;
00401       <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00402 
00403       <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a> = <span class="keyword">new</span> double4Ptr[8];
00404       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00405         <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i] = <span class="keyword">new</span> double3Ptr[8];
00406         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00407           <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j] = <span class="keyword">new</span> double2Ptr[18];
00408           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00409             <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k] = <span class="keyword">new</span> doublePtr[8];
00410             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00411               <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k][l] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00412             }
00413           }
00414         }
00415       }
00416 
00417       <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>  = <span class="keyword">new</span> double3Ptr[8];
00418       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00419         <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j] = <span class="keyword">new</span> double2Ptr[18];
00420         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00421           <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k] = <span class="keyword">new</span> doublePtr[8];
00422           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00423             <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k][l] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00424           }
00425         }
00426       }
00427 
00428       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>***** us5Ptr;
00429       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>**** us4Ptr;
00430       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>*** us3Ptr;
00431       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>** us2Ptr;
00432       <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>* usPtr;
00433 
00434       <a class="code" href="namespaceot.html#a2">VtxMap1</a> = <span class="keyword">new</span> us3Ptr[8];
00435       <a class="code" href="namespaceot.html#a3">VtxMap2</a> = <span class="keyword">new</span> us4Ptr[8];
00436       <a class="code" href="namespaceot.html#a4">VtxMap3</a> = <span class="keyword">new</span> us4Ptr[7];
00437       <a class="code" href="namespaceot.html#a5">VtxMap4</a> = <span class="keyword">new</span> us5Ptr[7];
00438       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00439         <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i] = <span class="keyword">new</span> us2Ptr[8];
00440         <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i] = <span class="keyword">new</span> us3Ptr[8];
00441         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00442           <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j] = <span class="keyword">new</span> usPtr[18];
00443           <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j] = <span class="keyword">new</span> us2Ptr[8];
00444           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00445             <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j][k] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00446           }
00447           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00448             <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k] = <span class="keyword">new</span> usPtr[18];
00449             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00450               <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k][l] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00451             }
00452           }
00453         }
00454       }<span class="comment">//end for i</span>
00455 
00456       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00457         <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i] = <span class="keyword">new</span> us3Ptr[2];
00458         <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i] = <span class="keyword">new</span> us4Ptr[2];
00459         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00460           <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j] = <span class="keyword">new</span> us2Ptr[8];
00461           <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j] = <span class="keyword">new</span> us3Ptr[8]; 
00462           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00463             <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k] = <span class="keyword">new</span> usPtr[18];
00464             <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k] = <span class="keyword">new</span> us2Ptr[8];
00465             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00466               <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k][l] =<span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00467             }
00468             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00469               <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l] = <span class="keyword">new</span> usPtr[18];
00470               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 18; m++) {
00471                 <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l][m] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[8];
00472               }
00473             }
00474           }
00475         }
00476       }<span class="comment">//end for i</span>
00477 
00478     }<span class="comment">//end if p0</span>
00479 
00480     <span class="comment">//Processor 0 Broadcasts to other processors</span>
00481     <span class="comment">//doubles ...</span>
00482     <span class="comment">//RmatType1[8][8][18][8][8]: 73728</span>
00483     <span class="comment">//RmatType2[8][18][8][8]: 9216</span>
00484     <span class="keywordtype">double</span> * tmpRmats = <span class="keyword">new</span> <span class="keywordtype">double</span> [82944];
00485 
00486     <span class="keywordflow">if</span>(!rank) {
00487       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00488       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00489         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00490           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00491             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00492               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00493                 tmpRmats[ctr] = <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k][l][m];
00494                 ctr++;
00495               }<span class="comment">//end for m</span>
00496             }<span class="comment">//end for l</span>
00497           }<span class="comment">//end for k</span>
00498         }<span class="comment">//end for j</span>
00499       }<span class="comment">//end for i</span>
00500       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00501         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00502           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00503             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00504               tmpRmats[ctr] = <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k][l][m];
00505               ctr++;
00506             }<span class="comment">//end for m</span>
00507           }<span class="comment">//end for l</span>
00508         }<span class="comment">//end for k</span>
00509       }<span class="comment">//end for j</span>
00510     }
00511 
00512     par::Mpi_Bcast&lt;double&gt;(tmpRmats, 82944, 0, comm);
00513 
00514     <span class="keywordflow">if</span>(rank) {
00515       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00516       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00517         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00518           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00519             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00520               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00521                 <a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>[i][j][k][l][m] = tmpRmats[ctr];
00522                 ctr++;
00523               }<span class="comment">//end for m</span>
00524             }<span class="comment">//end for l</span>
00525           }<span class="comment">//end for k</span>
00526         }<span class="comment">//end for j</span>
00527       }<span class="comment">//end for i</span>
00528       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00529         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00530           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00531             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00532               <a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>[j][k][l][m] = tmpRmats[ctr];
00533               ctr++;
00534             }<span class="comment">//end for m</span>
00535           }<span class="comment">//end for l</span>
00536         }<span class="comment">//end for k</span>
00537       }<span class="comment">//end for j</span>
00538     }
00539 
00540     <span class="keyword">delete</span> [] tmpRmats;
00541 
00542     <span class="comment">//unsigned shorts...</span>
00543     <span class="comment">//map1[8][8][18][8]: 9216</span>
00544     <span class="comment">//map2[8][8][8][18][8]: 73728</span>
00545     <span class="comment">//map3[7][2][8][18][8]: 16128</span>
00546     <span class="comment">//map4[7][2][8][8][18][8]: 129024</span>
00547     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> * tmpVtxMaps = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>[228096];
00548 
00549     <span class="keywordflow">if</span>(!rank) {
00550       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00551       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00552         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00553           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00554             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00555               tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j][k][l]; 
00556               ctr++;
00557             }<span class="comment">//end for l</span>
00558           }<span class="comment">//end for k</span>
00559         }<span class="comment">//end for j</span>
00560       }<span class="comment">//end for i</span>
00561       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00562         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00563           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00564             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00565               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00566                 tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k][l][m]; 
00567                 ctr++;
00568               }<span class="comment">//end for m</span>
00569             }<span class="comment">//end for l</span>
00570           }<span class="comment">//end for k</span>
00571         }<span class="comment">//end for j</span>
00572       }<span class="comment">//end for i</span>
00573       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00574         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00575           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00576             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00577               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00578                 tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k][l][m]; 
00579                 ctr++;
00580               }<span class="comment">//end for m</span>
00581             }<span class="comment">//end for l</span>
00582           }<span class="comment">//end for k</span>
00583         }<span class="comment">//end for j</span>
00584       }<span class="comment">//end for i</span>
00585       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00586         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00587           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00588             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00589               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 18; m++) {
00590                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; 8; n++) {
00591                   tmpVtxMaps[ctr] = <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l][m][n]; 
00592                   ctr++;
00593                 }<span class="comment">//end for n</span>
00594               }<span class="comment">//end for m</span>
00595             }<span class="comment">//end for l</span>
00596           }<span class="comment">//end for k</span>
00597         }<span class="comment">//end for j</span>
00598       }<span class="comment">//end for i</span>
00599     }
00600 
00601     par::Mpi_Bcast&lt;unsigned short&gt;(tmpVtxMaps, 228096, 0, comm);
00602 
00603     <span class="keywordflow">if</span>(rank) {
00604       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00605       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00606         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00607           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 18; k++) {
00608             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00609               <a class="code" href="namespaceot.html#a2">VtxMap1</a>[i][j][k][l] = tmpVtxMaps[ctr]; 
00610               ctr++;
00611             }<span class="comment">//end for l</span>
00612           }<span class="comment">//end for k</span>
00613         }<span class="comment">//end for j</span>
00614       }<span class="comment">//end for i</span>
00615       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00616         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00617           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00618             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00619               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00620                 <a class="code" href="namespaceot.html#a3">VtxMap2</a>[i][j][k][l][m] = tmpVtxMaps[ctr]; 
00621                 ctr++;
00622               }<span class="comment">//end for m</span>
00623             }<span class="comment">//end for l</span>
00624           }<span class="comment">//end for k</span>
00625         }<span class="comment">//end for j</span>
00626       }<span class="comment">//end for i</span>
00627       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00628         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00629           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00630             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 18; l++) {
00631               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 8; m++) {
00632                 <a class="code" href="namespaceot.html#a4">VtxMap3</a>[i][j][k][l][m] = tmpVtxMaps[ctr]; 
00633                 ctr++;
00634               }<span class="comment">//end for m</span>
00635             }<span class="comment">//end for l</span>
00636           }<span class="comment">//end for k</span>
00637         }<span class="comment">//end for j</span>
00638       }<span class="comment">//end for i</span>
00639       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 7; i++) {
00640         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
00641           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00642             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> l = 0; l &lt; 8; l++) {
00643               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 18; m++) {
00644                 <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; 8; n++) {
00645                   <a class="code" href="namespaceot.html#a5">VtxMap4</a>[i][j][k][l][m][n] = tmpVtxMaps[ctr]; 
00646                   ctr++;
00647                 }<span class="comment">//end for n</span>
00648               }<span class="comment">//end for m</span>
00649             }<span class="comment">//end for l</span>
00650           }<span class="comment">//end for k</span>
00651         }<span class="comment">//end for j</span>
00652       }<span class="comment">//end for i</span>
00653     }
00654 
00655     <span class="keyword">delete</span> [] tmpVtxMaps;
00656 
00657   }
00658 
<a name="l00659"></a><a class="code" href="namespaceot.html#a93">00659</a>   PetscErrorCode <a class="code" href="namespaceot.html#a93">DAMG_Finalize</a>() {
00660     <a class="code" href="omg_8h.html#a14">PROF_MG_FINAL_BEGIN</a>
00661 
00662       <a class="code" href="namespaceot.html#a122">destroyRmatType1Stencil</a>(<a class="code" href="namespaceot.html#a0">RmatType1Stencil</a>);
00663     <a class="code" href="namespaceot.html#a125">destroyRmatType2Stencil</a>(<a class="code" href="namespaceot.html#a1">RmatType2Stencil</a>);
00664     <a class="code" href="namespaceot.html#a128">destroyVtxMaps</a>(<a class="code" href="namespaceot.html#a2">VtxMap1</a>, <a class="code" href="namespaceot.html#a3">VtxMap2</a>, <a class="code" href="namespaceot.html#a4">VtxMap3</a>, <a class="code" href="namespaceot.html#a5">VtxMap4</a>);
00665 
00666     <a class="code" href="omg_8h.html#a15">PROF_MG_FINAL_END</a>  
00667   }
00668 
<a name="l00669"></a><a class="code" href="namespaceot.html#a94">00669</a>   PetscErrorCode <a class="code" href="namespaceot.html#a94">DAMGDestroy</a>(<a class="code" href="structot_1_1__p__DAMG.html">DAMG</a>* damg)
00670   {
00671     PetscErrorCode ierr;
00672     <span class="keywordtype">int</span>       i,nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
00673 
00674     PetscFunctionBegin;
00675 
00676     <span class="keywordtype">int</span> rank;
00677     MPI_Comm_rank(damg[0]-&gt;comm,&amp;rank);
00678 
00679     <span class="keywordflow">if</span> (!damg) SETERRQ(PETSC_ERR_ARG_NULL,<span class="stringliteral">"Passing null as DAMG"</span>);
00680 
00681     <span class="keywordflow">for</span> (i = 1; i &lt; nlevels; i++) {
00682       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o11">R</a>) {
00683         ierr = MatDestroy(damg[i]-&gt;R);
00684         CHKERRQ(ierr);
00685       }
00686     }
00687 
00688     <span class="keywordflow">for</span> (i = 0; i &lt; nlevels; i++) {
00689       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o19">x</a>)       {
00690         ierr = VecDestroy(damg[i]-&gt;x);
00691         CHKERRQ(ierr);
00692       }
00693 
00694       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o1">b</a>)       {
00695         ierr = VecDestroy(damg[i]-&gt;b);
00696         CHKERRQ(ierr);
00697       }
00698 
00699       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o12">r</a>)       {
00700         ierr = VecDestroy(damg[i]-&gt;r);
00701         CHKERRQ(ierr);
00702       }
00703 
00704       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a>) {
00705         <span class="keyword">delete</span> [] (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a>);
00706         damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a> = NULL;
00707       }
00708 
00709       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o16">suppressedDOFaux</a>) {
00710         <span class="keyword">delete</span> [] (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o16">suppressedDOFaux</a>);
00711         damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o16">suppressedDOFaux</a> = NULL;
00712       }
00713 
00714       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o0">B</a> &amp;&amp; (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o0">B</a> != damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a>)) {
00715         ierr = MatDestroy(damg[i]-&gt;B);CHKERRQ(ierr);
00716       }
00717 
00718       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a>)         {
00719         ierr = MatDestroy(damg[i]-&gt;J);CHKERRQ(ierr);
00720       }
00721 
00722       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o8">ksp</a>) {
00723         ierr = KSPDestroy(damg[i]-&gt;ksp);CHKERRQ(ierr);
00724       }
00725 
00726       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>)      {
00727         <span class="keyword">delete</span> damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>; 
00728         damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a> = NULL;
00729       }
00730 
00731       <span class="keywordflow">if</span> (damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>)      {
00732         <span class="keyword">delete</span> damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>; 
00733         damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a> = NULL;
00734       }
00735 
00736       <span class="keyword">delete</span> damg[i];
00737       damg[i] = NULL;
00738     }<span class="comment">//end for all levels</span>
00739 
00740     <span class="keyword">delete</span> [] damg;
00741     damg = NULL;  
00742     PetscFunctionReturn(0);
00743   }
00744 
00745   <span class="comment">//RS: This is the function used to create the J matrix. </span>
00746   <span class="comment">//This must be called before calling DAMGSetKSP or DAMGSetSNES if you want to set</span>
00747   <span class="comment">//J and B to be different. If this is not called, by default J and B will be equal.</span>
<a name="l00748"></a><a class="code" href="namespaceot.html#a95">00748</a>   PetscErrorCode <a class="code" href="namespaceot.html#a136">DAMGCreateJMatrix</a>(<a class="code" href="structot_1_1__p__DAMG.html">DAMG</a> damg, PetscErrorCode (*crjac)(<a class="code" href="structot_1_1__p__DAMG.html">DAMG</a>,Mat*)) {
00749     PetscErrorCode ierr;
00750     PetscFunctionBegin;         
00751     <span class="keywordflow">if</span>(crjac){
00752       ierr = (*crjac)(damg,&amp;(damg-&gt;J)); CHKERRQ(ierr);
00753     }<span class="keywordflow">else</span>{
00754       SETERRQ(PETSC_ERR_ARG_NULL,<span class="stringliteral">"ot::DA can not create a Matrix for you! Pass a function handle."</span>);  
00755     }
00756     PetscFunctionReturn(0);
00757   }
00758 
00759   <span class="comment">//crjac is the function to create the B matrix for each level</span>
00760   <span class="comment">//compJac is an optional function to change the entries of the matrix. This</span>
00761   <span class="comment">//could be used if you don't want to re-build the matrix but only want to</span>
00762   <span class="comment">//change its entries. It is not useful for a single stand-alone solve.</span>
<a name="l00763"></a><a class="code" href="namespaceot.html#a96">00763</a>   PetscErrorCode <a class="code" href="namespaceot.html#a137">DAMGSetKSP</a>(<a class="code" href="structot_1_1__p__DAMG.html">DAMG</a> *damg, PetscErrorCode (*crjac)(<a class="code" href="structot_1_1__p__DAMG.html">DAMG</a>,Mat*), 
00764       PetscErrorCode (*compJac)(DAMG,Mat,Mat), PetscErrorCode (*rhs)(DAMG,Vec) )        
00765   {
00766     PetscErrorCode ierr;
00767     <span class="keywordtype">int</span>       i,nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
00768 
00769     <span class="comment">//Galerkin coarsening is NOT an option.</span>
00770     <a class="code" href="omg_8h.html#a16">PROF_MG_SET_KSP_BEGIN</a>
00771 
00772       <span class="keywordtype">int</span> rank;
00773     MPI_Comm_rank(damg[0]-&gt;comm, &amp;rank);
00774 
00775     <span class="keywordflow">if</span> (!damg) SETERRQ(PETSC_ERR_ARG_NULL,<span class="stringliteral">"Passing null as DAMG"</span>);  
00776     <span class="keywordflow">if</span> (!crjac) SETERRQ(PETSC_ERR_ARG_NULL,<span class="stringliteral">"ot::DA can not create a Matrix for you! Pass a function handle."</span>);
00777 
00778     <span class="keywordflow">if</span> (!damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o8">ksp</a>) {
00779       <span class="comment">/* create solvers for each level if they don't already exist*/</span>
00780       <span class="keywordflow">for</span> (i = 0; i &lt; nlevels; i++) {
00781         <span class="keywordflow">if</span> (!damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o0">B</a>) {              
00782           ierr = (*crjac)(damg[i],&amp;(damg[i]-&gt;B));CHKERRQ(ierr);
00783         }
00784         <span class="keywordflow">if</span> (!damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a>) {
00785 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
00786 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(!rank) {   
00787             std::cout&lt;&lt;<span class="stringliteral">"J and B are the same for lev: "</span>&lt;&lt;i&lt;&lt;std::endl;
00788             fflush(stdout);
00789           }
00790 <span class="preprocessor">#endif</span>
00791 <span class="preprocessor"></span>          damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a> = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o0">B</a>;
00792         }<span class="keywordflow">else</span> {
00793 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
00794 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(!rank) {   
00795             std::cout&lt;&lt;<span class="stringliteral">"J and B are different for lev: "</span>&lt;&lt;i&lt;&lt;std::endl;
00796             fflush(stdout);
00797           }
00798 <span class="preprocessor">#endif</span>
00799 <span class="preprocessor"></span>          assert(damg[i]-&gt;J != damg[i]-&gt;B);
00800         }
00801 
00802         ierr = KSPCreate(damg[i]-&gt;comm,&amp;(damg[i]-&gt;ksp));CHKERRQ(ierr);
00803 
00804         <span class="comment">//No prefix for the finest level</span>
00805         <span class="keywordflow">if</span>(i &lt; (nlevels-1)) {
00806           <span class="keywordtype">char</span> prefix[256];
00807           sprintf(prefix,<span class="stringliteral">"damg_levels_%d_"</span>,(<span class="keywordtype">int</span>)i);
00808           KSPSetOptionsPrefix(damg[i]-&gt;ksp,prefix);
00809         }
00810 
00811         ierr = <a class="code" href="namespaceot.html#a102">DAMGSetUpLevel</a>(damg,damg[i]-&gt;ksp,i+1); CHKERRQ(ierr);
00812 
00813         ierr = KSPSetFromOptions(damg[i]-&gt;ksp);CHKERRQ(ierr);
00814 
00815         <span class="keywordflow">if</span>( (damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>()) &lt; (damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_20">getNpesAll</a>()) ) {
00816           <span class="comment">//If all processors are NOT active on the coarsest grid</span>
00817           <span class="comment">//reset the solver on the coarsest grid to be KSP_Shell </span>
00818           PC pc;
00819           <span class="keyword">const</span> <span class="keywordtype">char</span>* clearOptionPrefix;
00820           <span class="keywordtype">char</span> optionName[256];
00821           <span class="keywordflow">if</span>(i == 0) {
00822             KSPGetOptionsPrefix(damg[0]-&gt;ksp, &amp;clearOptionPrefix);
00823 
00824             sprintf(optionName, <span class="stringliteral">"-%sksp_type"</span>,clearOptionPrefix);
00825             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00826             ierr = KSPSetType(damg[0]-&gt;ksp, KSPRICHARDSON); CHKERRQ(ierr);
00827 
00828             sprintf(optionName, <span class="stringliteral">"-%sksp_knoll"</span>,clearOptionPrefix);
00829             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00830             ierr = KSPSetInitialGuessKnoll(damg[0]-&gt;ksp, PETSC_FALSE);
00831             CHKERRQ(ierr);
00832 
00833             sprintf(optionName, <span class="stringliteral">"-%sksp_richardson_scale"</span>,clearOptionPrefix);
00834             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00835             ierr = KSPRichardsonSetScale(damg[0]-&gt;ksp, 1.0);
00836             CHKERRQ(ierr);
00837 
00838             sprintf(optionName, <span class="stringliteral">"-%sksp_right_pc"</span>,clearOptionPrefix);
00839             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00840             sprintf(optionName, <span class="stringliteral">"-%sksp_symmetric_pc"</span>,clearOptionPrefix);
00841             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00842             ierr = KSPSetPreconditionerSide(damg[0]-&gt;ksp, PC_LEFT);
00843             CHKERRQ(ierr);
00844 
00845             sprintf(optionName, <span class="stringliteral">"-%sksp_norm_type"</span>,clearOptionPrefix);
00846             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00847             ierr = KSPSetNormType(damg[0]-&gt;ksp, KSP_NORM_NO);
00848             CHKERRQ(ierr);
00849 
00850             sprintf(optionName, <span class="stringliteral">"-%sksp_rtol"</span>,clearOptionPrefix);
00851             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00852             sprintf(optionName, <span class="stringliteral">"-%sksp_atol"</span>,clearOptionPrefix);
00853             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00854             sprintf(optionName, <span class="stringliteral">"-%sksp_divtol"</span>,clearOptionPrefix);
00855             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00856             sprintf(optionName, <span class="stringliteral">"-%sksp_max_it"</span>,clearOptionPrefix);
00857             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00858             ierr = KSPSetTolerances(damg[0]-&gt;ksp, PETSC_DEFAULT, PETSC_DEFAULT,
00859                 PETSC_DEFAULT, 1); 
00860             CHKERRQ(ierr);
00861 
00862             ierr = KSPSetConvergenceTest(damg[0]-&gt;ksp, KSPSkipConverged,
00863                 PETSC_NULL);
00864             CHKERRQ(ierr);
00865 
00866             ierr = KSPSetInitialGuessNonzero(damg[0]-&gt;ksp, PETSC_FALSE);
00867             CHKERRQ(ierr);
00868 
00869             ierr  = KSPGetPC(damg[0]-&gt;ksp, &amp;pc); CHKERRQ(ierr);
00870 
00871             PCGetOptionsPrefix(pc, &amp;clearOptionPrefix);
00872             sprintf(optionName, <span class="stringliteral">"-%spc_type"</span>,clearOptionPrefix);
00873             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00874             ierr  = PCSetType(pc, PCSHELL); CHKERRQ(ierr);
00875             ierr = PCShellSetName(pc, <span class="stringliteral">"PC_KSP_Shell"</span>); CHKERRQ(ierr);
00876 
00877             <a class="code" href="structot_1_1PC__KSP__Shell.html">PC_KSP_Shell</a>* pcShellContext = <span class="keyword">new</span> <a class="code" href="structot_1_1PC__KSP__Shell.html">PC_KSP_Shell</a>;
00878             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a> = NULL;
00879             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a> = NULL;
00880             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a> = NULL;
00881             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o3">pc</a> = pc;
00882             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o1">iAmActive</a> = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>();
00883             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o0">commActive</a> = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
00884             ierr = PCShellSetContext(pc, pcShellContext); CHKERRQ(ierr);
00885             ierr = PCShellSetSetUp(pc, <a class="code" href="namespaceot.html#a109">PC_KSP_Shell_SetUp</a>); CHKERRQ(ierr);
00886             ierr = PCShellSetApply(pc, <a class="code" href="namespaceot.html#a111">PC_KSP_Shell_Apply</a>); CHKERRQ(ierr);
00887             ierr = PCShellSetDestroy(pc, <a class="code" href="namespaceot.html#a110">PC_KSP_Shell_Destroy</a>); CHKERRQ(ierr);
00888           } <span class="keywordflow">else</span> {
00889             ierr  = KSPGetPC(damg[i]-&gt;ksp, &amp;pc); CHKERRQ(ierr);
00890           }
00891 
00892           PetscTruth ismg;
00893           PetscTypeCompare((PetscObject)pc, PCMG, &amp;ismg);
00894 
00895           <span class="keywordflow">if</span>(ismg) {
00896             PetscTruth useRTLMG;
00897             ierr = PetscOptionsHasName(PETSC_NULL,<span class="stringliteral">"-damg_useRTLMG"</span>,&amp;useRTLMG);
00898             CHKERRQ(ierr);
00899             KSP lksp;
00900             <span class="keywordflow">if</span>(useRTLMG) {
00901               <span class="keywordflow">while</span>(ismg) {
00902                 ierr = PCMGGetSmoother(pc,0,&amp;lksp);CHKERRQ(ierr);
00903                 ierr  = KSPGetPC(lksp, &amp;pc); CHKERRQ(ierr);
00904                 PetscTypeCompare((PetscObject)pc, PCMG, &amp;ismg);
00905               }
00906             } <span class="keywordflow">else</span> {
00907               ierr = PCMGGetSmoother(pc,0,&amp;lksp);CHKERRQ(ierr);
00908             }
00909 
00910             KSPGetOptionsPrefix(lksp, &amp;clearOptionPrefix);
00911 
00912             sprintf(optionName, <span class="stringliteral">"-%sksp_type"</span>,clearOptionPrefix);
00913             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00914             ierr = KSPSetType(lksp, KSPRICHARDSON); CHKERRQ(ierr);              
00915 
00916             sprintf(optionName, <span class="stringliteral">"-%sksp_knoll"</span>,clearOptionPrefix);
00917             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00918             ierr = KSPSetInitialGuessKnoll(lksp, PETSC_FALSE);
00919             CHKERRQ(ierr);
00920 
00921             sprintf(optionName, <span class="stringliteral">"-%sksp_richardson_scale"</span>,clearOptionPrefix);
00922             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00923             ierr = KSPRichardsonSetScale(lksp, 1.0);
00924             CHKERRQ(ierr);
00925 
00926             sprintf(optionName, <span class="stringliteral">"-%sksp_right_pc"</span>,clearOptionPrefix);
00927             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00928             sprintf(optionName, <span class="stringliteral">"-%sksp_symmetric_pc"</span>,clearOptionPrefix);
00929             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00930             ierr = KSPSetPreconditionerSide(lksp, PC_LEFT);
00931             CHKERRQ(ierr);
00932 
00933             sprintf(optionName, <span class="stringliteral">"-%sksp_norm_type"</span>,clearOptionPrefix);
00934             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00935             ierr = KSPSetNormType(lksp, KSP_NORM_NO);
00936             CHKERRQ(ierr);
00937 
00938             sprintf(optionName, <span class="stringliteral">"-%sksp_rtol"</span>,clearOptionPrefix);
00939             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00940             sprintf(optionName, <span class="stringliteral">"-%sksp_atol"</span>,clearOptionPrefix);
00941             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00942             sprintf(optionName, <span class="stringliteral">"-%sksp_divtol"</span>,clearOptionPrefix);
00943             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00944             sprintf(optionName, <span class="stringliteral">"-%sksp_max_it"</span>,clearOptionPrefix);
00945             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00946             ierr = KSPSetTolerances(lksp, PETSC_DEFAULT, PETSC_DEFAULT,
00947                 PETSC_DEFAULT, 1); 
00948             CHKERRQ(ierr);
00949 
00950             ierr = KSPSetConvergenceTest(lksp, KSPSkipConverged, PETSC_NULL);
00951             CHKERRQ(ierr);
00952 
00953             ierr = KSPSetInitialGuessNonzero(lksp, PETSC_FALSE);
00954             CHKERRQ(ierr);
00955 
00956             ierr  = KSPGetPC(lksp, &amp;pc); CHKERRQ(ierr);
00957 
00958             PCGetOptionsPrefix(pc, &amp;clearOptionPrefix);
00959             sprintf(optionName, <span class="stringliteral">"-%spc_type"</span>,clearOptionPrefix);
00960             ierr = PetscOptionsClearValue(optionName); CHKERRQ(ierr);
00961             ierr  = PCSetType(pc, PCSHELL); CHKERRQ(ierr);
00962             ierr = PCShellSetName(pc, <span class="stringliteral">"PC_KSP_Shell"</span>); CHKERRQ(ierr);
00963 
00964             <a class="code" href="structot_1_1PC__KSP__Shell.html">PC_KSP_Shell</a>* pcShellContext = <span class="keyword">new</span> <a class="code" href="structot_1_1PC__KSP__Shell.html">PC_KSP_Shell</a>;
00965             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a> = NULL;
00966             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a> = NULL;
00967             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a> = NULL;
00968             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o3">pc</a> = pc;
00969             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o1">iAmActive</a> = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>();
00970             pcShellContext-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o0">commActive</a> = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
00971             ierr = PCShellSetContext(pc, pcShellContext); CHKERRQ(ierr);
00972             ierr = PCShellSetSetUp(pc, <a class="code" href="namespaceot.html#a109">PC_KSP_Shell_SetUp</a>); CHKERRQ(ierr);
00973             ierr = PCShellSetApply(pc, <a class="code" href="namespaceot.html#a111">PC_KSP_Shell_Apply</a>); CHKERRQ(ierr);
00974             ierr = PCShellSetDestroy(pc, <a class="code" href="namespaceot.html#a110">PC_KSP_Shell_Destroy</a>); CHKERRQ(ierr);
00975           }<span class="comment">//end if PC==MG</span>
00976         }<span class="comment">//end if all procs active on coarsest level</span>
00977 
00978         damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o14">solve</a> = DAMGSolveKSP;
00979         damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o13">rhs</a>   = rhs;
00980       }<span class="comment">//end for i</span>
00981     }<span class="comment">//end if ksp</span>
00982 
00983 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
00984 <span class="preprocessor"></span>    MPI_Barrier(damg[0]-&gt;comm);
00985     <span class="keywordflow">if</span>(!rank) {
00986       std::cout&lt;&lt;<span class="stringliteral">"Finished setting up ksp for all levels."</span>&lt;&lt;std::endl;
00987       fflush(stdout);
00988     }
00989     MPI_Barrier(damg[0]-&gt;comm);
00990 <span class="preprocessor">#endif</span>
00991 <span class="preprocessor"></span>
00992     <span class="keywordflow">for</span> (i = 0; i &lt; nlevels; i++) {
00993       <span class="keywordflow">if</span>(compJac) {
00994         ierr = (*compJac)(damg[i],damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a>,damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o0">B</a>); CHKERRQ(ierr);
00995       }
00996       damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o9">matricesset</a> = PETSC_TRUE;
00997     }
00998 
00999 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
01000 <span class="preprocessor"></span>    MPI_Barrier(damg[0]-&gt;comm);
01001     <span class="keywordflow">if</span>(!rank) {
01002       std::cout&lt;&lt;<span class="stringliteral">"Finished building matrices for all levels."</span>&lt;&lt;std::endl;
01003       fflush(stdout);
01004     }
01005     MPI_Barrier(damg[0]-&gt;comm);
01006 <span class="preprocessor">#endif</span>
01007 <span class="preprocessor"></span>
01008     <a class="code" href="omg_8h.html#a17">PROF_MG_SET_KSP_END</a>
01009   }
01010 
<a name="l01011"></a><a class="code" href="namespaceot.html#a97">01011</a>   PetscErrorCode <a class="code" href="namespaceot.html#a138">DAMGSetNullSpace</a>(DAMG* damg, PetscTruth has_cnst, PetscInt n,
01012       PetscErrorCode (*func)(DAMG,Vec[]))
01013   {
01014     PetscErrorCode ierr;
01015     <span class="keywordtype">int</span>       i, j, nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
01016     Vec            *nulls = 0;
01017     MatNullSpace   nullsp;
01018     KSP            iksp;
01019     PC             pc,ipc;
01020     PetscTruth     ismg,isred;
01021 
01022     PetscFunctionBegin;
01023     <span class="keywordflow">if</span> (!damg) SETERRQ(PETSC_ERR_ARG_NULL,<span class="stringliteral">"Passing null as DAMG"</span>);
01024     <span class="keywordflow">if</span> (!damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o8">ksp</a>) SETERRQ(PETSC_ERR_ORDER,<span class="stringliteral">"Must call AFTER DAMGSetKSP() or DAMGSetSNES()"</span>);
01025     <span class="keywordflow">if</span> ((n &amp;&amp; !func) || (!n &amp;&amp; func)) SETERRQ(PETSC_ERR_ARG_INCOMP,<span class="stringliteral">"Both n and func() must be set together"</span>);
01026     <span class="keywordflow">if</span> (n &lt; 0) SETERRQ1(PETSC_ERR_ARG_OUTOFRANGE,<span class="stringliteral">"Cannot have negative number of vectors in null space n = %D"</span>,n)
01027 
01028       <span class="keywordflow">for</span> (i = 0; i &lt; nlevels; i++) {
01029         <span class="keywordflow">if</span> (n) {
01030           ierr = VecDuplicateVecs(damg[i]-&gt;b,n,&amp;nulls);CHKERRQ(ierr);
01031           ierr = (*func)(damg[i],nulls);CHKERRQ(ierr);
01032         }
01033         ierr = MatNullSpaceCreate(damg[i]-&gt;comm,has_cnst,n,nulls,&amp;nullsp);CHKERRQ(ierr);
01034         ierr = KSPSetNullSpace(damg[i]-&gt;ksp,nullsp);CHKERRQ(ierr);
01035         <span class="keywordflow">for</span> (j = i; j &lt; nlevels; j++) {
01036           ierr = KSPGetPC(damg[j]-&gt;ksp,&amp;pc);CHKERRQ(ierr);
01037           ierr = PetscTypeCompare((PetscObject)pc,PCMG,&amp;ismg);CHKERRQ(ierr);
01038           <span class="keywordflow">if</span> (ismg) {
01039             ierr = PCMGGetSmoother(pc,i,&amp;iksp);CHKERRQ(ierr);
01040             ierr = KSPSetNullSpace(iksp, nullsp);CHKERRQ(ierr);
01041           }
01042         }
01043         ierr = MatNullSpaceDestroy(nullsp);CHKERRQ(ierr);
01044         <span class="keywordflow">if</span> (n) {
01045           ierr = PetscFree(nulls);CHKERRQ(ierr);
01046         }
01047       }<span class="comment">//end for i</span>
01048 
01049     <span class="comment">/* make all the coarse grid solvers have LU shift since they are singular */</span>
01050     <span class="keywordflow">for</span> (i = 0; i &lt; nlevels; i++) {
01051       ierr = KSPGetPC(damg[i]-&gt;ksp,&amp;pc);CHKERRQ(ierr);
01052       ierr = PetscTypeCompare((PetscObject)pc,PCMG,&amp;ismg);CHKERRQ(ierr);
01053       <span class="keywordflow">if</span> (ismg) {
01054         ierr = PCMGGetSmoother(pc,0,&amp;iksp);CHKERRQ(ierr);
01055         ierr = KSPGetPC(iksp,&amp;ipc);CHKERRQ(ierr);
01056         ierr = PetscTypeCompare((PetscObject)ipc,PCREDUNDANT,&amp;isred);CHKERRQ(ierr);
01057         <span class="keywordflow">if</span> (isred) {
01058           ierr = PCRedundantGetPC(ipc,&amp;ipc);CHKERRQ(ierr);
01059         }
01060         ierr = PCFactorSetShiftPd(ipc,PETSC_TRUE);CHKERRQ(ierr); 
01061       }
01062     }<span class="comment">//end for i</span>
01063 
01064     PetscFunctionReturn(0);
01065   }
01066 
<a name="l01067"></a><a class="code" href="namespaceot.html#a98">01067</a>   PetscErrorCode <a class="code" href="namespaceot.html#a98">DAMGSetInitialGuess</a>(DAMG* damg, PetscErrorCode (*guess)(DAMG, Vec)) {
01068     <span class="keywordtype">int</span> i, nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
01069     <span class="keywordflow">for</span>(i = 0; i &lt; nlevels; i++) {
01070       damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o6">initialguess</a> = guess;
01071     }
01072     <span class="keywordflow">return</span>(0);
01073   }
01074 
<a name="l01075"></a><a class="code" href="namespaceot.html#a99">01075</a>   PetscErrorCode <a class="code" href="namespaceot.html#a99">DAMGInitialGuessCurrent</a>(DAMG damg, Vec vec) {
01076     <span class="keywordflow">return</span> (0);
01077   }
01078 
<a name="l01079"></a><a class="code" href="namespaceot.html#a100">01079</a>   PetscErrorCode <a class="code" href="namespaceot.html#a100">DAMGSolve</a>(DAMG* damg)
01080   {
01081     PetscErrorCode ierr;
01082     <span class="keywordtype">int</span>       i,nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
01083     PetscTruth     gridseq,vecmonitor;
01084 
01085     PetscFunctionBegin;
01086     ierr = PetscOptionsHasName(0,<span class="stringliteral">"-damg_grid_sequence"</span>,&amp;gridseq);CHKERRQ(ierr);
01087     ierr = PetscOptionsHasName(0,<span class="stringliteral">"-damg_vecmonitor"</span>,&amp;vecmonitor);CHKERRQ(ierr);
01088     <span class="keywordflow">if</span> (gridseq) {    
01089       <span class="keywordflow">if</span>(damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o6">initialguess</a>) {
01090         (*(damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o6">initialguess</a>))(damg[0],damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o19">x</a>);
01091         KSPSetInitialGuessNonzero(damg[0]-&gt;ksp, PETSC_TRUE);
01092       }
01093       <span class="keywordflow">for</span> (i=0; i&lt;nlevels-1; i++) {
01094         ierr = (*damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o14">solve</a>)(damg,i);CHKERRQ(ierr);
01095         <span class="keywordflow">if</span> (vecmonitor) {
01096           ierr = VecView(damg[i]-&gt;x,PETSC_VIEWER_DRAW_(damg[i]-&gt;comm));CHKERRQ(ierr);
01097         }
01098         ierr = MatInterpolate(damg[i+1]-&gt;R,damg[i]-&gt;x,damg[i+1]-&gt;x);CHKERRQ(ierr);      
01099         KSPSetInitialGuessNonzero(damg[i+1]-&gt;ksp, PETSC_TRUE);
01100       }    
01101     }<span class="keywordflow">else</span> {
01102       <span class="keywordflow">if</span>(damg[nlevels-1]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o6">initialguess</a>) {
01103         (*(damg[nlevels-1]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o6">initialguess</a>))(damg[nlevels-1], damg[nlevels-1]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o19">x</a>);
01104         KSPSetInitialGuessNonzero(damg[nlevels-1]-&gt;ksp, PETSC_TRUE);
01105       }
01106     }
01107     ierr = (*<a class="code" href="omg_8h.html#a40">DAMGGetFine</a>(damg)-&gt;solve)(damg, nlevels-1);CHKERRQ(ierr);
01108     <span class="keywordflow">if</span> (vecmonitor) {
01109       ierr = VecView(damg[nlevels-1]-&gt;x,PETSC_VIEWER_DRAW_(damg[nlevels-1]-&gt;comm));CHKERRQ(ierr);
01110     }  
01111     PetscFunctionReturn(0);
01112   }
01113 
<a name="l01114"></a><a class="code" href="namespaceot.html#a101">01114</a>   PetscErrorCode <a class="code" href="namespaceot.html#a101">DAMGSolveKSP</a>(DAMG *damg, <span class="keywordtype">int</span> level)
01115   {
01116     PetscErrorCode ierr;
01117 
01118     PetscFunctionBegin;
01119 
01120     <span class="keywordflow">if</span> (damg[level]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o13">rhs</a>) {
01121       ierr = (*damg[level]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o13">rhs</a>)(damg[level],damg[level]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o1">b</a>);CHKERRQ(ierr); 
01122     }
01123 
01124     <span class="keywordflow">if</span> (damg[level]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o9">matricesset</a>) {
01125       ierr = KSPSetOperators(damg[level]-&gt;ksp, damg[level]-&gt;J,
01126           damg[level]-&gt;B, SAME_NONZERO_PATTERN);CHKERRQ(ierr);
01127       damg[level]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o9">matricesset</a> = PETSC_FALSE;
01128     }
01129 
01130     ierr = KSPSolve(damg[level]-&gt;ksp, damg[level]-&gt;b, damg[level]-&gt;x);CHKERRQ(ierr);
01131 
01132     PetscFunctionReturn(0);
01133   }
01134 
<a name="l01135"></a><a class="code" href="namespaceot.html#a102">01135</a>   PetscErrorCode <a class="code" href="namespaceot.html#a102">DAMGSetUpLevel</a>(DAMG* damg, KSP ksp, <span class="keywordtype">int</span> nlevels)
01136   {
01137     PetscErrorCode ierr;
01138     PC             pc;
01139     PetscTruth     ismg,monitor,ismf,isshell,ismffd;
01140     PetscTruth     useRTLMG;
01141     KSP            lksp; <span class="comment">/* solver internal to the multigrid preconditioner */</span>
01142     MPI_Comm       *comms,comm;
01143     PetscViewer    ascii;
01144 
01145     PetscFunctionBegin;
01146     <span class="keywordflow">if</span> (!damg) SETERRQ(PETSC_ERR_ARG_NULL,<span class="stringliteral">"Passing null as DAMG"</span>);
01147 
01148     ierr = PetscOptionsHasName(PETSC_NULL,<span class="stringliteral">"-damg_ksp_monitor"</span>,&amp;monitor);CHKERRQ(ierr);
01149     ierr = PetscOptionsHasName(PETSC_NULL,<span class="stringliteral">"-damg_useRTLMG"</span>,&amp;useRTLMG);CHKERRQ(ierr);
01150 
01151     <span class="keywordflow">if</span> (monitor) {
01152       ierr = PetscObjectGetComm((PetscObject)ksp,&amp;comm);CHKERRQ(ierr);
01153       ierr = PetscViewerASCIIOpen(comm,<span class="stringliteral">"stdout"</span>,&amp;ascii);CHKERRQ(ierr);
01154       ierr = PetscViewerASCIISetTab(ascii,1+(damg[0]-&gt;nlevels)-nlevels);CHKERRQ(ierr);
01155       ierr = KSPMonitorSet(ksp, KSPMonitorDefault, ascii,
01156           (PetscErrorCode(*)(<span class="keywordtype">void</span>*))PetscViewerDestroy);CHKERRQ(ierr);
01157     }
01158 
01159     <span class="comment">/* use fgmres on outer iteration by default */</span>
01160     ierr  = KSPSetType(ksp, KSPFGMRES); CHKERRQ(ierr);
01161     ierr  = KSPGetPC(ksp,&amp;pc); CHKERRQ(ierr);
01162     ierr  = PCSetType(pc,PCMG); CHKERRQ(ierr);
01163 
01164     <span class="keyword">const</span> <span class="keywordtype">char</span> *mainKSPprefix;
01165     KSPGetOptionsPrefix(ksp, &amp;mainKSPprefix);
01166 
01167     <span class="keywordflow">if</span>(useRTLMG) {
01168       <span class="keywordtype">char</span> prefixName[256];
01169       sprintf(prefixName, <span class="stringliteral">"rtlmg_finest_"</span>);
01170       PCSetOptionsPrefix(pc, mainKSPprefix);
01171       PCAppendOptionsPrefix(pc, prefixName);
01172       <span class="comment">//finest to coarsest</span>
01173       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (nlevels-1); i &gt;= 1; i--) {
01174         ierr  = PetscMalloc(2*<span class="keyword">sizeof</span>(MPI_Comm),&amp;comms);CHKERRQ(ierr);
01175         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; 2; j++) {
01176           comms[j] = damg[j]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>;
01177         }
01178         PCMGSetLevels(pc,2,comms);
01179         PetscFree(comms);
01180         PCMGSetType(pc,PC_MG_FULL);
01181         PetscTypeCompare((PetscObject)pc,PCMG,&amp;ismg);
01182         <span class="keywordflow">if</span> (ismg) {
01183           <span class="comment">/*Finer Level*/</span>
01184           PCMGGetSmoother(pc,1,&amp;lksp);
01185           KSPSetOperators(lksp,damg[i]-&gt;B,damg[i]-&gt;B,DIFFERENT_NONZERO_PATTERN);
01186           PCMGSetR(pc,1,damg[i]-&gt;r);
01187           PCMGSetResidual(pc,1,PCMGDefaultResidual,damg[i]-&gt;B);
01188           <span class="comment">/*Coarser Level*/</span>
01189           PCMGGetSmoother(pc,0,&amp;lksp);
01190           KSPSetOperators(lksp,damg[i-1]-&gt;J,damg[i-1]-&gt;J,DIFFERENT_NONZERO_PATTERN);
01191           PCMGSetX(pc,0,damg[i-1]-&gt;x);
01192           PCMGSetRhs(pc,0,damg[i-1]-&gt;b);
01193           <span class="comment">/* Set interpolation/restriction between levels */</span>
01194           PCMGSetInterpolation(pc,1,damg[i]-&gt;R);
01195           PCMGSetRestriction(pc,1,damg[i]-&gt;R);
01196           <span class="keywordflow">if</span>(i &gt; 1) {
01197             <span class="comment">/*Get PC for the next level*/</span>
01198             KSPSetType(lksp,KSPFGMRES);
01199             KSPGetPC(lksp,&amp;pc);
01200             PCSetType(pc,PCMG);
01201             sprintf(prefixName, <span class="stringliteral">"rtlmg_levels_%d_"</span>,((<span class="keywordtype">int</span>)(i-1)));
01202             PCSetOptionsPrefix(pc, mainKSPprefix);
01203             PCAppendOptionsPrefix(pc, prefixName);
01204           }
01205         }<span class="comment">//end if mg</span>
01206       }<span class="comment">//end for i</span>
01207     } <span class="keywordflow">else</span> {
01208       <span class="comment">//Standard Scheme same as original DMMG </span>
01209       ierr  = PetscMalloc(nlevels*<span class="keyword">sizeof</span>(MPI_Comm),&amp;comms);CHKERRQ(ierr);
01210       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
01211         comms[i] = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>;
01212       }
01213       ierr  = PCMGSetLevels(pc,nlevels,comms);CHKERRQ(ierr);
01214       ierr =  PCMGSetType(pc,PC_MG_FULL);CHKERRQ(ierr);
01215 
01216       ierr  = PetscFree(comms);CHKERRQ(ierr); 
01217 
01218       ierr = PetscTypeCompare((PetscObject)pc,PCMG,&amp;ismg);CHKERRQ(ierr);
01219       <span class="keywordflow">if</span> (ismg) {
01220         <span class="comment">/* set solvers for each level */</span>
01221         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
01222           ierr = PCMGGetSmoother(pc, i, &amp;lksp);CHKERRQ(ierr);
01223 
01224           ierr = KSPSetOperators(lksp, damg[i]-&gt;J, damg[i]-&gt;B,
01225               DIFFERENT_NONZERO_PATTERN);CHKERRQ(ierr);
01226 
01227           <span class="keywordflow">if</span> (i &lt; nlevels-1) { <span class="comment">/* don't set for finest level, they are set in PCApply_MG()*/</span>
01228             ierr = PCMGSetX(pc,i,damg[i]-&gt;x);CHKERRQ(ierr); 
01229             ierr = PCMGSetRhs(pc,i,damg[i]-&gt;b);CHKERRQ(ierr); 
01230           }
01231           <span class="keywordflow">if</span> (i &gt; 0) {
01232             ierr = PCMGSetR(pc,i,damg[i]-&gt;r);CHKERRQ(ierr); 
01233             ierr = PCMGSetResidual(pc,i,PCMGDefaultResidual,damg[i]-&gt;J);CHKERRQ(ierr);
01234           }
01235           <span class="keywordflow">if</span> (monitor) {
01236             ierr = PetscObjectGetComm((PetscObject)lksp,&amp;comm);CHKERRQ(ierr);
01237             ierr = PetscViewerASCIIOpen(comm,<span class="stringliteral">"stdout"</span>,&amp;ascii);CHKERRQ(ierr);
01238             ierr = PetscViewerASCIISetTab(ascii,1+damg[0]-&gt;nlevels-i);CHKERRQ(ierr);
01239             ierr = KSPMonitorSet(lksp,KSPMonitorDefault,ascii,
01240                 (PetscErrorCode(*)(<span class="keywordtype">void</span>*))PetscViewerDestroy);CHKERRQ(ierr);
01241           }
01242           <span class="comment">/* If using a matrix free multiply and did not provide an explicit matrix to build</span>
01243 <span class="comment">             the preconditioner then must use no preconditioner </span>
01244 <span class="comment">             */</span>
01245           ierr = PetscTypeCompare((PetscObject)damg[i]-&gt;B,MATSHELL,&amp;isshell);CHKERRQ(ierr);
01246           ierr = PetscTypeCompare((PetscObject)damg[i]-&gt;B,MATDAAD,&amp;ismf);CHKERRQ(ierr);
01247           ierr = PetscTypeCompare((PetscObject)damg[i]-&gt;B,MATMFFD,&amp;ismffd);CHKERRQ(ierr);
01248           <span class="keywordflow">if</span> (isshell || ismf || ismffd) {
01249             PC  lpc;
01250             ierr = KSPGetPC(lksp,&amp;lpc);CHKERRQ(ierr);
01251             <span class="comment">//This is only the default value. It can be modified later</span>
01252             ierr = PCSetType(lpc,PCNONE);CHKERRQ(ierr);
01253           }
01254         }<span class="comment">//end for i</span>
01255 
01256         <span class="comment">/* Set interpolation/restriction between levels */</span>
01257         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;nlevels; i++) {
01258           ierr = PCMGSetInterpolation(pc,i,damg[i]-&gt;R);CHKERRQ(ierr); 
01259           ierr = PCMGSetRestriction(pc,i,damg[i]-&gt;R);CHKERRQ(ierr); 
01260         }<span class="comment">//end for i</span>
01261       }<span class="comment">//end if mg</span>
01262     }<span class="comment">//end if TLMG</span>
01263 
01264     PetscFunctionReturn(0);
01265   }<span class="comment">//end fn.</span>
01266 
01267   <span class="comment">//level = 0 is the coarsest, level = (nlevels-1) is the finest.</span>
01268   <span class="comment">//nlevels for each level is the number of levels finer than this level.</span>
01269   <span class="comment">//New implementation. Written on April 24, 2008</span>
<a name="l01270"></a><a class="code" href="namespaceot.html#a103">01270</a>   PetscErrorCode <a class="code" href="namespaceot.html#a103">DAMGCreateAndSetDA</a>(MPI_Comm comm, <span class="keywordtype">int</span> &amp; nlevels, 
01271       <span class="keywordtype">void</span>* user, DAMG** damg, std::vector&lt;ot::TreeNode&gt;&amp; finestOctree,
01272       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof, <span class="keywordtype">double</span> loadFac,
01273       <span class="keywordtype">bool</span> compressLut, <span class="keywordtype">bool</span> incCorner) {
01274 
01275     <a class="code" href="omg_8h.html#a18">PROF_MG_SET_DA_BEGIN</a>
01276 
01277       <a class="code" href="omg_8h.html#a0">PROF_SET_DA_STAGE1_BEGIN</a>
01278 
01279       PetscErrorCode ierr;
01280     <span class="keywordtype">int</span> rank, npes;
01281     MPI_Comm_rank(comm, &amp;rank);
01282     MPI_Comm_size(comm, &amp;npes);
01283 
01284 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
01285 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(!rank) {
01286       std::cout&lt;&lt;<span class="stringliteral">"MG-Load Fac: "</span>&lt;&lt;loadFac&lt;&lt;std::endl;
01287       fflush(stdout);
01288     }
01289 <span class="preprocessor">#endif</span>
01290 <span class="preprocessor"></span>
01291     par::partitionW&lt;ot::TreeNode&gt;(finestOctree, NULL, comm);
01292 
01293     assert(nlevels &gt; 0);
01294     <span class="keywordflow">if</span>(finestOctree.empty()) {
01295       std::cout&lt;&lt;<span class="stringliteral">"Processor "</span>&lt;&lt;rank&lt;&lt;
01296         <span class="stringliteral">" called DAMGCreateAndSetDA with an empty finest octree."</span>&lt;&lt;std::endl;
01297       fflush(stdout);
01298       assert(<span class="keyword">false</span>);
01299     }
01300 
01301     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = finestOctree[0].getDim();
01302     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = finestOctree[0].getMaxDepth();
01303 
01304     <a class="code" href="omg_8h.html#a1">PROF_SET_DA_STAGE1_END</a>
01305 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
01306 <span class="preprocessor"></span>      MPI_Barrier(comm);
01307 <span class="preprocessor">#endif</span>
01308 <span class="preprocessor"></span>    <a class="code" href="omg_8h.html#a2">PROF_SET_DA_STAGE2_BEGIN</a>
01309 
01310       <span class="keywordtype">int</span> idxOfCoarsestLev = -1; 
01311 
01312     std::vector&lt;ot::TreeNode&gt;* coarserOctrees = NULL;
01313 
01314     <span class="keywordtype">bool</span>* activeStatesInCoarseBal = NULL;
01315     MPI_Comm* activeCommsInCoarseBal = NULL;
01316     <span class="keywordtype">int</span>* activeNpesInCoarseBal = NULL;
01317 
01318     <span class="keywordflow">if</span>(nlevels &gt; 1) {
01319       coarserOctrees = <span class="keyword">new</span> std::vector&lt;ot::TreeNode&gt; [nlevels-1];
01320       activeStatesInCoarseBal = <span class="keyword">new</span> <span class="keywordtype">bool</span>[nlevels - 1];
01321       activeCommsInCoarseBal = <span class="keyword">new</span> MPI_Comm[nlevels - 1];
01322       activeNpesInCoarseBal = <span class="keyword">new</span> <span class="keywordtype">int</span>[nlevels - 1];
01323 
01324       <span class="comment">//Default value is false so if a processor becomes inactive at some</span>
01325       <span class="comment">//level and exits the loop it will still have the correct value for the</span>
01326       <span class="comment">//remaining levels </span>
01327       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; (nlevels-1); i++) {
01328         activeStatesInCoarseBal[i] = <span class="keyword">false</span>;
01329       }<span class="comment">//end for i</span>
01330 
01331       MPI_Comm tmpComm1 = comm;
01332       MPI_Comm tmpComm2;
01333       <span class="keywordtype">bool</span> iAmActiveForCoarsening = <span class="keyword">true</span>;
01334       <span class="keywordtype">bool</span> repeatLoop = <span class="keyword">true</span>;
01335       <span class="keywordflow">while</span>( (idxOfCoarsestLev &lt; (nlevels-2)) &amp;&amp; (repeatLoop) ) {
01336         std::vector&lt;ot::TreeNode&gt; tmpOctree;      
01337         <span class="comment">//First coarsen</span>
01338         <span class="keywordflow">if</span> (idxOfCoarsestLev == -1) {
01339           <span class="comment">//We can skip Partition for the first call to coarsen since</span>
01340           <span class="comment">//finestOctree is explicitly partitioned above. </span>
01341           <a class="code" href="namespaceot.html#a31">ot::coarsenOctree</a>(finestOctree, tmpOctree, dim, maxDepth, 
01342               tmpComm1, <span class="keyword">true</span>, &amp;tmpComm2, &amp;iAmActiveForCoarsening);
01343         } <span class="keywordflow">else</span> {
01344           <span class="comment">//We cannot skip Partition here since there is no explicit call to</span>
01345           <span class="comment">//partition at the end of balancing and after the intial block</span>
01346           <span class="comment">//partition, balancing could have introduced a load imbalance across</span>
01347           <span class="comment">//the processors</span>
01348           <a class="code" href="namespaceot.html#a31">ot::coarsenOctree</a>(coarserOctrees[idxOfCoarsestLev], tmpOctree,
01349               dim, maxDepth, tmpComm1, <span class="keyword">false</span>, &amp;tmpComm2, &amp;iAmActiveForCoarsening);
01350         }<span class="comment">//end if finest level</span>
01351 
01352         idxOfCoarsestLev++;
01353 
01354         <span class="comment">//Then balance</span>
01355         <span class="keywordflow">if</span>(iAmActiveForCoarsening) {
01356           <a class="code" href="namespaceot.html#a10">ot::balanceOctree</a>(tmpOctree, coarserOctrees[idxOfCoarsestLev],
01357               dim, maxDepth, incCorner, tmpComm2, &amp;tmpComm1, &amp;iAmActiveForCoarsening);
01358         }
01359         tmpOctree.clear();
01360 
01361         <span class="comment">//All active processors for this level will have the correct comm set</span>
01362         <span class="comment">//and that's all we care. We do not care about the comms for inactive</span>
01363         <span class="comment">//processors</span>
01364         activeStatesInCoarseBal[idxOfCoarsestLev] = iAmActiveForCoarsening;
01365         activeCommsInCoarseBal[idxOfCoarsestLev] = tmpComm1;
01366 
01367         <span class="keywordflow">if</span>(iAmActiveForCoarsening) {
01368           MPI_Comm_size(tmpComm1, (activeNpesInCoarseBal + idxOfCoarsestLev));
01369           <span class="keywordflow">if</span>( (activeNpesInCoarseBal[idxOfCoarsestLev] == 1) &amp;&amp;
01370               (coarserOctrees[idxOfCoarsestLev].size() &lt; 500) ) {
01371             repeatLoop = <span class="keyword">false</span>;
01372           }
01373         } <span class="keywordflow">else</span> {
01374           assert(coarserOctrees[idxOfCoarsestLev].empty());
01375           <span class="keywordflow">break</span>;
01376         }
01377 
01378       }<span class="comment">//end while</span>
01379     }<span class="comment">//end if initial nlevels &gt; 1</span>
01380 
01381     <a class="code" href="omg_8h.html#a3">PROF_SET_DA_STAGE2_END</a>
01382 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
01383 <span class="preprocessor"></span>      MPI_Barrier(comm);
01384 <span class="preprocessor">#endif</span>
01385 <span class="preprocessor"></span>    <a class="code" href="omg_8h.html#a4">PROF_SET_DA_STAGE3_BEGIN</a>
01386 
01387       <span class="comment">//Only processor 0 is guaranteed to have the correct idxOfCoarsestLev</span>
01388       par::Mpi_Bcast&lt;int&gt;(&amp;idxOfCoarsestLev, 1, 0, comm);
01389 
01390     <span class="comment">//Reset nlevels</span>
01391     nlevels = (idxOfCoarsestLev + 2);
01392 
01393     <span class="comment">//Need to synchronize activeNpesInCoarseBal across all processors.</span>
01394     <span class="comment">//Only processor 0 is guaranteed to be active at all levels. Hence, only it</span>
01395     <span class="comment">//will have the correct values at all levels. Inactive processors will have</span>
01396     <span class="comment">//junk values.  Similarly, only processor 0 will have the correct</span>
01397     <span class="comment">//globalSizes for all levels since only it is active on all levels.</span>
01398     <span class="comment">//Inactive processors will have junk values.</span>
01399     <span class="keywordflow">if</span>(nlevels &gt; 1) {
01400       par::Mpi_Bcast&lt;int&gt;(activeNpesInCoarseBal, (nlevels - 1), 0, comm);
01401     }
01402 
01403 <span class="preprocessor">#ifdef __USE_PVT_DA_IN_MG__</span>
01404 <span class="preprocessor"></span>    <span class="comment">//All processors are active on the finest level</span>
01405     std::vector&lt;ot::TreeNode&gt; positiveBoundaries;
01406     <a class="code" href="namespaceot.html#a61">ot::addBoundaryNodesType1</a>(finestOctree, positiveBoundaries, dim, maxDepth);
01407 
01408     <span class="comment">//update maxdepth</span>
01409     maxDepth = maxDepth + 1;
01410 
01411     <span class="comment">//Most processors will not add any positive boundaries. So, there is no need</span>
01412     <span class="comment">//to unnecessarily distribute positive boundaries on all procs just for</span>
01413     <span class="comment">//sorting. So only the few processors touching the positive boundary will</span>
01414     <span class="comment">//participate in the parallel sort</span>
01415     MPI_Comm bdyComm;
01416     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>((positiveBoundaries.empty()), &amp;bdyComm, comm);
01417 
01418     <span class="keywordflow">if</span>(!(positiveBoundaries.empty())) {
01419       <span class="comment">//Call Sample Sort  </span>
01420       std::vector&lt;ot::TreeNode &gt; tmpVecTN;
01421       par::sampleSort&lt;ot::TreeNode&gt;(positiveBoundaries, tmpVecTN, bdyComm);
01422       positiveBoundaries = tmpVecTN;
01423       tmpVecTN.clear();
01424     }
01425 
01426     par::concatenate&lt;ot::TreeNode&gt;(finestOctree, positiveBoundaries, comm);
01427     positiveBoundaries.clear();
01428 
01429     <span class="comment">//Now for all the coarser levels</span>
01430     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> lev = 0; lev &lt; (nlevels - 1); lev++) {
01431       <span class="keywordflow">if</span>(activeStatesInCoarseBal[lev]) {        
01432         <a class="code" href="namespaceot.html#a61">ot::addBoundaryNodesType1</a>(coarserOctrees[lev], positiveBoundaries, dim, maxDepth-1);
01433 
01434         <span class="comment">//Most processors will not add any positive boundaries. So, there is no need</span>
01435         <span class="comment">//to unnecessarily distribute positive boundaries on all procs just for</span>
01436         <span class="comment">//sorting. So only the few processors touching the positive boundary will</span>
01437         <span class="comment">//participate in the parallel sort</span>
01438         <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>((positiveBoundaries.empty()), &amp;bdyComm, activeCommsInCoarseBal[lev]);
01439 
01440         <span class="keywordflow">if</span>(!(positiveBoundaries.empty())) {
01441           <span class="comment">//Call Sample Sort  </span>
01442           std::vector&lt;ot::TreeNode &gt; tmpVecTN;
01443           par::sampleSort&lt;ot::TreeNode&gt;(positiveBoundaries, tmpVecTN, bdyComm);
01444           positiveBoundaries = tmpVecTN;
01445           tmpVecTN.clear();
01446         }
01447 
01448         par::concatenate&lt;ot::TreeNode&gt;(coarserOctrees[lev], positiveBoundaries, activeCommsInCoarseBal[lev]);
01449         positiveBoundaries.clear();
01450       }
01451     }<span class="comment">//end for lev</span>
01452 
01453 <span class="preprocessor">#endif</span>
01454 <span class="preprocessor"></span>
01455     <span class="comment">//All processors should know the global size at each level</span>
01456     <a class="code" href="dendro_8h.html#a0">DendroIntL</a>* localOctreeSizeForThisLevel = <span class="keyword">new</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a>[nlevels];
01457     <a class="code" href="dendro_8h.html#a0">DendroIntL</a>* globalOctreeSizeForThisLevel = <span class="keyword">new</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a>[nlevels];
01458     localOctreeSizeForThisLevel[0] = finestOctree.size();
01459     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> lev = 0; lev &lt; (nlevels - 1); lev++) {
01460       localOctreeSizeForThisLevel[lev + 1] = coarserOctrees[lev].size();
01461     }<span class="comment">//end for lev</span>
01462     par::Mpi_Allreduce&lt;DendroIntL&gt;(localOctreeSizeForThisLevel,
01463         globalOctreeSizeForThisLevel, nlevels, MPI_SUM, comm);
01464     <span class="keyword">delete</span> [] localOctreeSizeForThisLevel;
01465 
01466 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
01467 <span class="preprocessor"></span>    MPI_Barrier(comm);
01468     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; (nlevels - 1); i++) {
01469       <span class="keywordflow">if</span>(rank &lt; activeNpesInCoarseBal[i]) {
01470         assert(activeStatesInCoarseBal[i]);
01471       } <span class="keywordflow">else</span> {
01472         assert(!(activeStatesInCoarseBal[i]));
01473       }
01474     }<span class="comment">//end for i</span>
01475     MPI_Barrier(comm);
01476 <span class="preprocessor">#endif</span>
01477 <span class="preprocessor"></span>
01478     <span class="comment">//0 is the finest and (nlevels-1) is the coarsest</span>
01479     <span class="keywordtype">int</span> *maxProcsForThisLevel = <span class="keyword">new</span> <span class="keywordtype">int</span> [nlevels];
01480 
01481     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
01482       <span class="keyword">const</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a> THOUSAND = 1000;
01483       <span class="keywordflow">if</span>(globalOctreeSizeForThisLevel[i] &lt; (THOUSAND*npes)) {
01484         <span class="keywordtype">int</span> maxProcsToUse = (globalOctreeSizeForThisLevel[i]/THOUSAND);
01485         <span class="keywordflow">if</span>(maxProcsToUse == 0) {
01486           maxProcsToUse = 1;
01487         }
01488         <span class="keywordflow">if</span>(maxProcsToUse &lt; 1) {
01489           <span class="keywordflow">if</span>(!rank) {
01490             std::cout&lt;&lt;<span class="stringliteral">"There are too few octants."</span>&lt;&lt;
01491               <span class="stringliteral">" Can not use more than 1 processor."</span>&lt;&lt;std::endl;
01492             fflush(stdout);
01493           }
01494           assert(<span class="keyword">false</span>);
01495         }
01496         maxProcsForThisLevel[i] = maxProcsToUse;
01497       } <span class="keywordflow">else</span> {
01498         <span class="comment">//use all the processors</span>
01499         maxProcsForThisLevel[i] = npes;
01500       }
01501     }<span class="comment">//end for i</span>
01502 
01503     <span class="comment">//maxProcsForThisLevel was computed above using the final balanced octree</span>
01504     <span class="comment">//size for that level. However, the octree itself may be distributed on</span>
01505     <span class="comment">//(a) fewer or (b) more processors. The former case occurs when too many</span>
01506     <span class="comment">//new octants were generated during the balancing step. The latter case</span>
01507     <span class="comment">//occurs when too many extra boundaries were removed. Here we measure the</span>
01508     <span class="comment">//discrepancy between the two and decide which one to pick. On one hand if</span>
01509     <span class="comment">//we change the number of active processors, then we must call scatter to </span>
01510     <span class="comment">//redistribute the octants. On the other hand if the grain size is much</span>
01511     <span class="comment">//larger than what it should be we will unnecessarily increase the cost</span>
01512     <span class="comment">//for subsequent operations. We will do this only for the coarsest level,</span>
01513     <span class="comment">//this will automatically influence the finer levels in the subsequent</span>
01514     <span class="comment">//step. </span>
01515     <span class="keywordflow">if</span>(nlevels &gt; 1) {
01516       <span class="keywordflow">if</span>(activeNpesInCoarseBal[nlevels - 2] &lt; maxProcsForThisLevel[nlevels - 1]) {
01517         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> currentGrainSize = 
01518           (globalOctreeSizeForThisLevel[nlevels - 1]/activeNpesInCoarseBal[nlevels - 2]);
01519 
01520         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> expectedGrainSize = 
01521           (globalOctreeSizeForThisLevel[nlevels - 1]/maxProcsForThisLevel[nlevels - 1]);
01522 
01523         <span class="keywordflow">if</span>(static_cast&lt;double&gt;(currentGrainSize) &lt; 
01524             (1.5*static_cast&lt;double&gt;(expectedGrainSize))) {
01525           maxProcsForThisLevel[nlevels - 1] = activeNpesInCoarseBal[nlevels - 2];
01526         }
01527       }
01528     }
01529 
01530     <span class="comment">//avoid repartitioning at every level.</span>
01531     <span class="comment">//Loop from coarsest to finest</span>
01532     <span class="comment">//If the fine level does not fit on all processors, then</span>
01533     <span class="comment">//the coarser levels will not fit on all p either.</span>
01534     <span class="comment">//The procs for the coarse level will be &gt;= 1/8 that</span>
01535     <span class="comment">//of the finer level and &lt;= the finer level procs. This is because the</span>
01536     <span class="comment">//number of elements on the coarse level can be anything from almost same</span>
01537     <span class="comment">//(just 8 octants coarsened) to a 8 times reduction in size.  </span>
01538     <span class="comment">//So the grain size for the fine octree computed on the coarse grid procs</span>
01539     <span class="comment">//will be &gt;= the true grain size and &lt;= 8*(the true grain size) </span>
01540     <span class="comment">//If P_coarse = P_fine, then the cost of the matvec goes up, but there is</span>
01541     <span class="comment">//no additional meshing and no scatters during transfers</span>
01542     <span class="comment">//If P_coarse &lt; P_fine, then there is an extra fine grid mesh using P_fine</span>
01543     <span class="comment">//procs and extra scatters, but the cost of the matvec goes down (due to</span>
01544     <span class="comment">//smaller grain size)</span>
01545 
01546     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (nlevels-2); i &gt;= 0; i--) {
01547       <span class="keywordflow">if</span>(maxProcsForThisLevel[i] &gt; maxProcsForThisLevel[i+1]) {
01548         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgGrainSize = (globalOctreeSizeForThisLevel[i]/maxProcsForThisLevel[i]);
01549 
01550         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgGrainSizeUsing1LevCoarserNpes = 
01551           (globalOctreeSizeForThisLevel[i]/maxProcsForThisLevel[i+1]);
01552 
01553         <span class="keywordflow">if</span>(static_cast&lt;double&gt;(avgGrainSizeUsing1LevCoarserNpes) &lt;
01554             (1.5*static_cast&lt;double&gt;(avgGrainSize))) {
01555           maxProcsForThisLevel[i] = maxProcsForThisLevel[i+1];
01556         }
01557       } <span class="keywordflow">else</span> {
01558         assert(maxProcsForThisLevel[i] == maxProcsForThisLevel[i+1]);
01559       }
01560     }<span class="comment">//end for i</span>
01561 
01562 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
01563 <span class="preprocessor"></span>    <span class="keywordflow">if</span>(!rank) {
01564       std::cout&lt;&lt;<span class="stringliteral">" Using "</span>&lt;&lt;nlevels&lt;&lt;<span class="stringliteral">" Multigrid Levels."</span>&lt;&lt;std::endl; 
01565       fflush(stdout);
01566       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
01567         std::cout&lt;&lt;<span class="stringliteral">" maxNpes for lev "</span>&lt;&lt; i &lt;&lt;<span class="stringliteral">": "</span>&lt;&lt; maxProcsForThisLevel[i] &lt;&lt;std::endl;
01568         fflush(stdout);
01569       }
01570     }
01571 <span class="preprocessor">#endif</span>
01572 <span class="preprocessor"></span>
01573     <a class="code" href="omg_8h.html#a5">PROF_SET_DA_STAGE3_END</a>
01574 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
01575 <span class="preprocessor"></span>      MPI_Barrier(comm);
01576 <span class="preprocessor">#endif</span>
01577 <span class="preprocessor"></span>    <a class="code" href="omg_8h.html#a6">PROF_SET_DA_STAGE4_BEGIN</a>
01578 
01579       <span class="comment">//Create activeComms for each level.</span>
01580       <span class="comment">//0 is the finest and (nlevels-1) is the coarsest</span>
01581       MPI_Comm* activeComms = <span class="keyword">new</span> MPI_Comm[nlevels];
01582 
01583     <span class="keywordflow">if</span>(maxProcsForThisLevel[0] == npes) {
01584       activeComms[0] = comm;
01585     } <span class="keywordflow">else</span> {
01586 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
01587 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(!rank) {
01588         std::cout&lt;&lt;<span class="stringliteral">"splitting Comm in SetDA (using comm) "</span>&lt;&lt;npes&lt;&lt;<span class="stringliteral">" -&gt; "</span>&lt;&lt;maxProcsForThisLevel[0]&lt;&lt;std::endl; 
01589       }
01590 <span class="preprocessor">#endif</span>
01591 <span class="preprocessor"></span>      <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(maxProcsForThisLevel[0], activeComms, comm);
01592     }
01593     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> lev = 1; lev &lt; nlevels; lev++) {
01594       <span class="keywordflow">if</span>(maxProcsForThisLevel[lev] == maxProcsForThisLevel[lev - 1]) {
01595         <span class="comment">//coarse and fine grid use the same comm</span>
01596         activeComms[lev] = activeComms[lev - 1];
01597       } <span class="keywordflow">else</span> {
01598         assert(maxProcsForThisLevel[lev] &lt; maxProcsForThisLevel[lev - 1]);
01599         <span class="keywordflow">if</span>(maxProcsForThisLevel[lev] == activeNpesInCoarseBal[lev - 1]) {
01600           <span class="comment">//The correct comm for this level was already created during coarsening</span>
01601           activeComms[lev] = activeCommsInCoarseBal[lev - 1];
01602         } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(maxProcsForThisLevel[lev] &lt; activeNpesInCoarseBal[lev - 1]) {
01603           <span class="comment">//The correct comm is a subset of the comm that was already created for this level</span>
01604           <span class="keywordflow">if</span>(maxProcsForThisLevel[lev - 1] &lt; activeNpesInCoarseBal[lev - 1]) {
01605 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
01606 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(!rank) {
01607               std::cout&lt;&lt;<span class="stringliteral">"splitting Comm in SetDA (using fine activeComm) "</span>&lt;&lt;
01608                 maxProcsForThisLevel[lev - 1]&lt;&lt;<span class="stringliteral">" -&gt; "</span>&lt;&lt;maxProcsForThisLevel[lev]&lt;&lt;std::endl; 
01609             }
01610 <span class="preprocessor">#endif</span>
01611 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(rank &lt; maxProcsForThisLevel[lev - 1]) {
01612               <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(maxProcsForThisLevel[lev],
01613                   (activeComms + lev), activeComms[lev - 1]);
01614             }
01615           } <span class="keywordflow">else</span> {
01616 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
01617 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(!rank) {
01618               std::cout&lt;&lt;<span class="stringliteral">"splitting Comm in SetDA (using coarseBalComm) "</span>&lt;&lt;
01619                 activeNpesInCoarseBal[lev - 1]&lt;&lt;<span class="stringliteral">" -&gt; "</span>&lt;&lt;maxProcsForThisLevel[lev]&lt;&lt;std::endl; 
01620             }
01621 <span class="preprocessor">#endif</span>
01622 <span class="preprocessor"></span>            <span class="keywordflow">if</span>(rank &lt; activeNpesInCoarseBal[lev - 1]) {
01623               <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(maxProcsForThisLevel[lev],
01624                   (activeComms + lev), activeCommsInCoarseBal[lev - 1]);
01625             }
01626           }
01627         } <span class="keywordflow">else</span> {
01628 <span class="preprocessor">#ifndef __SILENT_MODE__</span>
01629 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(!rank) {
01630             std::cout&lt;&lt;<span class="stringliteral">"splitting Comm in SetDA (using fine activeComm) "</span>&lt;&lt;
01631               maxProcsForThisLevel[lev - 1]&lt;&lt;<span class="stringliteral">" -&gt; "</span>&lt;&lt;maxProcsForThisLevel[lev]&lt;&lt;std::endl; 
01632           }
01633 <span class="preprocessor">#endif</span>
01634 <span class="preprocessor"></span>          <span class="keywordflow">if</span>(rank &lt; maxProcsForThisLevel[lev - 1]) {
01635             <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(maxProcsForThisLevel[lev],
01636                 (activeComms + lev), activeComms[lev - 1]);
01637           }
01638         }
01639       }
01640     }<span class="comment">//end for lev</span>
01641 
01642     <a class="code" href="omg_8h.html#a7">PROF_SET_DA_STAGE4_END</a>
01643 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
01644 <span class="preprocessor"></span>      MPI_Barrier(comm);
01645 <span class="preprocessor">#endif</span>
01646 <span class="preprocessor"></span>    <a class="code" href="omg_8h.html#a8">PROF_SET_DA_STAGE5_BEGIN</a>
01647 
01648       <span class="comment">//Distribute the octrees on maxProcsForThisLevel processors</span>
01649       <span class="comment">//finestOctree is not empty on any processor and so all processors</span>
01650       <span class="comment">//participate in this scatter</span>
01651       <span class="keywordflow">if</span>(maxProcsForThisLevel[0] &lt; npes) {
01652         std::vector&lt;ot::TreeNode&gt; tmpOctree;
01653         <span class="keywordflow">if</span>(rank &lt; maxProcsForThisLevel[0]) {
01654           <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgGlobalOctSize = (globalOctreeSizeForThisLevel[0]/maxProcsForThisLevel[0]);
01655           <span class="keywordtype">int</span> extraOcts = (globalOctreeSizeForThisLevel[0] % maxProcsForThisLevel[0]);
01656           <span class="keywordflow">if</span>(rank &lt; extraOcts) {
01657             par::scatterValues&lt;ot::TreeNode&gt;(finestOctree, tmpOctree,
01658                 (avgGlobalOctSize+1), comm);
01659           }<span class="keywordflow">else</span> {
01660             par::scatterValues&lt;ot::TreeNode&gt;(finestOctree, tmpOctree,
01661                 avgGlobalOctSize, comm);
01662           }
01663         }<span class="keywordflow">else</span> {
01664           par::scatterValues&lt;ot::TreeNode&gt;(finestOctree, tmpOctree,
01665               0, comm);
01666         }
01667         finestOctree = tmpOctree;
01668         tmpOctree.clear();
01669       }
01670 
01671     <span class="comment">//coarseOctrees[i] is only distributed on activeCommsInCoarseBal[i]</span>
01672     <span class="comment">//It is empty on all other processors</span>
01673     <span class="comment">//So by using "activeCommsInCoarseBal[i]" instead of "comm", we can skip idle</span>
01674     <span class="comment">//processors from participating in the scatter. </span>
01675     <span class="comment">//If "activeCommsInCoarseBal[i]" is different from "comm", it would have</span>
01676     <span class="comment">//been created using the function "splitCommUsingSplittingRank" inside</span>
01677     <span class="comment">//"CoarsenOctree" or "BalanceOctree". Moreover, this will happen only when</span>
01678     <span class="comment">//the the total input size for that function is &lt; 1000*npes. When this</span>
01679     <span class="comment">//happens the input would be redistributed to the first few processors.</span>
01680     <span class="comment">//"splitCommUsingSplittingRank" preserves the relative order of ranks in</span>
01681     <span class="comment">//the old and new comms. Hence, on all active processors the "rank" in</span>
01682     <span class="comment">//"comm" and in "activeCommsInCoarseBal[i]" will be the same. Similarly,</span>
01683     <span class="comment">//"activeComms" is also created above using "splitCommUsingSplittingRank",</span>
01684     <span class="comment">//hence the ranks in "activeComms" and "comm" will also be the same. </span>
01685 
01686     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; nlevels; i++) {
01687       <span class="keywordflow">if</span>(activeNpesInCoarseBal[i-1] &lt; maxProcsForThisLevel[i]) {
01688         <span class="comment">//This case happens when the grain size using activeNpes is more than</span>
01689         <span class="comment">//1.5 times the grain size using maxProcs </span>
01690         <span class="comment">//We need to expand the communicator</span>
01691         <span class="comment">//Both active and inactive processors need to participate here</span>
01692         <span class="comment">//But not all inactive processors need to participate. We have already</span>
01693         <span class="comment">//created the final activeComms above. We can use that here</span>
01694         std::vector&lt;ot::TreeNode&gt; tmpOctree;
01695         <span class="keywordflow">if</span>(rank &lt; maxProcsForThisLevel[i]) {
01696           <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgGlobalOctSize = (globalOctreeSizeForThisLevel[i]/maxProcsForThisLevel[i]);
01697           <span class="keywordtype">int</span> extraOcts = (globalOctreeSizeForThisLevel[i] % maxProcsForThisLevel[i]);
01698           <span class="keywordflow">if</span>(rank &lt; extraOcts) {
01699             par::scatterValues&lt;ot::TreeNode&gt;(coarserOctrees[i-1], tmpOctree,
01700                 (avgGlobalOctSize+1), activeComms[i]);
01701           }<span class="keywordflow">else</span> {
01702             par::scatterValues&lt;ot::TreeNode&gt;(coarserOctrees[i-1], tmpOctree,
01703                 avgGlobalOctSize, activeComms[i]);
01704           }
01705         }
01706         coarserOctrees[i-1] = tmpOctree;
01707         tmpOctree.clear();
01708       } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(activeNpesInCoarseBal[i-1] &gt; maxProcsForThisLevel[i]) {
01709         <span class="comment">//We need to shrink the communicator</span>
01710         <span class="comment">//This case happens when we decide to use the same number of processors</span>
01711         <span class="comment">//as the immediate coarser level or too many extra boundaries were</span>
01712         <span class="comment">//discarded resulting in new empty processors</span>
01713         <span class="comment">//Inactive processors can be skipped here</span>
01714         <span class="keywordflow">if</span>(activeStatesInCoarseBal[i-1]) {
01715           std::vector&lt;ot::TreeNode&gt; tmpOctree;
01716           <span class="keywordflow">if</span>(rank &lt; maxProcsForThisLevel[i]) {
01717             <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgGlobalOctSize = (globalOctreeSizeForThisLevel[i]/maxProcsForThisLevel[i]);
01718             <span class="keywordtype">int</span> extraOcts = (globalOctreeSizeForThisLevel[i] % maxProcsForThisLevel[i]);
01719             <span class="keywordflow">if</span>(rank &lt; extraOcts) {
01720               par::scatterValues&lt;ot::TreeNode&gt;(coarserOctrees[i-1], tmpOctree,
01721                   (avgGlobalOctSize+1), activeCommsInCoarseBal[i-1]);
01722             }<span class="keywordflow">else</span> {
01723               par::scatterValues&lt;ot::TreeNode&gt;(coarserOctrees[i-1], tmpOctree,
01724                   avgGlobalOctSize, activeCommsInCoarseBal[i-1]);
01725             }
01726           }<span class="keywordflow">else</span> {
01727             par::scatterValues&lt;ot::TreeNode&gt;(coarserOctrees[i-1], tmpOctree,
01728                 0, activeCommsInCoarseBal[i-1]);
01729           }
01730           coarserOctrees[i-1] = tmpOctree;
01731           tmpOctree.clear();
01732         }<span class="comment">//end if active</span>
01733       }<span class="comment">//end if expanding or shrinking</span>
01734     }<span class="comment">//end for i</span>
01735 
01736 <span class="preprocessor">#ifdef __USE_PVT_DA_IN_MG__</span>
01737 <span class="preprocessor"></span>    <span class="comment">//A simple implementation for now. This just calls flagNodesType3 for all</span>
01738     <span class="comment">//levels. A smarter implementation would use the fact that regular coarse</span>
01739     <span class="comment">//grid nodes remain regular on all finer octrees </span>
01740     <a class="code" href="namespaceot.html#a60">ot::markHangingNodesAtAllLevels</a>(finestOctree, nlevels, coarserOctrees,
01741         activeComms, dim, maxDepth);
01742 <span class="preprocessor">#endif</span>
01743 <span class="preprocessor"></span>
01744     <span class="keywordflow">if</span>(activeStatesInCoarseBal) {
01745       <span class="keyword">delete</span> [] activeStatesInCoarseBal;
01746       activeStatesInCoarseBal = NULL;
01747     }
01748 
01749     <span class="keywordflow">if</span>(activeCommsInCoarseBal) {
01750       <span class="keyword">delete</span> [] activeCommsInCoarseBal;
01751       activeCommsInCoarseBal = NULL;
01752     }
01753 
01754     <span class="keywordflow">if</span>(activeNpesInCoarseBal) {
01755       <span class="keyword">delete</span> [] activeNpesInCoarseBal;
01756       activeNpesInCoarseBal = NULL;
01757     }
01758 
01759     <span class="comment">//nlevels has been corrected if necessary. Create the DAMG now...</span>
01760     <a class="code" href="namespaceot.html#a9">DAMG</a>     *tmpDAMG = <span class="keyword">new</span> <a class="code" href="namespaceot.html#a9">DAMG</a>[nlevels];  
01761     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
01762       tmpDAMG[i] = <span class="keyword">new</span> <a class="code" href="structot_1_1__p__DAMG.html">_p_DAMG</a>;    
01763       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>  = nlevels - i;
01764       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o17">totalLevels</a> = nlevels;
01765       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>     = comm;
01766       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>     = user;    
01767       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o6">initialguess</a> = NULL;
01768       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a> = NULL; 
01769       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o16">suppressedDOFaux</a> = NULL; 
01770       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o5">dof</a> = dof;
01771       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a> = NULL;
01772       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a> = NULL;
01773       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o19">x</a> = NULL;
01774       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o1">b</a> = NULL;
01775       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o12">r</a> = NULL;
01776       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a> = NULL;
01777       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o0">B</a> = NULL;
01778       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o11">R</a> = NULL;
01779       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o14">solve</a> = NULL;         
01780       <span class="comment">// KSP only </span>
01781       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o8">ksp</a> = NULL;             
01782       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o13">rhs</a> = NULL;
01783       <span class="comment">// User had called stsDMMGSetKSP() and the matrices have been computed </span>
01784       tmpDAMG[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o9">matricesset</a> = PETSC_FALSE;
01785     }<span class="comment">//end for i  </span>
01786     *damg = tmpDAMG;
01787 
01788     <a class="code" href="omg_8h.html#a9">PROF_SET_DA_STAGE5_END</a>
01789 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
01790 <span class="preprocessor"></span>      MPI_Barrier(comm);
01791 <span class="preprocessor">#endif</span>
01792 <span class="preprocessor"></span>    <a class="code" href="omg_8h.html#a10">PROF_SET_DA_STAGE6_BEGIN</a>
01793 
01794       <span class="keywordflow">if</span>(nlevels == 1) {
01795         <span class="comment">//Single level only</span>
01796 
01797 <span class="preprocessor">#ifndef __USE_PVT_DA_IN_MG__</span>
01798 <span class="preprocessor"></span>        tmpDAMG[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a> = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(finestOctree, comm, activeComms[0], compressLut, NULL, NULL);
01799 <span class="preprocessor">#else</span>
01800 <span class="preprocessor"></span>        tmpDAMG[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a> = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(1, finestOctree, comm, activeComms[0], compressLut, NULL, NULL);
01801 <span class="preprocessor">#endif</span>
01802 <span class="preprocessor"></span>
01803         <span class="keywordflow">if</span>(!rank) {
01804           <span class="keywordtype">int</span> activeNpes = tmpDAMG[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>();
01805           <span class="keywordflow">if</span>(activeNpes &lt; npes) {
01806             std::cout&lt;&lt;<span class="stringliteral">"WARNING: Some processors will be"</span>&lt;&lt;
01807               <span class="stringliteral">" idle even on the finest level."</span>&lt;&lt;
01808               <span class="stringliteral">" You might want to use fewer processors."</span>&lt;&lt;std::endl;
01809             fflush(stdout);
01810           }
01811         }
01812 
01813         finestOctree.clear();
01814 
01815         <span class="comment">//Free memory</span>
01816         <span class="keyword">delete</span> [] maxProcsForThisLevel;
01817         maxProcsForThisLevel = NULL;
01818 
01819         <span class="keyword">delete</span> [] globalOctreeSizeForThisLevel;
01820         globalOctreeSizeForThisLevel = NULL;
01821 
01822         <span class="keyword">delete</span> [] activeComms;
01823         activeComms = NULL;
01824 
01825         <span class="comment">//If initial nlevels was 1, then coarserOctree would never have been</span>
01826         <span class="comment">//created. If nlevels was reset to 1 later then coarserOctrees would</span>
01827         <span class="comment">//have been created.</span>
01828         <span class="keywordflow">if</span>(coarserOctrees != NULL) {
01829           <span class="keyword">delete</span> [] coarserOctrees;
01830           coarserOctrees = NULL;
01831         }
01832 
01833         <a class="code" href="omg_8h.html#a11">PROF_SET_DA_STAGE6_END</a>
01834 
01835           ierr = <a class="code" href="namespaceot.html#a104">DAMGSetUp</a>(tmpDAMG);CHKERRQ(ierr); 
01836 
01837         <a class="code" href="omg_8h.html#a19">PROF_MG_SET_DA_END</a>
01838       }<span class="comment">//special case: single grid  </span>
01839 
01840     <span class="comment">//Start with the coarsest octree and mesh. </span>
01841     std::vector&lt;ot::TreeNode&gt;* blocksPtr = NULL;
01842     <a class="code" href="classot_1_1DA.html">ot::DA</a>* newDa = NULL;
01843     <span class="keywordflow">while</span>(idxOfCoarsestLev &gt;= 0) {
01844 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
01845 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(!rank) {
01846         std::cout&lt;&lt;<span class="stringliteral">"Meshing lev: "</span>&lt;&lt;idxOfCoarsestLev&lt;&lt;std::endl;
01847       }
01848 <span class="preprocessor">#endif</span>
01849 <span class="preprocessor"></span>
01850       <span class="keywordflow">if</span>(newDa == NULL) {
01851 <span class="preprocessor">#ifndef __USE_PVT_DA_IN_MG__</span>
01852 <span class="preprocessor"></span>        newDa = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(coarserOctrees[idxOfCoarsestLev], comm, 
01853             activeComms[idxOfCoarsestLev + 1], compressLut,
01854             blocksPtr, NULL);
01855 <span class="preprocessor">#else</span>
01856 <span class="preprocessor"></span>        newDa = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(1, coarserOctrees[idxOfCoarsestLev], comm, 
01857             activeComms[idxOfCoarsestLev + 1], compressLut,
01858             blocksPtr, NULL);
01859 <span class="preprocessor">#endif</span>
01860 <span class="preprocessor"></span>      }
01861 
01862       <span class="comment">//The constructor will modify the input octree. So it's useless</span>
01863       <span class="comment">//afterwards.</span>
01864       coarserOctrees[idxOfCoarsestLev].clear();
01865       tmpDAMG[nlevels-(2+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a> = newDa;
01866       newDa = NULL;
01867 
01868       <span class="keywordtype">bool</span> procsNotUsedWell;
01869       <span class="keywordflow">if</span>(!rank) {  
01870         <span class="keywordtype">int</span> activeNpes = tmpDAMG[nlevels-(2+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>();
01871         <span class="keywordflow">if</span>( (activeNpes &lt; maxProcsForThisLevel[idxOfCoarsestLev+1]) ||
01872             (maxProcsForThisLevel[idxOfCoarsestLev+1] &lt;
01873              maxProcsForThisLevel[idxOfCoarsestLev]) ) {
01874           procsNotUsedWell = <span class="keyword">true</span>;
01875         } <span class="keywordflow">else</span> {
01876           procsNotUsedWell = <span class="keyword">false</span>;
01877         }
01878       }
01879 
01880       par::Mpi_Bcast&lt;bool&gt;(&amp;procsNotUsedWell, 1, 0, comm);
01881 
01882       <span class="comment">//For the mat-vecs, </span>
01883       <span class="comment">//Communication cost: O(dependent)</span>
01884       <span class="comment">//Computation cost: O(own + pre-Ghost)</span>
01885       <span class="comment">//Heuristic: Give 75% weight to computation and 25% to communication</span>
01886       <span class="comment">//load =  0.75*computation + 0.25*communication  </span>
01887       <span class="keywordtype">double</span> minMaxLoad[2]; <span class="comment">//0 for minLoad, 1 for maxLoad</span>
01888 
01889       <span class="keywordflow">if</span>(tmpDAMG[nlevels-(2+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
01890         <a class="code" href="classot_1_1DA.html">ot::DA</a>* currDa = tmpDAMG[nlevels-(2+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
01891 
01892         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localPreGhostSize = currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_9">getIdxElementBegin</a>();
01893 
01894         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localIndependentSize = currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_12">getIndependentSize</a>();
01895 
01896         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localOwnSize = currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_5">getElementSize</a>();
01897 
01898         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localDependentSize = (localOwnSize - localIndependentSize);
01899 
01900 <span class="preprocessor">#ifdef __NO_GHOST_LOOP__</span>
01901 <span class="preprocessor"></span>        <span class="keywordtype">double</span> computationLoad = localOwnSize;
01902 <span class="preprocessor">#else</span>
01903 <span class="preprocessor"></span>        <span class="keywordtype">double</span> computationLoad = (localOwnSize + localPreGhostSize);
01904 <span class="preprocessor">#endif</span>
01905 <span class="preprocessor"></span>        <span class="keywordtype">double</span> communicationLoad = localDependentSize;
01906 
01907         <span class="keywordtype">double</span> localLoad = ((0.75*computationLoad) + (0.25*communicationLoad));
01908 
01909         par::Mpi_Reduce&lt;double&gt;(&amp;localLoad, &amp;(minMaxLoad[0]), 1, 
01910             MPI_MIN, 0, currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>());
01911 
01912         par::Mpi_Reduce&lt;double&gt;(&amp;localLoad, &amp;(minMaxLoad[1]), 1, 
01913             MPI_MAX, 0, currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>());
01914       }
01915 
01916       par::Mpi_Bcast&lt;double&gt;(minMaxLoad, 2, 0, comm);
01917 
01918       <span class="comment">//Give the finer grids a chance to be well load balanced and</span>
01919       <span class="comment">//be distributed on as many procs as possible.</span>
01920       <span class="keywordtype">bool</span> needAuxGrid = (procsNotUsedWell ||
01921           (minMaxLoad[1] &gt; (minMaxLoad[0]*loadFac)));
01922 
01923       <span class="comment">//Get the coarse grid partition. This will be needed whether or not the</span>
01924       <span class="comment">//aux_mesh is required</span>
01925       <span class="keywordflow">if</span>(blocksPtr == NULL) {
01926         blocksPtr = <span class="keyword">new</span> std::vector&lt;ot::TreeNode&gt;;
01927         (*blocksPtr) = tmpDAMG[nlevels-(2+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a0">getBlocks</a>();
01928       }
01929 
01930       <span class="keywordflow">if</span>(needAuxGrid) {
01931         <span class="comment">//Need DA_AUX for the immediate finer octree</span>
01932         <span class="comment">//Create DA_AUX for the immediate finer octree using the current</span>
01933         <span class="comment">//partition</span>
01934         <span class="comment">//We don't want to alter the actual fine octree. So we work with a copy</span>
01935         <span class="comment">//instead.</span>
01936         std::vector&lt;ot::TreeNode&gt; fineOctreeCopy;
01937         <span class="keywordflow">if</span>(idxOfCoarsestLev &gt; 0) {
01938           fineOctreeCopy = coarserOctrees[idxOfCoarsestLev-1];
01939         }<span class="keywordflow">else</span> {
01940           fineOctreeCopy = finestOctree;
01941         }
01942 
01943         <span class="comment">//Need to redistribute fineOctreeCopy such that the input is only</span>
01944         <span class="comment">//distributed on the processors that are active on the coarse grid.</span>
01945         <span class="keywordtype">bool</span> iAmActive = tmpDAMG[nlevels-(2+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>();
01946         MPI_Comm newComm = tmpDAMG[nlevels-(2+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
01947 
01948         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> mySize = fineOctreeCopy.size();
01949         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> totalSize = globalOctreeSizeForThisLevel[idxOfCoarsestLev];   
01950 
01951         std::vector&lt;ot::TreeNode&gt; fineOctAfterPart;
01952 
01953         <span class="keywordflow">if</span>(rank &lt; maxProcsForThisLevel[idxOfCoarsestLev]) {
01954           <span class="keywordflow">if</span>(iAmActive) {
01955             <span class="keywordtype">int</span> newRank;
01956             <span class="keywordtype">int</span> newNpes;
01957             MPI_Comm_rank(newComm, &amp;newRank);
01958             MPI_Comm_size(newComm, &amp;newNpes);
01959             <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgSize = (totalSize / newNpes);
01960             <span class="keywordtype">int</span> leftOvers = (totalSize % newNpes);
01961             <span class="keywordflow">if</span>(newRank &lt; leftOvers) {
01962               par::scatterValues&lt;ot::TreeNode&gt;(fineOctreeCopy, fineOctAfterPart,
01963                   (avgSize+1), activeComms[idxOfCoarsestLev]);
01964             }<span class="keywordflow">else</span> {
01965               par::scatterValues&lt;ot::TreeNode&gt;(fineOctreeCopy, fineOctAfterPart,
01966                   avgSize, activeComms[idxOfCoarsestLev]);
01967             }
01968           }<span class="keywordflow">else</span> {
01969             par::scatterValues&lt;ot::TreeNode&gt;(fineOctreeCopy, fineOctAfterPart,
01970                 0, activeComms[idxOfCoarsestLev]);
01971           }<span class="comment">//end if active on coarse grid</span>
01972         }<span class="comment">//end if active on fine grid</span>
01973 
01974         fineOctreeCopy.clear();
01975 
01976         <span class="comment">//This DA is aligned with the coarser grid</span>
01977 <span class="preprocessor">#ifndef __USE_PVT_DA_IN_MG__</span>
01978 <span class="preprocessor"></span>        newDa = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(fineOctAfterPart, comm, newComm, compressLut, blocksPtr, NULL);
01979 <span class="preprocessor">#else</span>
01980 <span class="preprocessor"></span>        newDa = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(1, fineOctAfterPart, comm, newComm, compressLut, blocksPtr, NULL);
01981 <span class="preprocessor">#endif</span>
01982 <span class="preprocessor"></span>
01983         fineOctAfterPart.clear();
01984 
01985         <span class="comment">//Re-calculate imbalance. Check if aux mesh was really necessary</span>
01986         <span class="comment">//a-priori estimates could be misleading at times...</span>
01987 
01988         <span class="keywordflow">if</span>(!procsNotUsedWell) {
01989           <span class="keywordflow">if</span>(newDa-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
01990             <a class="code" href="classot_1_1DA.html">ot::DA</a>* currDa = newDa;
01991 
01992             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localPreGhostSize = currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_9">getIdxElementBegin</a>();
01993 
01994             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localOwnSize = currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_5">getElementSize</a>();
01995 
01996             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localIndependentSize = currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_12">getIndependentSize</a>();
01997 
01998             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localDependentSize = (localOwnSize - localIndependentSize);
01999 
02000 <span class="preprocessor">#ifdef __NO_GHOST_LOOP__</span>
02001 <span class="preprocessor"></span>            <span class="keywordtype">double</span> computationLoad = localOwnSize;
02002 <span class="preprocessor">#else</span>
02003 <span class="preprocessor"></span>            <span class="keywordtype">double</span> computationLoad = (localOwnSize + localPreGhostSize);
02004 <span class="preprocessor">#endif</span>
02005 <span class="preprocessor"></span>            <span class="keywordtype">double</span> communicationLoad = localDependentSize;
02006 
02007             <span class="keywordtype">double</span> localLoad = ((0.75*computationLoad) + (0.25*communicationLoad));
02008 
02009             par::Mpi_Reduce&lt;double&gt;(&amp;localLoad, &amp;minMaxLoad[0], 1, 
02010                 MPI_MIN, 0, currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>());
02011 
02012             par::Mpi_Reduce&lt;double&gt;(&amp;localLoad, &amp;minMaxLoad[1], 1, 
02013                 MPI_MAX, 0, currDa-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>());
02014           }
02015 
02016           par::Mpi_Bcast&lt;double&gt;(minMaxLoad, 2, 0, comm);
02017 
02018           needAuxGrid = (minMaxLoad[1] &gt; (minMaxLoad[0]*loadFac));
02019         } <span class="keywordflow">else</span> {
02020           needAuxGrid = <span class="keyword">true</span>;
02021         }
02022 
02023         <span class="keywordflow">if</span>(needAuxGrid) {
02024           tmpDAMG[nlevels-(1+idxOfCoarsestLev)]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a> = newDa;
02025           newDa = NULL;
02026 
02027           <span class="comment">//We don't want to use the same partition for the next finer level.</span>
02028           blocksPtr-&gt;clear();
02029           <span class="keyword">delete</span> blocksPtr;
02030           blocksPtr = NULL;
02031         }
02032       }<span class="comment">//end check for aux_mesh </span>
02033 
02034       idxOfCoarsestLev--;
02035     }<span class="comment">//end loop to mesh coarser grids</span>
02036 
02037     <span class="comment">//Free the memory for the pointers to the coarser octrees.</span>
02038     <span class="keyword">delete</span> [] coarserOctrees;
02039     coarserOctrees = NULL;
02040 
02041     <span class="keyword">delete</span> [] globalOctreeSizeForThisLevel;
02042     globalOctreeSizeForThisLevel = NULL;
02043 
02044     <span class="keyword">delete</span> [] maxProcsForThisLevel;
02045     maxProcsForThisLevel = NULL;
02046 
02047     <span class="comment">//mesh finest level here</span>
02048     <span class="keywordflow">if</span>(newDa == NULL) {
02049 <span class="preprocessor">#ifndef __USE_PVT_DA_IN_MG__</span>
02050 <span class="preprocessor"></span>      newDa = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(finestOctree, comm, activeComms[0], compressLut, blocksPtr, NULL);
02051 <span class="preprocessor">#else</span>
02052 <span class="preprocessor"></span>      newDa = <span class="keyword">new</span> <a class="code" href="classot_1_1DA.html">DA</a>(1, finestOctree, comm, activeComms[0], compressLut, blocksPtr, NULL);
02053 <span class="preprocessor">#endif</span>
02054 <span class="preprocessor"></span>    }
02055 
02056     tmpDAMG[nlevels-1]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a> = newDa;
02057     newDa = NULL;
02058 
02059     finestOctree.clear();
02060 
02061     <span class="keyword">delete</span> [] activeComms;
02062     activeComms = NULL;
02063 
02064     <span class="keywordflow">if</span>(!rank) {
02065       <span class="keywordtype">int</span> activeNpes = tmpDAMG[nlevels-1]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>();
02066       <span class="keywordflow">if</span>(activeNpes &lt; npes) {
02067         std::cout&lt;&lt;<span class="stringliteral">"WARNING: Some processors will be idle"</span>
02068           &lt;&lt;<span class="stringliteral">" even on the finest level."</span>
02069           &lt;&lt;<span class="stringliteral">" You might want to use fewer processors."</span>&lt;&lt;std::endl;
02070         fflush(stdout);
02071       }
02072     }
02073 
02074     <span class="keywordflow">if</span>(blocksPtr != NULL) {
02075       blocksPtr-&gt;clear();
02076       <span class="keyword">delete</span> blocksPtr;
02077       blocksPtr = NULL;
02078     }
02079 
02080     <a class="code" href="omg_8h.html#a11">PROF_SET_DA_STAGE6_END</a>
02081 
02082       ierr = <a class="code" href="namespaceot.html#a104">DAMGSetUp</a>(tmpDAMG); CHKERRQ(ierr); 
02083 
02084     <a class="code" href="omg_8h.html#a19">PROF_MG_SET_DA_END</a>
02085 
02086   }<span class="comment">//end fn.</span>
02087 
<a name="l02088"></a><a class="code" href="namespaceot.html#a104">02088</a>   PetscErrorCode <a class="code" href="namespaceot.html#a104">DAMGSetUp</a>(DAMG* damg)
02089   {
02090     <a class="code" href="omg_8h.html#a20">PROF_MG_SETUP_BEGIN</a>
02091 
02092       <span class="keywordtype">int</span>       i,nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
02093 
02094 
02095 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
02096 <span class="preprocessor"></span>    <span class="keywordtype">int</span> rank;
02097     MPI_Comm_rank(damg[0]-&gt;comm,&amp;rank);
02098     <span class="keywordflow">if</span>(!rank) {
02099       std::cout&lt;&lt;<span class="stringliteral">"In DAMGSetUp."</span>&lt;&lt;std::endl;
02100       fflush(stdout);
02101     }   
02102 <span class="preprocessor">#endif</span>
02103 <span class="preprocessor"></span>
02104     <span class="comment">/* Create work vectors and matrix for each level */</span>
02105     damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>(damg[0]-&gt;x, <span class="keyword">false</span>, <span class="keyword">false</span>, damg[0]-&gt;dof);
02106     VecDuplicate(damg[0]-&gt;x,&amp;damg[0]-&gt;b); 
02107     VecDuplicate(damg[0]-&gt;x,&amp;damg[0]-&gt;r); 
02108 
02109 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
02110 <span class="preprocessor"></span>    assert(damg[0]-&gt;da_aux == NULL);
02111 <span class="preprocessor">#endif</span>
02112 <span class="preprocessor"></span>
02113     <span class="keywordflow">for</span> (i = 1; i &lt; nlevels; i++) {
02114       damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>(damg[i]-&gt;x, <span class="keyword">false</span>, <span class="keyword">false</span>, damg[i]-&gt;dof);
02115       VecDuplicate(damg[i]-&gt;x,&amp;damg[i]-&gt;b); 
02116       VecDuplicate(damg[i]-&gt;x,&amp;damg[i]-&gt;r); 
02117 
02118       <span class="comment">/* Create interpolation/restriction between levels. */</span>  
02119       <span class="comment">//nlevels must be atleast 2 for Restriction/Interpolation  </span>
02120       <span class="comment">//i is fine, i-1 is coarse</span>
02121       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a> == NULL) {
02122         <span class="comment">//Type-1. Assume Coarse and Fine are aligned. Do not use aux.</span>
02123 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
02124 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!rank) {
02125           std::cout&lt;&lt;<span class="stringliteral">"Lev: "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" R-type: 1"</span>&lt;&lt;std::endl;
02126           fflush(stdout);
02127         }
02128 <span class="preprocessor">#endif</span>
02129 <span class="preprocessor"></span>        <a class="code" href="namespaceot.html#a105">createInterpolationType1</a>(damg[i-1],damg[i],&amp;damg[i]-&gt;R); 
02130       }<span class="keywordflow">else</span> {
02131         <span class="comment">//Type-2. Use Aux. Coarse and Fine are not aligned.</span>
02132 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
02133 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!rank) {
02134           std::cout&lt;&lt;<span class="stringliteral">"Lev: "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" R-type: 2"</span>&lt;&lt;std::endl;
02135           fflush(stdout);
02136         }
02137 <span class="preprocessor">#endif</span>
02138 <span class="preprocessor"></span>        <a class="code" href="namespaceot.html#a106">createInterpolationType2</a>(damg[i-1],damg[i],&amp;damg[i]-&gt;R); 
02139       }
02140     }<span class="comment">//end for i</span>
02141 
02142     <a class="code" href="omg_8h.html#a21">PROF_MG_SETUP_END</a>
02143   }
02144 
02145   <span class="comment">/*Matrix-Free Intergrid Transfer Operators </span>
02146 <span class="comment">Type1: Assume Coarse and Fine are aligned. Do not use aux.</span>
02147 <span class="comment">Type2: Use Aux. Coarse and Fine are not aligned.</span>
02148 <span class="comment">*/</span>
<a name="l02149"></a><a class="code" href="namespaceot.html#a105">02149</a>   PetscErrorCode <a class="code" href="namespaceot.html#a105">createInterpolationType1</a>(DAMG damgc, DAMG damgf, Mat *R)
02150   {
02151     <a class="code" href="omg_8h.html#a22">PROF_MG_CREATE_RP1_BEGIN</a>
02152 
02153       <a class="code" href="classot_1_1DA.html">ot::DA</a>*   dac = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>; 
02154     <a class="code" href="classot_1_1DA.html">ot::DA</a>*   daf = damgf-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;  
02155     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o5">dof</a>;
02156     MPI_Comm comm = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>;
02157     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  mc,mf;
02158     <span class="comment">//The size this processor owns ( without ghosts).</span>
02159     mc=dac-&gt;getNodeSize();
02160     mf=daf-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
02161     <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a>* data = <span class="keyword">new</span> <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a>;
02162 
02163     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localCoarseIndSize =  dac-&gt;<a class="code" href="classot_1_1DA.html#z31_12">getIndependentSize</a>();
02164 
02165     <span class="keywordflow">if</span>(dac-&gt;iAmActive()) {
02166       par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;localCoarseIndSize, &amp;(data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o7">minIndependentSize</a>), 1,
02167           MPI_MIN, dac-&gt;getCommActive());
02168     } <span class="keywordflow">else</span> {
02169       data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o7">minIndependentSize</a> = 0;
02170     }
02171 
02172     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o3">dac</a> = dac;
02173     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o4">daf</a> = daf;
02174     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o8">suppressedDOFc</a> = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a>;
02175     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o9">suppressedDOFf</a> = damgf-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a>;
02176     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o2">comm</a> = comm;
02177     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o5">dof</a> = dof;
02178     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o6">fineTouchedFlags</a> = <span class="keyword">new</span> std::vector&lt;ot::FineTouchedStatus&gt;;
02179 
02180     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o10">tmp</a> = NULL;
02181     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o1">addRtmp</a> = NULL;
02182     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o0">addPtmp</a> = NULL;
02183 
02184     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_6">sendSzP</a> = NULL;
02185     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_4">sendOffP</a> = NULL;
02186     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_2">recvSzP</a> = NULL;
02187     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_0">recvOffP</a> = NULL;
02188     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_7">sendSzR</a> = NULL;
02189     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_5">sendOffR</a> = NULL;
02190     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_3">recvSzR</a> = NULL;
02191     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_1">recvOffR</a> = NULL;
02192 
02193     <a class="code" href="omg_8C.html#a0">iC</a>(MatCreateShell(comm, mc*dof ,mf*dof,PETSC_DETERMINE,PETSC_DETERMINE, (<span class="keywordtype">void</span>*)(data), R));  
02194     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT_TRANSPOSE,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a115">prolongMatVecType1</a>));
02195     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a119">restrictMatVecType1</a>));
02196     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT_ADD,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a116">addRestrictMatVec</a>));
02197     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT_TRANSPOSE_ADD,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a113">addProlongMatVec</a>));
02198     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="namespaceot.html#a107">rpMatDestroy</a>));
02199 
02200     <span class="comment">//dummy call to restrict-type-1</span>
02201     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o4">daf</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a> &gt;(*(data-&gt;fineTouchedFlags), <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
02202     <a class="code" href="namespaceot.html#a118">dummyRestrictMatVecType1</a>(data);
02203 
02204     <a class="code" href="omg_8h.html#a23">PROF_MG_CREATE_RP1_END</a>
02205   }
02206 
<a name="l02207"></a><a class="code" href="namespaceot.html#a106">02207</a>   PetscErrorCode  <a class="code" href="namespaceot.html#a106">createInterpolationType2</a>(DAMG damgc, DAMG damgf, Mat *R)      
02208   {
02209     <a class="code" href="omg_8h.html#a24">PROF_MG_CREATE_RP2_BEGIN</a>
02210 
02211       <a class="code" href="classot_1_1DA.html">ot::DA</a>*   dac = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>; 
02212     <a class="code" href="classot_1_1DA.html">ot::DA</a>*   daf = damgf-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;  
02213     <a class="code" href="classot_1_1DA.html">ot::DA</a>*  daf_aux = damgf-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>;
02214     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o5">dof</a>;
02215     MPI_Comm comm = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>;
02216     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  mc,mf;
02217     <span class="comment">//The size this processor owns ( without ghosts).</span>
02218     mc=dac-&gt;getNodeSize();
02219     mf=daf-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
02220     <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a>* data = <span class="keyword">new</span> <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a>;
02221 
02222     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localCoarseIndSize =  dac-&gt;<a class="code" href="classot_1_1DA.html#z31_12">getIndependentSize</a>();
02223 
02224     <span class="keywordflow">if</span>(dac-&gt;iAmActive()) {
02225       par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;localCoarseIndSize, &amp;(data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o7">minIndependentSize</a>), 1,
02226           MPI_MIN, dac-&gt;getCommActive());
02227     } <span class="keywordflow">else</span> {
02228       data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o7">minIndependentSize</a> = 0;
02229     }
02230 
02231     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o3">dac</a> = dac;
02232     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o4">daf</a> = daf_aux;        
02233     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o8">suppressedDOFc</a> = damgc-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o15">suppressedDOF</a>;
02234     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o9">suppressedDOFf</a> = damgf-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o16">suppressedDOFaux</a>;
02235     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o2">comm</a> = comm;
02236     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o5">dof</a> = dof;
02237     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o6">fineTouchedFlags</a> = <span class="keyword">new</span> std::vector&lt;ot::FineTouchedStatus&gt;;
02238     daf_aux-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>(data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o10">tmp</a>, <span class="keyword">false</span>, <span class="keyword">false</span>, dof);
02239     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o1">addRtmp</a> = NULL;
02240     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o0">addPtmp</a> = NULL;
02241 
02242     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_6">sendSzP</a> = NULL;
02243     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_4">sendOffP</a> = NULL;
02244     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_2">recvSzP</a> = NULL;
02245     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_0">recvOffP</a> = NULL;
02246     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_7">sendSzR</a> = NULL;
02247     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_5">sendOffR</a> = NULL;
02248     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_3">recvSzR</a> = NULL;
02249     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#z48_1">recvOffR</a> = NULL;
02250 
02251     <a class="code" href="omg_8C.html#a0">iC</a>(MatCreateShell(comm, mc*dof ,mf*dof,PETSC_DETERMINE,PETSC_DETERMINE, (<span class="keywordtype">void</span>*)(data), R));  
02252     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT_TRANSPOSE,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a114">prolongMatVecType2</a>));
02253     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a117">restrictMatVecType2</a>));
02254     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT_TRANSPOSE_ADD,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a113">addProlongMatVec</a>));
02255     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R,MATOP_MULT_ADD,(<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>))<a class="code" href="namespaceot.html#a116">addRestrictMatVec</a>));
02256     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*R ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="namespaceot.html#a107">rpMatDestroy</a>));
02257 
02258     <span class="comment">//dummy call to restrict-type-1.</span>
02259     <span class="comment">//Note type2 is not called. Since we don't need to scatter values for the</span>
02260     <span class="comment">//dummy loop. In fact, it will be wrong to use scatter values since it will</span>
02261     <span class="comment">//create the scatter contexts the first time it is called.</span>
02262     data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o4">daf</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a> &gt;(*(data-&gt;fineTouchedFlags), <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
02263     <a class="code" href="namespaceot.html#a118">dummyRestrictMatVecType1</a>(data);
02264 
02265     <a class="code" href="omg_8h.html#a25">PROF_MG_CREATE_RP2_END</a>
02266   }
02267 
<a name="l02268"></a><a class="code" href="namespaceot.html#a107">02268</a>   PetscErrorCode  <a class="code" href="namespaceot.html#a107">rpMatDestroy</a>(Mat R) {
02269     <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a> *data;
02270     PetscFunctionBegin;
02271     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext( R, (<span class="keywordtype">void</span> **)&amp;data));
02272     <span class="keywordflow">if</span>(data) {
02273       <span class="keywordflow">if</span>(data-&gt;fineTouchedFlags) { 
02274         data-&gt;fineTouchedFlags-&gt;clear(); 
02275         <span class="keyword">delete</span> data-&gt;fineTouchedFlags;
02276         data-&gt;fineTouchedFlags = NULL;
02277       }
02278       <span class="keywordflow">if</span>(data-&gt;tmp) { 
02279         <a class="code" href="omg_8C.html#a0">iC</a>(VecDestroy(data-&gt;tmp));
02280         data-&gt;tmp = NULL;
02281       }  
02282       <span class="keywordflow">if</span>(data-&gt;addRtmp) {
02283         VecDestroy(data-&gt;addRtmp);
02284         data-&gt;addRtmp = NULL;
02285       }
02286       <span class="keywordflow">if</span>(data-&gt;addPtmp) {
02287         VecDestroy(data-&gt;addPtmp);
02288         data-&gt;addPtmp = NULL;
02289       }
02290       <span class="keywordflow">if</span>(data-&gt;sendSzP) {
02291         <span class="keyword">delete</span> [] data-&gt;sendSzP;
02292         data-&gt;sendSzP = NULL;
02293       }
02294       <span class="keywordflow">if</span>(data-&gt;sendOffP) {
02295         <span class="keyword">delete</span> [] data-&gt;sendOffP;
02296         data-&gt;sendOffP = NULL;
02297       }
02298       <span class="keywordflow">if</span>(data-&gt;recvSzP) {
02299         <span class="keyword">delete</span> [] data-&gt;recvSzP;
02300         data-&gt;recvSzP = NULL;
02301       }
02302       <span class="keywordflow">if</span>(data-&gt;recvOffP) {
02303         <span class="keyword">delete</span> [] data-&gt;recvOffP;
02304         data-&gt;recvOffP = NULL;
02305       }
02306       <span class="keywordflow">if</span>(data-&gt;sendSzR) {
02307         <span class="keyword">delete</span> [] data-&gt;sendSzR;
02308         data-&gt;sendSzR = NULL;
02309       }
02310       <span class="keywordflow">if</span>(data-&gt;sendOffR) {
02311         <span class="keyword">delete</span> [] data-&gt;sendOffR;
02312         data-&gt;sendOffR = NULL;
02313       }
02314       <span class="keywordflow">if</span>(data-&gt;recvSzR) {
02315         <span class="keyword">delete</span> [] data-&gt;recvSzR;
02316         data-&gt;recvSzR = NULL;
02317       }
02318       <span class="keywordflow">if</span>(data-&gt;recvOffR) {
02319         <span class="keyword">delete</span> [] data-&gt;recvOffR;
02320         data-&gt;recvOffR = NULL;
02321       }
02322       <span class="keyword">delete</span> data;
02323       data = NULL;
02324     }
02325 
02326     PetscFunctionReturn(0);
02327   }
02328 
<a name="l02329"></a><a class="code" href="namespaceot.html#a108">02329</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a108">PrintDAMG</a>(DAMG* damg) {
02330     <span class="keywordtype">int</span>  nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
02331     <span class="keywordtype">int</span> rank;
02332     MPI_Comm_rank(damg[0]-&gt;comm,&amp;rank);
02333     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
02334       MPI_Comm activeComm = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
02335       MPI_Comm activeAuxComm;
02336 
02337       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02338         activeAuxComm = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
02339       }
02340 
02341       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> globalBlocksSize;
02342       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> globalBlocksSizeAux;
02343       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> localBlocksSize = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a4">getNumBlocks</a>();
02344       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> localBlocksSizeAux;
02345 
02346       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02347         localBlocksSizeAux = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#a4">getNumBlocks</a>();
02348       }
02349 
02350       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> elemSizeLocal = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_5">getElementSize</a>();
02351       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> ghostedElemSizeLocal = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_6">getGhostedElementSize</a>();
02352       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> elemSizeLocalAux;      
02353       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> ghostedElemSizeLocalAux;       
02354 
02355       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02356         elemSizeLocalAux = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_5">getElementSize</a>();
02357         ghostedElemSizeLocalAux = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_6">getGhostedElementSize</a>();
02358       } 
02359 
02360       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> elemSizeGlobal;
02361       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> minElemSize;
02362       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> maxElemSize;
02363       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> minGhostedElemSize;
02364       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> maxGhostedElemSize;
02365 
02366       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> elemSizeGlobalAux;
02367       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> minElemSizeAux;
02368       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> maxElemSizeAux;
02369       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> minGhostedElemSizeAux;
02370       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> maxGhostedElemSizeAux;
02371 
02372       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
02373         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;localBlocksSize, &amp;globalBlocksSize, 1, 
02374             MPI_SUM, 0, activeComm);
02375 
02376         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;elemSizeLocal, &amp;elemSizeGlobal, 1, 
02377             MPI_SUM, 0, activeComm);
02378 
02379         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;elemSizeLocal, &amp;minElemSize, 1, 
02380             MPI_MIN, 0, activeComm);
02381 
02382         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;elemSizeLocal, &amp;maxElemSize, 1, 
02383             MPI_MAX, 0, activeComm);
02384 
02385         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;ghostedElemSizeLocal, &amp;minGhostedElemSize, 1, 
02386             MPI_MIN, 0, activeComm);
02387 
02388         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;ghostedElemSizeLocal, &amp;maxGhostedElemSize, 1, 
02389             MPI_MAX, 0, activeComm);
02390       }
02391 
02392       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02393         <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
02394           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;localBlocksSizeAux, &amp;globalBlocksSizeAux, 1, 
02395               MPI_SUM, 0, activeAuxComm);
02396 
02397           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;elemSizeLocalAux, &amp;elemSizeGlobalAux, 1, 
02398               MPI_SUM, 0, activeAuxComm);
02399 
02400           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;elemSizeLocalAux, &amp;minElemSizeAux, 1,  
02401               MPI_MIN, 0, activeAuxComm);
02402 
02403           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;elemSizeLocalAux, &amp;maxElemSizeAux, 1, 
02404               MPI_MAX, 0, activeAuxComm);
02405 
02406           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;ghostedElemSizeLocalAux, &amp;minGhostedElemSizeAux, 1, 
02407               MPI_MIN, 0, activeAuxComm);
02408 
02409           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;ghostedElemSizeLocalAux, &amp;maxGhostedElemSizeAux, 1, 
02410               MPI_MAX, 0, activeAuxComm);
02411         }
02412       } 
02413 
02414       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nodeSizeLocal = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
02415       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nodeSizeLocalAux;
02416 
02417       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02418         nodeSizeLocalAux = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
02419       }
02420 
02421       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nodeSizeGlobal;
02422       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> minNodeSize;
02423       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> maxNodeSize;
02424 
02425       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
02426         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;nodeSizeLocal, &amp;nodeSizeGlobal, 1, 
02427             MPI_SUM, 0, activeComm);
02428 
02429         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;nodeSizeLocal, &amp;minNodeSize, 1, 
02430             MPI_MIN, 0, activeComm);
02431 
02432         par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;nodeSizeLocal, &amp;maxNodeSize, 1, 
02433             MPI_MAX, 0, activeComm);
02434       }
02435 
02436       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nodeSizeGlobalAux;
02437       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> minNodeSizeAux;
02438       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> maxNodeSizeAux;
02439 
02440       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02441         <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
02442           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;nodeSizeLocalAux, &amp;nodeSizeGlobalAux, 1, 
02443               MPI_SUM, 0, activeAuxComm);
02444 
02445           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;nodeSizeLocalAux, &amp;minNodeSizeAux, 1, 
02446               MPI_MIN, 0, activeAuxComm);
02447 
02448           par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;nodeSizeLocalAux, &amp;maxNodeSizeAux, 1, 
02449               MPI_MAX, 0, activeAuxComm);
02450         }
02451       }
02452 
02453       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMinLev = <a class="code" href="namespaceot.html#a79">getGlobalMinLevel</a>(damg[i]-&gt;da);
02454       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMaxLev = <a class="code" href="namespaceot.html#a80">getGlobalMaxLevel</a>(damg[i]-&gt;da);
02455 
02456       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMinLevAux;
02457       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {     
02458         globalMinLevAux = <a class="code" href="namespaceot.html#a79">getGlobalMinLevel</a>(damg[i]-&gt;da_aux);
02459       }
02460       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMaxLevAux;
02461       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02462         globalMaxLevAux = <a class="code" href="namespaceot.html#a80">getGlobalMaxLevel</a>(damg[i]-&gt;da_aux);
02463       }
02464 
02465       <span class="keywordtype">int</span> activeNpes = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>();
02466       <span class="keywordtype">int</span> activeNpesAux;
02467       <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02468         activeNpesAux = damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>();
02469       }
02470       <span class="keywordflow">if</span>(!rank) {
02471         std::cout&lt;&lt;<span class="stringliteral">"At Level "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" Elem size: "</span>&lt;&lt;elemSizeGlobal
02472           &lt;&lt;<span class="stringliteral">", GlobalBlocksSize: "</span>&lt;&lt;globalBlocksSize
02473           &lt;&lt;<span class="stringliteral">", node size: "</span>&lt;&lt;nodeSizeGlobal
02474           &lt;&lt;<span class="stringliteral">", minElemSize: "</span>&lt;&lt;minElemSize
02475           &lt;&lt;<span class="stringliteral">", maxElemSize: "</span>&lt;&lt;maxElemSize
02476           &lt;&lt;<span class="stringliteral">", minGhostedElemSize: "</span>&lt;&lt;minGhostedElemSize
02477           &lt;&lt;<span class="stringliteral">", maxGhostedElemSize: "</span>&lt;&lt;maxGhostedElemSize
02478           &lt;&lt;<span class="stringliteral">", minNodeSize: "</span>&lt;&lt;minNodeSize
02479           &lt;&lt;<span class="stringliteral">", maxNodeSize: "</span>&lt;&lt;maxNodeSize
02480           &lt;&lt;<span class="stringliteral">", min Lev: "</span>&lt;&lt;globalMinLev
02481           &lt;&lt;<span class="stringliteral">", max Lev: "</span>&lt;&lt;globalMaxLev
02482           &lt;&lt;<span class="stringliteral">", Active Npes: "</span>&lt;&lt;activeNpes&lt;&lt;std::endl; 
02483         fflush(stdout);
02484         <span class="keywordflow">if</span>(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o4">da_aux</a>) {
02485           std::cout&lt;&lt;<span class="stringliteral">"At AUX Level "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" Elem size: "</span>&lt;&lt;elemSizeGlobalAux
02486             &lt;&lt;<span class="stringliteral">", GlobalBlocksSize: "</span>&lt;&lt;globalBlocksSizeAux
02487             &lt;&lt;<span class="stringliteral">", node size: "</span>&lt;&lt;nodeSizeGlobalAux
02488             &lt;&lt;<span class="stringliteral">", minElemSize: "</span>&lt;&lt;minElemSizeAux
02489             &lt;&lt;<span class="stringliteral">", maxElemSize: "</span>&lt;&lt;maxElemSizeAux
02490             &lt;&lt;<span class="stringliteral">", minGhostedElemSize: "</span>&lt;&lt;minGhostedElemSizeAux
02491             &lt;&lt;<span class="stringliteral">", maxGhostedElemSize: "</span>&lt;&lt;maxGhostedElemSizeAux
02492             &lt;&lt;<span class="stringliteral">", minNodeSize: "</span>&lt;&lt;minNodeSizeAux
02493             &lt;&lt;<span class="stringliteral">", maxNodeSize: "</span>&lt;&lt;maxNodeSizeAux
02494             &lt;&lt;<span class="stringliteral">", min Lev: "</span>&lt;&lt;globalMinLevAux
02495             &lt;&lt;<span class="stringliteral">", max Lev: "</span>&lt;&lt;globalMaxLevAux
02496             &lt;&lt;<span class="stringliteral">", Active Npes: "</span>&lt;&lt;activeNpesAux&lt;&lt;std::endl; 
02497           fflush(stdout);
02498         }
02499       }<span class="comment">//end if p0</span>
02500     }<span class="comment">//end for i</span>
02501   }<span class="comment">//end function</span>
02502 
02503   <span class="comment">//Private Functions...</span>
02504 
<a name="l02505"></a><a class="code" href="namespaceot.html#a109">02505</a>   PetscErrorCode <a class="code" href="namespaceot.html#a109">PC_KSP_Shell_SetUp</a>(<span class="keywordtype">void</span>* ctx) {
02506 
02507     PetscFunctionBegin;
02508 
02509     <a class="code" href="structot_1_1PC__KSP__Shell.html">PC_KSP_Shell</a>* data = static_cast&lt;PC_KSP_Shell*&gt;(ctx); 
02510 
02511     MPI_Comm commActive = data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o0">commActive</a>;
02512     <span class="keywordtype">bool</span> iAmActive = data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o1">iAmActive</a>;
02513 
02514     <span class="comment">//This points to the shell itself</span>
02515     PC pc = data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o3">pc</a>;
02516 
02517     Mat Amat;
02518     PCGetOperators(pc, &amp;Amat, NULL, NULL);      
02519     PetscTruth isshell;
02520     PetscTypeCompare((PetscObject)Amat, MATSHELL, &amp;isshell);
02521 
02522     <span class="keywordflow">if</span>(!isshell) {
02523       SETERRQ(PETSC_ERR_SUP, <span class="stringliteral">" Expected a MATSHELL."</span>);
02524     }
02525 
02526     <span class="comment">//Create ksp_private, rhs_private, sol_private,</span>
02527     <span class="keywordflow">if</span>(iAmActive) {
02528       Mat Amat_private;
02529       Mat Pmat_private;
02530       MatStructure pFlag;
02531 
02532       <span class="keywordflow">if</span>(getPrivateMatricesForKSP_Shell) {
02533         (*getPrivateMatricesForKSP_Shell)(Amat, &amp;Amat_private,
02534             &amp;Pmat_private, &amp;pFlag);
02535       } <span class="keywordflow">else</span> {
02536         SETERRQ(PETSC_ERR_USER,
02537             <span class="stringliteral">" Expected function to be set:\</span>
02538 <span class="stringliteral">            getPrivateMatricesForKSP_Shell"</span>);
02539       }
02540 
02541       <span class="comment">//Sanity Checks</span>
02542       assert(Amat_private != NULL);
02543 
02544       PetscInt globalRowSize;
02545       PetscInt globalColSize;
02546       PetscInt localRowSize;
02547       PetscInt localColSize;
02548 
02549       PetscInt globalRowSizePrivate;
02550       PetscInt globalColSizePrivate;
02551       PetscInt localRowSizePrivate;
02552       PetscInt localColSizePrivate;
02553 
02554       MatGetSize(Amat, &amp;globalRowSize, &amp;globalColSize);
02555       MatGetSize(Amat_private, &amp;globalRowSizePrivate, &amp;globalColSizePrivate);
02556 
02557       MatGetLocalSize(Amat, &amp;localRowSize, &amp;localColSize);
02558       MatGetLocalSize(Amat_private, &amp;localRowSizePrivate, &amp;localColSizePrivate);
02559 
02560       assert(globalRowSize == globalRowSizePrivate);
02561       assert(globalColSize == globalColSizePrivate);
02562 
02563       assert(localRowSize == localRowSizePrivate);
02564       assert(localColSize == localColSizePrivate);
02565 
02566       MPI_Comm privateComm;
02567       PetscObjectGetComm((PetscObject)Amat_private, &amp;privateComm);
02568 
02569       <span class="keywordtype">int</span> commCompareResult;
02570 
02571       <span class="comment">//PetscHeaderCreate_Private duplicates comm</span>
02572       <span class="comment">//instead of a simple copy. So, the comms will not exactly be</span>
02573       <span class="comment">//identical. But, they will be equivalent  </span>
02574       MPI_Comm_compare(privateComm, commActive, &amp;commCompareResult);
02575 
02576       assert( (commCompareResult == MPI_CONGRUENT) || (commCompareResult == MPI_IDENT));
02577 
02578       KSPCreate(commActive, &amp;(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>));
02579 
02580       KSPSetOperators(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>, Amat_private, Pmat_private, pFlag);
02581 
02582       <span class="keyword">const</span> <span class="keywordtype">char</span> *prefix;
02583       PCGetOptionsPrefix(pc, &amp;prefix);
02584 
02585       <span class="comment">//These functions also set the correct prefix for the inner pc </span>
02586       KSPSetOptionsPrefix(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>, prefix);
02587       KSPAppendOptionsPrefix(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>, <span class="stringliteral">"private_"</span>);
02588 
02589       <span class="comment">//Default Types for KSP and PC</span>
02590       KSPSetType(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>, KSPPREONLY);
02591 
02592       PC privatePC;
02593       KSPGetPC(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>, &amp;privatePC);
02594       PCSetType(privatePC, PCLU);
02595 
02596       <span class="comment">//The command line options get higher precedence.</span>
02597       <span class="comment">//This also calls PCSetFromOptions for the private pc internally</span>
02598       KSPSetFromOptions(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>);  
02599 
02600       MatGetVecs(Amat_private, &amp;(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a>), &amp;(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a>));
02601 
02602     } <span class="keywordflow">else</span> {
02603       data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a> = NULL;
02604       data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a> = NULL;
02605       data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a> = NULL;
02606     }<span class="comment">//end if active</span>
02607 
02608     PetscFunctionReturn(0);
02609   }
02610 
<a name="l02611"></a><a class="code" href="namespaceot.html#a110">02611</a>   PetscErrorCode <a class="code" href="namespaceot.html#a110">PC_KSP_Shell_Destroy</a>(<span class="keywordtype">void</span>* ctx) {
02612 
02613     PetscFunctionBegin;
02614 
02615     <a class="code" href="structot_1_1PC__KSP__Shell.html">PC_KSP_Shell</a>* data = static_cast&lt;PC_KSP_Shell*&gt;(ctx); 
02616 
02617     <span class="keywordflow">if</span>(data) {
02618       <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>) {
02619         KSPDestroy(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>);
02620         data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a> = NULL;
02621       }
02622 
02623       <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a>) {
02624         VecDestroy(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a>);
02625         data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a> = NULL;
02626       }
02627 
02628       <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a>) {
02629         VecDestroy(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a>);
02630         data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a> = NULL;
02631       }
02632 
02633       <span class="keyword">delete</span> data;
02634       data = NULL;
02635     }
02636 
02637     PetscFunctionReturn(0);
02638   }
02639 
<a name="l02640"></a><a class="code" href="namespaceot.html#a111">02640</a>   PetscErrorCode <a class="code" href="namespaceot.html#a111">PC_KSP_Shell_Apply</a>(<span class="keywordtype">void</span>* ctx, Vec rhs, Vec sol) {
02641 
02642     PetscFunctionBegin;
02643 
02644     <a class="code" href="structot_1_1PC__KSP__Shell.html">PC_KSP_Shell</a>* data = static_cast&lt;PC_KSP_Shell*&gt;(ctx); 
02645 
02646     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o1">iAmActive</a>) {      
02647       PetscScalar* rhsArray;
02648       PetscScalar* solArray;
02649 
02650       <span class="comment">//There are no copies and no mallocs involved.</span>
02651 
02652       VecGetArray(rhs, &amp;rhsArray);
02653       VecGetArray(sol, &amp;solArray);
02654 
02655       VecPlaceArray(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a>, rhsArray);
02656       VecPlaceArray(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a>, solArray);
02657 
02658       KSPSolve(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o2">ksp_private</a>, data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a>, data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a>);
02659 
02660       VecResetArray(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o4">rhs_private</a>);
02661       VecResetArray(data-&gt;<a class="code" href="structot_1_1PC__KSP__Shell.html#o5">sol_private</a>);
02662 
02663       VecRestoreArray(rhs, &amp;rhsArray);
02664       VecRestoreArray(sol, &amp;solArray);
02665     }
02666 
02667     PetscFunctionReturn(0);
02668   }
02669 
<a name="l02670"></a><a class="code" href="namespaceot.html#a112">02670</a>   <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a19">scatterValues</a>(Vec in, Vec out, PetscInt inSz, PetscInt outSz,
02671       <span class="keywordtype">int</span> *&amp; sendSz, <span class="keywordtype">int</span> *&amp; sendOff, <span class="keywordtype">int</span> *&amp; recvSz, <span class="keywordtype">int</span> *&amp; recvOff, MPI_Comm comm ) {
02672 
02673     <a class="code" href="omg_8h.html#a26">PROF_MG_SCATTER_BEGIN</a> 
02674 
02675       <span class="keywordtype">bool</span> isNew = (sendSz == NULL);
02676 
02677     <span class="keywordflow">if</span>(isNew) {
02678       <span class="keywordtype">int</span> rank, npes;
02679 
02680       MPI_Comm_size(comm, &amp;npes);
02681       MPI_Comm_rank(comm, &amp;rank);
02682 
02683       MPI_Request request;
02684       MPI_Status status;
02685 
02686       PetscInt inSize, outSize; 
02687 
02688       VecGetLocalSize(in, &amp;inSize);
02689       VecGetLocalSize(out, &amp;outSize);
02690 
02691       assert(inSize == inSz);
02692       assert(outSize == outSz);
02693 
02694       PetscInt  off1 = 0, off2 = 0;
02695       PetscInt* scnIn = NULL;
02696       <span class="keywordflow">if</span>(inSz) {
02697         scnIn = <span class="keyword">new</span> PetscInt [inSz]; 
02698       }
02699 
02700       <span class="comment">// perform a local scan first ...</span>
02701       PetscInt zero=0;
02702       <span class="keywordflow">if</span>(inSz) {
02703         scnIn[0] = 1;
02704         <span class="keywordflow">for</span> (PetscInt i = 1; i &lt; inSz; i++) {
02705           scnIn[i] = scnIn[i-1] + 1;
02706         }<span class="comment">//end for</span>
02707         <span class="comment">// now scan with the final members of </span>
02708         par::Mpi_Scan&lt;PetscInt&gt;(scnIn+inSz-1, &amp;off1, 1, MPI_SUM, comm ); 
02709       } <span class="keywordflow">else</span>{
02710         par::Mpi_Scan&lt;PetscInt&gt;(&amp;zero, &amp;off1, 1, MPI_SUM, comm ); 
02711       }
02712 
02713       <span class="comment">// communicate the offsets ...</span>
02714       <span class="keywordflow">if</span> (rank &lt; (npes-1)){
02715         par::Mpi_Issend&lt;PetscInt&gt;( &amp;off1, 1, rank+1, 0, comm, &amp;request );
02716       }
02717       <span class="keywordflow">if</span> (rank){
02718         par::Mpi_Recv&lt;PetscInt&gt;( &amp;off2, 1, rank-1, 0, comm, &amp;status );
02719       } <span class="keywordflow">else</span>{
02720         off2 = 0; 
02721       }
02722 
02723       <span class="comment">// add offset to local array</span>
02724       <span class="keywordflow">for</span> (PetscInt i = 0; i &lt; inSz; i++) {
02725         scnIn[i] = scnIn[i] + off2;  <span class="comment">// This has the global scan results now ...</span>
02726       }<span class="comment">//end for</span>
02727 
02728       <span class="comment">//Gather Scan of outCnts</span>
02729       PetscInt* outCnts;
02730       outCnts = <span class="keyword">new</span> PetscInt[npes];
02731 
02732       <span class="keywordflow">if</span>(rank &lt; (npes-1)) {
02733         MPI_Status statusWait;
02734         MPI_Wait(&amp;request, &amp;statusWait);
02735       }
02736 
02737       <span class="keywordflow">if</span>( outSz ) {
02738         par::Mpi_Scan&lt;PetscInt&gt;( &amp;outSz, &amp;off1, 1, MPI_SUM, comm ); 
02739       }<span class="keywordflow">else</span> {
02740         par::Mpi_Scan&lt;PetscInt&gt;( &amp;zero, &amp;off1, 1, MPI_SUM, comm ); 
02741       }
02742 
02743       par::Mpi_Allgather&lt;PetscInt&gt;( &amp;off1, outCnts, 1, comm);
02744 
02745 <span class="preprocessor">#ifdef __DEBUG_MG__</span>
02746 <span class="preprocessor"></span>      assert(sendSz == NULL);
02747       assert(recvSz == NULL);
02748       assert(sendOff == NULL);
02749       assert(recvOff == NULL);
02750 <span class="preprocessor">#endif</span>
02751 <span class="preprocessor"></span>
02752       sendSz = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
02753       recvSz = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
02754       sendOff = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
02755       recvOff = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
02756 
02757       <span class="comment">// compute the partition offsets and sizes so that All2Allv can be performed.</span>
02758       <span class="comment">// initialize ...</span>
02759       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
02760         sendSz[i] = 0;
02761       }
02762 
02763       <span class="comment">//The Heart of the algorithm....</span>
02764       <span class="comment">//scnIn and outCnts are both sorted </span>
02765       PetscInt inCnt = 0;
02766       <span class="keywordtype">int</span> pCnt = 0;
02767       <span class="keywordflow">while</span>( (inCnt &lt; inSz) &amp;&amp; (pCnt &lt; npes) ) {
02768         <span class="keywordflow">if</span>( scnIn[inCnt] &lt;= outCnts[pCnt]  ) {
02769           sendSz[pCnt]++;
02770           inCnt++;
02771         }<span class="keywordflow">else</span> {
02772           pCnt++;
02773         }
02774       }
02775 
02776       <span class="comment">// communicate with other procs how many you shall be sending and get how</span>
02777       <span class="comment">// many to recieve from whom.</span>
02778       par::Mpi_Alltoall&lt;int&gt;(sendSz, recvSz, 1, comm);
02779 
02780       PetscInt nn=0; <span class="comment">// new value of nlSize, ie the local nodes.</span>
02781       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
02782         nn += recvSz[i];
02783       }
02784 
02785       <span class="comment">// compute offsets ...</span>
02786       sendOff[0] = 0;
02787       recvOff[0] = 0;
02788       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;npes; i++) {
02789         sendOff[i] = sendOff[i-1] + sendSz[i-1];
02790         recvOff[i] = recvOff[i-1] + recvSz[i-1];
02791       }
02792 
02793       assert(nn == outSz);
02794       <span class="comment">// clean up...</span>
02795       <span class="keywordflow">if</span>(scnIn) {
02796         <span class="keyword">delete</span> [] scnIn;
02797       }
02798       <span class="keyword">delete</span> [] outCnts;
02799     }<span class="comment">//end if isNew</span>
02800 
02801     <span class="comment">// perform All2All  ... </span>
02802     PetscScalar * inArr;
02803     PetscScalar * outArr;
02804 
02805     VecGetArray(in,&amp;inArr);
02806     VecGetArray(out,&amp;outArr);
02807 
02808     par::Mpi_Alltoallv_sparse&lt;PetscScalar&gt;(inArr, sendSz, sendOff, 
02809         outArr, recvSz, recvOff, comm);
02810 
02811     VecRestoreArray(in,&amp;inArr);
02812     VecRestoreArray(out,&amp;outArr);
02813 
02814     <a class="code" href="omg_8h.html#a27">PROF_MG_SCATTER_END</a> 
02815   }<span class="comment">//end function</span>
02816 
02817 }<span class="comment">//end namespace</span>
02818 
02819 
02820 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:33 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
