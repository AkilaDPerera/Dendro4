<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/examples/omgJac.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">examples</a></div>
<h1>omgJac.C</h1><a href="omgJac_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "petsc.h"</span>
00008 <span class="preprocessor">#include "petscmat.h"</span>
00009 <span class="preprocessor">#include "petscvec.h"</span>
00010 <span class="preprocessor">#include "<a class="code" href="omg_8h.html">omg.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="omgJac_8h.html">omgJac.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="odaJac_8h.html">odaJac.h</a>"</span>
00014 
00015 
00016 <span class="preprocessor">#ifdef PETSC_USE_LOG</span>
00017 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2MultEvent;
00018 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2DiagEvent;
00019 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2FinestMultEvent;
00020 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2FinestDiagEvent;
00021 
00022 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac3MultEvent;
00023 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac3DiagEvent;
00024 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac3FinestMultEvent;
00025 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac3FinestDiagEvent;
00026 <span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 
00029 <span class="keyword">extern</span> <span class="keywordtype">double</span>***** LaplacianType1Stencil; 
00030 <span class="keyword">extern</span> <span class="keywordtype">double</span>***** MassType1Stencil; 
00031 
00032 <span class="keyword">extern</span> <span class="keywordtype">double</span>**** LaplacianType2Stencil; 
00033 <span class="keyword">extern</span> <span class="keywordtype">double</span>**** MassType2Stencil; 
00034 
<a name="l00035"></a><a class="code" href="omgJac_8h.html#a13">00035</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a14">Jacobian2ShellMatMult</a>(Mat J, Vec in, Vec out) {
00036   PetscFunctionBegin;
00037 
00038   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00039 
00040   MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg));
00041 
00042   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>* ctx = static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user);
00043 
00044   <span class="keywordflow">if</span>(damg-&gt;da-&gt;iAmActive()) {      
00045     PetscScalar* inArray;
00046     PetscScalar* outArray;
00047 
00048     VecGetArray(in, &amp;inArray);
00049     VecGetArray(out, &amp;outArray);
00050 
00051     VecPlaceArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>, inArray);
00052     VecPlaceArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>, outArray);
00053 
00054     MatMult(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>, ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>);
00055 
00056     VecResetArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>);
00057     VecResetArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>);
00058 
00059     VecRestoreArray(in, &amp;inArray);
00060     VecRestoreArray(out, &amp;outArray);
00061   }
00062 
00063   PetscFunctionReturn(0);
00064 }
00065 
<a name="l00066"></a><a class="code" href="omgJac_8h.html#a34">00066</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a34">Jacobian3ShellMatMult</a>(Mat J, Vec in, Vec out) {
00067   PetscFunctionBegin;
00068 
00069   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00070 
00071   MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg));
00072 
00073   <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a>* ctx = static_cast&lt;Jac3MFreeData*&gt;(damg-&gt;user);
00074 
00075   <span class="keywordflow">if</span>(damg-&gt;da-&gt;iAmActive()) {      
00076     PetscScalar* inArray;
00077     PetscScalar* outArray;
00078 
00079     VecGetArray(in, &amp;inArray);
00080     VecGetArray(out, &amp;outArray);
00081 
00082     VecPlaceArray(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a>, inArray);
00083     VecPlaceArray(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a>, outArray);
00084 
00085     MatMult(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>, ctx-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a>, ctx-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a>);
00086 
00087     VecResetArray(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a>);
00088     VecResetArray(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a>);
00089 
00090     VecRestoreArray(in, &amp;inArray);
00091     VecRestoreArray(out, &amp;outArray);
00092   }
00093 
00094   PetscFunctionReturn(0);
00095 }
00096 
<a name="l00097"></a><a class="code" href="omgJac_8h.html#a37">00097</a> <span class="keywordtype">void</span> <a class="code" href="omgJac_8h.html#a37">getActiveStateAndActiveCommForKSP_Shell_Jac1</a>(Mat mat,
00098     <span class="keywordtype">bool</span> &amp; activeState, MPI_Comm &amp; activeComm) {
00099   PetscTruth isshell;
00100   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00101   assert(isshell);
00102   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00103   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;data));
00104   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = data-&gt;da;
00105   activeState = da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>();
00106   activeComm = da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
00107 }
00108 
<a name="l00109"></a><a class="code" href="omgJac_8h.html#a38">00109</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8C.html#a15">getActiveStateAndActiveCommForKSP_Shell_Jac2or3</a>(Mat mat,
00110     <span class="keywordtype">bool</span> &amp; activeState, MPI_Comm &amp; activeComm) {
00111   PetscTruth isshell;
00112   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00113   assert(isshell);
00114   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00115   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;damg));
00116   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;da;
00117   activeState = da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>();
00118   activeComm = da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
00119 }
00120 
<a name="l00121"></a><a class="code" href="omgJac_8h.html#a39">00121</a> <span class="keywordtype">void</span> <a class="code" href="omgJac_8h.html#a39">getPrivateMatricesForKSP_Shell_Jac1</a>(Mat mat,
00122     Mat *AmatPrivate, Mat *PmatPrivate, MatStructure* pFlag) {
00123   PetscTruth isshell;
00124   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00125   assert(isshell);
00126   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a> *data;
00127   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;data));
00128   *AmatPrivate = data-&gt;Jmat_private;
00129   *PmatPrivate = data-&gt;Jmat_private;
00130   *pFlag = DIFFERENT_NONZERO_PATTERN;
00131 }
00132 
<a name="l00133"></a><a class="code" href="omgNeumann_8h.html#a1">00133</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8h.html#a1">getPrivateMatricesForKSP_Shell_Jac2</a>(Mat mat,
00134     Mat *AmatPrivate, Mat *PmatPrivate, MatStructure* pFlag) {
00135   PetscTruth isshell;
00136   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00137   assert(isshell);
00138   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00139   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;damg));
00140   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user));
00141   *AmatPrivate = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00142   *PmatPrivate = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00143   *pFlag = DIFFERENT_NONZERO_PATTERN;
00144 }
00145 
<a name="l00146"></a><a class="code" href="omgJac_8h.html#a41">00146</a> <span class="keywordtype">void</span> <a class="code" href="omgJac_8h.html#a41">getPrivateMatricesForKSP_Shell_Jac3</a>(Mat mat,
00147     Mat *AmatPrivate, Mat *PmatPrivate, MatStructure* pFlag) {
00148   PetscTruth isshell;
00149   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00150   assert(isshell);
00151   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00152   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;damg));
00153   <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a> *data = (static_cast&lt;Jac3MFreeData*&gt;(damg-&gt;user));
00154   *AmatPrivate = data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>;
00155   *PmatPrivate = data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>;
00156   *pFlag = DIFFERENT_NONZERO_PATTERN;
00157 }
00158 
<a name="l00159"></a><a class="code" href="omgJac_8h.html#a9">00159</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a9">CreateAndComputeMassMatrix</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat* jac) {
00160   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00161   PetscFunctionBegin;
00162   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00163   <span class="comment">//The size this processor owns ( without ghosts).</span>
00164   m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00165   <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* data = <span class="keyword">new</span> <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>;
00166   data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a> = da;
00167   data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00168   data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00169   data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00170   <a class="code" href="omg_8C.html#a0">iC</a>(MatCreateShell(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(), m ,n,PETSC_DETERMINE,PETSC_DETERMINE, (<span class="keywordtype">void</span>*)(data), jac));
00171   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a14">MassMatMult</a>));
00172   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a12">MassMatGetDiagonal</a>));
00173   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a10">MassMatDestroy</a>));
00174   PetscFunctionReturn(0);
00175 }
00176 
00177 <span class="comment">/* WRAPPERS FOR JACOBIAN TYPE-1 MATRICES */</span>
<a name="l00178"></a><a class="code" href="omgJac_8h.html#a5">00178</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a5">CreateJacobian1</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Mat *jac) {
00179   PetscFunctionBegin;
00180   PetscInt buildFullCoarseMat;
00181   PetscInt buildFullMatAll;
00182   <span class="keywordtype">int</span> totalLevels;
00183   PetscTruth flg;
00184   PetscOptionsGetInt(PETSC_NULL, <span class="stringliteral">"-buildFullMatAll"</span>, &amp;buildFullMatAll, &amp;flg);
00185   PetscOptionsGetInt(PETSC_NULL, <span class="stringliteral">"-buildFullCoarseMat"</span>, &amp;buildFullCoarseMat, &amp;flg);
00186   <span class="keywordflow">if</span>(buildFullMatAll) {
00187     buildFullCoarseMat = 1;
00188   }
00189   totalLevels = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o17">totalLevels</a>;
00190   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00191   <span class="keywordtype">int</span> myRank;
00192   MPI_Comm_rank(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(), &amp;myRank);
00193   <span class="comment">//The size this processor owns ( without ghosts).</span>
00194   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00195   m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00196   <span class="keywordflow">if</span>(totalLevels == damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>) {
00197     <span class="comment">//This is the coarsest.</span>
00198     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; buildFullCoarseMat ) {
00199       std::cout&lt;&lt;<span class="stringliteral">"Building Full Coarse Mat."</span>&lt;&lt;std::endl;
00200     }
00201     <span class="keywordflow">if</span>(buildFullCoarseMat) {
00202       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00203         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00204       }
00205     }
00206     <span class="keywordtype">bool</span> requirePrivateMats = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>() != da-&gt;<a class="code" href="classot_1_1DA.html#z31_20">getNpesAll</a>());    
00207     <span class="keywordflow">if</span>(requirePrivateMats) {
00208       <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* data = <span class="keyword">new</span> <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>;
00209       data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a> = da;
00210       <span class="keywordflow">if</span>(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a> == 1) {
00211         data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">true</span>;
00212       }<span class="keywordflow">else</span> {
00213         data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">false</span>;
00214       }
00215       <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00216         <span class="keywordflow">if</span>(buildFullCoarseMat) {
00217           <a class="code" href="omgJac_8h.html#a8">CreateAndComputeFullActiveJacobian1</a>(damg, &amp;(data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a>));
00218         } <span class="keywordflow">else</span> {
00219           <a class="code" href="omg_8C.html#a0">iC</a>(MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>(), m ,n,PETSC_DETERMINE,PETSC_DETERMINE,
00220                 (<span class="keywordtype">void</span>*)(data), &amp;(data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a>)));
00221 
00222           <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation( data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a>, MATOP_MULT,
00223                 (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a13">Jacobian1MatMult</a>));
00224 
00225           <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation( data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a>, MATOP_GET_DIAGONAL,
00226                 (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a11">Jacobian1MatGetDiagonal</a>));
00227 
00228           <a class="code" href="omg_8C.html#a0">iC</a>(MatShellSetOperation(data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> ,MATOP_DESTROY,
00229                 (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a9">Jacobian1MatDestroy</a>));
00230         }
00231         MatGetVecs(data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a>, &amp;(data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a>), &amp;(data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a>));
00232       } <span class="keywordflow">else</span> {
00233         data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00234         data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00235         data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00236       }
00237       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE,PETSC_DETERMINE,
00238           (<span class="keywordtype">void</span>*)(data), jac);
00239       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a9">Jacobian1MatDestroy</a>);
00240       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a4">Jacobian1ShellMatMult</a>);
00241     } <span class="keywordflow">else</span> {
00242       <span class="keywordflow">if</span>(buildFullCoarseMat) {
00243         <a class="code" href="omgJac_8h.html#a7">CreateAndComputeFullJacobian1</a>(damg, jac);
00244       } <span class="keywordflow">else</span> {
00245         <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* data = <span class="keyword">new</span> <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>;
00246         data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a> = da;
00247         <span class="keywordflow">if</span>(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a> == 1) {
00248           data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">true</span>;
00249         }<span class="keywordflow">else</span> {
00250           data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">false</span>;
00251         }
00252         data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00253         data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00254         data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00255         MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n,PETSC_DETERMINE,PETSC_DETERMINE,
00256             (<span class="keywordtype">void</span>*)(data), jac);
00257 
00258         MatShellSetOperation(*jac ,MATOP_MULT,
00259             (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a13">Jacobian1MatMult</a>);
00260 
00261         MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL,
00262             (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a11">Jacobian1MatGetDiagonal</a>);
00263 
00264         MatShellSetOperation(*jac ,MATOP_DESTROY,
00265             (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a9">Jacobian1MatDestroy</a>);
00266       }
00267     }
00268     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; buildFullCoarseMat ) {
00269       std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Coarse Mat."</span>&lt;&lt;std::endl;
00270     }
00271   } <span class="keywordflow">else</span> {
00272     <span class="comment">//This is some finer level. So no need for KSP_Shell</span>
00273     <span class="keywordflow">if</span>(buildFullMatAll) {
00274       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00275         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00276       }
00277       <span class="keywordflow">if</span>(!myRank) {
00278         std::cout&lt;&lt;<span class="stringliteral">"Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00279       }
00280       <a class="code" href="omgJac_8h.html#a7">CreateAndComputeFullJacobian1</a>(damg,jac);
00281       <span class="keywordflow">if</span>(!myRank) {
00282         std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00283       }
00284     } <span class="keywordflow">else</span> {
00285       <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>* data = <span class="keyword">new</span> <a class="code" href="structJac1MFreeData.html">Jac1MFreeData</a>;
00286       data-&gt;<a class="code" href="structJac1MFreeData.html#o0">da</a> = da;
00287       <span class="keywordflow">if</span>(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a> == 1) {
00288         data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">true</span>;
00289       }<span class="keywordflow">else</span> {
00290         data-&gt;<a class="code" href="structJac1MFreeData.html#o2">isFinestLevel</a> = <span class="keyword">false</span>;
00291       }
00292       data-&gt;<a class="code" href="structJac1MFreeData.html#o3">Jmat_private</a> = NULL;
00293       data-&gt;<a class="code" href="structJac1MFreeData.html#o1">inTmp</a> = NULL;
00294       data-&gt;<a class="code" href="structJac1MFreeData.html#o4">outTmp</a> = NULL;
00295       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n,PETSC_DETERMINE,PETSC_DETERMINE,
00296           (<span class="keywordtype">void</span>*)(data), jac);
00297       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a13">Jacobian1MatMult</a>);
00298       MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a11">Jacobian1MatGetDiagonal</a>);
00299       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="odaJac_8C.html#a9">Jacobian1MatDestroy</a>);
00300     }    
00301   }
00302 
00303   PetscFunctionReturn(0);
00304 }
00305 
<a name="l00306"></a><a class="code" href="omgJac_8h.html#a7">00306</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a7">CreateAndComputeFullJacobian1</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Mat *mat)
00307 {
00308   PetscFunctionBegin;
00309   <a class="code" href="omgJac_8h.html#a7">CreateAndComputeFullJacobian1</a>(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>, mat);
00310   PetscFunctionReturn(0);
00311 }
00312 
<a name="l00313"></a><a class="code" href="omgJac_8h.html#a8">00313</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a8">CreateAndComputeFullActiveJacobian1</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Mat *mat)
00314 {
00315   PetscFunctionBegin;
00316   <a class="code" href="omgJac_8h.html#a8">CreateAndComputeFullActiveJacobian1</a>(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>, mat);
00317   PetscFunctionReturn(0);
00318 }
00319 
<a name="l00320"></a><a class="code" href="omgJac_8h.html#a6">00320</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a6">ComputeJacobian1</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Mat J, Mat B) {
00321   <span class="comment">//damg not used here. might be used if user defined props exist for each level.</span>
00322   <span class="comment">//Since J and B are the same, only B is built.</span>
00323   PetscFunctionBegin;
00324   <span class="comment">//Nothing to do here</span>
00325   PetscFunctionReturn(0);
00326 }
00327 
<a name="l00328"></a><a class="code" href="omgJac_8h.html#a10">00328</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a21">CreateJacobian2</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat *jac) {
00329   PetscFunctionBegin;
00330   <span class="keywordtype">int</span> totalLevels;
00331   PetscTruth flg;
00332   PetscInt buildFullCoarseMat;
00333   PetscInt buildFullMatAll;
00334   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullMatAll"</span>,&amp;buildFullMatAll,&amp;flg);
00335   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullCoarseMat"</span>,&amp;buildFullCoarseMat,&amp;flg);
00336   <span class="keywordflow">if</span>(buildFullMatAll) {
00337     buildFullCoarseMat = 1;
00338   }
00339   totalLevels = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o17">totalLevels</a>;
00340   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00341   <span class="keywordtype">int</span> myRank;
00342   MPI_Comm_rank(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(),&amp;myRank);
00343   <span class="comment">//The size this processor owns ( without ghosts).</span>
00344   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00345   m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00346   <span class="keywordflow">if</span>(totalLevels == damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>) {
00347     <span class="comment">//This is the coarsest.</span>
00348     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; buildFullCoarseMat ) {
00349       std::cout&lt;&lt;<span class="stringliteral">"Building Full Coarse Mat."</span>&lt;&lt;std::endl;
00350     }
00351     <span class="keywordtype">char</span> matType[30];
00352     <span class="keywordflow">if</span>(buildFullCoarseMat) {
00353       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00354         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00355       }
00356       PetscTruth typeFound;
00357       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00358       <span class="keywordflow">if</span>(!typeFound) {
00359         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00360         assert(<span class="keyword">false</span>);
00361       } 
00362     }
00363     <span class="keywordtype">bool</span> requirePrivateMats = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>() != da-&gt;<a class="code" href="classot_1_1DA.html#z31_20">getNpesAll</a>());    
00364     <span class="keywordflow">if</span>(requirePrivateMats ) {
00365       <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00366       <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00367         <span class="keywordflow">if</span>(buildFullCoarseMat) {
00368           da-&gt;<a class="code" href="classot_1_1DA.html#z35_4">createActiveMatrix</a>(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, matType, 1);
00369         } <span class="keywordflow">else</span> {
00370           MatCreateShell(da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>(), m, n, PETSC_DETERMINE,
00371               PETSC_DETERMINE, damg, &amp;(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>));
00372           MatShellSetOperation(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, MATOP_MULT,
00373               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a28">Jacobian2MatMult</a>);
00374           MatShellSetOperation(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, MATOP_GET_DIAGONAL,
00375               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a27">Jacobian2MatGetDiagonal</a>);
00376           MatShellSetOperation(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, MATOP_DESTROY,
00377               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00378         }
00379         MatGetVecs(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, &amp;(data-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>), &amp;(data-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>));
00380       } <span class="keywordflow">else</span> {
00381         data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a> = NULL;
00382         data-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a> = NULL;
00383         data-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a> = NULL;
00384       }
00385       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00386       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00387       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a13">Jacobian2ShellMatMult</a>);
00388     } <span class="keywordflow">else</span> {
00389       <span class="keywordflow">if</span>(buildFullCoarseMat) {
00390         da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 1);
00391       } <span class="keywordflow">else</span> {
00392         MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00393         MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a28">Jacobian2MatMult</a>);
00394         MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a27">Jacobian2MatGetDiagonal</a>);
00395         MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00396       }
00397     }
00398     <span class="keywordflow">if</span>((!myRank) &amp;&amp; buildFullCoarseMat) {
00399       std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Coarse Mat."</span>&lt;&lt;std::endl;
00400     }
00401   } <span class="keywordflow">else</span> {
00402     <span class="comment">//This is some finer level.</span>
00403     <span class="keywordflow">if</span>(buildFullMatAll) {
00404       <span class="keywordflow">if</span>(!myRank) {
00405         std::cout&lt;&lt;<span class="stringliteral">"Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00406       }
00407       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00408         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00409       }
00410       <span class="keywordtype">char</span> matType[30];
00411       PetscTruth typeFound;
00412       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00413       <span class="keywordflow">if</span>(!typeFound) {
00414         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00415         assert(<span class="keyword">false</span>);
00416       } 
00417       da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 1);
00418       <span class="keywordflow">if</span>(!myRank) {
00419         std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00420       }
00421     } <span class="keywordflow">else</span> {
00422       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00423       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a28">Jacobian2MatMult</a>);
00424       MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a27">Jacobian2MatGetDiagonal</a>);
00425       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00426     }
00427   }
00428 
00429   PetscFunctionReturn(0);
00430 }<span class="comment">//end fn.</span>
00431 
<a name="l00432"></a><a class="code" href="omgJac_8h.html#a15">00432</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a17">Jacobian2MatDestroy</a>(Mat J) {
00433   PetscFunctionBegin;
00434   <span class="comment">//Nothing to be done here. No new pointers were created during creation. </span>
00435   <span class="comment">//The pointer were created in setUSerContext. So they will be destroyed in</span>
00436   <span class="comment">//DestroyUserContexts.</span>
00437   PetscFunctionReturn(0);
00438 }
00439 
<a name="l00440"></a><a class="code" href="omgJac_8C.html#a0">00440</a> <span class="preprocessor">#define JAC_TYPE2_ELEM_DIAG_BLOCK {\</span>
00441 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00442 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00443 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00444 <span class="preprocessor">  double matP1 = matPropArr[2*idx];\</span>
00445 <span class="preprocessor">  double matP2 = matPropArr[2*idx+1];\</span>
00446 <span class="preprocessor">  double fac1 = matP1*h/2.0;\</span>
00447 <span class="preprocessor">  double fac2 = matP2*h*h*h/8.0;\</span>
00448 <span class="preprocessor">  unsigned int indices[8];\</span>
00449 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00450 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00451 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00452 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00453 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00454 <span class="preprocessor">  for(int k = 0; k &lt; 8; k++) {\</span>
00455 <span class="preprocessor">    diagArr[indices[k]] +=  ((fac1*(LaplacianType2Stencil[childNum][elemType][k][k])) +\</span>
00456 <span class="preprocessor">        (fac2*(MassType2Stencil[childNum][elemType][k][k])));\</span>
00457 <span class="preprocessor">  } </span><span class="comment">/*end k*/</span>\
00458 }
00459 
<a name="l00460"></a><a class="code" href="omgJac_8C.html#a1">00460</a> <span class="preprocessor">#define JAC_TYPE2_DIAG_BLOCK {\</span>
00461 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00462 <span class="preprocessor">  iC(VecZeroEntries(diag));\</span>
00463 <span class="preprocessor">  double *matPropArr;\</span>
00464 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghost,Read-only,1 dof*/</span>\
00465   da-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00466   PetscScalar *diagArr;\
00467   <span class="comment">/*Nodal,Non-Ghosted,Write,1 dof*/</span>\
00468   da-&gt;vecGetBuffer(diag,diagArr,false,false,false,1);\
00469   unsigned int maxD;\
00470   double hFac;\
00471   if(da-&gt;iAmActive()) {\
00472     maxD = (da-&gt;getMaxDepth());\
00473     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\
00474     <span class="comment">/*Loop through All Elements including ghosted*/</span>\
00475     for(da-&gt;init&lt;ot::DA_FLAGS::ALL&gt;();\
00476         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::ALL&gt;();\
00477         da-&gt;next&lt;ot::DA_FLAGS::ALL&gt;()) {\
00478       JAC_TYPE2_ELEM_DIAG_BLOCK\
00479     } <span class="comment">/*end i*/</span>\
00480   } <span class="comment">/*end if active*/</span>\
00481   da-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00482   da-&gt;vecRestoreBuffer(diag,diagArr,false,false,false,1);\
00483   PetscLogFlops(44*(da-&gt;getGhostedElementSize()));\
00484 }
00485 
<a name="l00486"></a><a class="code" href="omgJac_8h.html#a14">00486</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a18">Jacobian2MatGetDiagonal</a>(Mat J, Vec diag) {
00487   PetscFunctionBegin;
00488 
00489   PetscLogEventBegin(Jac2DiagEvent,diag,0,0,0);
00490 
00491   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00492   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00493 
00494   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user));
00495 
00496   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00497     PetscLogEventBegin(Jac2FinestDiagEvent,diag,0,0,0);
00498   }
00499 
00500   <a class="code" href="omgJac_8C.html#a1">JAC_TYPE2_DIAG_BLOCK</a> 
00501 
00502     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00503       PetscLogEventEnd(Jac2FinestDiagEvent,diag,0,0,0);
00504     }
00505 
00506   PetscLogEventEnd(Jac2DiagEvent,diag,0,0,0);
00507 
00508   PetscFunctionReturn(0);
00509 }
00510 
<a name="l00511"></a><a class="code" href="omgJac_8C.html#a2">00511</a> <span class="preprocessor">#define JAC_TYPE2_ELEM_MULT_BLOCK {\</span>
00512 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00513 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00514 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00515 <span class="preprocessor">  double matP1 = matPropArr[2*idx];\</span>
00516 <span class="preprocessor">  double matP2 = matPropArr[2*idx+1];\</span>
00517 <span class="preprocessor">  double fac1 = matP1*h/2.0;\</span>
00518 <span class="preprocessor">  double fac2 = matP2*h*h*h/8.0;\</span>
00519 <span class="preprocessor">  unsigned int indices[8];\</span>
00520 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00521 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00522 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00523 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00524 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00525 <span class="preprocessor">  for(int k = 0;k &lt; 8;k++) {\</span>
00526 <span class="preprocessor">    for(int j=0;j&lt;8;j++) {\</span>
00527 <span class="preprocessor">      outArr[indices[k]] +=  (((fac1*(LaplacianType2Stencil[childNum][elemType][k][j])) +\</span>
00528 <span class="preprocessor">            (fac2*(MassType2Stencil[childNum][elemType][k][j])))*inArr[indices[j]]);\</span>
00529 <span class="preprocessor">    }</span><span class="comment">/*end for j*/</span>\
00530   }<span class="comment">/*end for k*/</span>\
00531 }
00532 
<a name="l00533"></a><a class="code" href="omgJac_8C.html#a3">00533</a> <span class="preprocessor">#define JAC_TYPE2_MULT_BLOCK {\</span>
00534 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00535 <span class="preprocessor">  iC(VecZeroEntries(out));\</span>
00536 <span class="preprocessor">  unsigned int maxD;\</span>
00537 <span class="preprocessor">  double hFac;\</span>
00538 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00539 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
00540 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
00541 <span class="preprocessor">  }\</span>
00542 <span class="preprocessor">  double *matPropArr = NULL;\</span>
00543 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghost,Read-only,2 dof*/</span>\
00544   da-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00545   PetscScalar *outArr=NULL;\
00546   PetscScalar *inArr=NULL;\
00547   <span class="comment">/*Nodal,Non-Ghosted,Read,1 dof*/</span>\
00548   da-&gt;vecGetBuffer(in,inArr,false,false,true,1);\
00549   if(da-&gt;iAmActive()) {\
00550     da-&gt;ReadFromGhostsBegin&lt;PetscScalar&gt;(inArr,1);\
00551   }\
00552   <span class="comment">/*Nodal,Non-Ghosted,Write,1 dof*/</span>\
00553   da-&gt;vecGetBuffer(out,outArr,false,false,false,1);\
00554   <span class="comment">/*Loop through All Independent Elements*/</span>\
00555   if(da-&gt;iAmActive()) {\
00556     for(da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00557         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00558         da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;() ) {\
00559       JAC_TYPE2_ELEM_MULT_BLOCK\
00560     } <span class="comment">/*end independent*/</span>\
00561   } <span class="comment">/*end if active*/</span>\
00562   if(da-&gt;iAmActive()) {\
00563     da-&gt;ReadFromGhostsEnd&lt;PetscScalar&gt;(inArr);\
00564   }\
00565   <span class="comment">/*Loop through All Dependent Elements,*/</span>\
00566   <span class="comment">/*i.e. Elements which have atleast one*/</span>\
00567   <span class="comment">/*vertex owned by this processor and at least one*/</span>\
00568   <span class="comment">/*vertex not owned by this processor.*/</span>\
00569   if(da-&gt;iAmActive()) {\
00570     for(da-&gt;init&lt;ot::DA_FLAGS::DEPENDENT&gt;();\
00571         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::DEPENDENT&gt;();\
00572         da-&gt;next&lt;ot::DA_FLAGS::DEPENDENT&gt;() ) {\
00573       JAC_TYPE2_ELEM_MULT_BLOCK\
00574     } <span class="comment">/*end loop for dependent elems*/</span>\
00575   } <span class="comment">/*end if active*/</span>\
00576   da-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00577   da-&gt;vecRestoreBuffer(in,inArr,false,false,true,1);\
00578   da-&gt;vecRestoreBuffer(out,outArr,false,false,false,1);\
00579   PetscLogFlops(332*(da-&gt;getGhostedElementSize()));\
00580 }
00581 
<a name="l00582"></a><a class="code" href="omgJac_8C.html#a4">00582</a> <span class="preprocessor">#define JAC_TYPE2_MULT_DEBUG_BLOCK {\</span>
00583 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00584 <span class="preprocessor">  iC(VecZeroEntries(out));\</span>
00585 <span class="preprocessor">  unsigned int maxD;\</span>
00586 <span class="preprocessor">  double hFac;\</span>
00587 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00588 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
00589 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
00590 <span class="preprocessor">  }\</span>
00591 <span class="preprocessor">  double *matPropArr = NULL;\</span>
00592 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghost,Read-only,2 dof*/</span>\
00593   da-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00594   PetscScalar *outArr=NULL;\
00595   PetscScalar *inArr=NULL;\
00596   <span class="comment">/*Nodal,Non-Ghosted,Read,1 dof*/</span>\
00597   da-&gt;vecGetBuffer(in,inArr,false,false,true,1);\
00598   if(da-&gt;iAmActive()) {\
00599     da-&gt;ReadFromGhostsBegin&lt;PetscScalar&gt;(inArr,1);\
00600     da-&gt;ReadFromGhostsEnd&lt;PetscScalar&gt;(inArr);\
00601   }\
00602   <span class="comment">/*Nodal,Non-Ghosted,Write,1 dof*/</span>\
00603   da-&gt;vecGetBuffer(out,outArr,false,false,false,1);\
00604   if(da-&gt;iAmActive()) {\
00605     for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00606         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00607         da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;() ) {\
00608       JAC_TYPE2_ELEM_MULT_BLOCK\
00609     } <span class="comment">/*end loop */</span>\
00610   } <span class="comment">/*end if active*/</span>\
00611   if(da-&gt;iAmActive()) {\
00612     da-&gt;WriteToGhostsBegin&lt;PetscScalar&gt;(outArr,1);\
00613     da-&gt;WriteToGhostsEnd&lt;PetscScalar&gt;(outArr,1);\
00614   }\
00615   da-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00616   da-&gt;vecRestoreBuffer(in,inArr,false,false,true,1);\
00617   da-&gt;vecRestoreBuffer(out,outArr,false,false,false,1);\
00618   PetscLogFlops(332*(da-&gt;getGhostedElementSize()));\
00619 }
00620 
<a name="l00621"></a><a class="code" href="omgJac_8h.html#a12">00621</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a19">Jacobian2MatMult</a>(Mat J, Vec in, Vec out)
00622 {
00623   PetscFunctionBegin;
00624 
00625   PetscLogEventBegin(Jac2MultEvent,in,out,0,0);
00626 
00627   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00628   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00629 
00630   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user));
00631 
00632   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00633     PetscLogEventBegin(Jac2FinestMultEvent,in,out,0,0);
00634   }
00635 
00636   <a class="code" href="omgJac_8C.html#a3">JAC_TYPE2_MULT_BLOCK</a> 
00637 
00638     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00639       PetscLogEventEnd(Jac2FinestMultEvent,in,out,0,0);
00640     }
00641 
00642   PetscLogEventEnd(Jac2MultEvent,in,out,0,0);
00643 
00644   PetscFunctionReturn(0);
00645 }
00646 
00647 <span class="preprocessor">#undef JAC_TYPE2_MULT_DEBUG_BLOCK </span>
00648 <span class="preprocessor"></span>
<a name="l00649"></a><a class="code" href="omgJac_8C.html#a5">00649</a> <span class="preprocessor">#define BUILD_FULL_JAC_TYPE2_BLOCK(B) {\</span>
00650 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00651 <span class="preprocessor">  MatZeroEntries(B);\</span>
00652 <span class="preprocessor">  std::vector&lt;ot::MatRecord&gt; records;\</span>
00653 <span class="preprocessor">  unsigned int maxD;\</span>
00654 <span class="preprocessor">  double hFac;\</span>
00655 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00656 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
00657 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
00658 <span class="preprocessor">  }\</span>
00659 <span class="preprocessor">  double *matPropArr = NULL;\</span>
00660 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghost,Read-only,2 dof*/</span>\
00661   <span class="comment">/*Note: All the flags are used for describing*/</span>\
00662   <span class="comment">/*the type of input vector, not*/</span>\
00663   <span class="comment">/*the type of the buffer.*/</span>\
00664   da-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00665   if(da-&gt;iAmActive()) {\
00666     for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00667         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00668         da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\
00669       unsigned int idx = da-&gt;curr();\
00670       unsigned int lev = da-&gt;getLevel(idx);\
00671       double h = hFac*(1u &lt;&lt; (maxD - lev));\
00672       double matP1 = matPropArr[2*idx];\
00673       double matP2 = matPropArr[2*idx+1];\
00674       double fac1 = matP1*h/2.0;\
00675       double fac2 = matP2*h*h*h/8.0;\
00676       unsigned int indices[8];\
00677       da-&gt;getNodeIndices(indices);\
00678       unsigned char childNum = da-&gt;getChildNumber();\
00679       unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\
00680       unsigned char elemType = 0;\
00681       GET_ETYPE_BLOCK(elemType,hnMask,childNum)\
00682       for(int k = 0;k &lt; 8;k++) {\
00683         for(int j=0;j&lt;8;j++) {\
00684           ot::MatRecord currRec;\
00685           currRec.rowIdx = indices[k];\
00686           currRec.colIdx = indices[j];\
00687           currRec.rowDim = 0;\
00688           currRec.colDim = 0;\
00689           currRec.val = ((fac1*(LaplacianType2Stencil[childNum][elemType][k][j])) +\
00690               (fac2*(MassType2Stencil[childNum][elemType][k][j])));\
00691           records.push_back(currRec);\
00692         } <span class="comment">/*end for j*/</span>\
00693       } <span class="comment">/*end for k*/</span>\
00694       if(records.size() &gt; 1000) {\
00695         <span class="comment">/*records will be cleared inside the function*/</span>\
00696         da-&gt;setValuesInMatrix(B, records, 1, ADD_VALUES);\
00697       }\
00698     } <span class="comment">/*end writable*/</span>\
00699   } <span class="comment">/*end if active*/</span>\
00700   da-&gt;setValuesInMatrix(B, records, 1, ADD_VALUES);\
00701   MatAssemblyBegin(B, MAT_FINAL_ASSEMBLY);\
00702   da-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00703   MatAssemblyEnd(B, MAT_FINAL_ASSEMBLY);\
00704 }
00705 
<a name="l00706"></a><a class="code" href="omgJac_8h.html#a11">00706</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a20">ComputeJacobian2</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat J, Mat B) {
00707   <span class="comment">//For matShells nothing to be done here.</span>
00708   PetscFunctionBegin;
00709 
00710   PetscTruth isshell;
00711   PetscTypeCompare((PetscObject)B, MATSHELL, &amp;isshell);
00712 
00713   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00714 
00715   assert(B == J);
00716 
00717   <span class="keywordflow">if</span>(isshell) {
00718     <span class="keywordflow">if</span>( data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a> == NULL ) {
00719       PetscFunctionReturn(0);
00720     } <span class="keywordflow">else</span> {
00721       J = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00722       B = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00723     }
00724   }
00725 
00726   <span class="comment">//B and J are the same.</span>
00727 
00728   PetscTypeCompare((PetscObject)B, MATSHELL, &amp;isshell);
00729   <span class="keywordflow">if</span>(isshell) {
00730     <span class="comment">//Nothing to be done here.</span>
00731     PetscFunctionReturn(0);
00732   }
00733 
00734   <a class="code" href="omgJac_8C.html#a5">BUILD_FULL_JAC_TYPE2_BLOCK</a>(B) 
00735 
00736     PetscFunctionReturn(0);
00737 }
00738 
00739 <span class="comment">/*Functions for Jacobian Type 3: Exact Fine grid integration using coarse grid</span>
00740 <span class="comment">** shape functions  */</span>
<a name="l00741"></a><a class="code" href="omgJac_8h.html#a31">00741</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a31">CreateJacobian3</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Mat *jac) {
00742   PetscFunctionBegin;
00743   <span class="keywordtype">int</span> totalLevels;
00744   PetscTruth flg;
00745   PetscInt buildFullMatAll;
00746   PetscInt buildFullCoarseMat;
00747   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullMatAll"</span>,&amp;buildFullMatAll,&amp;flg);
00748   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullCoarseMat"</span>,&amp;buildFullCoarseMat,&amp;flg);
00749   <span class="keywordflow">if</span>(buildFullMatAll) {
00750     buildFullCoarseMat = 1;
00751   }
00752   totalLevels = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>;
00753   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00754   <span class="keywordtype">int</span> myRank;
00755   MPI_Comm_rank(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(), &amp;myRank);
00756   <span class="comment">//The size this processor owns ( without ghosts).</span>
00757   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00758   m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00759   <span class="keywordflow">if</span>(totalLevels == damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>) {
00760     <span class="comment">//This is the coarsest level</span>
00761     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; buildFullCoarseMat ) {
00762       std::cout&lt;&lt;<span class="stringliteral">"Building Full Mat for the coarsest level."</span>&lt;&lt;std::endl;
00763     }
00764     <span class="keywordtype">char</span> matType[30];
00765     <span class="keywordflow">if</span>(buildFullCoarseMat) {
00766       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00767         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00768       }
00769       PetscTruth typeFound;
00770       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00771       <span class="keywordflow">if</span>(!typeFound) {
00772         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00773         assert(<span class="keyword">false</span>);
00774       } 
00775     }
00776     <span class="keywordtype">bool</span> requirePrivateMats = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>() != da-&gt;<a class="code" href="classot_1_1DA.html#z31_20">getNpesAll</a>());    
00777     <span class="keywordflow">if</span>(requirePrivateMats) {
00778       <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a> *data = (static_cast&lt;Jac3MFreeData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00779       <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00780         <span class="keywordflow">if</span>(buildFullCoarseMat) {
00781           da-&gt;<a class="code" href="classot_1_1DA.html#z35_4">createActiveMatrix</a>(data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>, matType, 1);
00782         } <span class="keywordflow">else</span> {
00783           MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>(), m ,n, PETSC_DETERMINE,
00784               PETSC_DETERMINE, damg, &amp;(data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>) );
00785 
00786           MatShellSetOperation(data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a> ,MATOP_MULT,
00787               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a33">Jacobian3MatMult</a>);
00788 
00789           MatShellSetOperation(data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a> ,MATOP_GET_DIAGONAL,
00790               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a32">Jacobian3MatGetDiagonal</a>);
00791 
00792           MatShellSetOperation(data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a> ,MATOP_DESTROY,
00793               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a31">Jacobian3MatDestroy</a>);
00794         }
00795         MatGetVecs(data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>, &amp;(data-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a>), &amp;(data-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a>));
00796       } <span class="keywordflow">else</span> {
00797         data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a> = NULL;
00798         data-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a> = NULL;
00799         data-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a> = NULL;
00800       }
00801       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00802       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a31">Jacobian3MatDestroy</a>);
00803       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a14">Jacobian3ShellMatMult</a>);
00804     } <span class="keywordflow">else</span> {
00805       <span class="keywordflow">if</span>(buildFullCoarseMat) {
00806         da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 1);
00807       } <span class="keywordflow">else</span> {
00808         MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00809         MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a33">Jacobian3MatMult</a>);
00810         MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a32">Jacobian3MatGetDiagonal</a>);
00811         MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a31">Jacobian3MatDestroy</a>);
00812       }
00813     }
00814     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; buildFullCoarseMat ) {
00815       std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Mat for the coarsest level."</span>&lt;&lt;std::endl;
00816     }
00817   } <span class="keywordflow">else</span> {
00818     <span class="comment">//This is some finer level</span>
00819     <span class="keywordflow">if</span>(buildFullMatAll) {
00820       <span class="keywordflow">if</span>(!myRank) {
00821         std::cout&lt;&lt;<span class="stringliteral">"Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00822       }
00823       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00824         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00825       }
00826       <span class="keywordtype">char</span> matType[30];
00827       PetscTruth typeFound;
00828       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00829       <span class="keywordflow">if</span>(!typeFound) {
00830         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00831         assert(<span class="keyword">false</span>);
00832       } 
00833       da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 1);
00834       <span class="keywordflow">if</span>(!myRank) {
00835         std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00836       }
00837     } <span class="keywordflow">else</span> {
00838       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00839       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a33">Jacobian3MatMult</a>);
00840       MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a32">Jacobian3MatGetDiagonal</a>);
00841       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a31">Jacobian3MatDestroy</a>);
00842     }
00843   }
00844 
00845   PetscFunctionReturn(0);
00846 }
00847 
<a name="l00848"></a><a class="code" href="omgJac_8h.html#a36">00848</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a36">Jacobian3MatDestroy</a>(Mat J) {
00849   PetscFunctionBegin;
00850   <span class="comment">//Nothing to be done here. No new pointers were created during creation. </span>
00851   <span class="comment">//The pointer were created in setUSerContext. So they will be destroyed in</span>
00852   <span class="comment">//DestroyUserContexts.</span>
00853   PetscFunctionReturn(0);
00854 }
00855 
<a name="l00856"></a><a class="code" href="omgJac_8C.html#a6">00856</a> <span class="preprocessor">#define JAC_TYPE3_DIAG_BLOCK {\</span>
00857 <span class="preprocessor">  </span><span class="comment">/*The fine loop is always Writable, but the coarse loop*/</span>\
00858   <span class="comment">/*could be Independent or W_Dependent. Hence the fine counter must*/</span>\
00859   <span class="comment">/*be incremented properly to align with the coarse.*/</span>\
00860   Point Cpt = da-&gt;getCurrentOffset();\
00861   while(daf-&gt;getCurrentOffset() != Cpt) {\
00862     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00863   }\
00864   unsigned int idxC= da-&gt;curr();\
00865   unsigned int lev = da-&gt;getLevel(idxC);\
00866   double h = hFac*(1u &lt;&lt; (maxD - lev));\
00867   unsigned int indices[8];\
00868   da-&gt;getNodeIndices(indices);\
00869   unsigned char childNum = da-&gt;getChildNumber();\
00870   unsigned char hnMask = da-&gt;getHangingNodeIndex(idxC);\
00871   unsigned char elemType = 0;\
00872   GET_ETYPE_BLOCK(elemType,hnMask,childNum)\
00873   if(daf-&gt;getLevel(daf-&gt;curr()) == lev) {\
00874     <span class="comment">/*The coarse and fine elements are the same,*/</span>\
00875     type2Cnt++;\
00876     unsigned int idxF = daf-&gt;curr();\
00877     double matP1 = matPropArr[2*idxF];\
00878     double matP2 = matPropArr[2*idxF+1];\
00879     double fac1 = matP1*h/2.0;\
00880     double fac2 = matP2*h*h*h/8.0;\
00881     for(int k = 0; k &lt; 8; k++) {\
00882       diagArr[indices[k]] +=  ((fac1*(LaplacianType2Stencil[childNum][elemType][k][k])) +\
00883           (fac2*(MassType2Stencil[childNum][elemType][k][k])));\
00884     } <span class="comment">/*end k*/</span>\
00885     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00886   }else {\
00887     type1Cnt++;\
00888     for(unsigned int cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
00889       <span class="comment">/*The coarse and fine elements are NOT the same. */</span>\
00890       <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
00891       <span class="comment">/*These are the underlying fine elements.*/</span>\
00892       unsigned int idxF = daf-&gt;curr();\
00893       double matP1 = matPropArr[2*idxF];\
00894       double matP2 = matPropArr[2*idxF+1];\
00895       double fac1 = matP1*h/2.0;\
00896       double fac2 = matP2*h*h*h/8.0;\
00897       for(int k = 0; k &lt; 8; k++) {\
00898         diagArr[indices[k]] += \
00899         ((fac1*(LaplacianType1Stencil[childNum][elemType][cNumFine][k][k])) +\
00900          (fac2*(MassType1Stencil[childNum][elemType][cNumFine][k][k])));\
00901       } <span class="comment">/*end k*/</span>\
00902       daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00903     } <span class="comment">/*end loop over the 8 fine elements*/</span>\
00904   }\
00905 }
00906 
<a name="l00907"></a><a class="code" href="omgJac_8h.html#a35">00907</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a35">Jacobian3MatGetDiagonal</a>(Mat J, Vec diag) {
00908 
00909   PetscFunctionBegin;
00910 
00911   PetscLogEventBegin(Jac3DiagEvent,0,0,0,0);
00912 
00913   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00914   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00915 
00916   <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a> *data = (static_cast&lt;Jac3MFreeData*&gt;(damg-&gt;user));
00917 
00918   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o5">isFinestLevel</a>) {
00919     PetscLogEventBegin(Jac3FinestDiagEvent,0,0,0,0);
00920   }
00921 
00922   <span class="keywordflow">if</span>( (data-&gt;<a class="code" href="structJac3MFreeData.html#o5">isFinestLevel</a>) ||
00923       ( (data-&gt;<a class="code" href="structJac3MFreeData.html#o7">JmatThisLevel</a> != data-&gt;<a class="code" href="structJac3MFreeData.html#o0">BmatThisLevel</a>)
00924         &amp;&amp; (J == data-&gt;<a class="code" href="structJac3MFreeData.html#o0">BmatThisLevel</a>) ) ) {
00925     <a class="code" href="omgJac_8C.html#a1">JAC_TYPE2_DIAG_BLOCK</a> 
00926   }<span class="keywordflow">else</span> {
00927     <span class="comment">//Use the fine grid material properties</span>
00928     <span class="comment">//Loop over the coarse and fine meshes simultaneously</span>
00929     <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;da;
00930     <a class="code" href="classot_1_1DA.html">ot::DA</a>* daf = data-&gt;<a class="code" href="structJac3MFreeData.html#o2">daf</a>;
00931     assert(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>() == daf-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>());
00932     <a class="code" href="omg_8C.html#a0">iC</a>(VecZeroEntries(diag));
00933     <span class="keywordtype">double</span> *matPropArr = NULL;
00934     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o1">changedPartition</a>) {
00935       <span class="comment">/*Elem,Non-Ghost,Read-only,1 dof*/</span>
00936       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,2);
00937     }<span class="keywordflow">else</span> {
00938       <span class="comment">/*Elem,Ghost,Read-only,1 dof*/</span>
00939       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,2);
00940     }
00941     PetscScalar *diagArr = NULL;
00942     <span class="comment">/*Nodal,Non-Ghosted,Write,1 dof*/</span>
00943     da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(diag,diagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00944     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00945     <span class="keywordtype">double</span> hFac;
00946     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type1Cnt = 0; <span class="comment">/*Coarse and Fine are not the same */</span>
00947     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type2Cnt = 0; <span class="comment">/*Coarse and Fine are the same */</span>
00948     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00949       maxD = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>());
00950       hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
00951       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00952           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {
00953         <a class="code" href="omgJac_8C.html#a6">JAC_TYPE3_DIAG_BLOCK</a> 
00954       } <span class="comment">/*end dependent loop*/</span>
00955       da-&gt;<a class="code" href="classot_1_1DA.html#z33_6">WriteToGhostsBegin</a>&lt;PetscScalar&gt;(diagArr, 1);
00956       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00957           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;();  da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {
00958         <a class="code" href="omgJac_8C.html#a6">JAC_TYPE3_DIAG_BLOCK</a> 
00959       } <span class="comment">/*end Independent loop (overlapping with write to ghosts)*/</span>
00960       da-&gt;<a class="code" href="classot_1_1DA.html#z33_7">WriteToGhostsEnd</a>&lt;PetscScalar&gt;(diagArr, 1);
00961     } <span class="comment">/*end if active*/</span>
00962 
00963     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o1">changedPartition</a>) {
00964       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,2);
00965     }<span class="keywordflow">else</span> {
00966       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,2);
00967     }
00968 
00969     da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(diag,diagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00970 
00971     PetscLogFlops( (type1Cnt*336) + (type2Cnt*44) );
00972   }
00973 
00974   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o5">isFinestLevel</a>) {
00975     PetscLogEventEnd(Jac3FinestDiagEvent,0,0,0,0);
00976   }
00977 
00978   PetscLogEventEnd(Jac3DiagEvent,0,0,0,0);
00979 
00980   PetscFunctionReturn(0);
00981 }
00982 
00983 <span class="preprocessor">#undef JAC_TYPE3_DIAG_BLOCK </span>
00984 <span class="preprocessor"></span>
<a name="l00985"></a><a class="code" href="omgJac_8C.html#a7">00985</a> <span class="preprocessor">#define JAC_TYPE3_MULT_BLOCK {\</span>
00986 <span class="preprocessor">  </span><span class="comment">/*The fine loop is always Writable, but the coarse loop*/</span>\
00987   <span class="comment">/*could be Independent or W_Dependent. Hence the fine counter must*/</span>\
00988   <span class="comment">/*be incremented properly to align with the coarse.*/</span>\
00989   Point Cpt = da-&gt;getCurrentOffset();\
00990   while(daf-&gt;getCurrentOffset() != Cpt) {\
00991     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00992   }\
00993   unsigned int idxC= da-&gt;curr();\
00994   unsigned int lev = da-&gt;getLevel(idxC);\
00995   double h = hFac*(1u &lt;&lt; (maxD - lev));\
00996   unsigned int indices[8];\
00997   da-&gt;getNodeIndices(indices);\
00998   unsigned char childNum = da-&gt;getChildNumber();\
00999   unsigned char hnMask = da-&gt;getHangingNodeIndex(idxC);\
01000   unsigned char elemType = 0;\
01001   GET_ETYPE_BLOCK(elemType,hnMask,childNum)\
01002   if(daf-&gt;getLevel(daf-&gt;curr()) == lev) {\
01003     <span class="comment">/*The coarse and fine elements are the same,*/</span>\
01004     type2Cnt++;\
01005     unsigned int idxF = daf-&gt;curr();\
01006     double matP1 = matPropArr[2*idxF];\
01007     double matP2 = matPropArr[2*idxF+1];\
01008     double fac1 = matP1*h/2.0;\
01009     double fac2 = matP2*h*h*h/8.0;\
01010     for(int k = 0; k &lt; 8; k++) {\
01011       for(int j = 0; j &lt; 8; j++) {\
01012         outArr[indices[k]] += (((fac1*(LaplacianType2Stencil[childNum][elemType][k][j])) +\
01013               (fac2*(MassType2Stencil[childNum][elemType][k][j])))*inArr[indices[j]]);\
01014       } <span class="comment">/*end j*/</span>\
01015     } <span class="comment">/*end k*/</span>\
01016     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
01017   }else {\
01018     double matP1[8];\
01019     double matP2[8];\
01020     for(unsigned int cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
01021       <span class="comment">/*The coarse and fine elements are NOT the same. */</span>\
01022       <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
01023       <span class="comment">/*These are the underlying fine elements.*/</span>\
01024       unsigned int idxF = daf-&gt;curr();\
01025       matP1[cNumFine] = matPropArr[2*idxF];\
01026       matP2[cNumFine] = matPropArr[2*idxF+1];\
01027       daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
01028     } <span class="comment">/*end loop over the 8 fine elements*/</span>\
01029     double maxP1 = matP1[0];\
01030     double minP1 = matP1[0];\
01031     double maxP2 = matP2[0];\
01032     double minP2 = matP2[0];\
01033     double totalP1 = 0.0;\
01034     double totalP2 = 0.0;\
01035     for(unsigned int cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
01036       if(matP1[cNumFine] &gt; maxP1) {\
01037         maxP1 = matP1[cNumFine];\
01038       }\
01039       if(matP2[cNumFine] &gt; maxP2) {\
01040         maxP2 = matP2[cNumFine];\
01041       }\
01042       if(matP1[cNumFine] &lt; minP1) {\
01043         minP1 = matP1[cNumFine];\
01044       }\
01045       if(matP2[cNumFine] &lt; minP2) {\
01046         minP2 = matP2[cNumFine];\
01047       }\
01048       totalP1 += matP1[cNumFine];\
01049       totalP2 += matP2[cNumFine];\
01050     }\
01051     <span class="comment">/*If the difference in the material properties is small*/</span>\
01052     <span class="comment">/*use the average value instead*/</span>\
01053     if( ( (maxP1-minP1) &lt;= (tolToCoarsenMatProp*maxP1) )\
01054         &amp;&amp; ( (maxP2-minP2) &lt;= (tolToCoarsenMatProp*maxP2) ) ) {\
01055       type2Cnt++;\
01056       double fac1 = totalP1*h/16.0;\
01057       double fac2 = totalP2*h*h*h/64.0;\
01058       for(int k = 0; k &lt; 8; k++) {\
01059         for(int j = 0; j &lt; 8; j++) {\
01060           outArr[indices[k]] += (((fac1*(LaplacianType2Stencil[childNum][elemType][k][j])) +\
01061                 (fac2*(MassType2Stencil[childNum][elemType][k][j])))*inArr[indices[j]]);\
01062         } <span class="comment">/*end j*/</span>\
01063       } <span class="comment">/*end k*/</span>\
01064     }else {\
01065       type1Cnt++;\
01066       for(unsigned int cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
01067         double fac1 = (matP1[cNumFine])*h/2.0;\
01068         double fac2 = (matP2[cNumFine])*h*h*h/8.0;\
01069         for(int k = 0; k &lt; 8; k++) {\
01070           for(int j = 0; j &lt; 8; j++) {\
01071             outArr[indices[k]] +=\
01072             (((fac1*(LaplacianType1Stencil[childNum][elemType][cNumFine][k][j])) +\
01073               (fac2*(MassType1Stencil[childNum][elemType][cNumFine][k][j])))*inArr[indices[j]]);\
01074           } <span class="comment">/*end j*/</span>\
01075         } <span class="comment">/*end k*/</span>\
01076       } <span class="comment">/*end loop over the 8 fine elements*/</span>\
01077     }\
01078   }\
01079 }
01080 
<a name="l01081"></a><a class="code" href="omgJac_8h.html#a33">01081</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a33">Jacobian3MatMult</a>(Mat J, Vec in, Vec out)
01082 {
01083   PetscFunctionBegin;
01084 
01085   PetscLogEventBegin(Jac3MultEvent,in,out,0,0);
01086 
01087   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
01088   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
01089 
01090   <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a> *data = (static_cast&lt;Jac3MFreeData*&gt;(damg-&gt;user));
01091 
01092   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o5">isFinestLevel</a>) {
01093     PetscLogEventBegin(Jac3FinestMultEvent,in,out,0,0);
01094   }
01095 
01096   <span class="comment">//The finest level and the pcMat for other levels use matProp directly</span>
01097   <span class="comment">//The Jmat for other levels use matPropFine</span>
01098   <span class="comment">//Only the finest and the coarsest grids have Jmat==Bmat</span>
01099   <span class="comment">//For the coarsest grid matPropFine must be used</span>
01100   <span class="keywordflow">if</span>( (data-&gt;<a class="code" href="structJac3MFreeData.html#o5">isFinestLevel</a>) ||
01101       ( (data-&gt;<a class="code" href="structJac3MFreeData.html#o0">BmatThisLevel</a> != data-&gt;<a class="code" href="structJac3MFreeData.html#o7">JmatThisLevel</a>) 
01102         &amp;&amp; (J == data-&gt;<a class="code" href="structJac3MFreeData.html#o0">BmatThisLevel</a>) ) ) {
01103     <a class="code" href="omgJac_8C.html#a3">JAC_TYPE2_MULT_BLOCK</a> 
01104   }<span class="keywordflow">else</span> {
01105     <span class="comment">//Use the fine grid material properties</span>
01106     <span class="comment">//Loop over the coarse and fine meshes simultaneously</span>
01107     PetscReal tolToCoarsenMatProp = 1.0e-12;
01108     PetscTruth optFound;
01109     PetscOptionsGetReal(0,<span class="stringliteral">"-tolToCoarsenMatProp"</span>,&amp;tolToCoarsenMatProp,&amp;optFound);
01110     assert(tolToCoarsenMatProp &gt;= 0.0);
01111 
01112     <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;da;
01113     <a class="code" href="classot_1_1DA.html">ot::DA</a>* daf = data-&gt;<a class="code" href="structJac3MFreeData.html#o2">daf</a>;
01114     assert(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>() == daf-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>());
01115     <span class="keywordtype">double</span> *matPropArr = NULL;
01116     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o1">changedPartition</a>) {
01117       <span class="comment">/*Elem,Non-Ghost,Read-only,1 dof*/</span>
01118       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,2);
01119     }<span class="keywordflow">else</span> {
01120       <span class="comment">/*Elem,Ghost,Read-only,1 dof*/</span>
01121       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,2);
01122     }
01123     PetscScalar *inArr = NULL;
01124     PetscScalar *outArr = NULL;
01125     <span class="comment">/*Nodal,Non-Ghosted,ReadOnly,1 dof*/</span>
01126     da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in, inArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
01127     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
01128       da-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;PetscScalar&gt;(inArr, 1);
01129     }
01130     <a class="code" href="omg_8C.html#a0">iC</a>(VecZeroEntries(out));
01131     <span class="comment">/*Nodal,Non-Ghosted,Write,1 dof*/</span>
01132     da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(out, outArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
01133     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
01134     <span class="keywordtype">double</span> hFac;
01135     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type1Cnt = 0; <span class="comment">/*Coarse and Fine are not the same */</span>
01136     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> type2Cnt = 0; <span class="comment">/*Coarse and Fine are the same */</span>
01137     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
01138       maxD = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>());
01139       hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));
01140       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loopCtr = 0;
01141       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numItersFirstLoop = static_cast&lt;unsigned int&gt;(0.3*static_cast&lt;double&gt;(da-&gt;<a class="code" href="classot_1_1DA.html#z31_5">getElementSize</a>()));
01142       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
01143           ( (daf-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>() == daf-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>()) &amp;&amp; 
01144             (da-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) &amp;&amp; (loopCtr &lt; numItersFirstLoop) );
01145           da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), loopCtr++) {
01146         <a class="code" href="omgJac_8C.html#a7">JAC_TYPE3_MULT_BLOCK</a> 
01147       } <span class="comment">/*end Independent loop (overlapping with read from ghosts)*/</span>
01148     } <span class="comment">/* end if active */</span>
01149     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
01150       da-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;PetscScalar&gt;(inArr);
01151     }
01152     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
01153       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
01154           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {
01155         <a class="code" href="omgJac_8C.html#a7">JAC_TYPE3_MULT_BLOCK</a> 
01156       } <span class="comment">/*end dependent loop*/</span>
01157       da-&gt;<a class="code" href="classot_1_1DA.html#z33_6">WriteToGhostsBegin</a>&lt;PetscScalar&gt;(outArr, 1);
01158       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::FROM_STORED&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::FROM_STORED&gt;();
01159           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {
01160         <a class="code" href="omgJac_8C.html#a7">JAC_TYPE3_MULT_BLOCK</a> 
01161       } <span class="comment">/*end Independent loop (overlapping with write to ghosts)*/</span>
01162       da-&gt;<a class="code" href="classot_1_1DA.html#z33_7">WriteToGhostsEnd</a>&lt;PetscScalar&gt;(outArr, 1);
01163     } <span class="comment">/*end if active*/</span>
01164 
01165     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o1">changedPartition</a>) {
01166       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,2);
01167     }<span class="keywordflow">else</span> {
01168       daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<span class="keywordtype">double</span>&gt;(*(data-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>),matPropArr,<span class="keyword">true</span>,<span class="keyword">true</span>,<span class="keyword">true</span>,2);
01169     }
01170 
01171     da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(out, outArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
01172     da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in, inArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
01173 
01174     PetscLogFlops( (type1Cnt*2643) + (type2Cnt*333) );
01175   }
01176 
01177   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o5">isFinestLevel</a>) {
01178     PetscLogEventEnd(Jac3FinestMultEvent,in,out,0,0);
01179   }
01180   PetscLogEventEnd(Jac3MultEvent,in,out,0,0);
01181 
01182   PetscFunctionReturn(0);
01183 }
01184 
01185 <span class="preprocessor">#undef JAC_TYPE3_MULT_BLOCK </span>
01186 <span class="preprocessor"></span>
<a name="l01187"></a><a class="code" href="omgJac_8C.html#a8">01187</a> <span class="preprocessor">#define BUILD_FULL_JAC_TYPE3_BLOCK(B) {\</span>
01188 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
01189 <span class="preprocessor">  ot::DA* daf = data-&gt;daf;\</span>
01190 <span class="preprocessor">  MatZeroEntries(B);\</span>
01191 <span class="preprocessor">  std::vector&lt;ot::MatRecord&gt; records;\</span>
01192 <span class="preprocessor">  unsigned int maxD;\</span>
01193 <span class="preprocessor">  double hFac;\</span>
01194 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
01195 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
01196 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
01197 <span class="preprocessor">  }\</span>
01198 <span class="preprocessor">  double *matPropArr = NULL;\</span>
01199 <span class="preprocessor">  if(data-&gt;changedPartition) {\</span>
01200 <span class="preprocessor">    </span><span class="comment">/*Elem,Non-Ghosted,Read-only,2 dof*/</span>\
01201     daf-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matPropFine),matPropArr,\
01202         true,false,true,2);\
01203   }else {\
01204     <span class="comment">/*Elem,Ghosted,Read-only,2 dof*/</span>\
01205     daf-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matPropFine),matPropArr,\
01206         true,true,true,2);\
01207   }\
01208   if(da-&gt;iAmActive()) {\
01209     assert(daf-&gt;iAmActive());\
01210     for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;(),\
01211         daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
01212         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();\
01213         da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\
01214       Point Cpt = da-&gt;getCurrentOffset();\
01215       while(daf-&gt;getCurrentOffset() != Cpt) {\
01216         daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
01217       }\
01218       unsigned int idxC = da-&gt;curr();\
01219       unsigned int lev = da-&gt;getLevel(idxC);\
01220       double h = hFac*(1u &lt;&lt; (maxD - lev));\
01221       unsigned int indices[8];\
01222       da-&gt;getNodeIndices(indices);\
01223       unsigned char childNum = da-&gt;getChildNumber();\
01224       unsigned char hnMask = da-&gt;getHangingNodeIndex(idxC);\
01225       unsigned char elemType = 0;\
01226       GET_ETYPE_BLOCK(elemType,hnMask,childNum)\
01227       if(daf-&gt;getLevel(daf-&gt;curr()) == lev) {\
01228         <span class="comment">/*The coarse and fine elements are the same,*/</span>\
01229         unsigned int idxF = daf-&gt;curr();\
01230         double matP1 = matPropArr[2*idxF];\
01231         double matP2 = matPropArr[2*idxF+1];\
01232         double fac1 = matP1*h/2.0;\
01233         double fac2 = matP2*h*h*h/8.0;\
01234         for(int k = 0; k &lt; 8; k++) {\
01235           for(int j = 0; j &lt; 8; j++) {\
01236             ot::MatRecord currRec;\
01237             currRec.rowIdx = indices[k];\
01238             currRec.colIdx = indices[j];\
01239             currRec.rowDim = 0;\
01240             currRec.colDim = 0;\
01241             currRec.val = ((fac1*\
01242                   (LaplacianType2Stencil[childNum][elemType][k][j])) +\
01243                 (fac2*\
01244                  (MassType2Stencil[childNum][elemType][k][j])));\
01245             records.push_back(currRec);\
01246           } <span class="comment">/*end for j*/</span>\
01247         } <span class="comment">/*end for k*/</span>\
01248         daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
01249       }else {\
01250         for(unsigned char cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
01251           <span class="comment">/*The coarse and fine elements are NOT the same. */</span>\
01252           <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
01253           <span class="comment">/*These are the underlying fine elements.*/</span>\
01254           unsigned int idxF = daf-&gt;curr();\
01255           double matP1 = matPropArr[2*idxF];\
01256           double matP2 = matPropArr[2*idxF+1];\
01257           double fac1 = matP1*h/2.0;\
01258           double fac2 = matP2*h*h*h/8.0;\
01259           for(int k = 0; k &lt; 8; k++) {\
01260             for(int j = 0; j &lt; 8; j++) {\
01261               ot::MatRecord currRec;\
01262               currRec.rowIdx = indices[k];\
01263               currRec.colIdx = indices[j];\
01264               currRec.rowDim = 0;\
01265               currRec.colDim = 0;\
01266               currRec.val = ((fac1*(LaplacianType1Stencil\
01267                       [childNum][elemType][cNumFine][k][j]))+\
01268                   (fac2*(MassType1Stencil\
01269                          [childNum][elemType][cNumFine][k][j])));\
01270               records.push_back(currRec);\
01271             } <span class="comment">/*end for j*/</span>\
01272           } <span class="comment">/*end for k*/</span>\
01273           daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
01274         } <span class="comment">/*end loop over the 8 fine elements*/</span>\
01275       }\
01276       if(records.size() &gt; 1000) {\
01277         <span class="comment">/*records will be cleared inside the function*/</span>\
01278         da-&gt;setValuesInMatrix(B, records, 1, ADD_VALUES);\
01279       }\
01280     } <span class="comment">/*end writable*/</span>\
01281   } else {\
01282     assert(!(daf-&gt;iAmActive()));\
01283   } <span class="comment">/*end if active*/</span>\
01284   da-&gt;setValuesInMatrix(B, records, 1, ADD_VALUES);\
01285   MatAssemblyBegin(B, MAT_FINAL_ASSEMBLY);\
01286   if(data-&gt;changedPartition) {\
01287     daf-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matPropFine),matPropArr,\
01288         true,false,true,2);\
01289   }else {\
01290     daf-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matPropFine),matPropArr,\
01291         true,true,true,2);\
01292   }\
01293   MatAssemblyEnd(B, MAT_FINAL_ASSEMBLY);\
01294 }
01295 
<a name="l01296"></a><a class="code" href="omgJac_8h.html#a32">01296</a> PetscErrorCode <a class="code" href="omgJac_8h.html#a32">ComputeJacobian3</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat J, Mat B) {
01297   PetscFunctionBegin;
01298 
01299   <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a> *data = (static_cast&lt;Jac3MFreeData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
01300 
01301   PetscTruth isShellB, isShellJ;
01302   PetscTypeCompare((PetscObject)B, MATSHELL, &amp;isShellB);
01303   PetscTypeCompare((PetscObject)J, MATSHELL, &amp;isShellJ);
01304 
01305   assert(isShellB == isShellJ);
01306 
01307   <span class="comment">//For matShells nothing to be done here.</span>
01308   <span class="keywordflow">if</span>(isShellB) {
01309     <span class="keywordflow">if</span>( data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a> == NULL ) {
01310       <span class="comment">//This will be used to determine the type of matrix in the MatVecs</span>
01311       data-&gt;<a class="code" href="structJac3MFreeData.html#o7">JmatThisLevel</a> = J;
01312       data-&gt;<a class="code" href="structJac3MFreeData.html#o0">BmatThisLevel</a> = B;
01313 
01314       PetscFunctionReturn(0);
01315     } <span class="keywordflow">else</span> {
01316       <span class="comment">//This must be the coarsest level: J and B will be the same</span>
01317       J = data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>;
01318       B = data-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>;
01319     }
01320   }
01321 
01322   <span class="comment">//This will be used to determine the type of matrix in the MatVecs</span>
01323   data-&gt;<a class="code" href="structJac3MFreeData.html#o7">JmatThisLevel</a> = J;
01324   data-&gt;<a class="code" href="structJac3MFreeData.html#o0">BmatThisLevel</a> = B;
01325 
01326   PetscTypeCompare((PetscObject)B, MATSHELL, &amp;isShellB);
01327   PetscTypeCompare((PetscObject)J, MATSHELL, &amp;isShellJ);
01328 
01329   <span class="keywordflow">if</span>(J != B) {
01330     <span class="comment">//Build both B ond J</span>
01331     <span class="comment">//Use matProp for J</span>
01332     <span class="keywordflow">if</span>(!isShellJ) {
01333       <a class="code" href="omgJac_8C.html#a5">BUILD_FULL_JAC_TYPE2_BLOCK</a>(J) 
01334     }
01335     <span class="comment">//Use matPropFine for B</span>
01336     <span class="comment">//Loop over the coarse and fine meshes simultaneously</span>
01337     <span class="keywordflow">if</span>(!isShellB) {
01338       <a class="code" href="omgJac_8C.html#a8">BUILD_FULL_JAC_TYPE3_BLOCK</a>(B) 
01339     }
01340   } <span class="keywordflow">else</span> {
01341     <span class="comment">//Build B only</span>
01342     <span class="keywordflow">if</span>(!isShellB) {
01343       <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac3MFreeData.html#o5">isFinestLevel</a>) {
01344         <span class="comment">//Use matProp</span>
01345         <a class="code" href="omgJac_8C.html#a5">BUILD_FULL_JAC_TYPE2_BLOCK</a>(B) 
01346       } <span class="keywordflow">else</span> {
01347         <span class="comment">//This must be the coarsest grid</span>
01348         <span class="comment">//Use matPropFine</span>
01349         <span class="comment">//Loop over the coarse and fine meshes simultaneously</span>
01350         <a class="code" href="omgJac_8C.html#a8">BUILD_FULL_JAC_TYPE3_BLOCK</a>(B) 
01351       }<span class="comment">//end if finest</span>
01352     }
01353   }<span class="comment">//end if J == B</span>
01354 
01355   PetscFunctionReturn(0);
01356 }
01357 
01358 
01359 <span class="preprocessor">#undef BUILD_FULL_JAC_TYPE2_BLOCK </span>
01360 <span class="preprocessor"></span><span class="preprocessor">#undef BUILD_FULL_JAC_TYPE3_BLOCK </span>
01361 <span class="preprocessor"></span><span class="preprocessor">#undef JAC_TYPE2_MULT_BLOCK </span>
01362 <span class="preprocessor"></span><span class="preprocessor">#undef JAC_TYPE2_DIAG_BLOCK </span>
01363 <span class="preprocessor"></span><span class="preprocessor">#undef JAC_TYPE2_ELEM_DIAG_BLOCK </span>
01364 <span class="preprocessor"></span><span class="preprocessor">#undef JAC_TYPE2_ELEM_MULT_BLOCK </span>
01365 <span class="preprocessor"></span>
01366 
01367 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:24 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
