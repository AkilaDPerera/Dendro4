<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oct/pickBdy.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">oct</a></div>
<h1>pickBdy.C</h1><a href="pickBdy_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00008 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00009 
00010 <span class="preprocessor">#ifdef __DEBUG__</span>
00011 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_OCT__</span>
00012 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_OCT__</span>
00013 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00015 <span class="preprocessor"></span>
00016 <span class="keyword">namespace </span>ot {
00017 
00018   <span class="comment">//Basic idea: Any octant with all possible neighbours inside blocks are</span>
00019   <span class="comment">//considered to be stable. This works on the assumption that the blocks are</span>
00020   <span class="comment">//internally balanced and inter-block boundaries are also balanced. So if all</span>
00021   <span class="comment">//possible neighbours of an octant are inside these blocks, then its entire</span>
00022   <span class="comment">//insulation layer is stable. Although, initially developed for checking</span>
00023   <span class="comment">//unstable inter-processor boundaries only,this idea is also applicable to</span>
00024   <span class="comment">//test stable remote octants in computing sendNodes for stage 2 communication</span>
00025   <span class="comment">//for balancing.</span>
00026   <span class="comment">//Assumptions: Blocks are sorted and unique and linear, nodes is sorted and unique and linear.</span>
00027   <span class="comment">//Every element in nodes is a decendant of or equal to some block.</span>
00028   <span class="comment">//Blocks are complete i.e. there are no gaps in the morton-space covered by</span>
00029   <span class="comment">//the blocks. </span>
00030   <span class="comment">//Some Blocks may be empty.</span>
00031 
<a name="l00032"></a><a class="code" href="pickBdy_8C.html#a0">00032</a> <span class="preprocessor">#define PICK_IPBB_SET_TN_VALUE res.push_back(nodes[nodeCnt]);</span>
00033 <span class="preprocessor"></span>
<a name="l00034"></a><a class="code" href="pickBdy_8C.html#a1">00034</a> <span class="preprocessor">#define PICK_IPBB_SET_UI_VALUE res.push_back(nodeCnt);</span>
00035 <span class="preprocessor"></span>
<a name="l00036"></a><a class="code" href="pickBdy_8C.html#a2">00036</a> <span class="preprocessor">#define PICK_INTER_PROCESSOR_BOUNDARY_BLOCK(SetValueLine) {\</span>
00037 <span class="preprocessor">  res.clear();\</span>
00038 <span class="preprocessor">  unsigned int dim = firstBlock.getDim();\</span>
00039 <span class="preprocessor">  unsigned int maxDepth = firstBlock.getMaxDepth();\</span>
00040 <span class="preprocessor">  ot::TreeNode root(dim, maxDepth);\</span>
00041 <span class="preprocessor">  for(unsigned int nodeCnt = 0; nodeCnt &lt; nodes.size(); nodeCnt++) {\</span>
00042 <span class="preprocessor">    unsigned int myMinX = nodes[nodeCnt].minX();\</span>
00043 <span class="preprocessor">    unsigned int myMinY = nodes[nodeCnt].minY();\</span>
00044 <span class="preprocessor">    unsigned int myMinZ = nodes[nodeCnt].minZ();\</span>
00045 <span class="preprocessor">    unsigned int myMaxX = nodes[nodeCnt].maxX();\</span>
00046 <span class="preprocessor">    unsigned int myMaxY = nodes[nodeCnt].maxY();\</span>
00047 <span class="preprocessor">    unsigned int myMaxZ = nodes[nodeCnt].maxZ();\</span>
00048 <span class="preprocessor">    unsigned int myLen = (myMaxX - myMinX);\</span>
00049 <span class="preprocessor">    unsigned int myLevel = nodes[nodeCnt].getLevel();\</span>
00050 <span class="preprocessor">    unsigned int negX = ((myMinX &gt; 0) ? (myMinX - myLen) : myMinX);\</span>
00051 <span class="preprocessor">    unsigned int negY = ((myMinY &gt; 0) ? (myMinY - myLen) : myMinY);\</span>
00052 <span class="preprocessor">    unsigned int negZ = ((myMinZ &gt; 0) ? (myMinZ - myLen) : myMinZ);\</span>
00053 <span class="preprocessor">    unsigned int posX = ((myMaxX &lt; (1u &lt;&lt; maxDepth)) ? (myMaxX + myLen -1) : (myMaxX-1));\</span>
00054 <span class="preprocessor">    unsigned int posY = ((myMaxY &lt; (1u &lt;&lt; maxDepth)) ? (myMaxY + myLen -1) : (myMaxY-1));\</span>
00055 <span class="preprocessor">    unsigned int posZ = ((myMaxZ &lt; (1u &lt;&lt; maxDepth)) ? (myMaxZ + myLen -1) : (myMaxZ-1));\</span>
00056 <span class="preprocessor">    ot::TreeNode negCorner(negX, negY, negZ, myLevel, dim, maxDepth);\</span>
00057 <span class="preprocessor">    ot::TreeNode posCorner(posX, posY, posZ, maxDepth, dim, maxDepth);\</span>
00058 <span class="preprocessor">    bool add = true;\</span>
00059 <span class="preprocessor">    if( (negCorner &gt;= firstBlock) &amp;&amp; (posCorner &lt;= lastBlock.getDLD()) ) {\</span>
00060 <span class="preprocessor">      add = false;\</span>
00061 <span class="preprocessor">    }\</span>
00062 <span class="preprocessor">    if (add) {\</span>
00063 <span class="preprocessor">      SetValueLine\</span>
00064 <span class="preprocessor">    }\</span>
00065 <span class="preprocessor">  }\</span>
00066 <span class="preprocessor">  return 1;\</span>
00067 <span class="preprocessor">}</span>
00068 <span class="preprocessor"></span>
00069 <span class="comment">//New Implementation</span>
00070 
<a name="l00071"></a><a class="code" href="namespaceot.html#a65">00071</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a66">pickInterProcessorBoundaryNodes</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt; &amp; nodes,
00072     std::vector&lt;unsigned int&gt; &amp; res, <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> &amp; firstBlock,
00073     <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> &amp; lastBlock) {
00074   <a class="code" href="octUtils_8h.html#a30">PROF_PICK_BND_BEGIN</a>
00075 
00076   <a class="code" href="pickBdy_8C.html#a2">PICK_INTER_PROCESSOR_BOUNDARY_BLOCK</a>(<a class="code" href="pickBdy_8C.html#a1">PICK_IPBB_SET_UI_VALUE</a>)
00077 
00078   <a class="code" href="octUtils_8h.html#a69">PROF_PICK_BND_END</a>
00079 }
00080 
<a name="l00081"></a><a class="code" href="namespaceot.html#a66">00081</a> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a66">pickInterProcessorBoundaryNodes</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt; &amp; nodes,
00082     std::vector&lt;ot::TreeNode&gt; &amp; res, <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> &amp; firstBlock,
00083     <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> &amp; lastBlock) {
00084   <a class="code" href="octUtils_8h.html#a30">PROF_PICK_BND_BEGIN</a>
00085 
00086   <a class="code" href="pickBdy_8C.html#a2">PICK_INTER_PROCESSOR_BOUNDARY_BLOCK</a>(<a class="code" href="pickBdy_8C.html#a0">PICK_IPBB_SET_TN_VALUE</a>)
00087   
00088   <a class="code" href="octUtils_8h.html#a69">PROF_PICK_BND_END</a>
00089 }
00090 
00091 
00092 <span class="comment">/*</span>
00093 <span class="comment">#define PICK_INTER_PROCESSOR_BOUNDARY_BLOCK(SetValueLine) {\</span>
00094 <span class="comment">TreeNode root(dim,maxDepth);\</span>
00095 <span class="comment">res.clear();\</span>
00096 <span class="comment">unsigned int nodeCnt = 0;\</span>
00097 <span class="comment">unsigned int blkCnt = 0;\</span>
00098 <span class="comment">while ( ( blkCnt &lt; blocks.size() ) &amp;&amp; (  nodeCnt &lt; nodes.size() )  ) {\</span>
00099 <span class="comment">if ( blocks[blkCnt] &lt;= nodes[nodeCnt] ) {\</span>
00100 <span class="comment">*/</span><span class="comment">/*Check if Ancestor*/</span><span class="comment">/* \        </span>
00101 <span class="comment">if ( blocks[blkCnt].isAncestor(nodes[nodeCnt]) ) {\</span>
00102 <span class="comment">  */</span><span class="comment">/*Check if this node touches the internal boundary of the block.*/</span><span class="comment">/* \</span>
00103 <span class="comment">    unsigned int myMinX = nodes[nodeCnt].minX();\</span>
00104 <span class="comment">    unsigned int myMinY = nodes[nodeCnt].minY();\</span>
00105 <span class="comment">    unsigned int myMinZ = nodes[nodeCnt].minZ();\</span>
00106 <span class="comment">    unsigned int myMaxX = nodes[nodeCnt].maxX();\</span>
00107 <span class="comment">    unsigned int myMaxY = nodes[nodeCnt].maxY();\</span>
00108 <span class="comment">    unsigned int myMaxZ = nodes[nodeCnt].maxZ();\</span>
00109 <span class="comment">    unsigned int bMinX = blocks[blkCnt].minX();\</span>
00110 <span class="comment">    unsigned int bMinY = blocks[blkCnt].minY();\</span>
00111 <span class="comment">    unsigned int bMinZ = blocks[blkCnt].minZ();\</span>
00112 <span class="comment">    unsigned int bMaxX = blocks[blkCnt].maxX();\</span>
00113 <span class="comment">    unsigned int bMaxY = blocks[blkCnt].maxY();\</span>
00114 <span class="comment">    unsigned int bMaxZ = blocks[blkCnt].maxZ();\</span>
00115 <span class="comment">    if ( (myMinX == bMinX) || (myMinY == bMinY) || (myMinZ == bMinZ) ||\</span>
00116 <span class="comment">        (myMaxX == bMaxX) || (myMaxY == bMaxY) || (myMaxZ == bMaxZ) ) {\</span>
00117 <span class="comment">      */</span><span class="comment">/*node touches the boundary of this block from the inside*/</span><span class="comment">/* \</span>
00118 <span class="comment">        std::vector&lt;TreeNode&gt; nh = nodes[nodeCnt].getAllNeighbours();\</span>
00119 <span class="comment">        par::makeVectorUnique&lt;ot::TreeNode&gt;(nh, false);\</span>
00120 <span class="comment">        unsigned int st = 0;\</span>
00121 <span class="comment">        if (nh[0] == root) {\</span>
00122 <span class="comment">          st = 1;\</span>
00123 <span class="comment">        }\</span>
00124 <span class="comment">      bool add = true;\</span>
00125 <span class="comment">        */</span><span class="comment">/*An indirect and cheap way to assert existence*/</span><span class="comment">/* \</span>
00126 <span class="comment">        */</span><span class="comment">/*of an ancestor is to*/</span><span class="comment">/* \</span>
00127 <span class="comment">        */</span><span class="comment">/*compare nh with the span of the domain owned by this processor</span>
00128 <span class="comment">        */</span><span class="comment">/* \</span>
00129 <span class="comment">        */</span><span class="comment">/*Note the second condition. You must compare the DLDs on both</span>
00130 <span class="comment">        sides.*/</span><span class="comment">/*\</span>
00131 <span class="comment">        */</span><span class="comment">/* Just comparing reducedNh with last block or last block's DLD is</span>
00132 <span class="comment">        not enough*/</span><span class="comment">/*\</span>
00133 <span class="comment">        */</span><span class="comment">/* This is because, the last block could be a decendant of</span>
00134 <span class="comment">        reducedNh*/</span><span class="comment">/*\</span>
00135 <span class="comment">        if(st &lt; nh.size()) {\</span>
00136 <span class="comment">          if( (nh[st] &gt;= blocks[0]) &amp;&amp;\</span>
00137 <span class="comment">              ((nh[nh.size()-1].getDLD())\</span>
00138 <span class="comment">               &lt;= (blocks[blocks.size()-1].getDLD())) ) {\</span>
00139 <span class="comment">            add = false;\</span>
00140 <span class="comment">          }\</span>
00141 <span class="comment">        } else {\</span>
00142 <span class="comment">          add = false;\</span>
00143 <span class="comment">        }\</span>
00144 <span class="comment">      if (add) {\</span>
00145 <span class="comment">        SetValueLine\</span>
00146 <span class="comment">      }\</span>
00147 <span class="comment">    }\</span>
00148 <span class="comment">  */</span><span class="comment">/*There could be more nodes that are decendants of the same</span>
00149 <span class="comment">    block.*/</span><span class="comment">/* \</span>
00150 <span class="comment">    nodeCnt++;\</span>
00151 <span class="comment">} else if ( blocks[blkCnt] == nodes[nodeCnt] ) {\</span>
00152 <span class="comment">  std::vector&lt;TreeNode&gt; nh = nodes[nodeCnt].getAllNeighbours();\</span>
00153 <span class="comment">    par::makeVectorUnique&lt;TreeNode&gt;(nh,false);\</span>
00154 <span class="comment">    unsigned int st = 0;\</span>
00155 <span class="comment">    if (nh[0] == root) {\</span>
00156 <span class="comment">      st = 1;\</span>
00157 <span class="comment">    }\</span>
00158 <span class="comment">  bool add = true;\</span>
00159 <span class="comment">    */</span><span class="comment">/*An indirect and cheap way to assert existence*/</span><span class="comment">/* \</span>
00160 <span class="comment">    */</span><span class="comment">/*of an ancestor is to*/</span><span class="comment">/* \</span>
00161 <span class="comment">    */</span><span class="comment">/*compare nh with the span of the domain owned by this processor */</span><span class="comment">/* \</span>
00162 <span class="comment">    if(st &lt; nh.size()) {\</span>
00163 <span class="comment">      if( (nh[st] &gt;= blocks[0]) &amp;&amp;\</span>
00164 <span class="comment">          ((nh[nh.size()-1].getDLD())\</span>
00165 <span class="comment">           &lt;= (blocks[blocks.size()-1].getDLD())) ) {\</span>
00166 <span class="comment">        add = false;\</span>
00167 <span class="comment">      }\</span>
00168 <span class="comment">    } else {\</span>
00169 <span class="comment">      add = false;\</span>
00170 <span class="comment">    }\</span>
00171 <span class="comment">  if (add) {\</span>
00172 <span class="comment">    SetValueLine\</span>
00173 <span class="comment">  }\</span>
00174 <span class="comment">  blkCnt++;\</span>
00175 <span class="comment">} else {\</span>
00176 <span class="comment">  */</span><span class="comment">/*Neither Ancestor nor equal.*/</span><span class="comment">/* \</span>
00177 <span class="comment">    blkCnt++;\</span>
00178 <span class="comment">}\</span>
00179 <span class="comment">  } else {\</span>
00180 <span class="comment">    */</span><span class="comment">/*Block can't be an Ancestor of the node.*/</span><span class="comment">/* \</span>
00181 <span class="comment">      nodeCnt++;\</span>
00182 <span class="comment">  }\</span>
00183 <span class="comment">  }\</span>
00184 <span class="comment">  return 1;\</span>
00185 <span class="comment">  }</span>
00186 <span class="comment">*/</span>
00187 
00188 <span class="comment">/*</span>
00189 <span class="comment">//Old Implementation</span>
00190 <span class="comment">int pickInterProcessorBoundaryNodes(const std::vector&lt;ot::TreeNode&gt; &amp; blocks, </span>
00191 <span class="comment">const std::vector&lt;ot::TreeNode&gt; &amp;nodes, </span>
00192 <span class="comment">std::vector&lt;unsigned int &gt;&amp; res, </span>
00193 <span class="comment">unsigned int dim, unsigned int maxDepth) {</span>
00194 <span class="comment">PICK_INTER_PROCESSOR_BOUNDARY_BLOCK(PICK_IPBB_SET_UI_VALUE)</span>
00195 <span class="comment">} // end pickboundary</span>
00196 <span class="comment"></span>
00197 <span class="comment">int pickInterProcessorBoundaryNodes(const std::vector&lt;ot::TreeNode&gt; &amp; blocks, </span>
00198 <span class="comment">const std::vector&lt;ot::TreeNode&gt; &amp;nodes, </span>
00199 <span class="comment">std::vector&lt;ot::TreeNode&gt;&amp; res, </span>
00200 <span class="comment">unsigned int dim, unsigned int maxDepth) {</span>
00201 <span class="comment">PICK_INTER_PROCESSOR_BOUNDARY_BLOCK(PICK_IPBB_SET_TN_VALUE)</span>
00202 <span class="comment">} // end pickboundary</span>
00203 <span class="comment">*/</span>
00204 
00205 <span class="preprocessor">#undef PICK_IPBB_SET_TN_VALUE </span>
00206 <span class="preprocessor"></span><span class="preprocessor">#undef PICK_IPBB_SET_UI_VALUE </span>
00207 <span class="preprocessor"></span><span class="preprocessor">#undef PICK_INTER_PROCESSOR_BOUNDARY_BLOCK</span>
00208 <span class="preprocessor"></span>
00209 
00210 <span class="comment">// Oldest Implementation ...  </span>
00211 <span class="comment">/*</span>
00212 <span class="comment">   int pickInterProcessorBoundaryNodes(const std::vector&lt;ot::TreeNode&gt; &amp; blocks, const std::vector&lt;ot::TreeNode&gt; &amp;nodes, std::vector&lt;ot::TreeNode&gt;&amp; res, unsigned int dim, unsigned int maxDepth){</span>
00213 <span class="comment">   TreeNode root(dim,maxDepth);</span>
00214 <span class="comment">   unsigned int resLen=0;</span>
00215 <span class="comment">   res.resize(nodes.size());</span>
00216 <span class="comment">   for(unsigned int i=0;i&lt;nodes.size();i++) {</span>
00217 <span class="comment">//A node is considered stable only if it is stable in all directions.</span>
00218 <span class="comment">std::vector&lt;TreeNode&gt; nh = nodes[i].getAllNeighbours();</span>
00219 <span class="comment">bool add=false;</span>
00220 <span class="comment">for(unsigned int k=0;k&lt;nh.size();k++) {</span>
00221 <span class="comment">if(nh[k]==root){</span>
00222 <span class="comment">//Stable from this direction </span>
00223 <span class="comment">continue;</span>
00224 <span class="comment">}</span>
00225 <span class="comment">bool foundAnc = false;</span>
00226 <span class="comment">for(unsigned int j=0;j&lt;blocks.size();j++) {</span>
00227 <span class="comment">if((blocks[j] == nh[k]) || (blocks[j].isAncestor(nh[k]))){</span>
00228 <span class="comment">foundAnc=true;</span>
00229 <span class="comment">break;</span>
00230 <span class="comment">}</span>
00231 <span class="comment">}//end for j</span>
00232 <span class="comment">if(!foundAnc) {</span>
00233 <span class="comment">//Unstable from this direction </span>
00234 <span class="comment">add=true;</span>
00235 <span class="comment">break;</span>
00236 <span class="comment">}</span>
00237 <span class="comment">}//end for k</span>
00238 <span class="comment">if(add){</span>
00239 <span class="comment">res[resLen] = nodes[i];</span>
00240 <span class="comment">resLen++;</span>
00241 <span class="comment">}</span>
00242 <span class="comment">}//end for i</span>
00243 <span class="comment">res.resize(resLen);</span>
00244 <span class="comment">return 1;</span>
00245 <span class="comment">}//end function</span>
00246 <span class="comment">*/</span>
00247 
00248 }<span class="comment">//end namespace</span>
00249 
00250 
00251 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:31 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
