<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oda/private/odaBuildNlist.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000016.html">oda</a>&nbsp;/&nbsp;<a class="el" href="dir_000017.html">private</a></div>
<h1>odaBuildNlist.C</h1><a href="odaBuildNlist_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00009 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="colors_8h.html">colors.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="nodeAndRanks_8h.html">nodeAndRanks.h</a>"</span>
00014 <span class="preprocessor">#include "<a class="code" href="testUtils_8h.html">testUtils.h</a>"</span>
00015 
00016 <span class="preprocessor">#ifdef __DEBUG__</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA_NLIST__</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA_NLIST__</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span>
00022 <span class="preprocessor">#ifdef __DEBUG_DA__</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA_NLIST__</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA_NLIST__</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00027 <span class="preprocessor"></span>
00028 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00029 <span class="preprocessor"></span><span class="preprocessor">#ifndef __MEASURE_BUILD_NLIST__</span>
00030 <span class="preprocessor"></span><span class="preprocessor">#define __MEASURE_BUILD_NLIST__</span>
00031 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00033 <span class="preprocessor"></span>
00034 <span class="comment">//Warning: DO NOT MEDDLE WITH THIS PIECE OF CODE!!!</span>
00035 
00036 <span class="keyword">namespace </span>ot {
00037 
<a name="l00038"></a><a class="code" href="odaBuildNlist_8C.html#a0">00038</a> <span class="preprocessor">#define CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult) { \</span>
00039 <span class="preprocessor">  unsigned int tmpMlbIdx;\</span>
00040 <span class="preprocessor">  bool tmpMlbResult;\</span>
00041 <span class="preprocessor">  tmpMlbResult = seq::maxLowerBound&lt;ot::TreeNode&gt; (arr, key, tmpMlbIdx,NULL,NULL);\</span>
00042 <span class="preprocessor">  assert(tmpMlbResult == fastResult);\</span>
00043 <span class="preprocessor">  assert(tmpMlbIdx == fastIdx);\</span>
00044 <span class="preprocessor">}</span>
00045 <span class="preprocessor"></span>
00046 <span class="comment">//New Build Node list using 4-way searches...</span>
<a name="l00047"></a><a class="code" href="classot_1_1DA.html#b0">00047</a> <span class="keywordtype">void</span> DA::buildNodeList(std::vector&lt;ot::TreeNode&gt; &amp;in) {
00048 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00049 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00050 <span class="preprocessor">#endif</span>
00051 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#a21">PROF_BUILD_NLIST_BEGIN</a>
00052     <span class="comment">// everybody except for the boundary and positive ghosts should be elements,</span>
00053     <span class="comment">// This means that anything that is not a boundary should be an element.</span>
00054     <span class="comment">// The only extra elements added are the ghost elements.</span>
00055     <span class="comment">// Initially will store all 8 indices. will not be compressed.</span>
00056 
00057     <span class="comment">// compute number of elements.</span>
00058     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nelem = <a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a> + m_uiElementSize;
00059 
00060   std::vector&lt;unsigned int&gt; nlist;
00061 
00062   <span class="comment">/*</span>
00063 <span class="comment">     The first iteration is for pre-ghosts only.</span>
00064 <span class="comment">     The second iteration is for own elements. </span>
00065 <span class="comment">     The first iteration does not use 4-way searches. The second iteration does.</span>
00066 <span class="comment">     */</span>
00067   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numFullLoopCtr = 0; numFullLoopCtr &lt; 2; numFullLoopCtr++) {
00068 
00069     <span class="comment">// Some storage ...</span>
00070     std::vector&lt;ot::TreeNode&gt; primaryKeys;
00071     std::vector&lt;ot::TreeNode&gt; secondaryKeys;
00072     std::vector&lt;ot::TreeNode&gt; extraAtEnd;
00073 
00074 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00075 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00076     std::vector&lt;ot:: TreeNode &gt; checkSecondRing;
00077     std::vector&lt;ot::TreeNode&gt; chkMissedPrimary;
00078 <span class="preprocessor">#endif</span>
00079 <span class="preprocessor"></span>
00080     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iLoopSt,iLoopEnd;
00081     <span class="keywordflow">if</span>( numFullLoopCtr == 0) {
00082       <span class="comment">//PreGhosts only...</span>
00083       iLoopSt = 0;
00084       iLoopEnd = m_uiPreGhostElementSize;
00085     }<span class="keywordflow">else</span> {
00086       <span class="comment">//nelem and m_uiPreGhostElementSize would have been changed in the</span>
00087       <span class="comment">//first iteration. It's ok. Use the new values only.</span>
00088       <span class="comment">//Own elements only...</span>
00089       iLoopSt = m_uiPreGhostElementSize;
00090       iLoopEnd = nelem;
00091     }
00092 
00093 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00094 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00095     <span class="keywordflow">if</span>(!m_iRankActive) {
00096       std::cout&lt;&lt;<span class="stringliteral">"numFullLoopCtr: "</span>&lt;&lt;numFullLoopCtr&lt;&lt;std::endl;
00097     }
00098     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">": preElemSz: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a>
00099       &lt;&lt;<span class="stringliteral">" elemBeg: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>&lt;&lt;<span class="stringliteral">" elemEnd: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>
00100       &lt;&lt;<span class="stringliteral">" postGhostBegin: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>
00101       &lt;&lt;<span class="stringliteral">" locBufferSz: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a>
00102       &lt;&lt;<span class="stringliteral">" nelem: "</span>&lt;&lt;nelem
00103       &lt;&lt;<span class="stringliteral">" iLoopSt: "</span>&lt;&lt;iLoopSt
00104       &lt;&lt;<span class="stringliteral">" iLoopEnd: "</span>&lt;&lt;iLoopEnd&lt;&lt;std::endl;
00105     <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> &lt; m_uiPostGhostBegin) {
00106       std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" my First Octant(elem/Bnd): "</span>&lt;&lt;in[m_uiElementBegin]&lt;&lt;std::endl;
00107     }
00108     MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00109 <span class="preprocessor">#endif</span>
00110 <span class="preprocessor"></span>
00111 
00112     <span class="comment">//Malloc...</span>
00113     <span class="comment">//In the first iteration, we need to only allocate for pre-ghosts.</span>
00114     <span class="comment">//The second iteration, it would already be resized to the correct size.</span>
00115     <span class="comment">//So there would be no change.</span>
00116     <span class="keywordflow">if</span>( numFullLoopCtr == 0) {
00117       nlist.resize(8*iLoopEnd);
00118       <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>.resize(2*iLoopEnd);
00119     }
00120 
00121     <span class="comment">//Loop through all the elements in this set and set LUTs.</span>
00122     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = iLoopSt; i &lt; iLoopEnd; i++) {
00123 
00124       <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i + 1] = 0;
00125 
00126       std::vector&lt;ot::TreeNode&gt; nodeLocations(8);
00127       std::vector&lt;ot::TreeNode&gt; parNodeLocations(8);
00128       <span class="comment">// get basic info ...</span>
00129       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[i].getLevel();
00130       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[i].getX();
00131       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[i].getY();
00132       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[i].getZ();
00133 
00134       <span class="comment">//Cryptic Implementation:</span>
00135       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parX = ( ( x &gt;&gt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d + 1 ) );
00136       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parY = ( ( y &gt;&gt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d + 1 ) );
00137       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parZ = ( ( z &gt;&gt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d + 1 ) );
00138 
00139       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 1u &lt;&lt; (<a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d);
00140       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len_par = (<span class="keywordtype">unsigned</span> int)(1u&lt;&lt;( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>  - d +1 ) );
00141 
00142       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = x % len_par;
00143       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = y % len_par;
00144       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = z % len_par;
00145 
00146       a /= sz;
00147       b /= sz;
00148       c /= sz;
00149 
00150       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ch_num = (4*c + 2*b + a);
00151 
00152 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00153 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( !ch_num || (ch_num==7) ) {
00154         <span class="keywordflow">if</span> ( !(in[i].getFlag() &amp; ot::TreeNode::NODE) ) {
00155           std::cerr &lt;&lt; <a class="code" href="colors_8h.html#a0">RED</a><span class="stringliteral">"Nodes are marked wrongly "</span><a class="code" href="colors_8h.html#a6">NRM</a> &lt;&lt; std::endl;
00156           assert(<span class="keyword">false</span>);
00157         }
00158       }
00159 <span class="preprocessor">#endif</span>
00160 <span class="preprocessor"></span>
00161       <span class="keywordtype">bool</span> found[8];
00162       <span class="comment">// haven't found anything yet. Set Default values.</span>
00163       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
00164         nlist[8*i + k] = m_uiLocalBufferSize;
00165         found[k] = <span class="keyword">false</span>;
00166       }<span class="comment">//end for k</span>
00167 
00168       <span class="comment">//~~~~~~~~~~~~~~~~~~~~~~~NEGATIVE SEARCH~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
00169       <span class="keywordflow">if</span>(numFullLoopCtr == 1) {
00170         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idnx, idny, idnz;
00171         <span class="comment">//Basic Idea of a negative search. </span>
00172         <span class="comment">//1. Search and find elements on the negative faces. </span>
00173         <span class="comment">//2. If the result is a brother and the Vtx in question is hanging, swap and copy.</span>
00174         <span class="comment">//3. In all other cases, simply copy.</span>
00175         <span class="comment">//4. Note, copy only if the nlist is pointing to a valid location</span>
00176 
00177         <span class="keywordtype">bool</span> foundNegX=<span class="keyword">false</span>, foundNegY=<span class="keyword">false</span>, foundNegZ=<span class="keyword">false</span>;
00178 
00179         <span class="comment">// first lets do the 3 negative searches and we'll decide how to use it later ...</span>
00180         <span class="comment">// search negative X</span>
00181         <span class="keywordflow">if</span> (x) {
00182           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> knx( x-1, y, z, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00183           foundNegX = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, knx, idnx,NULL,&amp;i);
00184 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00185 <span class="preprocessor"></span>          <a class="code" href="odaBuildNlist_8C.html#a0">CHECK_FAST_MAX_LOWER_BOUND</a>(in,knx,idnx,foundNegX)
00186 #endif
00187 
00188             <span class="keywordflow">if</span> ( foundNegX &amp;&amp; (!( (in[idnx].isAncestor(knx) ) || (in[idnx] == knx) )) ) {
00189               foundNegX=<span class="keyword">false</span>;
00190             }
00191           <span class="keywordflow">if</span> ( foundNegX &amp;&amp; (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*idnx+1] == ot::DA_FLAGS::FOREIGN) ) {
00192             foundNegX=<span class="keyword">false</span>;
00193           }
00194         }
00195 
00196         <span class="comment">// search negative Y</span>
00197         <span class="keywordflow">if</span> (y) {
00198           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> kny( x, y-1, z, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00199           foundNegY = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, kny, idny,NULL,&amp;i) ;
00200 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00201 <span class="preprocessor"></span>          <a class="code" href="odaBuildNlist_8C.html#a0">CHECK_FAST_MAX_LOWER_BOUND</a>(in,kny,idny,foundNegY)
00202 #endif
00203             <span class="keywordflow">if</span> ( foundNegY &amp;&amp; (!( (in[idny].isAncestor(kny) ) || (in[idny] == kny) )) ) {
00204               foundNegY=<span class="keyword">false</span>;
00205             }
00206           <span class="keywordflow">if</span> ( foundNegY &amp;&amp; (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*idny+1] == ot::DA_FLAGS::FOREIGN) ) {
00207             foundNegY=<span class="keyword">false</span>;
00208           }
00209         }
00210 
00211         <span class="comment">// search negative Z</span>
00212         <span class="keywordflow">if</span> (z) {
00213           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> knz( x, y, z-1, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00214           foundNegZ = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, knz, idnz,NULL,&amp;i) ;
00215 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00216 <span class="preprocessor"></span>          <a class="code" href="odaBuildNlist_8C.html#a0">CHECK_FAST_MAX_LOWER_BOUND</a>(in,knz,idnz,foundNegZ)
00217 #endif
00218             <span class="keywordflow">if</span> ( foundNegZ &amp;&amp; (!( (in[idnz].isAncestor(knz) ) || (in[idnz] == knz) )) ) {
00219               foundNegZ=<span class="keyword">false</span>;
00220             }
00221           <span class="keywordflow">if</span> ( foundNegZ &amp;&amp; (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*idnz+1] == ot::DA_FLAGS::FOREIGN) ) {
00222             foundNegZ=<span class="keyword">false</span>;
00223           }
00224         }
00225 
00226         <span class="comment">// How we use the results of the negative search depends on the child number ...</span>
00227         <span class="comment">// if here my is the current element and x, y, and z are the elements in the </span>
00228         <span class="comment">// respective negative directions, then the default mapping sans corrections is</span>
00229         <span class="comment">// </span>
00230         <span class="comment">// my[0] = x[1] = y[2] = z[4]</span>
00231         <span class="comment">// my[1] = y[3] = z[5]</span>
00232         <span class="comment">// my[2] = x[3] = z[6]</span>
00233         <span class="comment">// my[3] = z[7];</span>
00234         <span class="comment">// my[4] = x[5] = y[6]</span>
00235         <span class="comment">// my[5] = y[7];</span>
00236         <span class="comment">// my[6] = x[7];</span>
00237         <span class="comment">// </span>
00238         <span class="comment">// The corrections will appear for all children except for child zero ... </span>
00239         <span class="comment">// and will be explained when they are performed.</span>
00240 
00241 <span class="preprocessor">#define NEG_SEARCH_BLOCK1(idx,n1l,n1r,n2l,n2r,n3l,n3r,n4l,n4r) {\</span>
00242 <span class="preprocessor">  if(nlist[8*idx+n1r] &lt; m_uiLocalBufferSize) {\</span>
00243 <span class="preprocessor">    nlist[8*i+n1l] = nlist[8*idx+n1r];\</span>
00244 <span class="preprocessor">    found[n1l] = true;\</span>
00245 <span class="preprocessor">  }\</span>
00246 <span class="preprocessor">  if(nlist[8*idx+n2r] &lt; m_uiLocalBufferSize) {\</span>
00247 <span class="preprocessor">    nlist[8*i+n2l] = nlist[8*idx+n2r];\</span>
00248 <span class="preprocessor">    found[n2l] = true;\</span>
00249 <span class="preprocessor">  }\</span>
00250 <span class="preprocessor">  if(nlist[8*idx+n3r] &lt; m_uiLocalBufferSize) {\</span>
00251 <span class="preprocessor">    nlist[8*i+n3l] = nlist[8*idx+n3r];\</span>
00252 <span class="preprocessor">    found[n3l] = true;\</span>
00253 <span class="preprocessor">  }\</span>
00254 <span class="preprocessor">  if(nlist[8*idx+n4r] &lt; m_uiLocalBufferSize) {\</span>
00255 <span class="preprocessor">    nlist[8*i+n4l] = nlist[8*idx+n4r];\</span>
00256 <span class="preprocessor">    found[n4l] = true;\</span>
00257 <span class="preprocessor">  }\</span>
00258 <span class="preprocessor">}</span>
00259 <span class="preprocessor"></span>
00260 <span class="preprocessor">#define NEG_SEARCH_BLOCK2(idx,n1l,n1r,n2l,n2r,n3l,n3r,n4l,n4r) {\</span>
00261 <span class="preprocessor">  unsigned char negMask;\</span>
00262 <span class="preprocessor">  if ( in[i].getLevel() != in[idx].getLevel()) {\</span>
00263 <span class="preprocessor">    negMask = 0;\</span>
00264 <span class="preprocessor">  } else {\</span>
00265 <span class="preprocessor">    negMask = m_ucpLutMasks[2*idx+1];\</span>
00266 <span class="preprocessor">  }\</span>
00267 <span class="preprocessor">  if (negMask != ot::DA_FLAGS::FOREIGN) {\</span>
00268 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n1r)) {\</span>
00269 <span class="preprocessor">      if(nlist[8*idx+n1l] &lt; m_uiLocalBufferSize) {\</span>
00270 <span class="preprocessor">        nlist[8*i+n1l] = nlist[8*idx+n1l];\</span>
00271 <span class="preprocessor">        found[n1l] = true;\</span>
00272 <span class="preprocessor">      }\</span>
00273 <span class="preprocessor">    } else {\</span>
00274 <span class="preprocessor">      if(nlist[8*idx+n1r] &lt; m_uiLocalBufferSize) {\</span>
00275 <span class="preprocessor">        nlist[8*i+n1l] = nlist[8*idx+n1r];\</span>
00276 <span class="preprocessor">        found[n1l] = true;\</span>
00277 <span class="preprocessor">      }\</span>
00278 <span class="preprocessor">    }\</span>
00279 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n2r)) {\</span>
00280 <span class="preprocessor">      if(nlist[8*idx+n2l] &lt; m_uiLocalBufferSize) {\</span>
00281 <span class="preprocessor">        nlist[8*i+n2l] = nlist[8*idx+n2l];\</span>
00282 <span class="preprocessor">        found[n2l] = true;\</span>
00283 <span class="preprocessor">      }\</span>
00284 <span class="preprocessor">    } else {\</span>
00285 <span class="preprocessor">      if(nlist[8*idx+n2r] &lt; m_uiLocalBufferSize) {\</span>
00286 <span class="preprocessor">        nlist[8*i+n2l] = nlist[8*idx+n2r];\</span>
00287 <span class="preprocessor">        found[n2l] = true;\</span>
00288 <span class="preprocessor">      }\</span>
00289 <span class="preprocessor">    }\</span>
00290 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n3r)) {\</span>
00291 <span class="preprocessor">      if(nlist[8*idx+n3l] &lt; m_uiLocalBufferSize) {\</span>
00292 <span class="preprocessor">        nlist[8*i+n3l] = nlist[8*idx+n3l];\</span>
00293 <span class="preprocessor">        found[n3l] = true;\</span>
00294 <span class="preprocessor">      }\</span>
00295 <span class="preprocessor">    } else {\</span>
00296 <span class="preprocessor">      if(nlist[8*idx+n3r] &lt; m_uiLocalBufferSize) {\</span>
00297 <span class="preprocessor">        nlist[8*i+n3l] = nlist[8*idx+n3r];\</span>
00298 <span class="preprocessor">        found[n3l] = true;\</span>
00299 <span class="preprocessor">      }\</span>
00300 <span class="preprocessor">    }\</span>
00301 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n4r)) {\</span>
00302 <span class="preprocessor">      if(nlist[8*idx+n4l] &lt; m_uiLocalBufferSize) {\</span>
00303 <span class="preprocessor">        nlist[8*i+n4l] = nlist[8*idx+n4l];\</span>
00304 <span class="preprocessor">        found[n4l] = true;\</span>
00305 <span class="preprocessor">      }\</span>
00306 <span class="preprocessor">    } else {\</span>
00307 <span class="preprocessor">      if(nlist[8*idx+n4r] &lt; m_uiLocalBufferSize) {\</span>
00308 <span class="preprocessor">        nlist[8*i+n4l] = nlist[8*idx+n4r];\</span>
00309 <span class="preprocessor">        found[n4l] = true;\</span>
00310 <span class="preprocessor">      }\</span>
00311 <span class="preprocessor">    }\</span>
00312 <span class="preprocessor">  }\</span>
00313 <span class="preprocessor">}</span>
00314 <span class="preprocessor"></span>
00315 <span class="preprocessor">#define NEG_SEARCH_BLOCK1X NEG_SEARCH_BLOCK1(idnx,0,1,2,3,4,5,6,7)</span>
00316 <span class="preprocessor"></span><span class="preprocessor">#define NEG_SEARCH_BLOCK2X NEG_SEARCH_BLOCK2(idnx,0,1,2,3,4,5,6,7)</span>
00317 <span class="preprocessor"></span>
00318 <span class="preprocessor">#define NEG_SEARCH_BLOCK1Y NEG_SEARCH_BLOCK1(idny,0,2,1,3,4,6,5,7)</span>
00319 <span class="preprocessor"></span><span class="preprocessor">#define NEG_SEARCH_BLOCK2Y NEG_SEARCH_BLOCK2(idny,0,2,1,3,4,6,5,7)</span>
00320 <span class="preprocessor"></span>
00321 <span class="preprocessor">#define NEG_SEARCH_BLOCK1Z NEG_SEARCH_BLOCK1(idnz,0,4,1,5,2,6,3,7)</span>
00322 <span class="preprocessor"></span><span class="preprocessor">#define NEG_SEARCH_BLOCK2Z NEG_SEARCH_BLOCK2(idnz,0,4,1,5,2,6,3,7)</span>
00323 <span class="preprocessor"></span>
00324 <span class="keywordflow">switch</span> (ch_num) {
00325   <span class="keywordflow">case</span> 0: {
00326             <span class="comment">//No Negative brothers.</span>
00327             <span class="keywordflow">if</span> (foundNegX) {
00328               <a class="code" href="odaBuildNlist_8C.html#a3">NEG_SEARCH_BLOCK1X</a>
00329             }
00330             <span class="keywordflow">if</span> (foundNegY) {
00331               <a class="code" href="odaBuildNlist_8C.html#a5">NEG_SEARCH_BLOCK1Y</a>
00332             }
00333             <span class="keywordflow">if</span> (foundNegZ) {
00334               <a class="code" href="odaBuildNlist_8C.html#a7">NEG_SEARCH_BLOCK1Z</a>
00335             }
00336             <span class="keywordflow">break</span>;
00337           }
00338   <span class="keywordflow">case</span> 1: {
00339             <span class="comment">//negX could be a brother. </span>
00340             <span class="keywordflow">if</span> (foundNegX) {
00341               <a class="code" href="odaBuildNlist_8C.html#a4">NEG_SEARCH_BLOCK2X</a>
00342             }
00343             <span class="keywordflow">if</span> (foundNegY) {
00344               <a class="code" href="odaBuildNlist_8C.html#a5">NEG_SEARCH_BLOCK1Y</a>
00345             }
00346             <span class="keywordflow">if</span> (foundNegZ) {
00347               <a class="code" href="odaBuildNlist_8C.html#a7">NEG_SEARCH_BLOCK1Z</a>
00348             }
00349             <span class="keywordflow">break</span>;
00350           }
00351   <span class="keywordflow">case</span> 2: {
00352             <span class="comment">//negY could be a brother.</span>
00353             <span class="keywordflow">if</span> (foundNegX) {
00354               <a class="code" href="odaBuildNlist_8C.html#a3">NEG_SEARCH_BLOCK1X</a>
00355             }
00356             <span class="keywordflow">if</span> (foundNegY) {
00357               <a class="code" href="odaBuildNlist_8C.html#a6">NEG_SEARCH_BLOCK2Y</a>
00358             }
00359             <span class="keywordflow">if</span> (foundNegZ) {
00360               <a class="code" href="odaBuildNlist_8C.html#a7">NEG_SEARCH_BLOCK1Z</a>
00361             }
00362             <span class="keywordflow">break</span>;
00363           }
00364   <span class="keywordflow">case</span> 3: {
00365             <span class="comment">//negX and negY could be brothers.</span>
00366             <span class="keywordflow">if</span> (foundNegX) {
00367               <a class="code" href="odaBuildNlist_8C.html#a4">NEG_SEARCH_BLOCK2X</a>
00368             }
00369             <span class="keywordflow">if</span> (foundNegY) {
00370               <a class="code" href="odaBuildNlist_8C.html#a6">NEG_SEARCH_BLOCK2Y</a>
00371             }
00372             <span class="keywordflow">if</span> (foundNegZ) {
00373               <a class="code" href="odaBuildNlist_8C.html#a7">NEG_SEARCH_BLOCK1Z</a>
00374             }
00375             <span class="keywordflow">break</span>;
00376           }
00377   <span class="keywordflow">case</span> 4: {
00378             <span class="comment">//negZ could be a brother.</span>
00379             <span class="keywordflow">if</span> (foundNegX) {
00380               <a class="code" href="odaBuildNlist_8C.html#a3">NEG_SEARCH_BLOCK1X</a>
00381             }
00382             <span class="keywordflow">if</span> (foundNegY) { 
00383               <a class="code" href="odaBuildNlist_8C.html#a5">NEG_SEARCH_BLOCK1Y</a>
00384             }
00385             <span class="keywordflow">if</span> (foundNegZ) {
00386               <a class="code" href="odaBuildNlist_8C.html#a8">NEG_SEARCH_BLOCK2Z</a>
00387             }
00388             <span class="keywordflow">break</span>;
00389           }
00390   <span class="keywordflow">case</span> 5: {
00391             <span class="comment">//negX and negZ could be brothers.</span>
00392             <span class="keywordflow">if</span> (foundNegX) {
00393               <a class="code" href="odaBuildNlist_8C.html#a4">NEG_SEARCH_BLOCK2X</a>
00394             }
00395             <span class="keywordflow">if</span> (foundNegY) {  
00396               <a class="code" href="odaBuildNlist_8C.html#a5">NEG_SEARCH_BLOCK1Y</a>
00397             }
00398             <span class="keywordflow">if</span> (foundNegZ) {
00399               <a class="code" href="odaBuildNlist_8C.html#a8">NEG_SEARCH_BLOCK2Z</a>
00400             }
00401             <span class="keywordflow">break</span>;
00402           }
00403   <span class="keywordflow">case</span> 6: {
00404             <span class="comment">//negY and negZ could be brothers.</span>
00405             <span class="keywordflow">if</span> (foundNegX) {
00406               <a class="code" href="odaBuildNlist_8C.html#a3">NEG_SEARCH_BLOCK1X</a>
00407             }
00408             <span class="keywordflow">if</span> (foundNegY) {
00409               <a class="code" href="odaBuildNlist_8C.html#a6">NEG_SEARCH_BLOCK2Y</a>
00410             }
00411             <span class="keywordflow">if</span> (foundNegZ) {
00412               <a class="code" href="odaBuildNlist_8C.html#a8">NEG_SEARCH_BLOCK2Z</a>
00413             }
00414             <span class="keywordflow">break</span>;
00415           }
00416   <span class="keywordflow">case</span> 7: {
00417             <span class="comment">//negX negY and negZ could be brothers.</span>
00418             <span class="keywordflow">if</span> (foundNegX) {
00419               <a class="code" href="odaBuildNlist_8C.html#a4">NEG_SEARCH_BLOCK2X</a>
00420             }
00421             <span class="keywordflow">if</span> (foundNegY) {
00422               <a class="code" href="odaBuildNlist_8C.html#a6">NEG_SEARCH_BLOCK2Y</a>
00423             }
00424             <span class="keywordflow">if</span> (foundNegZ) {
00425               <a class="code" href="odaBuildNlist_8C.html#a8">NEG_SEARCH_BLOCK2Z</a>
00426             }
00427             <span class="keywordflow">break</span>;
00428           }
00429   <span class="keywordflow">default</span>: {
00430              std::cerr &lt;&lt; <span class="stringliteral">"Wrong Child Number "</span> &lt;&lt; ch_num &lt;&lt; std::endl;
00431              assert(<span class="keyword">false</span>);
00432              <span class="keywordflow">break</span>;
00433            }
00434 }<span class="comment">//end cases</span>
00435 }<span class="comment">//end if for negative</span>
00436 
00437 <span class="preprocessor">#undef NEG_SEARCH_BLOCK1X</span>
00438 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2X</span>
00439 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK1Y</span>
00440 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2Y </span>
00441 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK1Z </span>
00442 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2Z</span>
00443 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK1</span>
00444 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2</span>
00445 <span class="preprocessor"></span>
00446 <span class="comment">//~~~~~~~~~~~~~~~~~~~~~POSITIVE SEARCH~~~~~~~~~~~~~~~~~~~~~~</span>
00447 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00448 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult) CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult)</span>
00449 <span class="preprocessor"></span>
00450 <span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK1(debugV1,debugV2) {\</span>
00451 <span class="preprocessor">  if ( (ch_num == debugV1) || (ch_num == debugV2) ) {\</span>
00452 <span class="preprocessor">    std::cout &lt;&lt; "Failing for index " &lt;&lt; i &lt;&lt; " with child num " &lt;&lt; ch_num &lt;&lt; std::endl;\</span>
00453 <span class="preprocessor">    assert(false);\</span>
00454 <span class="preprocessor">  }\</span>
00455 <span class="preprocessor">}</span>
00456 <span class="preprocessor"></span>
00457 <span class="preprocessor">#define  POS_SEARCH_DEBUG_BLOCK2 {\</span>
00458 <span class="preprocessor">  assert(sKey &gt; in[m_uiPostGhostBegin - 1]);\</span>
00459 <span class="preprocessor">  chkMissedPrimary.push_back(sKey);\</span>
00460 <span class="preprocessor">}</span>
00461 <span class="preprocessor"></span>
00462 <span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK3 {\</span>
00463 <span class="preprocessor">  assert( (idx+k) &lt; m_uiLocalBufferSize );\</span>
00464 <span class="preprocessor">  assert( in[idx+k].getParent() == newKey );\</span>
00465 <span class="preprocessor">  assert( !(in[idx+k].getFlag() &amp; ot::TreeNode::NODE) );\</span>
00466 <span class="preprocessor">  assert( ((idx+k) &lt; m_uiElementBegin) || (((idx+k) &gt;= m_uiPostGhostBegin)) );\</span>
00467 <span class="preprocessor">}</span>
00468 <span class="preprocessor"></span>
00469 <span class="preprocessor">#else</span>
00470 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult) </span>
00471 <span class="preprocessor"></span><span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK1(debugV1,debugV2)</span>
00472 <span class="preprocessor"></span><span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK2</span>
00473 <span class="preprocessor"></span><span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK3</span>
00474 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00475 <span class="preprocessor"></span>
00476 <span class="preprocessor">#define POS_SECONDARY_SEARCH_BLOCK(debugV1,debugV2) {\</span>
00477 <span class="preprocessor">  </span><span class="comment">/* if this is not a node, i.e., it is hanging*/</span>\
00478   POS_SEARCH_DEBUG_BLOCK1(debugV1,debugV2)\
00479   <span class="comment">/* All other cNums are anchored at the parent+(2*sz,0,0).*/</span>\
00480   sKey = parNodeLocations[j];\
00481   lastLevel = d-1;\
00482   foundKey = seq::maxLowerBound&lt;ot::TreeNode&gt;(in, sKey, idx,&amp;i,NULL);\
00483   DEBUG_CHECK_FAST_MAX_LOWER_BOUND(in, sKey,idx, foundKey) \
00484   if ( foundKey &amp;&amp; !((in[idx].getAnchor()==sKey.getAnchor()) &amp;&amp; (in[idx].getFlag()&amp;ot::TreeNode::NODE))) {\
00485     foundKey=false;\
00486   }\
00487   if ( foundKey ) {\
00488     nlist[8*i+j] = idx;\
00489   } else {\
00490     <span class="comment">/* Can happen for own elements too. */</span>\
00491     findGhost = true;\
00492   }\
00493 }
00494 
00495 <span class="preprocessor">#define POS_SEARCH_BLOCK(debugV1,debugV2) {\</span>
00496 <span class="preprocessor">  </span><span class="comment">/* first search in default location */</span>\
00497   sKey = nodeLocations[j];\
00498   lastLevel = d;\
00499   foundKey = seq::maxLowerBound&lt;ot::TreeNode&gt;(in, sKey, idx,&amp;i,NULL);\
00500   DEBUG_CHECK_FAST_MAX_LOWER_BOUND(in, sKey,idx, foundKey) \
00501   if(foundKey &amp;&amp; !( (in[idx].isAncestor(sKey) ) || (in[idx]==sKey))) {\
00502     foundKey=false;\
00503   }\
00504   if(foundKey) {\
00505     <span class="comment">/*found somebody*/</span>\
00506     if((in[idx].getAnchor()==sKey.getAnchor())&amp;&amp;(in[idx].getFlag() &amp; ot::TreeNode::NODE)) {\
00507       <span class="comment">/*found a node, so set it.*/</span>\
00508       nlist[8*i+j] = idx;\
00509     } else {\
00510       POS_SECONDARY_SEARCH_BLOCK(debugV1,debugV2)\
00511     }\
00512   } else {\
00513     if(i &gt;= m_uiElementBegin) {\
00514       <span class="comment">/*The primary search for some vertex of my own element failed*/</span>\
00515       <span class="comment">/*This should only happen if the node we are looking for is*/</span>\
00516       <span class="comment">/*a post-ghost and it is hanging. When we do the check later*/</span>\
00517       <span class="comment">/*we must also test that this node is a real anchor. */</span>\
00518       POS_SEARCH_DEBUG_BLOCK2\
00519       <span class="comment">/*Treat this case just as if the search successfully returned*/</span>\
00520       <span class="comment">/*a node, but it turned out to be hanging*/</span>\
00521       POS_SECONDARY_SEARCH_BLOCK(debugV1,debugV2)\
00522     } else {\
00523       <span class="comment">/* this is a pre-ghost so it is normal*/</span>\
00524       <span class="comment">/*to miss some primary searches */</span>\
00525       findGhost=true;\
00526     }\
00527   }\
00528   if ( findGhost ) {\
00529     findGhost=false;\
00530     <span class="comment">/* need to find the ghost. */</span>\
00531     <span class="comment">/* check if idx+k is valid */</span>\
00532     ot::TreeNode newKey(sKey.getX(),sKey.getY(),sKey.getZ(),\
00533         lastLevel,m_uiDimension,m_uiMaxDepth);\
00534     unsigned int k=1;\
00535     while ( (idx+k) &lt; in.size() ) {\
00536       if ( in[idx+k].getParent() == newKey ) {\
00537         if ( in[idx+k].getFlag() &amp; ot::TreeNode::NODE ) {\
00538           k++;\
00539           continue;\
00540         } else {\
00541           <span class="comment">/* found the correct node. (hanging)*/</span>\
00542           findGhost=true;\
00543           break;\
00544         }\
00545       }\
00546       if ( in[idx+k] &gt; newKey.getDLD() ) {\
00547         findGhost = false;\
00548         break;\
00549       } else {\
00550         k++;\
00551       }\
00552     }\
00553     if (findGhost) {\
00554       nlist[8*i+j] = idx+k;\
00555       POS_SEARCH_DEBUG_BLOCK3\
00556     } else {\
00557       nlist[8*i+j] = m_uiLocalBufferSize;\
00558     }\
00559   }\
00560 }
00561 
00562 <span class="comment">// find the eight vertices ...</span>
00563 <span class="comment">//Only 0 is a special case.</span>
00564 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00565   <span class="keywordflow">if</span>(found[j]) {
00566     <span class="keywordflow">continue</span>;
00567   }
00568   <span class="keywordtype">bool</span> foundKey=<span class="keyword">false</span>;
00569   <span class="keywordtype">bool</span> findGhost=<span class="keyword">false</span>;
00570   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00571   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastLevel;
00572   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> sKey(<a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00573 
00574   <span class="keywordflow">switch</span> (j) {
00575     <span class="keywordflow">case</span> 0: {
00576               nodeLocations[j] =
00577                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, z, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00578               parNodeLocations[j] = 
00579                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY, parZ, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00580               <span class="comment">// first search is not required since we are searching for i</span>
00581               <span class="keywordflow">if</span> ( !(in[i].getFlag() &amp; ot::TreeNode::NODE ) ) {
00582                 <span class="comment">// if this is not a node, i.e., it is hanging</span>
00583 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00584 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( (ch_num == 0) || (ch_num == 7) ) {
00585                   std::cout &lt;&lt; <span class="stringliteral">"Failing for index "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" with child num "</span> &lt;&lt; ch_num &lt;&lt; std::endl;
00586                   assert(<span class="keyword">false</span>);
00587                 }
00588 <span class="preprocessor">#endif</span>
00589 <span class="preprocessor"></span>                <span class="comment">// All other child numbers are anchored at the parent.</span>
00590                 sKey = parNodeLocations[j];
00591                 lastLevel = d-1;
00592                 foundKey = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, sKey, idx,NULL,&amp;i);
00593 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00594 <span class="preprocessor"></span>                <a class="code" href="odaBuildNlist_8C.html#a0">CHECK_FAST_MAX_LOWER_BOUND</a>(in, sKey,idx, foundKey) 
00595 #endif
00596                   <span class="keywordflow">if</span> ( foundKey &amp;&amp; 
00597                       (!( (in[idx].getAnchor() == sKey.getAnchor()) &amp;&amp; (in[idx].getFlag() &amp; ot::TreeNode::NODE) )) ) {
00598                     foundKey=<span class="keyword">false</span>;
00599                   }
00600                 <span class="keywordflow">if</span> ( !foundKey ) {
00601 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00602 <span class="preprocessor"></span>                  <span class="comment">// should only happen for ghosts ...</span>
00603                   <span class="keywordflow">if</span>(i &gt;= m_uiElementBegin) {
00604                     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" i = "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" preGhostElemEnd "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a>
00605                       &lt;&lt;<span class="stringliteral">" elemBeg: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>&lt;&lt;<span class="stringliteral">" elemEnd: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a>&lt;&lt;std::endl;
00606                   }
00607                   assert (i &lt; <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>);
00608 <span class="preprocessor">#endif</span>
00609 <span class="preprocessor"></span>                  <span class="comment">// for node zero, simply default to i.</span>
00610                   nlist[8*i+j] = i;
00611                 } <span class="keywordflow">else</span> {
00612                   nlist[8*i+j] = idx;
00613                 }
00614               } <span class="keywordflow">else</span> {
00615                 nlist[8*i+j] = i;
00616               }
00617               <span class="keywordflow">break</span>;
00618             }
00619     <span class="keywordflow">case</span> 1: {
00620               nodeLocations[j] = 
00621                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y, z, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00622               parNodeLocations[j] = 
00623                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY, parZ, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00624               <a class="code" href="odaBuildNlist_8C.html#a14">POS_SEARCH_BLOCK</a>(1,6) 
00625                 <span class="keywordflow">break</span>;
00626             }
00627     <span class="keywordflow">case</span> 2: {
00628               nodeLocations[j] = 
00629                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y+sz, z, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00630               parNodeLocations[j] = 
00631                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY+(sz&lt;&lt;1u), parZ, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00632               <a class="code" href="odaBuildNlist_8C.html#a14">POS_SEARCH_BLOCK</a>(2,5) 
00633                 <span class="keywordflow">break</span>;
00634             }
00635     <span class="keywordflow">case</span> 3: {
00636               nodeLocations[j] = 
00637                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y+sz, z, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00638               parNodeLocations[j] = 
00639                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY+(sz&lt;&lt;1u), parZ, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00640               <a class="code" href="odaBuildNlist_8C.html#a14">POS_SEARCH_BLOCK</a>(3,4) 
00641                 <span class="keywordflow">break</span>;
00642             }
00643     <span class="keywordflow">case</span> 4: {
00644               nodeLocations[j] = 
00645                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, z+sz, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00646               parNodeLocations[j] = 
00647                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY, parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00648               <a class="code" href="odaBuildNlist_8C.html#a14">POS_SEARCH_BLOCK</a>(4,3) 
00649                 <span class="keywordflow">break</span>;
00650             }
00651     <span class="keywordflow">case</span> 5: {
00652               nodeLocations[j] = 
00653                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y, z+sz, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00654               parNodeLocations[j] = 
00655                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY, parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00656               <a class="code" href="odaBuildNlist_8C.html#a14">POS_SEARCH_BLOCK</a>(5,2) 
00657                 <span class="keywordflow">break</span>;
00658             }
00659     <span class="keywordflow">case</span> 6: {
00660               nodeLocations[j] = 
00661                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y+sz, z+sz, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00662               parNodeLocations[j] = 
00663                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY+(sz&lt;&lt;1u), parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00664               <a class="code" href="odaBuildNlist_8C.html#a14">POS_SEARCH_BLOCK</a>(6,1) 
00665                 <span class="keywordflow">break</span>;
00666             }
00667     <span class="keywordflow">case</span> 7: {
00668               nodeLocations[j] = 
00669                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y+sz, z+sz, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00670               parNodeLocations[j] = 
00671                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY+(sz&lt;&lt;1u), parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00672               <a class="code" href="odaBuildNlist_8C.html#a14">POS_SEARCH_BLOCK</a>(7,0) 
00673                 <span class="keywordflow">break</span>;
00674             }
00675     <span class="keywordflow">default</span>: {
00676                std::cerr &lt;&lt; <a class="code" href="colors_8h.html#a0">RED</a>&lt;&lt;<span class="stringliteral">"Wrong node number in "</span> &lt;&lt; __func__ &lt;&lt;<a class="code" href="colors_8h.html#a6">NRM</a>&lt;&lt; std::endl;
00677                assert(<span class="keyword">false</span>);
00678                <span class="keywordflow">break</span>;
00679              }
00680   } <span class="comment">// end switch</span>
00681 } <span class="comment">// end loop over the 8 vertices of this element...</span>
00682 
00683 <span class="preprocessor">#undef POS_SEARCH_BLOCK</span>
00684 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SECONDARY_SEARCH_BLOCK</span>
00685 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SEARCH_DEBUG_BLOCK1</span>
00686 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SEARCH_DEBUG_BLOCK2</span>
00687 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SEARCH_DEBUG_BLOCK3</span>
00688 <span class="preprocessor"></span>
00689 <span class="comment">// FINISHED Searching for Node Indices ...</span>
00690 
00691 <span class="comment">//Ensure that the anchor of the local element is not pointing to ghost.</span>
00692 <span class="comment">//This can happen only if the octant in question is a singular block</span>
00693 <span class="comment">//and its anchor is hanging and the 0th child of its parent is sitting on a different processor.</span>
00694 <span class="comment">//BlockPart should have detected this case and prevented this.</span>
00695 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00696 <span class="preprocessor"></span><span class="keywordflow">if</span> ( (i &gt;= m_uiElementBegin) &amp;&amp; (i &lt; m_uiElementEnd) &amp;&amp;
00697     ( (nlist[8*i] &lt; m_uiElementBegin) || (nlist[8*i] &gt;= m_uiPostGhostBegin) ) ) {
00698   std::cout &lt;&lt; <span class="stringliteral">"At index "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" anchor is at "</span> &lt;&lt; nlist[8*i] &lt;&lt;
00699     <span class="stringliteral">" where elemBegin is at "</span> &lt;&lt; <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> &lt;&lt; <span class="stringliteral">" and postGhBegin is "</span>
00700     &lt;&lt; <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> &lt;&lt; std::endl;
00701   std::cout &lt;&lt; <span class="stringliteral">"RANK is "</span> &lt;&lt; <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt;&lt; std::endl;
00702   std::cout &lt;&lt; <span class="stringliteral">"NList is "</span>;
00703   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;8; j++) {
00704     std::cout &lt;&lt; nlist[8*i+j] &lt;&lt; <span class="stringliteral">", "</span>;
00705   }
00706   std::cout &lt;&lt; std::endl;
00707   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" failingOct: "</span>&lt;&lt;in[i]&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">" it's parent: "</span>&lt;&lt;in[i].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>()&lt;&lt;std::endl;
00708   <span class="keywordflow">if</span>( nlist[8*i] &lt; in.size() ) {
00709     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" failingOct's anchor is actually mapped to: "</span>&lt;&lt;in[nlist[8*i]]&lt;&lt;std::endl;  
00710   }
00711   assert(<span class="keyword">false</span>);
00712 }
00713 <span class="preprocessor">#endif</span>
00714 <span class="preprocessor"></span>
00715 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00716 <span class="preprocessor"></span><span class="comment">//Check if you sent yourself apriori (Second Ring). </span>
00717 <span class="keywordflow">if</span>( (i &gt;= m_uiElementBegin) &amp;&amp; (i &lt; m_uiPostGhostBegin) ) {
00718   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt; 8; j++) {
00719     <span class="keywordflow">if</span>(nlist[8*i + j] &lt; m_uiElementBegin) {
00720       std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Trying to send yourself as a Post Ghost ELEMENT for  i = "</span>
00721         &lt;&lt;i&lt;&lt;<span class="stringliteral">" j = "</span>&lt;&lt;j&lt;&lt;std::endl;
00722       assert(<span class="keyword">false</span>);
00723     }
00724     <span class="keywordflow">if</span>( (nlist[8*i+j] &gt;= m_uiPostGhostBegin) &amp;&amp; (nlist[8*i+j] &lt; m_uiLocalBufferSize) ) {
00725       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmpToSend = in[nlist[8*i+j]];
00726       tmpToSend.<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(i);
00727       checkSecondRing.push_back(tmpToSend);
00728     }
00729   }<span class="comment">//end for j</span>
00730 }
00731 <span class="preprocessor">#endif</span>
00732 <span class="preprocessor"></span>
00733 <span class="comment">// compute the hanging node mask for this element ...</span>
00734 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _mask=0;
00735 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numOutOfBounds = 0;
00736 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;8; j++) {
00737   <span class="keywordflow">if</span> ( ( nlist[8*i+j] &lt; m_uiElementBegin ) || (nlist[8*i+j] &gt;= m_uiPostGhostBegin) ) {
00738     numOutOfBounds++;
00739   }
00740 
00741   <span class="keywordflow">if</span>(nlist[8*i+j] &gt;= m_uiLocalBufferSize) {
00742     <span class="comment">//Skip setting mask for this vtx.</span>
00743     <span class="keywordflow">continue</span>;
00744   }
00745 
00746   <span class="comment">// check if any of the nodes is hanging ...</span>
00747   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x,_y,_z, _d;
00748   _x = in[nlist[8*i+j]].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>(); 
00749   _y = in[nlist[8*i+j]].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>(); 
00750   _z = in[nlist[8*i+j]].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>(); 
00751   _d = in[nlist[8*i+j]].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00752   <span class="keywordflow">if</span> ( !(in[nlist[8*i+j]].getFlag() &amp; ot::TreeNode::NODE ) ) {
00753     <span class="comment">// std::cout &lt;&lt; "For i=" &lt;&lt; i &lt;&lt; " looking at parent" &lt;&lt; std::endl;</span>
00754     _x  = ( ( _x &gt;&gt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - _d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - _d + 1 ) ); 
00755     _y  = ( ( _y &gt;&gt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - _d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - _d + 1 ) );
00756     _z  = ( ( _z &gt;&gt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - _d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - _d + 1 ) );
00757   }
00758 
00759   <span class="keywordflow">switch</span> (j) {
00760     <span class="keywordflow">case</span> 0:
00761       <span class="keywordflow">if</span> ( !(in[i].getFlag() &amp; ot::TreeNode::NODE ) ) {
00762         _mask |= (1 &lt;&lt; j);
00763       }
00764       <span class="keywordflow">break</span>;
00765     <span class="keywordflow">case</span> 1:
00766       <span class="comment">// look at the anchor of the +x neighbor</span>
00767       <span class="comment">// if ( (x+sz) != _x ) {</span>
00768       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( z != _z ) ) {
00769         _mask |= (1 &lt;&lt; j);
00770       }
00771       <span class="keywordflow">break</span>;
00772     <span class="keywordflow">case</span> 2:
00773       <span class="comment">// look at the anchor of the +y neighbor</span>
00774       <span class="comment">// if ( (y+sz) != _y ) {</span>
00775       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
00776         _mask |= (1 &lt;&lt; j);
00777       }
00778       <span class="keywordflow">break</span>;
00779     <span class="keywordflow">case</span> 3:
00780       <span class="comment">// look at both x and y anchors ...</span>
00781       <span class="comment">// if ( ( (x+sz) != _x ) || ( (y+sz) != _y )  ) {</span>
00782       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
00783         _mask |= (1 &lt;&lt; j);
00784       }
00785       <span class="keywordflow">break</span>;
00786     <span class="keywordflow">case</span> 4:
00787       <span class="comment">// look at z anchor</span>
00788       <span class="comment">// if ( (z+sz) != _z ) {</span>
00789       <span class="keywordflow">if</span> ( ( x != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
00790         _mask |= (1 &lt;&lt; j);
00791       }
00792       <span class="keywordflow">break</span>;
00793     <span class="keywordflow">case</span> 5:
00794       <span class="comment">// look at +z,+x</span>
00795       <span class="comment">// if ( ( (x+sz) != _x ) || ( (z+sz) != _z )  ) {</span>
00796       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
00797         _mask |= (1 &lt;&lt; j);
00798       }
00799       <span class="keywordflow">break</span>;
00800     <span class="keywordflow">case</span> 6:
00801       <span class="comment">// look at +z, +y</span>
00802       <span class="comment">// if ( ( (z+sz) != _z ) || ( (y+sz) != _y )  ) {</span>
00803       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
00804         _mask |= (1 &lt;&lt; j);
00805       }
00806       <span class="keywordflow">break</span>;
00807     <span class="keywordflow">case</span> 7:
00808       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
00809         _mask |= (1 &lt;&lt; j);
00810       }
00811       <span class="keywordflow">break</span>;
00812   }<span class="comment">//end switch-case</span>
00813   }<span class="comment">//end for j</span>
00814 
00815   <span class="comment">// store the mask ...</span>
00816   <span class="keywordflow">if</span> (numOutOfBounds == 8) {
00817     <span class="comment">//This does not even have one writable node and hence this is not an element.</span>
00818     _mask = ot::DA_FLAGS::FOREIGN;
00819   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numOutOfBounds) {
00820     <span class="comment">//A Dependent Element, is one which has atleast one writable node and atleast one ghosted node.</span>
00821     in[i].<a class="code" href="classot_1_1TreeNode.html#z19_15">orFlag</a>(ot::DA_FLAGS::DEP_ELEM);        
00822   }
00823 
00824   <span class="comment">//Prepare for the Ugly portion...</span>
00825   <span class="comment">//Sometimes, we might find a primary key but it could turn out to be hanging</span>
00826   <span class="comment">//and then we may not find the secondary key. In such cases, we still</span>
00827   <span class="comment">//generate both the priimary and secondary keys and search for both in the</span>
00828   <span class="comment">//following second ring correction phase. This might seem like an overkill</span>
00829   <span class="comment">//but this situation occurs only for pre-ghosts and singular blocks. Suppose,</span>
00830   <span class="comment">//the octant A searches for a secondary key B and does not find it and</span>
00831   <span class="comment">//suppose A is not a pre-ghost (i.e. this processor owns A). Since B is one</span>
00832   <span class="comment">//of the vertices of A's parent this means the sibling of A that shares the</span>
00833   <span class="comment">//vertex B with A's parent is not on the same processor as A (since all</span>
00834   <span class="comment">//direct vertices which are not hanging are communicated apriori and B can't</span>
00835   <span class="comment">//be hanging). Hence, A is singular</span>
00836   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;8; j++) {
00837     <span class="keywordflow">if</span> (nlist[8*i+j] &gt;= m_uiLocalBufferSize) {
00838       <span class="keywordflow">if</span> (_mask != ot::DA_FLAGS::FOREIGN) {
00839 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00840 <span class="preprocessor"></span>        assert(j);
00841 <span class="preprocessor">#endif</span>
00842 <span class="preprocessor"></span>        <span class="comment">// add to list ...</span>
00843         nodeLocations[j].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
00844         parNodeLocations[j].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
00845         primaryKeys.push_back(nodeLocations[j]);
00846         secondaryKeys.push_back(parNodeLocations[j]);
00847         <span class="comment">// correct lookUp Table ...</span>
00848         nlist[8*i+j] = <a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a> +
00849           static_cast&lt;unsigned int&gt;(extraAtEnd.size());
00850         nodeLocations[j].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(i);
00851         extraAtEnd.push_back(nodeLocations[j]);
00852       }<span class="comment">//end if foreign</span>
00853     }<span class="comment">//end if invalid</span>
00854   }<span class="comment">//end for j</span>
00855 
00856   <span class="comment">// Store the hanging node mask</span>
00857   <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i+1] = _mask;
00858   } <span class="comment">// end for i: All elements in this set </span>
00859 
00860 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00861 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00862   <span class="keywordflow">if</span>(!m_iRankActive) {
00863     std::cout&lt;&lt;std::endl;
00864     std::cout&lt;&lt;<span class="stringliteral">"Finished Elemental Loop for Set# "</span>&lt;&lt;numFullLoopCtr&lt;&lt;std::endl;
00865     std::cout&lt;&lt;std::endl;
00866   }
00867   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00868 <span class="preprocessor">#endif</span>
00869 <span class="preprocessor"></span>
00870 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
00871 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00872   seq::makeVectorUnique&lt;ot::TreeNode&gt;(chkMissedPrimary, <span class="keyword">false</span>);
00873   <span class="keywordtype">int</span>* chkMissedPrimarySendCounts = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00874   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
00875     chkMissedPrimarySendCounts[i] = 0; 
00876   }<span class="comment">//end for i</span>
00877 
00878   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; chkMissedPrimary.size(); i++) {
00879     <span class="comment">//maxLB returns the last index in a sorted array such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
00880     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00881     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(m_tnMinAllBlocks, chkMissedPrimary[i], idx, NULL, NULL);
00882     assert(found);
00883     <span class="comment">//missed keys must be post-ghosts</span>
00884     assert(idx &gt; <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
00885     chkMissedPrimarySendCounts[idx]++; 
00886   }<span class="comment">//end for i</span>
00887 
00888   <span class="keywordtype">int</span>* chkMissedPrimaryRecvCounts = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00889   par::Mpi_Alltoall&lt;int&gt;(chkMissedPrimarySendCounts, chkMissedPrimaryRecvCounts, 1, m_mpiCommActive);
00890 
00891   <span class="keywordtype">int</span>* chkMissedPrimarySendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00892   <span class="keywordtype">int</span>* chkMissedPrimaryRecvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
00893   chkMissedPrimarySendOffsets[0] = 0;
00894   chkMissedPrimaryRecvOffsets[0] = 0;
00895   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; m_iNpesActive; i++) {
00896     chkMissedPrimarySendOffsets[i] = chkMissedPrimarySendOffsets[i-1] + chkMissedPrimarySendCounts[i-1] ;
00897     chkMissedPrimaryRecvOffsets[i] = chkMissedPrimaryRecvOffsets[i-1] + chkMissedPrimaryRecvCounts[i-1] ;
00898   }<span class="comment">//end for i</span>
00899   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chkMissedPrimaryRecvSz = chkMissedPrimaryRecvOffsets[m_iNpesActive - 1] +
00900     chkMissedPrimaryRecvCounts[m_iNpesActive - 1];
00901   std::vector&lt;ot::TreeNode&gt; chkMissedPrimaryRecvBuffer(chkMissedPrimaryRecvSz);
00902   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* chkMissedPrimarySendPtr = NULL;
00903   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* chkMissedPrimaryRecvPtr = NULL;
00904   <span class="keywordflow">if</span>(!(chkMissedPrimary.empty())) {
00905     chkMissedPrimarySendPtr = (&amp;(*(chkMissedPrimary.begin())));
00906   }
00907   <span class="keywordflow">if</span>(!(chkMissedPrimaryRecvBuffer.empty())) {
00908     chkMissedPrimaryRecvPtr = (&amp;(*(chkMissedPrimaryRecvBuffer.begin())));
00909   }
00910   par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( chkMissedPrimarySendPtr, chkMissedPrimarySendCounts,
00911       chkMissedPrimarySendOffsets, chkMissedPrimaryRecvPtr,
00912       chkMissedPrimaryRecvCounts, chkMissedPrimaryRecvOffsets, m_mpiCommActive);
00913 
00914   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; chkMissedPrimaryRecvBuffer.size(); i++) {
00915     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00916     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(in, chkMissedPrimaryRecvBuffer[i], idx, NULL, NULL);
00917     assert(found);
00918     assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>) );
00919     <span class="comment">//Although this is a hanging node this is also some anchor</span>
00920     assert(in[idx].getAnchor() == chkMissedPrimaryRecvBuffer[i].getAnchor());
00921     assert( !(in[idx].<a class="code" href="classot_1_1DA.html#z36_4">getFlag</a>() &amp; ot::TreeNode::NODE) );
00922   }<span class="comment">//end for i</span>
00923 
00924   <span class="keyword">delete</span> [] chkMissedPrimarySendCounts;
00925   <span class="keyword">delete</span> [] chkMissedPrimaryRecvCounts;
00926   <span class="keyword">delete</span> [] chkMissedPrimarySendOffsets;
00927   <span class="keyword">delete</span> [] chkMissedPrimaryRecvOffsets;
00928   chkMissedPrimaryRecvBuffer.clear();
00929   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00930   <span class="keywordflow">if</span>(!m_iRankActive) {
00931     std::cout&lt;&lt;std::endl;
00932     std::cout&lt;&lt;<span class="stringliteral">"Passed Test for Missed Primary "</span>&lt;&lt;numFullLoopCtr&lt;&lt;std::endl;
00933     std::cout&lt;&lt;std::endl;
00934   }
00935   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
00936 <span class="preprocessor">#endif</span>
00937 <span class="preprocessor"></span>
00938   <span class="comment">/*</span>
00939 <span class="comment">     NOW, The Ugly Parallel Book-keeping and Corrections for the Missing Entries in the Previous Step...</span>
00940 <span class="comment">     */</span>
00941 
00942   <span class="comment">// ~~~~~~~~~~~~~~~~~~ SECONDARY ~~~~~~~~~~~~~~~~~~~~~~~</span>
00943   std::vector&lt;unsigned int&gt;               ScndScatterMap;
00944 
00945   std::vector&lt;unsigned int&gt;               ScndSendProcs;
00946   std::vector&lt;unsigned int&gt;               ScndSendCounts;
00947 
00948   std::vector&lt;unsigned int&gt;               ScndRecvProcs;
00949   std::vector&lt;unsigned int&gt;               ScndRecvCounts;
00950 
00951   <span class="comment">//~~~~~~~~~~~~~~~~~~~~~~~~ Search for Failed Keys ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//</span>
00952   <span class="comment">/*</span>
00953 <span class="comment">     1. Each octant which has a missing entry in its node-list would have generated a primary and secondary key for that entry.</span>
00954 <span class="comment">     This is the last for-j loop within the main i-loop.</span>
00955 <span class="comment">     2. Multiple octants might want the same entry. Hence, we make these keys unique before sending these requests</span>
00956 <span class="comment">     to the respective processors.</span>
00957 <span class="comment">     3. However, we need to map the results back to the octants which generated these keys.</span>
00958 <span class="comment">     So we keep a back-up of the original list of keys. This list will have duplicates.</span>
00959 <span class="comment">     4. Send the unique set of Primary and Secondary keys computed above to the processors which control those domains.</span>
00960 <span class="comment">     5. Each processor recieves the keys that lie within its domain.</span>
00961 <span class="comment">     Now, multiple processors might have requested for the same key. So, we make the list of keys recieved unique.</span>
00962 <span class="comment">     We need to map them back to the processors that requested them. Hence, we store the pair of keys and </span>
00963 <span class="comment">     a list of processors that requested that key. This is done using the NodeAndRanks class. The sort order</span>
00964 <span class="comment">     for this class is defined only on TreeNode.</span>
00965 <span class="comment">     6. Each processor performs a local search with this set of unique keys. Note only non-hanging nodes are considered as matches.</span>
00966 <span class="comment">     7. The results are returned to the processors that requested the respective keys.</span>
00967 <span class="comment">     8. The results are matched with the octants that generated the keys. </span>
00968 <span class="comment">     9. If a primary key returned a positive result, then it is used else the secondary key is used. </span>
00969 <span class="comment">     10. There is a special for the secondary key for the nlist of a pre-ghost element. It is possible that while the primary key was NOT recieved during the a-priori communication, but the secondary key was recieved. In such situations if the secondary key is to be selected, then we must select the copy that was recieved during the a-priori comm and not the one got from this second-ring correction. This must be done in order to prevent having duplicate elements in our local buffer.</span>
00970 <span class="comment">     11. Each of the octants that were selected is given an unique id. This will be used to fix the nlist.</span>
00971 <span class="comment">     12. The hanging masks need to be corrected as well.</span>
00972 <span class="comment">     13. Since, the primary key could be owned by one processor and the secondary key by another. Only the processor which owns the octant that generated</span>
00973 <span class="comment">     the keys can decide what key is actually picked. The decision is then communicated to the processors that own the keys.</span>
00974 <span class="comment">     14. A processor might be sending some primary results and some secondary results to the same processor. So both the sets must be merged and</span>
00975 <span class="comment">     a single scattermap is built. This is the secondary scattermap. This is from the primary scattermap, which is built in the constructor </span>
00976 <span class="comment">     before entering this function (BuildNodeList).</span>
00977 <span class="comment">     15. Finally, the same processor might have sent some of its elements in the first ring (apriori comm inside the constructor) and it</span>
00978 <span class="comment">     might send some of its elements in the second ring (below). When the actual data is sent, we want the two sets to come together.</span>
00979 <span class="comment">     We want both the first set of octants and the second set of octants to be merged and to be sorted.</span>
00980 <span class="comment">     16. The first set of octants and the second set of octants have to be merged and sorted. All the second set of octants are marked as FOREIGNs. So, we don't loop over them in the MatVec and we don't build their LUTs. They are simply place holders for ghost values.</span>
00981 <span class="comment">     17. The old LUT has to be re-mapped to the new LUT, since the indices will change after step 15.</span>
00982 <span class="comment">     18. Similarly, the scattermaps must be merged and corrected to point to the new indices.</span>
00983 <span class="comment">     19. We can have missing nodes both for pre-ghosts as well as own elements. Hence, this second ring correction is done inside the main outer loop (numFullLoopCtr).</span>
00984 <span class="comment">     */</span>
00985 
00986   <span class="comment">//~~~~~~~~~~~Correction for Second Ring Begins~~~~~~~~~~~~~~~~~~//</span>
00987   <span class="comment">//First Get the min and max from each processor.</span>
00988 
00989   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> rootNode(<a class="code" href="classot_1_1DA.html#p34">m_uiDimension</a>,<a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>);
00990 
00991   assert(!in.empty());
00992   assert(<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> &lt; in.size());
00993   assert(<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> &gt;= 1);
00994   assert((<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>-1) &lt; in.size());
00995 
00996   std::vector&lt;ot::TreeNode&gt; failedPrimaryKeys = primaryKeys;
00997   std::vector&lt;ot::TreeNode&gt; failedSecondaryKeys = secondaryKeys;
00998 
00999   <span class="comment">//Sort and Make Unique</span>
01000   seq::makeVectorUnique&lt;ot::TreeNode&gt;(failedPrimaryKeys, <span class="keyword">false</span>);
01001   seq::makeVectorUnique&lt;ot::TreeNode&gt;(failedSecondaryKeys, <span class="keyword">false</span>);
01002 
01003 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01004 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01005 
01006   <span class="keywordflow">if</span>(!m_iRankActive) {
01007     std::cout&lt;&lt;std::endl;
01008     std::cout&lt;&lt;<span class="stringliteral">"Made Failed Keys Unique. Finding Partition Next."</span>&lt;&lt;std::endl;
01009     std::cout&lt;&lt;std::endl;
01010   }
01011   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01012 <span class="preprocessor">#endif</span>
01013 <span class="preprocessor"></span>
01014   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PrimaryKeysSz = static_cast&lt;unsigned int&gt;(failedPrimaryKeys.size());
01015   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SecondaryKeysSz = static_cast&lt;unsigned int&gt;(failedSecondaryKeys.size());
01016 
01017   <span class="comment">//Now determine the processors which own these keys.</span>
01018   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partPrimary = NULL;
01019   <span class="keywordflow">if</span>(PrimaryKeysSz) {
01020     partPrimary = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[PrimaryKeysSz];    
01021   }
01022   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partSecondary = NULL;
01023   <span class="keywordflow">if</span>(SecondaryKeysSz) {
01024     partSecondary = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[SecondaryKeysSz];    
01025   }
01026 
01027   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;PrimaryKeysSz; i++) {
01028     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01029     <span class="comment">//maxLB returns the last index in a sorted array such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
01030     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(m_tnMinAllBlocks, failedPrimaryKeys[i], idx, NULL, NULL);
01031     assert(found);
01032     partPrimary[i] = idx;
01033   }<span class="comment">//end for i</span>
01034 
01035   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;SecondaryKeysSz; i++) {
01036     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01037     <span class="comment">//maxLB returns the last index in a sorted array such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
01038     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(m_tnMinAllBlocks, failedSecondaryKeys[i], idx, NULL, NULL);
01039     assert(found);
01040     partSecondary[i] = idx;
01041   }<span class="comment">//end for i</span>
01042 
01043   <span class="keywordtype">int</span> *numKeysSendP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
01044   <span class="keywordtype">int</span> *numKeysSendS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
01045   <span class="keywordtype">int</span> *numKeysRecvP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];    
01046   <span class="keywordtype">int</span> *numKeysRecvS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
01047 
01048   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m_iNpesActive; i++) {
01049     numKeysSendP[i] = 0;
01050     numKeysSendS[i] = 0;
01051   }
01052   <span class="comment">// calculate the number of keys to send ...</span>
01053   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;PrimaryKeysSz; i++) {
01054     numKeysSendP[partPrimary[i]]++;      
01055   }
01056   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;SecondaryKeysSz; i++) {
01057     numKeysSendS[partSecondary[i]]++;
01058   }    
01059 
01060 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01061 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01062   <span class="keywordflow">if</span>(!m_iRankActive) {
01063     std::cout&lt;&lt;std::endl;
01064     std::cout&lt;&lt;<span class="stringliteral">"First ALL2ALL for Second Ring..."</span>&lt;&lt;std::endl;
01065     std::cout&lt;&lt;std::endl;
01066   }
01067   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01068 <span class="preprocessor">#endif</span>
01069 <span class="preprocessor"></span>
01070 
01071   <span class="comment">// Now do an All2All to get inumKeysRecv</span>
01072   <a class="code" href="oda_8h.html#a23">PROF_BUILD_NLIST_COMM_BEGIN</a>
01073 
01074     par::Mpi_Alltoall&lt;int&gt;(numKeysSendP, numKeysRecvP, 1, m_mpiCommActive);
01075   par::Mpi_Alltoall&lt;int&gt;(numKeysSendS, numKeysRecvS, 1, m_mpiCommActive);
01076 
01077   <a class="code" href="oda_8h.html#a24">PROF_BUILD_NLIST_COMM_END</a>
01078 
01079     <span class="comment">// Now create sendK</span>
01080     <span class="keywordtype">int</span> *sendOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsP[0] = 0;
01081   <span class="keywordtype">int</span> *recvOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsP[0] = 0;
01082   <span class="keywordtype">int</span> *numKeysTmpP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; numKeysTmpP[0] = 0; 
01083 
01084   <span class="keywordtype">int</span> *sendOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsS[0] = 0;
01085   <span class="keywordtype">int</span> *recvOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsS[0] = 0;
01086   <span class="keywordtype">int</span> *numKeysTmpS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; numKeysTmpS[0] = 0; 
01087 
01088   <span class="comment">// compute offsets ...</span>
01089   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; m_iNpesActive; i++) {
01090     sendOffsetsP[i] = sendOffsetsP[i-1] + numKeysSendP[i-1];
01091     recvOffsetsP[i] = recvOffsetsP[i-1] + numKeysRecvP[i-1];
01092     numKeysTmpP[i] = 0; 
01093 
01094     sendOffsetsS[i] = sendOffsetsS[i-1] + numKeysSendS[i-1];
01095     recvOffsetsS[i] = recvOffsetsS[i-1] + numKeysRecvS[i-1];
01096     numKeysTmpS[i] = 0; 
01097   }
01098 
01099   <span class="comment">// create the send and recv buffers ...</span>
01100   std::vector&lt;ot::TreeNode&gt; sendKp (PrimaryKeysSz);
01101   std::vector&lt;ot::TreeNode&gt; recvKp (recvOffsetsP[m_iNpesActive-1] + numKeysRecvP[m_iNpesActive-1]);
01102 
01103   std::vector&lt;ot::TreeNode&gt; sendKs (SecondaryKeysSz);
01104   std::vector&lt;ot::TreeNode&gt; recvKs (recvOffsetsS[m_iNpesActive-1] + numKeysRecvS[m_iNpesActive-1]);
01105 
01106   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; PrimaryKeysSz; i++) {
01107     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmpP[partPrimary[i]];
01108     numKeysTmpP[partPrimary[i]]++;
01109     <span class="comment">// set entry ...</span>
01110     sendKp[sendOffsetsP[partPrimary[i]] + ni] = failedPrimaryKeys[i];      
01111   } 
01112 
01113   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; SecondaryKeysSz; i++) {
01114     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmpS[partSecondary[i]];
01115     numKeysTmpS[partSecondary[i]]++;
01116     <span class="comment">// set entry ...</span>
01117     sendKs[sendOffsetsS[partSecondary[i]] + ni] = failedSecondaryKeys[i];       
01118   } 
01119 
01120   failedPrimaryKeys.clear();
01121   failedSecondaryKeys.clear();
01122 
01123   <span class="keywordflow">if</span>(partPrimary) {
01124     <span class="keyword">delete</span> [] partPrimary;
01125     partPrimary = NULL;
01126   }
01127 
01128   <span class="keywordflow">if</span>(partSecondary) {
01129     <span class="keyword">delete</span> [] partSecondary;
01130     partSecondary = NULL;
01131   }
01132 
01133   <span class="keywordflow">if</span>(numKeysTmpP) {
01134     <span class="keyword">delete</span> [] numKeysTmpP;    
01135     numKeysTmpP = NULL;
01136   }
01137 
01138   <span class="keywordflow">if</span>(numKeysTmpS) {
01139     <span class="keyword">delete</span> [] numKeysTmpS;
01140     numKeysTmpS = NULL;
01141   }
01142 
01143   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKpPtr = NULL;
01144   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKpPtr = NULL;
01145   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKsPtr = NULL;
01146   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKsPtr = NULL;
01147   <span class="keywordflow">if</span>(!sendKp.empty()) {
01148     sendKpPtr = &amp;(*(sendKp.begin()));
01149   }
01150   <span class="keywordflow">if</span>(!recvKp.empty()) {
01151     recvKpPtr = &amp;(*(recvKp.begin()));
01152   }
01153   <span class="keywordflow">if</span>(!sendKs.empty()) {
01154     sendKsPtr = &amp;(*(sendKs.begin()));
01155   }
01156   <span class="keywordflow">if</span>(!recvKs.empty()) {
01157     recvKsPtr = &amp;(*(recvKs.begin()));
01158   }
01159 
01160   <a class="code" href="oda_8h.html#a23">PROF_BUILD_NLIST_COMM_BEGIN</a>
01161 
01162     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKpPtr, numKeysSendP, sendOffsetsP,
01163         recvKpPtr, numKeysRecvP, recvOffsetsP, m_mpiCommActive);
01164 
01165   par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKsPtr, numKeysSendS, sendOffsetsS,
01166       recvKsPtr, numKeysRecvS, recvOffsetsS, m_mpiCommActive);
01167 
01168   <a class="code" href="oda_8h.html#a24">PROF_BUILD_NLIST_COMM_END</a>
01169 
01170     sendKp.clear();
01171   sendKs.clear();
01172 
01173   <span class="keyword">delete</span> [] sendOffsetsP;
01174   sendOffsetsP = NULL;
01175 
01176   <span class="keyword">delete</span> [] recvOffsetsP;
01177   recvOffsetsP = NULL;
01178 
01179   <span class="keyword">delete</span> [] numKeysSendP;
01180   numKeysSendP = NULL;
01181 
01182   <span class="keyword">delete</span> [] numKeysRecvP;
01183   numKeysRecvP = NULL;
01184 
01185   <span class="keyword">delete</span> [] sendOffsetsS;
01186   sendOffsetsS = NULL;
01187 
01188   <span class="keyword">delete</span> [] recvOffsetsS;
01189   recvOffsetsS = NULL;
01190 
01191   <span class="keyword">delete</span> [] numKeysSendS;
01192   numKeysSendS = NULL;
01193 
01194   <span class="keyword">delete</span> [] numKeysRecvS;
01195   numKeysRecvS = NULL;
01196 
01197   std::vector&lt;ot::NodeAndRanks&gt; recvK2P;
01198   std::vector&lt;ot::NodeAndRanks&gt; recvK2S;
01199   <span class="comment">//recvKp and recvKs are NOT sorted and NOT unique.</span>
01200   <span class="comment">//First merge recvK into recvK2.</span>
01201   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; recvKp.size(); i++) {
01202     <a class="code" href="classot_1_1NodeAndRanks.html">ot::NodeAndRanks</a> tmp;
01203     tmp.<a class="code" href="classot_1_1NodeAndRanks.html#o0">node</a> = recvKp[i];
01204     tmp.<a class="code" href="classot_1_1NodeAndRanks.html#o1">ranks</a>.push_back(recvKp[i].getWeight());
01205     recvK2P.push_back(tmp);
01206   }
01207 
01208   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;recvKs.size();i++) {
01209     <a class="code" href="classot_1_1NodeAndRanks.html">ot::NodeAndRanks</a> tmp;
01210     tmp.<a class="code" href="classot_1_1NodeAndRanks.html#o0">node</a> = recvKs[i];
01211     tmp.<a class="code" href="classot_1_1NodeAndRanks.html#o1">ranks</a>.push_back(recvKs[i].getWeight());
01212     recvK2S.push_back(tmp);
01213   }
01214 
01215   recvKp.clear();  
01216   recvKs.clear();  
01217 
01218   <a class="code" href="Sort_8h.html#a7">std::sort</a>(recvK2P.begin(),recvK2P.end());
01219   <a class="code" href="Sort_8h.html#a7">std::sort</a>(recvK2S.begin(),recvK2S.end());
01220 
01221   <span class="comment">//Make recvK2P Unique and concatenate ranks.</span>
01222   <span class="keywordflow">if</span> (recvK2P.size() &gt;= 2) {
01223     std::vector&lt;ot::NodeAndRanks&gt; tmp(recvK2P.size());
01224     tmp[0] = recvK2P[0];
01225     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSize=1;
01226     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1;i&lt;recvK2P.size();i++) {
01227       <span class="keywordflow">if</span> (tmp[tmpSize-1] != recvK2P[i]) {
01228         <span class="comment">//new entry</span>
01229         tmp[tmpSize] = recvK2P[i];
01230         tmpSize++;
01231       } <span class="keywordflow">else</span> {
01232         tmp[tmpSize-1].<a class="code" href="classot_1_1NodeAndRanks.html#o1">ranks</a>.push_back(recvK2P[i].ranks[0]);
01233       }
01234     }<span class="comment">//end for</span>
01235     tmp.resize(tmpSize);
01236     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;tmpSize;i++) {
01237       seq::makeVectorUnique&lt;int&gt;(tmp[i].ranks,<span class="keyword">false</span>);
01238     }
01239     recvK2P = tmp; 
01240     tmp.clear();
01241   }
01242 
01243   <span class="comment">//Make recvK2S Unique and concatenate ranks.</span>
01244   <span class="keywordflow">if</span> (recvK2S.size() &gt;= 2) {
01245     std::vector&lt;ot::NodeAndRanks&gt; tmp(recvK2S.size());
01246     tmp[0] = recvK2S[0];
01247     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSize=1;
01248     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1;i&lt;recvK2S.size();i++) {
01249       <span class="keywordflow">if</span> (tmp[tmpSize-1] != recvK2S[i]) {
01250         <span class="comment">//new entry</span>
01251         tmp[tmpSize] = recvK2S[i];
01252         tmpSize++;
01253       } <span class="keywordflow">else</span> {
01254         tmp[tmpSize-1].<a class="code" href="classot_1_1NodeAndRanks.html#o1">ranks</a>.push_back(recvK2S[i].ranks[0]);
01255       }
01256     }<span class="comment">//end for</span>
01257     tmp.resize(tmpSize);
01258     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;tmpSize;i++) {
01259       seq::makeVectorUnique&lt;int&gt;(tmp[i].ranks,<span class="keyword">false</span>);
01260     }
01261     recvK2S = tmp; 
01262     tmp.clear();
01263   }
01264 
01265   <span class="comment">//Local Search and update sendNodes and sendCnt.              </span>
01266   std::vector&lt;std::vector&lt;ot::TreeNode&gt; &gt; sendNodesP(m_iNpesActive);
01267   std::vector&lt;std::vector&lt;ot::TreeNode&gt; &gt; sendNodesS(m_iNpesActive);
01268   <span class="comment">//int is necessary here. Set to -1 later.</span>
01269   std::vector&lt;std::vector&lt;int&gt; &gt; idxP(m_iNpesActive);
01270   std::vector&lt;std::vector&lt;int&gt; &gt; idxS(m_iNpesActive);
01271 
01272 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01273 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01274   <span class="keywordflow">if</span>(!m_iRankActive) {
01275     std::cout&lt;&lt;std::endl;
01276     std::cout&lt;&lt;<span class="stringliteral">"Starting Local Search for Second Ring..."</span>&lt;&lt;std::endl;
01277     std::cout&lt;&lt;std::endl;
01278   }
01279   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01280 <span class="preprocessor">#endif</span>
01281 <span class="preprocessor"></span>
01282   <span class="comment">//in is sorted and unique and linear and recvK2 is sorted and unique and linear.    </span>
01283   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;recvK2P.size();i++) {
01284     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
01285     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;ot::TreeNode &gt;(in, recvK2P[i].node, idx,NULL,NULL);
01286 
01287     <span class="keywordflow">if</span> (found) {
01288 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01289 <span class="preprocessor"></span>      assert( (in[idx].isAncestor(recvK2P[i].node)) || (in[idx] == (recvK2P[i].node)) );
01290       assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>) );
01291 <span class="preprocessor">#endif</span>
01292 <span class="preprocessor"></span>
01293       <span class="keywordflow">if</span> ( (in[idx].getAnchor() != recvK2P[i].node.getAnchor()) || 
01294           (!(in[idx].getFlag() &amp; ot::TreeNode::NODE)) ) {
01295         found = <span class="keyword">false</span>;
01296       }
01297     }
01298 
01299     <span class="comment">//Send the result to all the processors that want it.</span>
01300     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; recvK2P[i].ranks.size(); j++) {
01301       <span class="keywordflow">if</span> ( found ) {
01302         <span class="comment">//Send in[idx];</span>
01303         sendNodesP[recvK2P[i].ranks[j]].push_back(in[idx]);          
01304         idxP[recvK2P[i].ranks[j]].push_back(idx);
01305       } <span class="keywordflow">else</span> {
01306         <span class="comment">//Send rootNode;  </span>
01307         sendNodesP[recvK2P[i].ranks[j]].push_back(rootNode);          
01308         idxP[recvK2P[i].ranks[j]].push_back(-1);
01309       }
01310       sendNodesP[recvK2P[i].ranks[j]][sendNodesP[recvK2P[i].ranks[j]].size()-1].setWeight(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
01311     }<span class="comment">//end for j</span>
01312   }<span class="comment">//end for i          </span>
01313 
01314   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;recvK2S.size();i++) {
01315     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
01316     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;ot::TreeNode &gt;(in, recvK2S[i].node, idx, NULL, NULL);
01317     <span class="keywordflow">if</span> (found) {
01318 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01319 <span class="preprocessor"></span>      assert( (in[idx].isAncestor(recvK2S[i].node)) || (in[idx] == (recvK2S[i].node)) );
01320       assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>) );
01321 <span class="preprocessor">#endif</span>
01322 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( (in[idx].getAnchor() != recvK2S[i].node.getAnchor()) || (!(in[idx].getFlag() &amp; ot::TreeNode::NODE)) ) {
01323         found = <span class="keyword">false</span>;
01324       }
01325     }
01326     <span class="comment">//Send the result to all the processors that want it.</span>
01327     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; recvK2S[i].ranks.size(); j++) {
01328       <span class="keywordflow">if</span> ( found ) {
01329         <span class="comment">//Send in[idx];</span>
01330         sendNodesS[recvK2S[i].ranks[j]].push_back(in[idx]);
01331         idxS[recvK2S[i].ranks[j]].push_back(idx);
01332       } <span class="keywordflow">else</span> {
01333         <span class="comment">//Send rootNode;  </span>
01334         sendNodesS[recvK2S[i].ranks[j]].push_back(rootNode);
01335         idxS[recvK2S[i].ranks[j]].push_back(-1);
01336       }
01337       sendNodesS[recvK2S[i].ranks[j]][sendNodesS[recvK2S[i].ranks[j]].size()-1].setWeight(<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
01338     }
01339   }<span class="comment">//end for i          </span>
01340 
01341   recvK2P.clear(); 
01342   recvK2S.clear(); 
01343 
01344   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
01345     seq::makeVectorUnique&lt;TreeNode&gt;(sendNodesP[i],<span class="keyword">false</span>);
01346     seq::makeVectorUnique&lt;TreeNode&gt;(sendNodesS[i],<span class="keyword">false</span>);
01347     seq::makeVectorUnique&lt;int&gt;(idxP[i],<span class="keyword">false</span>);
01348     seq::makeVectorUnique&lt;int&gt;(idxS[i],<span class="keyword">false</span>);
01349   }
01350 
01351   numKeysSendP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
01352   numKeysSendS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
01353   numKeysRecvP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];    
01354   numKeysRecvS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
01355 
01356   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m_iNpesActive; i++) {
01357     numKeysSendP[i] = static_cast&lt;int&gt;(sendNodesP[i].size());
01358     numKeysSendS[i] = static_cast&lt;int&gt;(sendNodesS[i].size());    
01359   }        
01360 
01361 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01362 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01363   <span class="keywordflow">if</span>(!m_iRankActive) {
01364     std::cout&lt;&lt;std::endl;
01365     std::cout&lt;&lt;<span class="stringliteral">"Sending Results after Local Search for Second Ring..."</span>&lt;&lt;std::endl;
01366     std::cout&lt;&lt;std::endl;
01367   }
01368   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01369 <span class="preprocessor">#endif</span>
01370 <span class="preprocessor"></span>
01371   <span class="comment">// Now do an All2All to get inumKeysRecv</span>
01372   <a class="code" href="oda_8h.html#a23">PROF_BUILD_NLIST_COMM_BEGIN</a>
01373 
01374     par::Mpi_Alltoall&lt;int&gt;(numKeysSendP, numKeysRecvP, 1, m_mpiCommActive);
01375   par::Mpi_Alltoall&lt;int&gt;(numKeysSendS, numKeysRecvS, 1, m_mpiCommActive);    
01376 
01377   <a class="code" href="oda_8h.html#a24">PROF_BUILD_NLIST_COMM_END</a>
01378 
01379     <span class="comment">// Now create sendK</span>
01380     sendOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsP[0] = 0;
01381   sendOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsS[0] = 0;
01382   recvOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsP[0] = 0;   
01383   recvOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsS[0] = 0;
01384 
01385   <span class="comment">// compute offsets ...</span>
01386   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;m_iNpesActive; i++) {
01387     sendOffsetsP[i] = sendOffsetsP[i-1] + numKeysSendP[i-1];
01388     recvOffsetsP[i] = recvOffsetsP[i-1] + numKeysRecvP[i-1];
01389 
01390     sendOffsetsS[i] = sendOffsetsS[i-1] + numKeysSendS[i-1];
01391     recvOffsetsS[i] = recvOffsetsS[i-1] + numKeysRecvS[i-1];    
01392   }
01393 
01394   <span class="comment">// create the send and recv buffers ...</span>
01395   sendKp.resize(sendOffsetsP[m_iNpesActive-1] + numKeysSendP[m_iNpesActive-1]);
01396   recvKp.resize(recvOffsetsP[m_iNpesActive-1] + numKeysRecvP[m_iNpesActive-1]);
01397 
01398   sendKs.resize(sendOffsetsS[m_iNpesActive-1] + numKeysSendS[m_iNpesActive-1]);
01399   recvKs.resize(recvOffsetsS[m_iNpesActive-1] + numKeysRecvS[m_iNpesActive-1]);
01400 
01401   std::vector&lt;int&gt; idxSendKp(sendOffsetsP[m_iNpesActive-1] + numKeysSendP[m_iNpesActive-1]);
01402   std::vector&lt;int&gt; idxSendKs(sendOffsetsS[m_iNpesActive-1] + numKeysSendS[m_iNpesActive-1]);
01403 
01404   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
01405     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numKeysSendP[i]; j++) {
01406       <span class="comment">// set entry ...</span>
01407       sendKp[sendOffsetsP[i] + j] = sendNodesP[i][j];       
01408       idxSendKp[sendOffsetsP[i] + j] = idxP[i][j];       
01409 
01410 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01411 <span class="preprocessor"></span>      assert( ((sendKp[sendOffsetsP[i] + j] == rootNode) &amp;&amp; (idxSendKp[sendOffsetsP[i] + j] == -1)) ||
01412           (in[idxSendKp[sendOffsetsP[i] + j]] == sendKp[sendOffsetsP[i] + j]) );
01413 <span class="preprocessor">#endif</span>
01414 <span class="preprocessor"></span>    }
01415     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numKeysSendS[i]; j++) {
01416       <span class="comment">// set entry ...</span>
01417       sendKs[sendOffsetsS[i] + j] = sendNodesS[i][j];    
01418       idxSendKs[sendOffsetsS[i] + j] = idxS[i][j];       
01419 
01420 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01421 <span class="preprocessor"></span>      assert( ((sendKs[sendOffsetsS[i] + j] == rootNode) &amp;&amp; (idxSendKs[sendOffsetsS[i] + j] == -1)) ||
01422           (in[idxSendKs[sendOffsetsS[i] + j]] == sendKs[sendOffsetsS[i] + j]) );
01423 <span class="preprocessor">#endif</span>
01424 <span class="preprocessor"></span>    }
01425   } 
01426 
01427   sendNodesP.clear();
01428   sendNodesS.clear();
01429 
01430   idxP.clear();
01431   idxS.clear();
01432 
01433   sendKpPtr = NULL;
01434   recvKpPtr = NULL;
01435   sendKsPtr = NULL;
01436   recvKsPtr = NULL;
01437   <span class="keywordflow">if</span>(!sendKp.empty()) {
01438     sendKpPtr = &amp;(*(sendKp.begin()));
01439   }
01440   <span class="keywordflow">if</span>(!sendKs.empty()) {
01441     sendKsPtr = &amp;(*(sendKs.begin()));
01442   }
01443   <span class="keywordflow">if</span>(!recvKp.empty()) {
01444     recvKpPtr = &amp;(*(recvKp.begin()));
01445   }
01446   <span class="keywordflow">if</span>(!recvKs.empty()) {
01447     recvKsPtr = &amp;(*(recvKs.begin()));
01448   }
01449 
01450   <a class="code" href="oda_8h.html#a23">PROF_BUILD_NLIST_COMM_BEGIN</a>
01451 
01452     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKpPtr, numKeysSendP, sendOffsetsP,
01453         recvKpPtr, numKeysRecvP, recvOffsetsP, m_mpiCommActive);
01454 
01455   par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKsPtr, numKeysSendS, sendOffsetsS,
01456       recvKsPtr, numKeysRecvS, recvOffsetsS, m_mpiCommActive);
01457 
01458   <a class="code" href="oda_8h.html#a24">PROF_BUILD_NLIST_COMM_END</a>
01459 
01460     <span class="comment">//Store the sizes, will need it later</span>
01461     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> actualRecvKpSz = static_cast&lt;unsigned int&gt;(recvKp.size());
01462   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> actualRecvKsSz = static_cast&lt;unsigned int&gt;(recvKs.size());
01463 
01464   <span class="comment">//The result is sorted except for the fact that there might be multiple</span>
01465   <span class="comment">//roots in the middle. So remove all roots.</span>
01466   std::vector&lt;TreeNode&gt; tmpRecvKp;
01467   std::vector&lt;TreeNode&gt; tmpRecvKs;
01468 
01469   std::vector&lt;unsigned int&gt; kp2ActualKp;
01470   std::vector&lt;unsigned int&gt; ks2ActualKs;
01471 
01472   tmpRecvKp.push_back(rootNode);
01473   kp2ActualKp.push_back(recvKp.size());
01474   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; recvKp.size(); i++) {
01475     <span class="keywordflow">if</span>(recvKp[i] &gt; rootNode) {      
01476       tmpRecvKp.push_back(recvKp[i]);
01477       kp2ActualKp.push_back(i);
01478     }
01479   }
01480 
01481   tmpRecvKs.push_back(rootNode);
01482   ks2ActualKs.push_back(recvKs.size());
01483   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; recvKs.size(); i++) {
01484     <span class="keywordflow">if</span>(recvKs[i] &gt; rootNode) {
01485       tmpRecvKs.push_back(recvKs[i]);
01486       ks2ActualKs.push_back(i);
01487     }
01488   }
01489 
01490   recvKp = tmpRecvKp;
01491   recvKs = tmpRecvKs;
01492 
01493   tmpRecvKp.clear();
01494   tmpRecvKs.clear();
01495 
01496 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01497 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01498   assert(seq::test::isUniqueAndSorted(recvKp));
01499   assert(seq::test::isUniqueAndSorted(recvKs));
01500   <span class="keywordflow">if</span>(!m_iRankActive) {
01501     std::cout&lt;&lt;std::endl;
01502     std::cout&lt;&lt;<span class="stringliteral">"Processing Results in Second Ring..."</span>&lt;&lt;std::endl;
01503     std::cout&lt;&lt;std::endl;
01504   }
01505   MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01506 <span class="preprocessor">#endif</span>
01507 <span class="preprocessor"></span>
01508   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *oldToNewIdx = NULL;
01509   <span class="keywordtype">bool</span> *fromPrimary = NULL;
01510   <span class="keywordtype">bool</span> *fromSecondary = NULL;
01511   <span class="keywordflow">if</span>(!extraAtEnd.empty()) {
01512     oldToNewIdx = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[extraAtEnd.size()];
01513     fromPrimary = <span class="keyword">new</span> <span class="keywordtype">bool</span>[extraAtEnd.size()];
01514     fromSecondary = <span class="keyword">new</span> <span class="keywordtype">bool</span>[extraAtEnd.size()];
01515   }
01516   std::vector&lt;seq::IndexHolder&lt;ot::TreeNode&gt; &gt; extraIndices (extraAtEnd.size());
01517 
01518   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; extraAtEnd.size(); i++) {
01519     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
01520     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;ot::TreeNode &gt;(recvKp, primaryKeys[i], idx, NULL, NULL);
01521 
01522     <span class="keywordflow">if</span> (found) {
01523 
01524       <span class="keywordflow">if</span> (recvKp[idx] == rootNode) {
01525         found = <span class="keyword">false</span>;
01526         fromPrimary[i] = <span class="keyword">false</span>;
01527       } <span class="keywordflow">else</span> {
01528 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01529 <span class="preprocessor"></span>        assert( recvKp[idx].<a class="code" href="classot_1_1DA.html#z36_4">getFlag</a>() &amp; ot::TreeNode::NODE );
01530 <span class="preprocessor">#endif</span>
01531 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( recvKp[idx].getAnchor() != primaryKeys[i].getAnchor() ) {
01532           <span class="comment">//Treat just like it was root.</span>
01533           found = <span class="keyword">false</span>;
01534           fromPrimary[i] = <span class="keyword">false</span>;
01535         }<span class="keywordflow">else</span> {
01536           oldToNewIdx[i] = idx; 
01537           fromPrimary[i] = <span class="keyword">true</span>;
01538           fromSecondary[i] = <span class="keyword">false</span>;
01539           <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp = recvKp[idx];
01540           tmp.<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(extraAtEnd[i].getWeight());
01541           extraAtEnd[i] = tmp;
01542           extraIndices[i].value = &amp;(extraAtEnd[i]);
01543           extraIndices[i].index = i;
01544         }
01545       }        
01546     }<span class="keywordflow">else</span> {
01547       assert(<span class="keyword">false</span>);
01548     }
01549 
01550     <span class="keywordflow">if</span> (!found) {
01551       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
01552       found = seq::maxLowerBound&lt;ot::TreeNode &gt;(recvKs, secondaryKeys[i], idx, NULL, NULL);
01553 
01554 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01555 <span class="preprocessor"></span>      assert( found );
01556       assert( recvKs[idx] != rootNode );
01557       assert( recvKs[idx].<a class="code" href="classot_1_1DA.html#z36_4">getFlag</a>() &amp; ot::TreeNode::NODE );
01558       assert( recvKs[idx].getAnchor() == secondaryKeys[i].getAnchor() );
01559 <span class="preprocessor">#endif</span>
01560 <span class="preprocessor"></span>      <span class="comment">/*</span>
01561 <span class="comment">         Handle Special Case: When a pre-ghost element did not find its primary key in the local search, the secondary key is never searched for. In such situations, when the primary result is not usable and we must pick the secondary result got from the explicit parallel search, we must first check if this secondary result is already present in the local buffer (either own or elements got through a-priori comm.) If so, we must use the one that is already present and discard the one got through the parallel search. This must be done in order to avoid duplicate octants in the local buffer.</span>
01562 <span class="comment">         */</span>
01563       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idxTmp;
01564       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* inPtr = NULL;
01565       <span class="keywordflow">if</span>(!in.empty()) {
01566         inPtr = &amp;(*(in.begin()));
01567       }
01568       found = seq::BinarySearch&lt;ot::TreeNode&gt;(inPtr,
01569           static_cast&lt;unsigned int&gt;(in.size()), recvKs[idx], &amp;idxTmp);
01570 
01571       <span class="keywordflow">if</span>(found) {
01572         fromSecondary[i] = <span class="keyword">false</span>;
01573         oldToNewIdx[i] = idxTmp;
01574         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp = in[idxTmp];
01575         tmp.<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(extraAtEnd[i].getWeight());
01576         extraAtEnd[i] = tmp;
01577         extraIndices[i].value = &amp;(extraAtEnd[i]);
01578         extraIndices[i].index = i;
01579       }<span class="keywordflow">else</span> {    
01580         fromSecondary[i] = <span class="keyword">true</span>;
01581         oldToNewIdx[i] = idx; 
01582         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp = recvKs[idx];
01583         tmp.<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(extraAtEnd[i].getWeight());
01584         extraAtEnd[i] = tmp;
01585         extraIndices[i].value = &amp;(extraAtEnd[i]);
01586         extraIndices[i].index = i;
01587       }
01588     }
01589   }<span class="comment">//end for i</span>
01590 
01591   primaryKeys.clear();
01592   secondaryKeys.clear();
01593   extraAtEnd.clear();
01594 
01595   <a class="code" href="Sort_8h.html#a7">std::sort</a>(extraIndices.begin(),extraIndices.end());
01596 
01597   std::vector&lt;ot::TreeNode&gt; sortedUniqueExtras(extraIndices.size());    
01598   std::vector&lt;unsigned int&gt; chosenIndexIntoOld(extraIndices.size());
01599 
01600   <span class="comment">//Old refers to the unsorted and non-unique extraAtEnd list </span>
01601   std::vector&lt;std::vector&lt; unsigned int&gt; &gt; indicesIntoOld(extraIndices.size());
01602 
01603   <span class="comment">//LUT refers to localOcts (in)</span>
01604   std::vector&lt;std::vector&lt; unsigned int&gt; &gt; indicesIntoLUT(extraIndices.size());
01605 
01606   <span class="keywordflow">if</span> (!extraIndices.empty()) {
01607     sortedUniqueExtras[0] = *(extraIndices[0].value);
01608     chosenIndexIntoOld[0] = extraIndices[0].index;
01609 
01610     indicesIntoOld[0].push_back(extraIndices[0].index);
01611     indicesIntoLUT[0].push_back(extraIndices[0].value-&gt;getWeight());
01612   }
01613   <span class="comment">//Make  Unique and concatenate ranks.</span>
01614   <span class="keywordflow">if</span> (extraIndices.size() &gt;= 2) {
01615     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSize=1;
01616     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1;i&lt;extraIndices.size();i++) {
01617       <span class="keywordflow">if</span> (sortedUniqueExtras[tmpSize-1] != *(extraIndices[i].value)) {
01618         <span class="comment">//New entry</span>
01619         sortedUniqueExtras[tmpSize] = *(extraIndices[i].value);
01620         chosenIndexIntoOld[tmpSize] =  extraIndices[i].index;
01621 
01622         indicesIntoOld[tmpSize].push_back(extraIndices[i].index);
01623         indicesIntoLUT[tmpSize].push_back(extraIndices[i].value-&gt;getWeight());
01624         tmpSize++;
01625       } <span class="keywordflow">else</span> {
01626         indicesIntoOld[tmpSize-1].push_back(extraIndices[i].index);
01627         indicesIntoLUT[tmpSize-1].push_back(extraIndices[i].value-&gt;getWeight());
01628       }
01629     }<span class="comment">//end for</span>
01630 
01631     sortedUniqueExtras.resize(tmpSize);
01632 
01633 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01634 <span class="preprocessor"></span>    assert(seq::test::isUniqueAndSorted&lt;TreeNode &gt;(sortedUniqueExtras));
01635 <span class="preprocessor">#endif</span>
01636 <span class="preprocessor"></span>
01637     chosenIndexIntoOld.resize(tmpSize);
01638 
01639     indicesIntoOld.resize(tmpSize);
01640     indicesIntoLUT.resize(tmpSize);      
01641 
01642     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;tmpSize;i++) {
01643       <a class="code" href="Sort_8h.html#a7">std::sort</a>(indicesIntoOld[i].begin(),indicesIntoOld[i].<a class="code" href="classot_1_1DA.html#z36_2">end</a>());
01644       <a class="code" href="Sort_8h.html#a7">std::sort</a>(indicesIntoLUT[i].begin(),indicesIntoLUT[i].<a class="code" href="classot_1_1DA.html#z36_2">end</a>());        
01645 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01646 <span class="preprocessor"></span>      <span class="comment">//Ensuring that all the 8 vertices of an element map to different indices. </span>
01647       assert(seq::test::isUniqueAndSorted&lt;unsigned int&gt;(indicesIntoOld[i]));
01648       assert(seq::test::isUniqueAndSorted&lt;unsigned int&gt;(indicesIntoLUT[i]));
01649 <span class="preprocessor">#endif</span>
01650 <span class="preprocessor"></span>    }<span class="comment">//end for i      </span>
01651 
01652   }
01653 
01654   extraIndices.clear();
01655 
01656   <span class="comment">/*</span>
01657 <span class="comment">     std::vector&lt;bool&gt; pickPrimary(sortedUniqueExtras.size());</span>
01658 <span class="comment">     std::vector&lt;unsigned int&gt; oldIndex(sortedUniqueExtras.size());</span>
01659 <span class="comment"></span>
01660 <span class="comment">  //The same extra key can come from primary or secondary and from multiple</span>
01661 <span class="comment">  //pre-ghosts. So pick one.</span>
01662 <span class="comment">  //Some arbit default rule is used to make this decision...</span>
01663 <span class="comment">  //Here. The rule is simply if this key was some element's primary key use</span>
01664 <span class="comment">  //that. In this case, the smallest element is chosen. Else, the last</span>
01665 <span class="comment">  //element is chosen (secondary key).</span>
01666 <span class="comment">  //Note: indicesIntoOld[i] is sorted and unique.</span>
01667 <span class="comment">  for (unsigned int i=0; i &lt; sortedUniqueExtras.size(); i++) {</span>
01668 <span class="comment">  pickPrimary[i] = false;</span>
01669 <span class="comment">  for (unsigned int j = 0; j &lt; indicesIntoOld[i].size(); j++) {</span>
01670 <span class="comment">  oldIndex[i] = indicesIntoOld[i][j];</span>
01671 <span class="comment">  if (fromPrimary[indicesIntoOld[i][j]]) {</span>
01672 <span class="comment">  pickPrimary[i] = true;         </span>
01673 <span class="comment">  break;       </span>
01674 <span class="comment">  }</span>
01675 <span class="comment">  }//end for j</span>
01676 <span class="comment">  }//end for i</span>
01677 <span class="comment">  */</span>
01678 
01679   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *recvCntsExtras = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[m_iNpesActive];        
01680 
01681   std::vector&lt;char&gt; pickingP(actualRecvKpSz);
01682   std::vector&lt;char&gt; pickingS(actualRecvKsSz);
01683 
01684   std::vector&lt;char&gt; pickedP(sendKp.size());
01685   std::vector&lt;char&gt; pickedS(sendKs.size());
01686 
01687   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; actualRecvKpSz; i++) {
01688     pickingP[i] = 0;
01689   }
01690 
01691   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; actualRecvKsSz; i++) {
01692     pickingS[i] = 0;
01693   }
01694 
01695   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
01696     recvCntsExtras[i] = 0;
01697   }
01698 
01699   <span class="comment">// std::cout &lt;&lt; m_iRankActive &lt;&lt; " Correcting LuTs" &lt;&lt; std::endl;</span>
01700 
01701   <span class="comment">//Do not do an in-place update of nlist. Instead store the corrections. </span>
01702   std::vector&lt; std::vector&lt;unsigned int&gt; &gt; secondRingCorrections;
01703 
01704   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;sortedUniqueExtras.size();i++) {
01705 
01706     <span class="comment">/*</span>
01707 <span class="comment">       if (pickPrimary[i]) {</span>
01708 <span class="comment">#ifdef __DEBUG_DA_NLIST__</span>
01709 <span class="comment">assert( recvKp[oldToNewIdx[oldIndex[i]]] == sortedUniqueExtras[i] );</span>
01710 <span class="comment">assert( recvKp[oldToNewIdx[oldIndex[i]]] != rootNode );</span>
01711 <span class="comment">#endif</span>
01712 <span class="comment">in.push_back(recvKp[oldToNewIdx[oldIndex[i]]]);        </span>
01713 <span class="comment">recvCntsExtras[recvKp[oldToNewIdx[oldIndex[i]]].getWeight()]++;</span>
01714 <span class="comment">pickingP[kp2ActualKp[oldToNewIdx[oldIndex[i]]]] = 1;</span>
01715 <span class="comment">} else {</span>
01716 <span class="comment">#ifdef __DEBUG_DA_NLIST__</span>
01717 <span class="comment">assert( recvKs[oldToNewIdx[oldIndex[i]]] == sortedUniqueExtras[i] );</span>
01718 <span class="comment">assert( recvKs[oldToNewIdx[oldIndex[i]]] != rootNode );</span>
01719 <span class="comment">#endif</span>
01720 <span class="comment">in.push_back(recvKs[oldToNewIdx[oldIndex[i]]]);        </span>
01721 <span class="comment">recvCntsExtras[recvKs[oldToNewIdx[oldIndex[i]]].getWeight()]++;</span>
01722 <span class="comment">pickingS[ks2ActualKs[oldToNewIdx[oldIndex[i]]]] = 1;</span>
01723 <span class="comment">}</span>
01724 <span class="comment"></span>
01725 <span class="comment">for (unsigned int j =0;j &lt; indicesIntoLUT[i].size(); j++) {</span>
01726 <span class="comment">for (unsigned int k=0; k &lt; 8; k++) {</span>
01727 <span class="comment">for (unsigned int l = 0;l &lt; indicesIntoOld[i].size(); l++) {</span>
01728 <span class="comment">if (nlist[8*(indicesIntoLUT[i][j])+k] == (m_uiLocalBufferSize + indicesIntoOld[i][l])) {</span>
01729 <span class="comment">std::vector&lt;unsigned int&gt; ringCorrectionsTuple(3);</span>
01730 <span class="comment">ringCorrectionsTuple[0] = indicesIntoLUT[i][j];</span>
01731 <span class="comment">ringCorrectionsTuple[1] = k;</span>
01732 <span class="comment">ringCorrectionsTuple[2] = (in.size()-1);</span>
01733 <span class="comment">secondRingCorrections.push_back(ringCorrectionsTuple);</span>
01734 <span class="comment">break;</span>
01735 <span class="comment">} // if </span>
01736 <span class="comment">} // for l                   </span>
01737 <span class="comment">}  // for k     </span>
01738 <span class="comment">} // for j</span>
01739 <span class="comment">*/</span>
01740 
01741   <span class="keywordflow">if</span> (fromPrimary[chosenIndexIntoOld[i]]) {
01742 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01743 <span class="preprocessor"></span>    assert( recvKp[oldToNewIdx[chosenIndexIntoOld[i]]] == sortedUniqueExtras[i] );
01744     assert( recvKp[oldToNewIdx[chosenIndexIntoOld[i]]] != rootNode );
01745 <span class="preprocessor">#endif</span>
01746 <span class="preprocessor"></span>    in.push_back(recvKp[oldToNewIdx[chosenIndexIntoOld[i]]]);        
01747     recvCntsExtras[recvKp[oldToNewIdx[chosenIndexIntoOld[i]]].getWeight()]++;
01748     pickingP[kp2ActualKp[oldToNewIdx[chosenIndexIntoOld[i]]]] = 1;
01749   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(fromSecondary[chosenIndexIntoOld[i]]) {
01750 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01751 <span class="preprocessor"></span>    assert( recvKs[oldToNewIdx[chosenIndexIntoOld[i]]] == sortedUniqueExtras[i] );
01752     assert( recvKs[oldToNewIdx[chosenIndexIntoOld[i]]] != rootNode );
01753 <span class="preprocessor">#endif</span>
01754 <span class="preprocessor"></span>    in.push_back(recvKs[oldToNewIdx[chosenIndexIntoOld[i]]]);        
01755     recvCntsExtras[recvKs[oldToNewIdx[chosenIndexIntoOld[i]]].getWeight()]++;
01756     pickingS[ks2ActualKs[oldToNewIdx[chosenIndexIntoOld[i]]]] = 1;
01757   }
01758 
01759 <span class="comment">//If the element is neither in primary nor in secondary,</span>
01760 <span class="comment">//then 'in' already has it. So no need to append it into 'in' again.</span>
01761 <span class="comment">//Note, that we will never select a copy of sortedUniqueExtras[i] from primary or secondary if the element already exists within in.</span>
01762 
01763 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j =0;j &lt; indicesIntoLUT[i].size(); j++) {
01764   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k &lt; 8; k++) {
01765     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = 0;l &lt; indicesIntoOld[i].size(); l++) {
01766       <span class="keywordflow">if</span> (nlist[8*(indicesIntoLUT[i][j])+k] == (<a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a> + indicesIntoOld[i][l])) {
01767         std::vector&lt;unsigned int&gt; ringCorrectionsTuple(3);
01768         ringCorrectionsTuple[0] = indicesIntoLUT[i][j];
01769         ringCorrectionsTuple[1] = k;
01770 
01771         <span class="keywordflow">if</span>( fromPrimary[chosenIndexIntoOld[i]] || fromSecondary[chosenIndexIntoOld[i]] ) {
01772           ringCorrectionsTuple[2] = (static_cast&lt;unsigned int&gt;(in.size()) - 1);
01773         }<span class="keywordflow">else</span> {
01774           ringCorrectionsTuple[2] = oldToNewIdx[chosenIndexIntoOld[i]];
01775         }
01776 
01777         secondRingCorrections.push_back(ringCorrectionsTuple);
01778         <span class="keywordflow">break</span>;
01779       } <span class="comment">// if </span>
01780     } <span class="comment">// for l                   </span>
01781   }  <span class="comment">// for k     </span>
01782 } <span class="comment">// for j</span>
01783 
01784 } <span class="comment">// for i</span>
01785 
01786 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; secondRingCorrections.size(); i++) {
01787   <span class="comment">//Actual Correction here...</span>
01788   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elemId = secondRingCorrections[i][0];
01789   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = secondRingCorrections[i][1];
01790   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lutVal = secondRingCorrections[i][2];
01791   nlist[8*elemId+vtxId] = lutVal;
01792 
01793 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01794 <span class="preprocessor"></span>  assert( lutVal &lt; in.size() );
01795 <span class="preprocessor">#endif</span>
01796 <span class="preprocessor"></span>
01797   <span class="comment">// correct hanging node mask ...</span>
01798   <span class="comment">// check if any of the nodes is hanging ...</span>
01799   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x,_y,_z;
01800 
01801   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[elemId].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
01802   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[elemId].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
01803   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[elemId].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
01804   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[elemId].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01805   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = (1u &lt;&lt; (<a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d));
01806 
01807 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01808 <span class="preprocessor"></span>  <span class="comment">//You might have to find the actual node via final corrections</span>
01809   <span class="comment">//(explicit parallel search) although you sent yourself apriori</span>
01810   <span class="comment">//(Second Ring). </span>
01811   <span class="keywordflow">if</span>( (elemId &gt;= m_uiElementBegin) &amp;&amp; (elemId &lt; m_uiPostGhostBegin) ) {
01812     <span class="keywordflow">if</span>(in[lutVal] &lt; in[m_uiElementBegin]) {
01813       std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Trying to send yourself as a Post Ghost ELEMENT for  elemId = "</span>
01814         &lt;&lt;elemId&lt;&lt;<span class="stringliteral">" vtxId = "</span>&lt;&lt;vtxId&lt;&lt;std::endl;
01815       assert(<span class="keyword">false</span>);
01816     }
01817     <span class="keywordflow">if</span>( (<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> &lt; in.size()) &amp;&amp; (in[lutVal] &gt;= in[m_uiPostGhostBegin]) ) {
01818       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmpToSend = in[lutVal];
01819       tmpToSend.<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(elemId);
01820       checkSecondRing.push_back(tmpToSend);
01821     }
01822   }
01823 <span class="preprocessor">#endif</span>
01824 <span class="preprocessor"></span>
01825   _x = in[lutVal].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>(); 
01826   _y = in[lutVal].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>(); 
01827   _z = in[lutVal].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>(); 
01828 
01829 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01830 <span class="preprocessor"></span>  <span class="keywordflow">if</span> ( !(in[lutVal].getFlag() &amp; ot::TreeNode::NODE ) ) {
01831     <span class="comment">//Second ring must find a node only </span>
01832     assert(<span class="keyword">false</span>);
01833   }
01834 <span class="preprocessor">#endif</span>
01835 <span class="preprocessor"></span>
01836   <span class="keywordflow">switch</span> (vtxId) {
01837     <span class="keywordflow">case</span> 0:
01838       assert(<span class="keyword">false</span>);
01839       <span class="keywordflow">break</span>;
01840     <span class="keywordflow">case</span> 1:
01841       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( z != _z ) ) {
01842         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
01843       }
01844       <span class="keywordflow">break</span>;
01845     <span class="keywordflow">case</span> 2:
01846       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
01847         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
01848       }
01849       <span class="keywordflow">break</span>;
01850     <span class="keywordflow">case</span> 3:
01851       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
01852         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
01853       }
01854       <span class="keywordflow">break</span>;
01855     <span class="keywordflow">case</span> 4:
01856       <span class="keywordflow">if</span> ( ( x != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
01857         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
01858       }
01859       <span class="keywordflow">break</span>;
01860     <span class="keywordflow">case</span> 5:
01861       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
01862         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
01863       }
01864       <span class="keywordflow">break</span>;
01865     <span class="keywordflow">case</span> 6:
01866       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
01867         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
01868       }
01869       <span class="keywordflow">break</span>;
01870     <span class="keywordflow">case</span> 7:
01871       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
01872         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
01873       }
01874       <span class="keywordflow">break</span>;
01875   } <span class="comment">// switch (vtxId)</span>
01876 
01877 }<span class="comment">//end for i</span>
01878 
01879 secondRingCorrections.clear();
01880 
01881 <span class="comment">//pickPrimary.clear();</span>
01882 <span class="comment">//oldIndex.clear();</span>
01883 
01884 sortedUniqueExtras.clear();
01885 chosenIndexIntoOld.clear();
01886 
01887 indicesIntoLUT.clear();
01888 indicesIntoOld.clear();
01889 
01890 kp2ActualKp.clear();
01891 ks2ActualKs.clear();
01892 
01893 sendKp.clear();
01894 sendKs.clear();
01895 recvKp.clear(); 
01896 recvKs.clear();  
01897 
01898 <span class="keywordflow">if</span>(oldToNewIdx) {
01899   <span class="keyword">delete</span> [] oldToNewIdx;
01900   oldToNewIdx = NULL;
01901 }
01902 
01903 <span class="keywordflow">if</span>(fromPrimary) {
01904   <span class="keyword">delete</span> [] fromPrimary;    
01905   fromPrimary = NULL;
01906 }
01907 
01908 <span class="keywordflow">if</span>(fromSecondary) {
01909   <span class="keyword">delete</span> [] fromSecondary;
01910   fromSecondary = NULL;
01911 }
01912 
01913 <span class="comment">// Set secondary comm variables ...</span>
01914 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;m_iNpesActive; i++) {
01915   <span class="keywordflow">if</span> (recvCntsExtras[i]) {
01916     ScndRecvProcs.push_back(i);
01917     ScndRecvCounts.push_back(recvCntsExtras[i]); 
01918 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01919 <span class="preprocessor"></span>    std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Scnd Recv P : "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" Scnd Recv C : "</span>&lt;&lt; recvCntsExtras[i]&lt;&lt;std::endl;
01920     assert(i != <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
01921 <span class="preprocessor">#endif</span>
01922 <span class="preprocessor"></span>  }
01923 }
01924 
01925 <span class="keywordflow">if</span>(recvCntsExtras) {
01926   <span class="keyword">delete</span> [] recvCntsExtras;    
01927   recvCntsExtras = NULL;
01928 }
01929 
01930 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01931 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01932 <span class="keywordflow">if</span>(!m_iRankActive) {
01933   std::cout&lt;&lt;std::endl;
01934   std::cout&lt;&lt;<span class="stringliteral">"Returning Selection in Second Ring..."</span>&lt;&lt;std::endl;
01935   std::cout&lt;&lt;std::endl;
01936 }
01937 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01938 <span class="preprocessor">#endif</span>
01939 <span class="preprocessor"></span>
01940 <span class="keywordtype">char</span>* pickingPptr = NULL;
01941 <span class="keywordtype">char</span>* pickedPptr = NULL;
01942 <span class="keywordtype">char</span>* pickingSptr = NULL;
01943 <span class="keywordtype">char</span>* pickedSptr = NULL;
01944 
01945 <span class="keywordflow">if</span>(!pickingP.empty()) {
01946   pickingPptr = &amp;(*(pickingP.begin()));
01947 }
01948 <span class="keywordflow">if</span>(!pickingS.empty()) {
01949   pickingSptr = &amp;(*(pickingS.begin()));
01950 }
01951 <span class="keywordflow">if</span>(!pickedP.empty()) {
01952   pickedPptr = &amp;(*(pickedP.begin()));
01953 }
01954 <span class="keywordflow">if</span>(!pickedS.empty()) {
01955   pickedSptr = &amp;(*(pickedS.begin()));
01956 }
01957 
01958 <a class="code" href="oda_8h.html#a23">PROF_BUILD_NLIST_COMM_BEGIN</a>
01959 
01960 par::Mpi_Alltoallv_sparse&lt;char&gt;(pickingPptr ,numKeysRecvP, recvOffsetsP , 
01961     pickedPptr, numKeysSendP, sendOffsetsP, m_mpiCommActive);
01962 
01963 par::Mpi_Alltoallv_sparse&lt;char&gt;(pickingSptr ,numKeysRecvS, recvOffsetsS, 
01964     pickedSptr, numKeysSendS, sendOffsetsS , m_mpiCommActive);
01965 
01966 <a class="code" href="oda_8h.html#a24">PROF_BUILD_NLIST_COMM_END</a>
01967 
01968 pickingP.clear();
01969 pickingS.clear();
01970 
01971 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01972 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01973 <span class="keywordflow">if</span>(!m_iRankActive) {
01974   std::cout&lt;&lt;std::endl;
01975   std::cout&lt;&lt;<span class="stringliteral">"Second ScatterMap..."</span>&lt;&lt;std::endl;
01976   std::cout&lt;&lt;std::endl;
01977 }
01978 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
01979 <span class="preprocessor">#endif</span>
01980 <span class="preprocessor"></span>
01981 <span class="comment">//Create ScatterMap here using sendKp, recvKp, pickedP...</span>
01982 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cnt=0, pickedCnt=0;
01983 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pCnt=0, sCnt=0;
01984 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; static_cast&lt;unsigned int&gt;(m_iNpesActive); i++) {
01985   cnt=0;
01986   pickedCnt=0;
01987   <span class="comment">// merge and pick entries from both primary and secondary lists being sent to procs ...</span>
01988   <span class="keywordflow">while</span> (cnt &lt; (numKeysSendP[i] + numKeysSendS[i]) ) {
01989     <span class="comment">// sOver := sCnt &gt;= (sendOffsetsS[i] + numKeysSendS[i]);</span>
01990     <span class="comment">// pOver := pCnt &gt;= (sendOffsetsP[i] + numKeysSendP[i]);</span>
01991     <span class="comment">// sRemains = sCnt &lt; (sendOffsetsS[i] + numKeysSendS[i]);</span>
01992     <span class="comment">// pRemains = pCnt &lt; (sendOffsetsP[i] + numKeysSendP[i]);</span>
01993     <span class="keywordflow">if</span> ( (sCnt &gt;= (sendOffsetsS[i] + numKeysSendS[i])) ||
01994         ( ( pCnt &lt; (sendOffsetsP[i] + numKeysSendP[i]) ) &amp;&amp;
01995           ( idxSendKp[pCnt] &lt;= idxSendKs[sCnt]) ) ) {
01996 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
01997 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(idxSendKp[pCnt] == -1) {
01998         assert(!pickedP[pCnt]);
01999       }
02000 <span class="preprocessor">#endif</span>
02001 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (pickedP[pCnt]) {
02002         ScndScatterMap.push_back(idxSendKp[pCnt]);
02003         pickedCnt++;
02004       }
02005       pCnt++;
02006     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( pCnt &gt;=
02007           static_cast&lt;unsigned int&gt;(sendOffsetsP[i] + numKeysSendP[i]) ) ||
02008         ( sCnt &lt; static_cast&lt;unsigned int&gt;(sendOffsetsS[i] + numKeysSendS[i]) ) ) {
02009 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02010 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(idxSendKs[sCnt] == -1) {
02011         assert(!pickedS[sCnt]);
02012       }
02013 <span class="preprocessor">#endif</span>
02014 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (pickedS[sCnt]) {
02015         ScndScatterMap.push_back(idxSendKs[sCnt]);
02016         pickedCnt++;
02017       }
02018       sCnt++;
02019     } <span class="keywordflow">else</span> {
02020       std::cout &lt;&lt; <span class="stringliteral">"Scnd skipped both"</span> &lt;&lt; std::endl;
02021     }
02022     cnt++;
02023   }<span class="comment">//end while</span>
02024   <span class="keywordflow">if</span> (pickedCnt) {
02025     ScndSendProcs.push_back(i);  
02026     ScndSendCounts.push_back(pickedCnt);
02027 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02028 <span class="preprocessor"></span>    std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Scnd Send P : "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" Scnd Send C : "</span>&lt;&lt; pickedCnt&lt;&lt;std::endl;
02029     assert(i != <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>);
02030 <span class="preprocessor">#endif</span>
02031 <span class="preprocessor"></span>  }
02032 }<span class="comment">//end for i</span>
02033 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02034 <span class="preprocessor"></span><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
02035   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numToSend_i = 0;
02036   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = sendOffsetsP[i]; j &lt; (sendOffsetsP[i] + numKeysSendP[i]); j++) {
02037     <span class="keywordflow">if</span>(pickedP[j]) {
02038       numToSend_i++;
02039     }
02040   }<span class="comment">//end for j</span>
02041   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = sendOffsetsS[i]; j &lt; (sendOffsetsS[i] + numKeysSendS[i]); j++) {
02042     <span class="keywordflow">if</span>(pickedS[j]) {
02043       numToSend_i++;
02044     }
02045   }<span class="comment">//end for j</span>
02046   <span class="keywordflow">if</span>(numToSend_i) {
02047     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Actually should send "</span>&lt;&lt;numToSend_i&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt;i&lt;&lt;std::endl;
02048   }
02049 }<span class="comment">//end for i</span>
02050 <span class="preprocessor">#endif</span>
02051 <span class="preprocessor"></span>
02052 <span class="comment">//Reset LocalBuffer Size</span>
02053 <a class="code" href="classot_1_1DA.html#p44">m_uiLocalBufferSize</a> = static_cast&lt;unsigned int&gt;(in.size());
02054 
02055 idxSendKp.clear();
02056 idxSendKs.clear();
02057 
02058 <span class="keyword">delete</span> [] sendOffsetsP;
02059 sendOffsetsP = NULL;
02060 
02061 <span class="keyword">delete</span> [] sendOffsetsS;
02062 sendOffsetsS = NULL;
02063 
02064 <span class="keyword">delete</span> [] numKeysSendP;
02065 numKeysSendP = NULL;
02066 
02067 <span class="keyword">delete</span> [] numKeysSendS;
02068 numKeysSendS = NULL;
02069 
02070 <span class="keyword">delete</span> [] numKeysRecvP;
02071 numKeysRecvP = NULL;
02072 
02073 <span class="keyword">delete</span> [] recvOffsetsP;    
02074 recvOffsetsP = NULL;
02075 
02076 <span class="keyword">delete</span> [] recvOffsetsS;
02077 recvOffsetsS = NULL;
02078 
02079 <span class="keyword">delete</span> [] numKeysRecvS;
02080 numKeysRecvS = NULL;
02081 
02082 pickedP.clear();
02083 pickedS.clear();   
02084 
02085 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02086 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02087 <span class="keywordflow">if</span>(!m_iRankActive) {
02088   std::cout&lt;&lt;std::endl;
02089   std::cout&lt;&lt;<span class="stringliteral">"Finished Correction for Second Ring..."</span>&lt;&lt;std::endl;
02090   std::cout&lt;&lt;std::endl;
02091 }
02092 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02093 <span class="preprocessor">#endif</span>
02094 <span class="preprocessor"></span>
02095 <span class="comment">//~~~~~~~~~~~~~~~~Correction for Second Ring Ends~~~~~~~~~~~~~~//</span>
02096 
02097 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02098 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02099 <span class="comment">//CHECK if apriori comm for Second ring actually works.</span>
02100 <span class="comment">//Check if primary scattermap contains the right element and if it is</span>
02101 <span class="comment">//sent to the right processor</span>
02102 <span class="comment">//checkSecondRing[i] is a post-ghost element on the local proc, to which one of</span>
02103 <span class="comment">//my own elements are pointing to. The corresponding index of my own element is</span>
02104 <span class="comment">//stored in the weight of checkSecondRing[i]. </span>
02105 std::vector&lt;std::vector&lt;unsigned int&gt; &gt; secondRingExpectedScatterMap(m_iNpesActive);
02106 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; checkSecondRing.size(); i++) {
02107   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bId;
02108   <span class="comment">//Find the processor that owns the node.</span>
02109   <span class="keywordtype">bool</span> bucketFound = seq::maxLowerBound&lt;ot::TreeNode&gt;(m_tnMinAllBlocks, checkSecondRing[i], bId, NULL, NULL);
02110   assert(bucketFound);
02111   assert(bId &lt; m_iNpesActive);
02112   assert( m_tnMinAllBlocks[bId] &lt;= checkSecondRing[i] );
02113   secondRingExpectedScatterMap[bId].push_back(checkSecondRing[i].getWeight());
02114 }
02115 
02116 assert(seq::test::isUniqueAndSorted(<a class="code" href="classot_1_1DA.html#p68">m_uipSendProcs</a>));
02117 
02118 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> toSendCnt = 0;
02119 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currOffset = 0;
02120 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
02121   seq::makeVectorUnique&lt;unsigned int&gt;(secondRingExpectedScatterMap[i], <span class="keyword">false</span>) ;
02122   <span class="keywordflow">if</span>( (toSendCnt &lt; m_uipSendProcs.size()) &amp;&amp; (m_uipSendProcs[toSendCnt] == i) ) {
02123     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = currOffset; j &lt; (currOffset + <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[toSendCnt] - 1); j++ ) {
02124       assert(<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[j] &lt; <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[j+1]);
02125     }
02126     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> st = 0;    
02127     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; secondRingExpectedScatterMap[i].size(); j++) {
02128       <span class="keywordtype">bool</span> foundIt = <span class="keyword">false</span>;
02129       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = st; k &lt; <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[toSendCnt]; k++) {
02130         assert( (currOffset + k) &lt; <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.size() );
02131         <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[currOffset + k] == secondRingExpectedScatterMap[i][j] ) {
02132           foundIt = <span class="keyword">true</span>;
02133           <span class="comment">//secondRingExpectedScatterMap[i] is Sorted and Unique.</span>
02134           <span class="comment">//Primary ScatterMap is also sorted and Unique for each processor </span>
02135           st = (k+1); 
02136           <span class="keywordflow">break</span>;
02137         }
02138       }<span class="comment">//end for k</span>
02139       <span class="keywordflow">if</span>(!foundIt) {
02140         std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" should have sent in["</span>&lt;&lt;
02141           secondRingExpectedScatterMap[i][j]&lt;&lt;<span class="stringliteral">"]: "</span>&lt;&lt;in[secondRingExpectedScatterMap[i][j]]
02142           &lt;&lt;<span class="stringliteral">"  to "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" in primary. But did not."</span>&lt;&lt;std::endl; 
02143         assert(<span class="keyword">false</span>);
02144       }
02145     }<span class="comment">//end for j</span>
02146     currOffset += <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[toSendCnt];
02147     toSendCnt++;
02148   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( !(secondRingExpectedScatterMap[i].empty()) ) {
02149     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" should have sent some elements to "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" in primary."</span>
02150       &lt;&lt;<span class="stringliteral">" But did not. toSendCnt: "</span>&lt;&lt;toSendCnt&lt;&lt;<span class="stringliteral">" primarySz: "</span>&lt;&lt;(m_uipSendProcs.size())&lt;&lt;std::endl; 
02151     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" For example, This element was not found in primary ScatterMap: "</span>
02152       &lt;&lt;in[secondRingExpectedScatterMap[i][0]]&lt;&lt;std::endl;
02153     assert(<span class="keyword">false</span>);
02154   }<span class="comment">//end if ranks match</span>
02155 }<span class="comment">//end for i</span>
02156 
02157 secondRingExpectedScatterMap.clear();
02158 checkSecondRing.clear();
02159 
02160 <span class="keywordflow">if</span>(!m_iRankActive) {
02161   std::cout&lt;&lt;<span class="stringliteral">" Finished Checking Apriori send for Second Ring.."</span>&lt;&lt;std::endl;
02162 }
02163 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02164 <span class="preprocessor">#endif</span>
02165 <span class="preprocessor"></span>
02166 <span class="comment">//~~~~~~~~~~~Sort In, Flag Corrections as FOREIGN, update Luts~~~~~~~~~~~~~~~~~</span>
02167 
02168 <span class="comment">// Now resort in, and correct nlist and scattermap.</span>
02169 std::vector&lt;seq::IndexHolder&lt;ot::TreeNode&gt; &gt; inHolder(in.size());
02170 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; in.size(); i++) {
02171   in[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(i);
02172   inHolder[i].value = &amp;in[i];
02173   <span class="keywordflow">if</span>( i &gt;= nelem ) {
02174     <span class="comment">//Mark new octants, old postghosts and boundaries </span>
02175     <span class="comment">//Note, OLD FOREIGNs are NOT marked here itself. Old FOREIGNs will be</span>
02176     <span class="comment">//identified later. If not, it will mess up the computation of</span>
02177     <span class="comment">//new nelem for cases which do not have any own elements. </span>
02178     inHolder[i].index = 0;
02179   }<span class="keywordflow">else</span> {
02180     inHolder[i].index = 1;
02181   }
02182 } <span class="comment">// end i for resort set weights ...</span>
02183 
02184 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02185 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02186 <span class="keywordflow">if</span>(!m_iRankActive) {
02187   std::cout&lt;&lt;std::endl;
02188   std::cout&lt;&lt;<span class="stringliteral">"created inHolder..."</span>&lt;&lt;std::endl;
02189   std::cout&lt;&lt;std::endl;
02190 }
02191 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02192 <span class="preprocessor">#endif</span>
02193 <span class="preprocessor"></span>
02194 <span class="comment">// Now resort ...</span>
02195 <a class="code" href="Sort_8h.html#a7">std::sort</a>( inHolder.begin(), inHolder.end() );
02196 
02197 assert(<a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> &lt; in.size());
02198 <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  myFirstOctant = in[m_uiElementBegin];
02199 assert( (<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> - 1) &lt; in.size() );
02200 <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  myLastOctant = in[<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> - 1];
02201 
02202 <span class="comment">//This is a misnomer. It is really the index of the last element for</span>
02203 <span class="comment">//which the LUT was constructed.</span>
02204 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> oldNelem = iLoopEnd;
02205 <span class="comment">//Correct nelem...</span>
02206 nelem = static_cast&lt;unsigned int&gt;(in.size());
02207 <span class="keywordflow">while</span>( (nelem &gt; 0) &amp;&amp; (inHolder[nelem-1].index == 0) ) {
02208   nelem--;
02209 }
02210 
02211 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02212 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02213 <span class="keywordflow">if</span>(!m_iRankActive) {
02214   std::cout&lt;&lt;std::endl;
02215   std::cout&lt;&lt;<span class="stringliteral">"Corrected NELEM..."</span>&lt;&lt;std::endl;
02216   std::cout&lt;&lt;std::endl;
02217 }
02218 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02219 <span class="preprocessor">#endif</span>
02220 <span class="preprocessor"></span>
02221 <span class="comment">// Wts of in gives us new-&gt;old mapping. However to correct</span>
02222 <span class="comment">// nlist we need old-&gt;new mapping. So we need to generate this.</span>
02223 std::vector&lt;unsigned int&gt; oldToNew(in.size());
02224 
02225 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
02226   oldToNew[inHolder[i].value-&gt;getWeight()] = i;
02227 } <span class="comment">// end i for remap indices</span>
02228 
02229 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02230 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02231 <span class="keywordflow">if</span>(!m_iRankActive) {
02232   std::cout&lt;&lt;std::endl;
02233   std::cout&lt;&lt;<span class="stringliteral">"Computed Old2New..."</span>&lt;&lt;std::endl;
02234   std::cout&lt;&lt;std::endl;
02235 }
02236 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02237 <span class="preprocessor">#endif</span>
02238 <span class="preprocessor"></span>
02239 <span class="comment">//Re-shuffle in.</span>
02240 std::vector&lt;ot::TreeNode&gt; tmpIn(in.size());
02241 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;  i &lt; in.size(); i++) {
02242   tmpIn[i] = *(inHolder[i].value);
02243   <span class="keywordflow">if</span>( (inHolder[i].value-&gt;getWeight() &lt; oldNelem) &amp;&amp;
02244       (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*(inHolder[i].value-&gt;getWeight()) + 1] == ot::DA_FLAGS::FOREIGN) ) {
02245     <span class="comment">//Identify old Foreign</span>
02246     tmpIn[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(0);
02247   }<span class="keywordflow">else</span> {
02248     tmpIn[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(inHolder[i].index);
02249   }
02250 }<span class="comment">//end for i</span>
02251 
02252 in = tmpIn;
02253 tmpIn.clear();
02254 inHolder.clear();
02255 
02256 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02257 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02258 <span class="keywordflow">if</span>(!m_iRankActive) {
02259   std::cout&lt;&lt;std::endl;
02260   std::cout&lt;&lt;<span class="stringliteral">"Reshuffled In."</span>&lt;&lt;std::endl;
02261   std::cout&lt;&lt;std::endl;
02262 }
02263 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02264 <span class="preprocessor">#endif</span>
02265 <span class="preprocessor"></span>
02266 <span class="comment">//Reset Counters...</span>
02267 <span class="comment">// PreGhosts ....</span>
02268 <a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a> = 0;
02269 <span class="keywordflow">while</span>( (<a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a> &lt; in.size()) &amp;&amp; (in[m_uiPreGhostElementSize] &lt; myFirstOctant) ) {
02270   <span class="keywordflow">if</span> (!(in[m_uiPreGhostElementSize].getFlag() &amp; ot::TreeNode::BOUNDARY) ) {
02271     <a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a>++;
02272   }<span class="keywordflow">else</span> {
02273     <span class="keywordflow">break</span>;
02274   }
02275 }<span class="comment">//end while</span>
02276 
02277 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02278 <span class="preprocessor"></span>assert( nelem == (<a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a> + m_uiElementSize) );
02279 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02280 <span class="keywordflow">if</span>(!m_iRankActive) {
02281   std::cout&lt;&lt;std::endl;
02282   std::cout&lt;&lt;<span class="stringliteral">"PreGhost Counters Reset."</span>&lt;&lt;std::endl;
02283   std::cout&lt;&lt;std::endl;
02284 }
02285 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02286 <span class="preprocessor">#endif</span>
02287 <span class="preprocessor"></span>
02288 <span class="comment">//Mine ...</span>
02289 <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> = m_uiPreGhostElementSize;
02290 <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> = m_uiPreGhostElementSize;
02291 <span class="keywordflow">while</span>( (<a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a> &lt; in.size()) &amp;&amp; (in[m_uiPostGhostBegin] &lt;= myLastOctant) ) {
02292   <span class="keywordflow">if</span>(in[m_uiPostGhostBegin] &lt; myFirstOctant) {
02293     <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>++;
02294   }
02295   <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>++;
02296 }<span class="comment">//end while</span>
02297 <a class="code" href="classot_1_1DA.html#p36">m_uiElementEnd</a> = <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a> + m_uiElementSize;
02298 
02299 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02300 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02301 <span class="keywordflow">if</span>(!m_iRankActive) {
02302   std::cout&lt;&lt;std::endl;
02303   std::cout&lt;&lt;<span class="stringliteral">"All Counters Reset."</span>&lt;&lt;std::endl;
02304   std::cout&lt;&lt;std::endl;
02305 }
02306 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02307 <span class="preprocessor">#endif</span>
02308 <span class="preprocessor"></span>
02309 std::vector&lt;unsigned int&gt; nlistNew(8*nelem);
02310 std::vector&lt;unsigned char&gt; hnMaskNew(nelem);
02311 
02312 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02313 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02314 <span class="keywordflow">if</span>(!m_iRankActive) {
02315   std::cout&lt;&lt;std::endl;
02316   std::cout&lt;&lt;<span class="stringliteral">"Allocated memory for the new nlist and masks."</span>&lt;&lt;std::endl;
02317   std::cout&lt;&lt;std::endl;
02318 }
02319 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02320 <span class="preprocessor">#endif</span>
02321 <span class="preprocessor"></span>
02322 <span class="comment">// correct nLists ...</span>
02323 <span class="comment">// The loop is in the order of the old Indices ...</span>
02324 <span class="comment">//The first time only the nlist of preghosts are corrected.</span>
02325 <span class="comment">//Since, the nlist of own elements are not built in the first</span>
02326 <span class="comment">//outer-loop (numFullLoopCtr).</span>
02327 <span class="comment">//The second time the preghosts will be visited once again.</span>
02328 <span class="comment">//Skip correction of nlist for Foreigns </span>
02329 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; oldNelem; i++) {
02330 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02331 <span class="preprocessor"></span>  assert(i &lt; oldToNew.size() );
02332   assert(oldToNew[i] &lt; nelem);
02333   <span class="keywordflow">if</span>( numFullLoopCtr == 0 ) {
02334     assert(oldToNew[i] &lt; <a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a>);
02335   }
02336   assert( (2*i+1) &lt; <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>.size() );
02337 <span class="preprocessor">#endif</span>
02338 <span class="preprocessor"></span>
02339   hnMaskNew[oldToNew[i]] = <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i + 1];
02340 
02341   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i+1] == ot::DA_FLAGS::FOREIGN) {
02342     <span class="keywordflow">continue</span>;
02343   }
02344 
02345   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iiOld = 8*i;
02346   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iiNew = 8*oldToNew[i];
02347   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;8; j++) {
02348     <span class="comment">// remap ...</span>
02349 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02350 <span class="preprocessor"></span>    assert( (iiNew + j) &lt; nlistNew.size() );
02351     assert( (iiOld + j) &lt; nlist.size()  );
02352     <span class="keywordflow">if</span>( nlist[iiOld + j] &gt;= oldToNew.size() ) {
02353       std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">": oldToNew.size(): "</span>&lt;&lt;oldToNew.size()&lt;&lt;<span class="stringliteral">" nlist[8*"</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"+"</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">"]: "</span>&lt;&lt;nlist[iiOld+j]&lt;&lt;std::endl 
02354                                                        &lt;&lt;<span class="stringliteral">"oldToNew["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;oldToNew[i]&lt;&lt;<span class="stringliteral">" elem: "</span>&lt;&lt;in[oldToNew[i]]&lt;&lt;std::endl;                                        
02355       assert(<span class="keyword">false</span>);
02356     }
02357 <span class="preprocessor">#endif</span>
02358 <span class="preprocessor"></span>
02359     nlistNew[iiNew + j] = oldToNew[ nlist[iiOld + j] ];
02360   }<span class="comment">//end for j</span>
02361 }<span class="comment">//end for i</span>
02362 
02363 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02364 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02365 <span class="keywordflow">if</span>(!m_iRankActive) {
02366   std::cout&lt;&lt;std::endl;
02367   std::cout&lt;&lt;<span class="stringliteral">"Corrected Nlist."</span>&lt;&lt;std::endl;
02368   std::cout&lt;&lt;std::endl;
02369 }
02370 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02371 <span class="preprocessor">#endif</span>
02372 <span class="preprocessor"></span>
02373 <span class="comment">//Replace the old lists by the new lists and clear the new</span>
02374 <span class="comment">//lists...</span>
02375 
02376 <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>.resize(2*nelem);
02377 <span class="keywordflow">if</span>(numFullLoopCtr) {
02378   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nelem; i++) {
02379     <span class="keywordflow">if</span>(in[i].getWeight() == 0) {
02380       <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i + 1] = ot::DA_FLAGS::FOREIGN;
02381     }<span class="keywordflow">else</span> {
02382       <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i + 1] = hnMaskNew[i];
02383     }
02384   }<span class="comment">//end for i</span>
02385 }<span class="keywordflow">else</span> {
02386   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uiPreGhostElementSize; i++) {
02387     <span class="keywordflow">if</span>(in[i].getWeight() == 0) {
02388       <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i + 1] = ot::DA_FLAGS::FOREIGN;
02389     }<span class="keywordflow">else</span> {
02390       <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i + 1] = hnMaskNew[i];
02391     }
02392   }<span class="comment">//end for i</span>
02393 }
02394 hnMaskNew.clear();
02395 
02396 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
02397   in[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
02398 }
02399 
02400 nlist = nlistNew;
02401 nlistNew.clear();
02402 
02403 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02404 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02405 <span class="keywordflow">if</span>(!m_iRankActive) {
02406   std::cout&lt;&lt;std::endl;
02407   std::cout&lt;&lt;<span class="stringliteral">"Corrected HnMasks and Nlists."</span>&lt;&lt;std::endl;
02408   std::cout&lt;&lt;std::endl;
02409 }
02410 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02411 <span class="preprocessor">#endif</span>
02412 <span class="preprocessor"></span>
02413 <span class="comment">// Merge scattermap and scnScatterMap</span>
02414 std::vector&lt;unsigned int&gt;               tmpScatterMap;
02415 std::vector&lt;unsigned int&gt;               tmpSendProcs;
02416 std::vector&lt;unsigned int&gt;               tmpSendCounts;
02417 std::vector&lt;unsigned int&gt;               tmpRecvProcs;
02418 std::vector&lt;unsigned int&gt;               tmpRecvCounts;
02419 
02420 <span class="comment">//Assumes primary and secondary lists to be sorted independently. the</span>
02421 <span class="comment">//result will be sorted.</span>
02422 <span class="comment">//There is a 1-1 mapping between counts and procs.</span>
02423 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primaryCnt = 0;
02424 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> secondaryCnt = 0;
02425 <span class="keywordflow">while</span>( (primaryCnt &lt; m_uipSendProcs.size()) &amp;&amp; (secondaryCnt &lt; ScndSendProcs.size()) ) {
02426   <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &lt; ScndSendProcs[secondaryCnt] ) {
02427     tmpSendProcs.push_back(m_uipSendProcs[primaryCnt]);
02428     tmpSendCounts.push_back(<a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[primaryCnt]);
02429     primaryCnt++;
02430   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &gt; ScndSendProcs[secondaryCnt] ) {
02431     tmpSendProcs.push_back(ScndSendProcs[secondaryCnt]);
02432     tmpSendCounts.push_back(ScndSendCounts[secondaryCnt]);
02433     secondaryCnt++;
02434   }<span class="keywordflow">else</span> {
02435     <span class="comment">//if both are equal select p only from one. Arbitrarily, the default</span>
02436     <span class="comment">//is picked as primary</span>
02437     tmpSendProcs.push_back(m_uipSendProcs[primaryCnt]);
02438     <span class="comment">//Sum the counts from the primary and secondary...</span>
02439     tmpSendCounts.push_back(<a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[primaryCnt] + ScndSendCounts[secondaryCnt]);
02440     primaryCnt++;
02441     <span class="comment">//skip secondary</span>
02442     secondaryCnt++;
02443   }
02444 }<span class="comment">//end while</span>
02445 
02446 <span class="comment">//only primary remains</span>
02447 <span class="keywordflow">while</span>( primaryCnt &lt; m_uipSendProcs.size() ) {
02448   tmpSendProcs.push_back(m_uipSendProcs[primaryCnt]);
02449   tmpSendCounts.push_back(<a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[primaryCnt]);
02450   primaryCnt++;
02451 }
02452 
02453 <span class="comment">//only secondary remains</span>
02454 <span class="keywordflow">while</span>( secondaryCnt &lt; ScndSendProcs.size() ) {
02455   tmpSendProcs.push_back(ScndSendProcs[secondaryCnt]);
02456   tmpSendCounts.push_back(ScndSendCounts[secondaryCnt]);
02457   secondaryCnt++;
02458 }
02459 
02460 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02461 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02462 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(m_uipSendProcs) );
02463 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(ScndSendProcs) );
02464 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(tmpSendProcs) );
02465 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uipSendProcs.size(); i++) {
02466   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" --&gt; "</span>&lt;&lt;m_uipSendProcs[i]&lt;&lt;<span class="stringliteral">" (P) "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[i]&lt;&lt;std::endl;
02467 }
02468 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" P-Scatter: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.size()&lt;&lt;std::endl;
02469 assert( m_uipSendProcs.size() == <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>.size() );
02470 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02471 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ScndSendProcs.size(); i++) {
02472   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" --&gt; "</span>&lt;&lt;ScndSendProcs[i]&lt;&lt;<span class="stringliteral">" (S) "</span>&lt;&lt;ScndSendCounts[i]&lt;&lt;std::endl;
02473 }
02474 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" S-Scatter: "</span>&lt;&lt;ScndScatterMap.size()&lt;&lt;std::endl;
02475 assert( ScndSendProcs.size() == ScndSendCounts.size() );
02476 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02477 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; tmpSendProcs.size(); i++) {
02478   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" --&gt; "</span>&lt;&lt;tmpSendProcs[i]&lt;&lt;<span class="stringliteral">" (T) "</span>&lt;&lt;tmpSendCounts[i]&lt;&lt;std::endl;
02479 }
02480 assert( tmpSendProcs.size() == tmpSendCounts.size() );
02481 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02482 <span class="keywordflow">if</span>(!m_iRankActive) {
02483   std::cout&lt;&lt;std::endl;
02484   std::cout&lt;&lt;<span class="stringliteral">"Corrected SendCnts and SendProcs."</span>&lt;&lt;std::endl;
02485   std::cout&lt;&lt;std::endl;
02486 }
02487 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02488 <span class="preprocessor">#endif</span>
02489 <span class="preprocessor"></span>
02490 <span class="comment">//Assumes primary and secondary Scattermaps to be sorted</span>
02491 <span class="comment">//independently for each processors portion. the</span>
02492 <span class="comment">//result will also be sorted in chunks.</span>
02493 primaryCnt = 0;
02494 secondaryCnt = 0;
02495 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primarySz = 0;
02496 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> secondarySz = 0;
02497 <span class="keywordflow">while</span>( (primaryCnt &lt; m_uipSendProcs.size()) &amp;&amp; (secondaryCnt &lt; ScndSendProcs.size()) ) {
02498   <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &lt; ScndSendProcs[secondaryCnt] ) {
02499     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numSent = 0;
02500     <span class="keywordflow">while</span>( numSent &lt; <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[primaryCnt] ) {
02501       tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz++]]);
02502       numSent++;
02503     }
02504     primaryCnt++;
02505   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &gt; ScndSendProcs[secondaryCnt] ) {
02506     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numSent = 0;
02507     <span class="keywordflow">while</span>( numSent &lt; ScndSendCounts[secondaryCnt] ) {
02508       tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
02509       numSent++;
02510     }
02511     secondaryCnt++;
02512   }<span class="keywordflow">else</span> {
02513     <span class="comment">//Both primary and secondary are sending to the same processor so</span>
02514     <span class="comment">//merge.</span>
02515     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nP = 0;
02516     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nS = 0;
02517 
02518     <span class="comment">//Both are not over.</span>
02519     <span class="keywordflow">while</span>( ( nP &lt; <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[primaryCnt] ) &amp;&amp; ( nS &lt; ScndSendCounts[secondaryCnt] ) ) {
02520 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02521 <span class="preprocessor"></span>      <span class="comment">//The same octant can not be sent to the same processor in both</span>
02522       <span class="comment">//the primary and secondary lists.</span>
02523       <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz] == ScndScatterMap[secondarySz] ) {
02524         std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" is sending "</span>&lt;&lt;
02525           in[oldToNew[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz]]]&lt;&lt;<span class="stringliteral">" to "</span>
02526           &lt;&lt;m_uipSendProcs[primaryCnt]&lt;&lt;<span class="stringliteral">" in both primary and secondary."</span>&lt;&lt;std::endl;
02527         assert(<span class="keyword">false</span>);
02528       }
02529 <span class="preprocessor">#endif</span>
02530 <span class="preprocessor"></span>      <span class="comment">//Both primary and secondary can only send own elements, the</span>
02531       <span class="comment">//relative ordering of the own elements in the old and new</span>
02532       <span class="comment">//ordering should be the same.</span>
02533       <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz] &lt; ScndScatterMap[secondarySz] ) {
02534 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02535 <span class="preprocessor"></span>        assert( oldToNew[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz]] &lt; oldToNew[ScndScatterMap[secondarySz]] );
02536 <span class="preprocessor">#endif</span>
02537 <span class="preprocessor"></span>        tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz++]]);
02538         nP++;
02539       }<span class="keywordflow">else</span> {
02540 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02541 <span class="preprocessor"></span>        assert( oldToNew[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz]] &gt; oldToNew[ScndScatterMap[secondarySz]] );
02542 <span class="preprocessor">#endif</span>
02543 <span class="preprocessor"></span>        tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
02544         nS++;
02545       }
02546     }
02547 
02548     <span class="comment">//Only primary remains</span>
02549     <span class="keywordflow">while</span>( nP &lt; <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[primaryCnt] ) {
02550       tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz++]]);
02551       nP++;
02552     }
02553 
02554     <span class="comment">//only secondary remains</span>
02555     <span class="keywordflow">while</span>( nS &lt; ScndSendCounts[secondaryCnt] ) {
02556       tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
02557       nS++;
02558     }
02559 
02560     primaryCnt++;
02561     secondaryCnt++;
02562   }<span class="comment">//end if-else</span>
02563 }<span class="comment">//end while</span>
02564 
02565 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02566 <span class="preprocessor"></span><span class="comment">//ScatterMaps and Procs must finish together.</span>
02567 <span class="keywordflow">if</span>( primarySz &lt; <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.size() ) {
02568   assert(primaryCnt &lt; m_uipSendProcs.size());
02569 }<span class="keywordflow">else</span> {
02570   assert(primaryCnt == m_uipSendProcs.size());
02571 }
02572 
02573 <span class="keywordflow">if</span>( secondarySz &lt; ScndScatterMap.size() ) {
02574   assert(secondaryCnt &lt; ScndSendProcs.size());
02575 }<span class="keywordflow">else</span> {
02576   assert(secondaryCnt == ScndSendProcs.size());
02577 }
02578 <span class="preprocessor">#endif</span>
02579 <span class="preprocessor"></span>
02580 <span class="comment">//Only primary remains.</span>
02581 <span class="keywordflow">while</span>( primarySz &lt; <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.size() ) {
02582   tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[primarySz++]]);
02583 }
02584 
02585 <span class="comment">//Only secondary remains.</span>
02586 <span class="keywordflow">while</span>( secondarySz &lt; ScndScatterMap.size() ) {
02587   tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
02588 }
02589 
02590 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02591 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02592 <span class="keywordflow">if</span>(!m_iRankActive) {
02593   std::cout&lt;&lt;std::endl;
02594   std::cout&lt;&lt;<span class="stringliteral">"Merged Primary and Secondary Scatter Maps."</span>&lt;&lt;std::endl;
02595   std::cout&lt;&lt;std::endl;
02596 }
02597 
02598 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" pScatterSz: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.size()&lt;&lt;<span class="stringliteral">" sScatterSz: "</span>
02599 &lt;&lt;ScndScatterMap.size()&lt;&lt;<span class="stringliteral">" tScatterSz: "</span>&lt;&lt;tmpScatterMap.size()&lt;&lt;std::endl;
02600 
02601 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_pCnt = 0;
02602 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_sCnt = 0;
02603 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_tCnt = 0;
02604 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_pOff = 0;
02605 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_sOff = 0;
02606 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_tOff = 0;
02607 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt; m_iNpesActive; i++) {
02608   std::vector&lt;unsigned int&gt;  pSctList;
02609   std::vector&lt;unsigned int&gt;  sSctList;
02610   std::vector&lt;unsigned int&gt;  tSctList;
02611   <span class="keywordflow">if</span>( (debug_pCnt &lt; m_uipSendProcs.size()) &amp;&amp; (m_uipSendProcs[debug_pCnt] == i) ) {
02612     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[debug_pCnt]; j++) {
02613       pSctList.push_back(<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[debug_pOff + j]);
02614     }
02615     debug_pOff += m_uipSendCounts[debug_pCnt];
02616     debug_pCnt++;
02617   }
02618   <span class="keywordflow">if</span>( (debug_sCnt &lt; ScndSendProcs.size()) &amp;&amp; (ScndSendProcs[debug_sCnt] == i) ) {
02619     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; ScndSendCounts[debug_sCnt]; j++) {
02620       sSctList.push_back(ScndScatterMap[debug_sOff + j]);
02621     }
02622     debug_sOff += ScndSendCounts[debug_sCnt];
02623     debug_sCnt++;
02624   }
02625   <span class="keywordflow">if</span>( (debug_tCnt &lt; tmpSendProcs.size()) &amp;&amp; (tmpSendProcs[debug_tCnt] == i) ) {
02626     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; tmpSendCounts[debug_tCnt]; j++) {
02627       tSctList.push_back(tmpScatterMap[debug_tOff + j]);
02628     }
02629     debug_tOff += tmpSendCounts[debug_tCnt];
02630     debug_tCnt++;
02631   }
02632 
02633   assert( tSctList.size() == (pSctList.size() + sSctList.size()) );
02634 
02635   assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(pSctList) );
02636   assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(sSctList) );
02637 
02638   <span class="comment">//Explicitly merge p and s into tt.</span>
02639   std::vector&lt;unsigned int&gt; ttList;
02640   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; sSctList.size(); j++) {
02641     ttList.push_back(oldToNew[sSctList[j]]);
02642   }
02643   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; pSctList.size(); j++) {
02644     ttList.push_back(oldToNew[pSctList[j]]);
02645   }
02646 
02647   <a class="code" href="Sort_8h.html#a7">sort</a>(ttList.begin(),ttList.end());
02648   assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(ttList) );
02649 
02650   <span class="comment">// was assert(ttList == tSctList);</span>
02651   assert(ttList.size() == tSctList.size());
02652   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; ttList.size(); j++) {
02653     <span class="keywordflow">if</span> (ttList[j] != tSctList[j]) {
02654       std::cout &lt;&lt; <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt;&lt; <span class="stringliteral">": MergeFailed at "</span> &lt;&lt; j &lt;&lt; std::endl;
02655       std::cout &lt;&lt; ttList[j] &lt;&lt; <span class="stringliteral">" != "</span>  &lt;&lt; tSctList[j] &lt;&lt; std::endl;
02656       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; pSctList.size(); k++) {
02657         std::cout &lt;&lt; ttList[k] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; tSctList[k]
02658           &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; pSctList[k] &lt;&lt; std::endl;
02659       }
02660       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; sSctList.size(); k++) {
02661         std::cout &lt;&lt; sSctList[k] &lt;&lt; std::endl;
02662       }
02663       assert(<span class="keyword">false</span>);
02664     }
02665   }<span class="comment">//end for j</span>
02666 
02667   ttList.clear();
02668   pSctList.clear();
02669   sSctList.clear();
02670   tSctList.clear();
02671 }<span class="comment">//end for i</span>
02672 
02673 assert( debug_pCnt == m_uipSendProcs.size() );
02674 assert( debug_sCnt == ScndSendProcs.size() );
02675 assert( debug_tCnt == tmpSendProcs.size() );
02676 
02677 assert( tmpScatterMap.size() == (<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.size() + ScndScatterMap.size()) );
02678 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02679 <span class="preprocessor">#endif</span>
02680 <span class="preprocessor"></span>
02681 oldToNew.clear();
02682 
02683 primaryCnt = 0;
02684 secondaryCnt = 0;
02685 <span class="keywordflow">while</span>( (primaryCnt &lt; <a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>.size()) &amp;&amp; (secondaryCnt &lt; ScndRecvProcs.size()) ) {
02686   <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[primaryCnt] &lt; ScndRecvProcs[secondaryCnt] ) {
02687     tmpRecvProcs.push_back(<a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[primaryCnt]);
02688     tmpRecvCounts.push_back(<a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>[primaryCnt]);
02689     primaryCnt++;
02690   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[primaryCnt] &gt; ScndRecvProcs[secondaryCnt] ) {
02691     tmpRecvProcs.push_back(ScndRecvProcs[secondaryCnt]);
02692     tmpRecvCounts.push_back(ScndRecvCounts[secondaryCnt]);
02693     secondaryCnt++;
02694   }<span class="keywordflow">else</span> {
02695     <span class="comment">//if both are equal select only from primary</span>
02696     tmpRecvProcs.push_back(<a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[primaryCnt]);
02697     tmpRecvCounts.push_back(<a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>[primaryCnt] + ScndRecvCounts[secondaryCnt]);
02698     primaryCnt++;
02699     <span class="comment">//skip secondary</span>
02700     secondaryCnt++;
02701   }
02702 }
02703 
02704 <span class="keywordflow">while</span>( primaryCnt &lt; <a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>.size() ) {
02705   tmpRecvProcs.push_back(<a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[primaryCnt]);
02706   tmpRecvCounts.push_back(<a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>[primaryCnt]);
02707   primaryCnt++;
02708 }
02709 
02710 <span class="keywordflow">while</span>( secondaryCnt &lt; ScndRecvProcs.size() ) {
02711   tmpRecvProcs.push_back(ScndRecvProcs[secondaryCnt]);
02712   tmpRecvCounts.push_back(ScndRecvCounts[secondaryCnt]);
02713   secondaryCnt++;
02714 }
02715 
02716 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02717 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02718 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>) );
02719 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(ScndRecvProcs) );
02720 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(tmpRecvProcs) );
02721 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uipRecvProcs.size(); i++) {
02722   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" &lt;-- "</span>&lt;&lt;m_uipRecvProcs[i]&lt;&lt;<span class="stringliteral">" (P) "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>[i]&lt;&lt;std::endl;
02723 }
02724 assert( m_uipRecvProcs.size() == <a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>.size() );
02725 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02726 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ScndRecvProcs.size(); i++) {
02727   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" &lt;-- "</span>&lt;&lt;ScndRecvProcs[i]&lt;&lt;<span class="stringliteral">" (S) "</span>&lt;&lt;ScndRecvCounts[i]&lt;&lt;std::endl;
02728 }
02729 assert( ScndRecvProcs.size() == ScndRecvCounts.size() );
02730 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02731 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; tmpRecvProcs.size(); i++) {
02732   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" &lt;-- "</span>&lt;&lt;tmpRecvProcs[i]&lt;&lt;<span class="stringliteral">" (T) "</span>&lt;&lt;tmpRecvCounts[i]&lt;&lt;std::endl;
02733 }
02734 assert( tmpRecvProcs.size() == tmpRecvCounts.size() );
02735 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02736 <span class="preprocessor">#endif</span>
02737 <span class="preprocessor"></span>
02738 ScndScatterMap.clear();
02739 ScndSendProcs.clear();
02740 ScndSendCounts.clear();
02741 ScndRecvProcs.clear();
02742 ScndRecvCounts.clear();
02743 
02744 <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>  =  tmpScatterMap;
02745 m_uipSendProcs   =  tmpSendProcs;
02746 <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>  =  tmpSendCounts;
02747 m_uipRecvProcs   =  tmpRecvProcs;
02748 <a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>  =  tmpRecvCounts;
02749 
02750 tmpScatterMap.clear();
02751 tmpSendProcs.clear();
02752 tmpSendCounts.clear();
02753 tmpRecvProcs.clear();
02754 tmpRecvCounts.clear();
02755 
02756 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02757 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02758 <span class="keywordflow">if</span>(!m_iRankActive) {
02759   std::cout&lt;&lt;std::endl;
02760   std::cout&lt;&lt;<span class="stringliteral">"Corrected RecvCounts and RecvProcs."</span>&lt;&lt;std::endl;
02761   std::cout&lt;&lt;std::endl;
02762 }
02763 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02764 <span class="preprocessor">#endif</span>
02765 <span class="preprocessor"></span>
02766 }<span class="comment">//end for numFullLoopCtr</span>
02767 
02768 <span class="comment">// Compute and store the new offsets ...</span>
02769 <a class="code" href="classot_1_1DA.html#p67">m_uipSendOffsets</a>.resize(<a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>.size());
02770 <a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>.resize(<a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>.size());
02771 
02772 <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>.size() ) {
02773   <a class="code" href="classot_1_1DA.html#p67">m_uipSendOffsets</a>[0] = 0;
02774   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i &lt; <a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>.size(); i++) {
02775     <a class="code" href="classot_1_1DA.html#p67">m_uipSendOffsets</a>[i] = (<a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[i-1] + <a class="code" href="classot_1_1DA.html#p67">m_uipSendOffsets</a>[i-1]);
02776   }
02777 }
02778 
02779 <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>.size() ) {
02780   <span class="keywordtype">bool</span> adjustedAlready = <span class="keyword">false</span>;
02781   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[0] &lt; static_cast&lt;unsigned int&gt;(m_iRankActive)) {
02782     <a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[0] = 0;
02783   }<span class="keywordflow">else</span> {
02784     <a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[0] = m_uiPostGhostBegin;
02785     adjustedAlready = <span class="keyword">true</span>;
02786   }
02787   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i &lt; <a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>.size(); i++) {
02788     <span class="keywordflow">if</span>( (<a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[i] &lt; m_iRankActive) || adjustedAlready ) {
02789       <a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[i] = (<a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>[i-1] + <a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[i-1]);
02790     }<span class="keywordflow">else</span> {
02791       <a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[i] = m_uiPostGhostBegin;
02792       adjustedAlready = <span class="keyword">true</span>;
02793     }
02794   }<span class="comment">//end for i</span>
02795 }
02796 
02797 <span class="comment">//Store a copy of the original scattermap first. This will be required for</span>
02798 <span class="comment">//communicating ghost elements. Since there are no post-ghost element, we only</span>
02799 <span class="comment">//need to send to processors with ranks greater than my rank.</span>
02800 <a class="code" href="classot_1_1DA.html#p52">m_uipElemScatterMap</a>.clear();
02801 <a class="code" href="classot_1_1DA.html#p54">m_uipElemSendOffsets</a>.clear();
02802 <a class="code" href="classot_1_1DA.html#p55">m_uipElemSendProcs</a>.clear();
02803 <a class="code" href="classot_1_1DA.html#p53">m_uipElemSendCounts</a>.clear();
02804 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#p68">m_uipSendProcs</a>.size(); i++) {
02805   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p68">m_uipSendProcs</a>[i] &gt; static_cast&lt;unsigned int&gt;(m_iRankActive)) {
02806     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numElemProcs = static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#p54">m_uipElemSendOffsets</a>.size());
02807     <a class="code" href="classot_1_1DA.html#p54">m_uipElemSendOffsets</a>.push_back(<a class="code" href="classot_1_1DA.html#p52">m_uipElemScatterMap</a>.size());
02808     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = <a class="code" href="classot_1_1DA.html#p67">m_uipSendOffsets</a>[i]; j &lt; (<a class="code" href="classot_1_1DA.html#p66">m_uipSendCounts</a>[i] + <a class="code" href="classot_1_1DA.html#p67">m_uipSendOffsets</a>[i]); j++) {
02809       <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[j] &lt; m_uiElementEnd) {
02810         <a class="code" href="classot_1_1DA.html#p52">m_uipElemScatterMap</a>.push_back(<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[j]);
02811       }<span class="keywordflow">else</span> {
02812         <span class="keywordflow">break</span>;
02813       }
02814     }<span class="comment">//end for j    </span>
02815     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currCount = 
02816       (static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#p52">m_uipElemScatterMap</a>.size())
02817        - <a class="code" href="classot_1_1DA.html#p54">m_uipElemSendOffsets</a>[numElemProcs]);
02818     <span class="keywordflow">if</span>(currCount) {
02819       <a class="code" href="classot_1_1DA.html#p55">m_uipElemSendProcs</a>.push_back(<a class="code" href="classot_1_1DA.html#p68">m_uipSendProcs</a>[i]);
02820       <a class="code" href="classot_1_1DA.html#p53">m_uipElemSendCounts</a>.push_back(currCount);
02821     }<span class="keywordflow">else</span> {
02822       <a class="code" href="classot_1_1DA.html#p54">m_uipElemSendOffsets</a>.resize(numElemProcs);
02823     }
02824   }
02825 }<span class="comment">//end for i</span>
02826 
02827 <a class="code" href="classot_1_1DA.html#p50">m_uipElemRecvOffsets</a>.clear();
02828 <a class="code" href="classot_1_1DA.html#p51">m_uipElemRecvProcs</a>.clear();
02829 <a class="code" href="classot_1_1DA.html#p49">m_uipElemRecvCounts</a>.clear();
02830 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>.size(); i++) {
02831   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[i] &lt; m_uiPreGhostElementSize) {
02832     <span class="comment">//Planning to recieve at least 1 pre-ghost element from this processor</span>
02833     <a class="code" href="classot_1_1DA.html#p51">m_uipElemRecvProcs</a>.push_back(<a class="code" href="classot_1_1DA.html#p60">m_uipRecvProcs</a>[i]);
02834     <a class="code" href="classot_1_1DA.html#p50">m_uipElemRecvOffsets</a>.push_back(<a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[i]);
02835     <span class="keywordflow">if</span>( (<a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[i] + <a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>[i]) &lt;= m_uiPreGhostElementSize) {
02836       <a class="code" href="classot_1_1DA.html#p49">m_uipElemRecvCounts</a>.push_back(<a class="code" href="classot_1_1DA.html#p58">m_uipRecvCounts</a>[i]);
02837     } <span class="keywordflow">else</span> {
02838       <a class="code" href="classot_1_1DA.html#p49">m_uipElemRecvCounts</a>.push_back(<a class="code" href="classot_1_1DA.html#p62">m_uiPreGhostElementSize</a> - <a class="code" href="classot_1_1DA.html#p59">m_uipRecvOffsets</a>[i]);
02839     }
02840   }
02841 }<span class="comment">//end for i</span>
02842 
02843 <span class="comment">// Correct the scatter-map so that hanging nodes get correct info ...</span>
02844 <span class="comment">//  Logic is to find if any entry in the scatter map is hanging, and if</span>
02845 <span class="comment">//  so, we simply correct the scatter map so that it points to the</span>
02846 <span class="comment">//  correct anchor instead.</span>
02847 
02848 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>.size(); i++) {
02849   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[i];
02850 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02851 <span class="preprocessor"></span>  assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#p35">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#p56">m_uiPostGhostBegin</a>) );
02852 <span class="preprocessor">#endif</span>
02853 <span class="preprocessor"></span>  <span class="comment">// if idx is an elem ... use nlist ...</span>
02854   <span class="keywordflow">if</span> ( idx &lt; nelem) {
02855     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*idx + 1] &amp; 1) {
02856 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02857 <span class="preprocessor"></span>      assert( !(in[idx].<a class="code" href="classot_1_1DA.html#z36_4">getFlag</a>() &amp; ot::TreeNode::NODE) );
02858 <span class="preprocessor">#endif</span>
02859 <span class="preprocessor"></span>      <span class="comment">// anchor is hanging, so let us correct this ...</span>
02860       <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[i] = nlist[8*idx];
02861     }
02862   } <span class="keywordflow">else</span> {
02863     <span class="comment">// if idx points to a boundary node,</span>
02864     <span class="comment">// get the parent of in[idx] ...</span>
02865     <span class="keywordflow">if</span> ( !(in[idx].getFlag() &amp; ot::TreeNode::NODE)) {
02866       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> tn = in[idx].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
02867       <span class="keywordflow">while</span> ( in[idx] &gt; tn) {
02868         idx--;
02869       }
02870       <span class="comment">//At the end of the above while loop, in[idx] will point to 1 element</span>
02871       <span class="comment">//before the first child of tn.</span>
02872       idx++;
02873       <a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[i] = idx;
02874 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02875 <span class="preprocessor"></span>      assert( in[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[i]].getAnchor() == tn.<a class="code" href="classot_1_1TreeNode.html#z19_2">getAnchor</a>() );
02876       assert( (<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[i] &gt;= m_uiElementBegin) &amp;&amp; (<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[i] &lt; m_uiPostGhostBegin) );
02877       assert( in[<a class="code" href="classot_1_1DA.html#p65">m_uipScatterMap</a>[i]].<a class="code" href="classot_1_1DA.html#z36_4">getFlag</a>() &amp; ot::TreeNode::NODE );
02878 <span class="preprocessor">#endif</span>
02879 <span class="preprocessor"></span>    }
02880   }
02881 }<span class="comment">//end for i</span>
02882 
02883 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02884 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02885 <span class="keywordflow">if</span>(!m_iRankActive) {
02886   std::cout&lt;&lt;std::endl;
02887   std::cout&lt;&lt;<span class="stringliteral">"Corrected New Scatter Map for hanging anchors."</span>&lt;&lt;std::endl;
02888   std::cout&lt;&lt;std::endl;
02889 }
02890 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02891 <span class="preprocessor">#endif</span>
02892 <span class="preprocessor"></span>
02893 <span class="comment">//Correct nlist of all FOREIGNs....</span>
02894 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nelem;i++) {
02895   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i+1] == ot::DA_FLAGS::FOREIGN) {
02896     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;j&lt;8;j++) {
02897       nlist[8*i + j] = i;
02898     }
02899   }
02900 }<span class="comment">//end for i</span>
02901 
02902 <span class="comment">//~~~~~~~~~~~~~~~~~~~~Mark NODES~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
02903 <span class="keywordtype">bool</span> *<a class="code" href="classot_1_1DA.html#z36_12">isNode</a> = NULL;
02904 <span class="keywordflow">if</span>(m_uiLocalBufferSize) {
02905   isNode = <span class="keyword">new</span> <span class="keywordtype">bool</span>[m_uiLocalBufferSize];
02906 }
02907 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uiLocalBufferSize; i++) {
02908   isNode[i] = <span class="keyword">false</span>;
02909 }
02910 <span class="comment">// loop through the LUT, and tag everybody as being nodes or not ...</span>
02911 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nelem; i++) {
02912   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i+1] == ot::DA_FLAGS::FOREIGN) {
02913     <span class="keywordflow">continue</span>;
02914   }
02915   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
02916 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02917 <span class="preprocessor"></span>    assert(nlist[8*i + j] &lt; m_uiLocalBufferSize);
02918 <span class="preprocessor">#endif</span>
02919 <span class="preprocessor"></span>    isNode[nlist[8*i + j]] = <span class="keyword">true</span>;
02920   }
02921 }
02922 
02923 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uiLocalBufferSize; i++) {
02924   <span class="keywordflow">if</span> ( isNode[i] ) {
02925 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02926 <span class="preprocessor"></span>    <span class="keywordflow">if</span> ( (i &gt;= m_uiElementBegin) &amp;&amp; (i &lt; m_uiPostGhostBegin) ) {
02927       assert( (in[i].<a class="code" href="classot_1_1DA.html#z36_4">getFlag</a>() &amp; ot::TreeNode::NODE) );
02928     }
02929 <span class="preprocessor">#endif</span>
02930 <span class="preprocessor"></span>    in[i].<a class="code" href="classot_1_1TreeNode.html#z19_15">orFlag</a>( ot::TreeNode::NODE );
02931   }
02932 }<span class="comment">//end for i</span>
02933 
02934 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02935 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02936 <span class="keywordflow">if</span>(!m_iRankActive) {
02937   std::cout&lt;&lt;std::endl;
02938   std::cout&lt;&lt;<span class="stringliteral">"Finished is NODE..."</span>&lt;&lt;std::endl;
02939   std::cout&lt;&lt;std::endl;
02940 }
02941 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02942 <span class="preprocessor">#endif</span>
02943 <span class="preprocessor"></span>
02944 <span class="comment">// Now compute the elem node size, and boundary node sizes ...</span>
02945 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elemNodeSz = 0;
02946 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bndNodeSz = 0;
02947 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> preGhostNodeSz = 0;
02948 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> preBndNodeSz = 0;
02949 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> postGhostNodeSz = 0;
02950 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> postBndNodeSz = 0;
02951 
02952 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uiElementBegin; i++) {
02953   <span class="keywordflow">if</span> ( isNode[i]  &amp;&amp; (!(in[i].getFlag() &amp; ot::TreeNode::BOUNDARY)) ) {
02954     preGhostNodeSz++;                    
02955   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNode[i]) {
02956     preBndNodeSz++;
02957   }
02958 }
02959 
02960 <span class="comment">//My Elements which are also nodes.</span>
02961 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementBegin; i &lt; m_uiElementEnd; i++) {
02962   <span class="keywordflow">if</span> (isNode[i]) {
02963     elemNodeSz++;        
02964   }
02965 }
02966 
02967 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementEnd; i &lt; m_uiPostGhostBegin; i++) {
02968   <span class="keywordflow">if</span> (isNode[i]) {
02969     bndNodeSz++;          
02970   }
02971 }
02972 
02973 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiPostGhostBegin; i &lt; m_uiLocalBufferSize; i++) {
02974   <span class="keywordflow">if</span> (isNode[i] &amp;&amp; (!(in[i].getFlag() &amp; ot::TreeNode::BOUNDARY)) ) {
02975     postGhostNodeSz++;
02976   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNode[i]) {
02977     postBndNodeSz++;
02978   }
02979 }
02980 
02981 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
02982 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02983 <span class="keywordflow">if</span>(!m_iRankActive) {
02984   std::cout&lt;&lt;std::endl;
02985   std::cout&lt;&lt;<span class="stringliteral">"Finished setting sizes..."</span>&lt;&lt;std::endl;
02986   std::cout&lt;&lt;std::endl;
02987 }
02988 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
02989 <span class="preprocessor">#endif</span>
02990 <span class="preprocessor"></span>
02991 <span class="keywordflow">if</span>(isNode) {
02992   <span class="keyword">delete</span> [] isNode;
02993   isNode = NULL;
02994 }
02995 
02996 <span class="comment">//Store the sizes.</span>
02997 <a class="code" href="classot_1_1DA.html#p63">m_uiPreGhostNodeSize</a> = preGhostNodeSz;
02998 <a class="code" href="classot_1_1DA.html#p61">m_uiPreGhostBoundaryNodeSize</a> = preBndNodeSz;
02999 <a class="code" href="classot_1_1DA.html#p57">m_uiPostGhostNodeSize</a> = postGhostNodeSz + postBndNodeSz;
03000 <a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a> = elemNodeSz;
03001 <a class="code" href="classot_1_1DA.html#p31">m_uiBoundaryNodeSize</a> = bndNodeSz;
03002 
03003 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
03004 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
03005 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Just Before Compression...."</span>&lt;&lt;std::endl&lt;&lt;std::endl;
03006 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p63">m_uiPreGhostNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p61">m_uiPreGhostBoundaryNodeSize</a>
03007 &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p57">m_uiPostGhostNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>
03008 &lt;&lt;<a class="code" href="classot_1_1DA.html#p31">m_uiBoundaryNodeSize</a>&lt;&lt;std::endl&lt;&lt;std::endl;
03009 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
03010 <span class="preprocessor">#endif</span>
03011 <span class="preprocessor"></span>
03012 <span class="comment">// All done ... Now COMPRESS</span>
03013 <span class="comment">// Now compress the node list ...</span>
03014 
03015 <span class="comment">// allocate a small buffer to unsort ...</span>
03016 <span class="keywordflow">if</span>(m_bCompressLut) {
03017   <a class="code" href="classot_1_1DA.html#p24">m_ucpLutRemainders</a>.resize(8*nelem);
03018   <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>.resize(nelem);
03019 }
03020 
03021 <span class="keywordtype">bool</span> foundBeg = <span class="keyword">false</span>;
03022 <span class="keywordtype">bool</span> foundEnd = <span class="keyword">false</span>;
03023 
03024 <a class="code" href="classot_1_1DA.html#p42">m_uiIndependentElementSize</a> = 0;
03025 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nelem; i++) {
03026   <span class="comment">// get basic info ...</span>
03027   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii = 8*i;
03028 
03029   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
03030   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
03031   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
03032 
03033   <span class="keywordflow">if</span>(m_bCompressLut) {
03034     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
03035     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 1u &lt;&lt; (<a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a> - d);
03036     <span class="comment">//compute and store the sort order for the non-hanging case.</span>
03037     <span class="keywordflow">if</span>(!(<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i+1])){
03038       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xp = x + sz;
03039       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yp = y + sz;
03040       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zp = z + sz;
03041 
03042       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x = x^xp;
03043       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _y = y^yp;
03044       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _z = z^zp;
03045 
03046       <span class="keywordflow">if</span> (_x &gt; _y) {
03047         <span class="keywordflow">if</span> ( _y &gt; _z) {
03048           <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>[i] = ot::DA_FLAGS::ZYX;
03049         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _x &gt; _z ) {
03050           <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>[i] = ot::DA_FLAGS::YZX;
03051         } <span class="keywordflow">else</span> {
03052           <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>[i] = ot::DA_FLAGS::YXZ;
03053         }
03054       } <span class="keywordflow">else</span> {
03055         <span class="keywordflow">if</span> ( _x &gt; _z) {
03056           <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>[i] = ot::DA_FLAGS::ZXY;
03057         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _y &gt; _z ) {
03058           <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>[i] = ot::DA_FLAGS::XZY;
03059         } <span class="keywordflow">else</span> {
03060           <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>[i] = ot::DA_FLAGS::XYZ;
03061         }
03062       }
03063     }<span class="keywordflow">else</span> {
03064       <span class="comment">//store the childnumber instead for the hanging cases.</span>
03065       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len_par = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; ( <a class="code" href="classot_1_1DA.html#p45">m_uiMaxDepth</a>  - d +1 ) );
03066 
03067       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = x % len_par;
03068       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = y % len_par;
03069       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = z % len_par;
03070 
03071       a /= sz;
03072       b /= sz;
03073       c /= sz;
03074 
03075       <a class="code" href="classot_1_1DA.html#p29">m_ucpSortOrders</a>[i]  = (4*c + 2*b + a);
03076     }<span class="comment">//end sortOrderRegular block</span>
03077   }<span class="comment">//end if Lut compressed</span>
03078 
03079   <span class="comment">// use this loop to also detect the begining and end of dependent.</span>
03080   <span class="keywordflow">if</span> ( !foundBeg &amp;&amp; !(in[i].getFlag() &amp; ot::DA_FLAGS::DEP_ELEM)
03081       &amp;&amp; (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i+1] != ot::DA_FLAGS::FOREIGN) ) {
03082     <span class="comment">//std::cout &lt;&lt; GRN"FOUND BEGINING OF INDEPENDENT "NRM &lt;&lt; i &lt;&lt; std::endl;</span>
03083     foundBeg = <span class="keyword">true</span>;
03084     <a class="code" href="classot_1_1DA.html#p39">m_uiIndependentElementBegin</a> = i;
03085     <a class="code" href="classot_1_1DA.html#p16">m_ptIndependentOffset</a> = <a class="code" href="classPoint.html">Point</a>(x,y,z);
03086   }
03087 
03088   <span class="comment">// reverse loop to find end ...</span>
03089   <span class="keywordflow">if</span> ( !foundEnd &amp;&amp; !(in[nelem-i-1].getFlag() &amp; ot::DA_FLAGS::DEP_ELEM)
03090       &amp;&amp; (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*(nelem-i-1)+1] != ot::DA_FLAGS::FOREIGN) ) {
03091     <span class="comment">//std::cout &lt;&lt; GRN"FOUND END OF INDEPENDENT "NRM &lt;&lt; nelem - i &lt;&lt; std::endl;</span>
03092     foundEnd = <span class="keyword">true</span>;
03093     <a class="code" href="classot_1_1DA.html#p40">m_uiIndependentElementEnd</a> = nelem - i;
03094   }
03095 
03096   <span class="comment">//Actual number of Independent elements. In between IndependentElementBegin</span>
03097   <span class="comment">//and IndependentElementEnd, we can also have dependent elements and so</span>
03098   <span class="comment">//simply taking the difference of end and begin will not work</span>
03099   <span class="keywordflow">if</span>( (!(in[i].getFlag() &amp; ot::DA_FLAGS::DEP_ELEM)) &amp;&amp;
03100       (<a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i+1] != ot::DA_FLAGS::FOREIGN) ) {
03101     <a class="code" href="classot_1_1DA.html#p42">m_uiIndependentElementSize</a>++;
03102   }
03103 
03104   <span class="keywordflow">if</span> ( i == m_uiElementBegin ) {
03105     <a class="code" href="classot_1_1DA.html#p37">m_uiElementQuotient</a> = static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#p70">m_uspLutQuotients</a>.size());
03106   }
03107 
03108   <span class="keywordflow">if</span> ( i == m_uiIndependentElementBegin ) {
03109     <a class="code" href="classot_1_1DA.html#p41">m_uiIndependentElementQuotient</a> = static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#p70">m_uspLutQuotients</a>.size());
03110   }
03111 
03112   <span class="comment">//First initialize Masks...</span>
03113   <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i] = 0;
03114 
03115   <span class="comment">// locally sort ...</span>
03116   <span class="keywordflow">if</span>(m_bCompressLut) {
03117     <span class="comment">// Perform Golomb-Rice encoding</span>
03118     <span class="comment">//Assumes that the highest 8 bits in offset are not significant, i.e. they will be all 0.</span>
03119     <span class="comment">//This means offset can not be more than (2^24-1) = 16,777,215.</span>
03120     <span class="comment">//Since the number of octants on a processor will not be more than 16M,</span>
03121     <span class="comment">//this does not pose any kind of difficulty.</span>
03122 
03123     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> q;
03124     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset;
03125     std::vector&lt;unsigned int&gt; nl(8);
03126     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ij = 0; ij &lt; 8; ij++) {
03127       nl[ij] = nlist[ii+ij];
03128     }
03129     <a class="code" href="Sort_8h.html#a7">std::sort</a>(nl.begin(), nl.end());
03130 
03131     <span class="comment">// 0 is special, it computes the offset wrt i.</span>
03132     <span class="comment">// 0, we have a negative offset .. or 0</span>
03133     offset = i - nl[0];
03134     q = (offset &gt;&gt; 8);
03135     <a class="code" href="classot_1_1DA.html#p24">m_ucpLutRemainders</a>[8*i] = (offset%256);
03136     <span class="keywordflow">if</span> (q) {
03137       <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i] |= 1;
03138       <a class="code" href="classot_1_1DA.html#p70">m_uspLutQuotients</a>.push_back(q);
03139     }
03140 
03141     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 1; j &lt; 8; j++) {
03142       offset =  nl[j] - nl[j-1];
03143       q = (offset &gt;&gt; 8);
03144       <a class="code" href="classot_1_1DA.html#p24">m_ucpLutRemainders</a>[8*i + j] = (offset%256);
03145       <span class="keywordflow">if</span> (q) {
03146         <a class="code" href="classot_1_1DA.html#p22">m_ucpLutMasks</a>[2*i] |= (1 &lt;&lt; j);
03147         <a class="code" href="classot_1_1DA.html#p70">m_uspLutQuotients</a>.push_back(q);
03148       }
03149     } <span class="comment">// for j ...</span>
03150     nl.clear();
03151   }<span class="comment">//end if compress</span>
03152 
03153 } <span class="comment">// for i</span>
03154 
03155 <span class="comment">//Store Nlist if you are not compressing...</span>
03156 <span class="keywordflow">if</span>(!m_bCompressLut) {
03157   <a class="code" href="classot_1_1DA.html#p46">m_uiNlist</a> = nlist; 
03158 }
03159 
03160 <span class="comment">// free up</span>
03161 nlist.clear();
03162 
03163 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
03164 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
03165 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Just After Compression...."</span>&lt;&lt;std::endl&lt;&lt;std::endl;
03166 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p63">m_uiPreGhostNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>
03167 &lt;&lt;<a class="code" href="classot_1_1DA.html#p61">m_uiPreGhostBoundaryNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p57">m_uiPostGhostNodeSize</a>
03168 &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p48">m_uiNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#p31">m_uiBoundaryNodeSize</a>&lt;&lt;std::endl&lt;&lt;std::endl;
03169 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
03170 std::cout &lt;&lt; <a class="code" href="classot_1_1DA.html#p8">m_iRankActive</a> &lt;&lt; <span class="stringliteral">": Leaving "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
03171 MPI_Barrier(<a class="code" href="classot_1_1DA.html#p11">m_mpiCommActive</a>);
03172 <span class="preprocessor">#endif</span>
03173 <span class="preprocessor"></span>
03174 <a class="code" href="oda_8h.html#a22">PROF_BUILD_NLIST_END</a>
03175 
03176 }<span class="comment">//end 4-way BuildNode List</span>
03177 }<span class="comment">//end namespace ot</span>
03178 
03179 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:32 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
