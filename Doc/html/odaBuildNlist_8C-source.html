<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /export/home/ilashuk3/Dendro/src/oda/private/odaBuildNlist.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_95d5eb57f2839000f42cfeba4072b840.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_b5c6e06b1ba7006988474c52fce3c3f3.html">oda</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_74475bc0462dae8674a4c3cfed617d48.html">private</a></div>
<h1>odaBuildNlist.C</h1><a href="odaBuildNlist_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00009"></a>00009 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
<a name="l00012"></a>00012 <span class="preprocessor">#include "<a class="code" href="colors_8h.html">colors.h</a>"</span>
<a name="l00013"></a>00013 <span class="preprocessor">#include "<a class="code" href="nodeAndRanks_8h.html">nodeAndRanks.h</a>"</span>
<a name="l00014"></a>00014 <span class="preprocessor">#include "<a class="code" href="testUtils_8h.html">testUtils.h</a>"</span>
<a name="l00015"></a>00015 
<a name="l00016"></a>00016 <span class="preprocessor">#ifdef __DEBUG__</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA_NLIST__</span>
<a name="l00018"></a>00018 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA_NLIST__</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span>
<a name="l00022"></a>00022 <span class="preprocessor">#ifdef __DEBUG_DA__</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA_NLIST__</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA_NLIST__</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span>
<a name="l00028"></a>00028 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#ifndef __MEASURE_BUILD_NLIST__</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="preprocessor">#define __MEASURE_BUILD_NLIST__</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span>
<a name="l00034"></a>00034 <span class="comment">//Warning: DO NOT MEDDLE WITH THIS PIECE OF CODE!!!</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="keyword">namespace </span>ot {
<a name="l00037"></a>00037 
<a name="l00038"></a><a class="code" href="odaBuildNlist_8C.html#06e9da9758e62f2e1c8302ea8ac3c32f">00038</a> <span class="preprocessor">#define CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult) { \</span>
<a name="l00039"></a>00039 <span class="preprocessor">  unsigned int tmpMlbIdx;\</span>
<a name="l00040"></a>00040 <span class="preprocessor">  bool tmpMlbResult;\</span>
<a name="l00041"></a>00041 <span class="preprocessor">  tmpMlbResult = seq::maxLowerBound&lt;ot::TreeNode&gt; (arr, key, tmpMlbIdx,NULL,NULL);\</span>
<a name="l00042"></a>00042 <span class="preprocessor">  assert(tmpMlbResult == fastResult);\</span>
<a name="l00043"></a>00043 <span class="preprocessor">  assert(tmpMlbIdx == fastIdx);\</span>
<a name="l00044"></a>00044 <span class="preprocessor">}</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="comment">//Build Node list using 4-way searches...</span>
<a name="l00047"></a><a class="code" href="classot_1_1DA.html#2a53ca905bc072ddf6641e3d91d7dfb8">00047</a> <span class="keywordtype">void</span> <a class="code" href="classot_1_1DA.html#2a53ca905bc072ddf6641e3d91d7dfb8">DA::buildNodeList</a>(std::vector&lt;ot::TreeNode&gt; &amp;in) {
<a name="l00048"></a>00048 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>  <a class="code" href="oda_8h.html#953a7de40693b5e712df61d50d511a8d">PROF_BUILD_NLIST_BEGIN</a>
<a name="l00052"></a>00052     <span class="comment">// everybody except for the boundary and positive ghosts should be elements,</span>
<a name="l00053"></a>00053     <span class="comment">// This means that anything that is not a boundary should be an element.</span>
<a name="l00054"></a>00054     <span class="comment">// The only extra elements added are the ghost elements.</span>
<a name="l00055"></a>00055     <span class="comment">// Initially will store all 8 indices. will not be compressed.</span>
<a name="l00056"></a>00056 
<a name="l00057"></a>00057     <span class="comment">// compute number of elements.</span>
<a name="l00058"></a>00058     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nelem = <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a> + <a class="code" href="classot_1_1DA.html#316fa899531a2eaf1ed039583580d431">m_uiElementSize</a>;
<a name="l00059"></a>00059 
<a name="l00060"></a>00060   std::vector&lt;unsigned int&gt; nlist;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062   <span class="comment">/*</span>
<a name="l00063"></a>00063 <span class="comment">     The first iteration is for pre-ghosts only.</span>
<a name="l00064"></a>00064 <span class="comment">     The second iteration is for own elements. </span>
<a name="l00065"></a>00065 <span class="comment">     The first iteration does not use 4-way searches. The second iteration does.</span>
<a name="l00066"></a>00066 <span class="comment">     */</span>
<a name="l00067"></a>00067   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numFullLoopCtr = 0; numFullLoopCtr &lt; 2; numFullLoopCtr++) {
<a name="l00068"></a>00068 
<a name="l00069"></a>00069     <span class="comment">// Some storage ...</span>
<a name="l00070"></a>00070     std::vector&lt;ot::TreeNode&gt; primaryKeys;
<a name="l00071"></a>00071     std::vector&lt;ot::TreeNode&gt; secondaryKeys;
<a name="l00072"></a>00072     std::vector&lt;ot::TreeNode&gt; extraAtEnd;
<a name="l00073"></a>00073 
<a name="l00074"></a>00074 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00075"></a>00075 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00076"></a>00076     std::vector&lt;ot:: TreeNode &gt; checkSecondRing;
<a name="l00077"></a>00077     std::vector&lt;ot::TreeNode&gt; chkMissedPrimary;
<a name="l00078"></a>00078 <span class="preprocessor">#endif</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iLoopSt,iLoopEnd;
<a name="l00081"></a>00081     <span class="keywordflow">if</span>( numFullLoopCtr == 0) {
<a name="l00082"></a>00082       <span class="comment">//PreGhosts only...</span>
<a name="l00083"></a>00083       iLoopSt = 0;
<a name="l00084"></a>00084       iLoopEnd = <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>;
<a name="l00085"></a>00085     }<span class="keywordflow">else</span> {
<a name="l00086"></a>00086       <span class="comment">//nelem and m_uiPreGhostElementSize would have been changed in the</span>
<a name="l00087"></a>00087       <span class="comment">//first iteration. It's ok. Use the new values only.</span>
<a name="l00088"></a>00088       <span class="comment">//Own elements only...</span>
<a name="l00089"></a>00089       iLoopSt = <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>;
<a name="l00090"></a>00090       iLoopEnd = nelem;
<a name="l00091"></a>00091     }
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>    MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00095"></a>00095     <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l00096"></a>00096       std::cout&lt;&lt;<span class="stringliteral">"numFullLoopCtr: "</span>&lt;&lt;numFullLoopCtr&lt;&lt;std::endl;
<a name="l00097"></a>00097     }
<a name="l00098"></a>00098     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">": preElemSz: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>
<a name="l00099"></a>00099       &lt;&lt;<span class="stringliteral">" elemBeg: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>&lt;&lt;<span class="stringliteral">" elemEnd: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#7663ba260ee97dcc80c083c9ab841f49">m_uiElementEnd</a>
<a name="l00100"></a>00100       &lt;&lt;<span class="stringliteral">" postGhostBegin: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>
<a name="l00101"></a>00101       &lt;&lt;<span class="stringliteral">" locBufferSz: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>
<a name="l00102"></a>00102       &lt;&lt;<span class="stringliteral">" nelem: "</span>&lt;&lt;nelem
<a name="l00103"></a>00103       &lt;&lt;<span class="stringliteral">" iLoopSt: "</span>&lt;&lt;iLoopSt
<a name="l00104"></a>00104       &lt;&lt;<span class="stringliteral">" iLoopEnd: "</span>&lt;&lt;iLoopEnd&lt;&lt;std::endl;
<a name="l00105"></a>00105     assert(<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a> &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>);
<a name="l00106"></a>00106     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" my First Octant(elem/Bnd): "</span>&lt;&lt;in[<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>]&lt;&lt;std::endl;
<a name="l00107"></a>00107     MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00108"></a>00108 <span class="preprocessor">#endif</span>
<a name="l00109"></a>00109 <span class="preprocessor"></span>
<a name="l00110"></a>00110 
<a name="l00111"></a>00111     <span class="comment">//Malloc...</span>
<a name="l00112"></a>00112     <span class="comment">//In the first iteration, we need to only allocate for pre-ghosts.</span>
<a name="l00113"></a>00113     <span class="comment">//The second iteration, it would already be resized to the correct size.</span>
<a name="l00114"></a>00114     <span class="comment">//So there would be no change.</span>
<a name="l00115"></a>00115     <span class="keywordflow">if</span>( numFullLoopCtr == 0) {
<a name="l00116"></a>00116       nlist.resize(8*iLoopEnd);
<a name="l00117"></a>00117       <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>.resize(2*iLoopEnd);
<a name="l00118"></a>00118     }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120     <span class="comment">//Loop through all the elements in this set and set LUTs.</span>
<a name="l00121"></a>00121     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = iLoopSt; i &lt; iLoopEnd; i++) {
<a name="l00122"></a>00122 
<a name="l00123"></a>00123       <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i + 1] = 0;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125       std::vector&lt;ot::TreeNode&gt; nodeLocations(8);
<a name="l00126"></a>00126       std::vector&lt;ot::TreeNode&gt; parNodeLocations(8);
<a name="l00127"></a>00127       <span class="comment">// get basic info ...</span>
<a name="l00128"></a>00128       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[i].getLevel();
<a name="l00129"></a>00129       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[i].getX();
<a name="l00130"></a>00130       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[i].getY();
<a name="l00131"></a>00131       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[i].getZ();
<a name="l00132"></a>00132 
<a name="l00133"></a>00133       <span class="comment">//Cryptic Implementation:</span>
<a name="l00134"></a>00134       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parX = ( ( x &gt;&gt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d + 1 ) );
<a name="l00135"></a>00135       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parY = ( ( y &gt;&gt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d + 1 ) );
<a name="l00136"></a>00136       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parZ = ( ( z &gt;&gt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d + 1 ) );
<a name="l00137"></a>00137 
<a name="l00138"></a>00138       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 1u &lt;&lt; (<a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d);
<a name="l00139"></a>00139       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len_par = (<span class="keywordtype">unsigned</span> int)(1u&lt;&lt;( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>  - d +1 ) );
<a name="l00140"></a>00140 
<a name="l00141"></a>00141       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = x % len_par;
<a name="l00142"></a>00142       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = y % len_par;
<a name="l00143"></a>00143       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = z % len_par;
<a name="l00144"></a>00144 
<a name="l00145"></a>00145       a /= sz;
<a name="l00146"></a>00146       b /= sz;
<a name="l00147"></a>00147       c /= sz;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ch_num = (4*c + 2*b + a);
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00152"></a>00152 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( !ch_num || (ch_num==7) ) {
<a name="l00153"></a>00153         <span class="keywordflow">if</span> ( !(in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a>) ) {
<a name="l00154"></a>00154           std::cerr &lt;&lt; <a class="code" href="colors_8h.html#61ef7a1b5082f8dc3761eec9833867c3">RED</a><span class="stringliteral">"Nodes are marked wrongly "</span><a class="code" href="colors_8h.html#a15368f9f838e27e7fab6d2a6379e7a1">NRM</a> &lt;&lt; std::endl;
<a name="l00155"></a>00155           assert(<span class="keyword">false</span>);
<a name="l00156"></a>00156         }
<a name="l00157"></a>00157       }
<a name="l00158"></a>00158 <span class="preprocessor">#endif</span>
<a name="l00159"></a>00159 <span class="preprocessor"></span>
<a name="l00160"></a>00160       <span class="keywordtype">bool</span> found[8];
<a name="l00161"></a>00161       <span class="comment">// haven't found anything yet. Set Default values.</span>
<a name="l00162"></a>00162       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; 8; k++) {
<a name="l00163"></a>00163         nlist[8*i + k] = <a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>;
<a name="l00164"></a>00164         found[k] = <span class="keyword">false</span>;
<a name="l00165"></a>00165       }<span class="comment">//end for k</span>
<a name="l00166"></a>00166 
<a name="l00167"></a>00167       <span class="comment">//~~~~~~~~~~~~~~~~~~~~~~~NEGATIVE SEARCH~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="l00168"></a>00168       <span class="keywordflow">if</span>(numFullLoopCtr == 1) {
<a name="l00169"></a>00169         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idnx, idny, idnz;
<a name="l00170"></a>00170         <span class="comment">//Basic Idea of a negative search. </span>
<a name="l00171"></a>00171         <span class="comment">//1. Search and find elements on the negative faces. </span>
<a name="l00172"></a>00172         <span class="comment">//2. If the result is a brother and the Vtx in question is hanging, swap and copy.</span>
<a name="l00173"></a>00173         <span class="comment">//3. In all other cases, simply copy.</span>
<a name="l00174"></a>00174         <span class="comment">//4. Note, copy only if the nlist is pointing to a valid location</span>
<a name="l00175"></a>00175 
<a name="l00176"></a>00176         <span class="keywordtype">bool</span> foundNegX=<span class="keyword">false</span>, foundNegY=<span class="keyword">false</span>, foundNegZ=<span class="keyword">false</span>;
<a name="l00177"></a>00177 
<a name="l00178"></a>00178         <span class="comment">// first lets do the 3 negative searches and we'll decide how to use it later ...</span>
<a name="l00179"></a>00179         <span class="comment">// search negative X</span>
<a name="l00180"></a>00180         <span class="keywordflow">if</span> (x) {
<a name="l00181"></a>00181           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> knx( x-1, y, z, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00182"></a>00182           foundNegX = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, knx, idnx,NULL,&amp;i);
<a name="l00183"></a>00183 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00184"></a>00184 <span class="preprocessor"></span>          <a class="code" href="odaBuildNlist_8C.html#06e9da9758e62f2e1c8302ea8ac3c32f">CHECK_FAST_MAX_LOWER_BOUND</a>(in,knx,idnx,foundNegX)
<a name="l00185"></a>00185 <span class="preprocessor">#endif</span>
<a name="l00186"></a>00186 <span class="preprocessor"></span>
<a name="l00187"></a>00187             <span class="keywordflow">if</span> ( foundNegX &amp;&amp; (!( (in[idnx].isAncestor(knx) ) || (in[idnx] == knx) )) ) {
<a name="l00188"></a>00188               foundNegX=<span class="keyword">false</span>;
<a name="l00189"></a>00189             }
<a name="l00190"></a>00190           <span class="keywordflow">if</span> ( foundNegX &amp;&amp; (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*idnx+1] == <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) ) {
<a name="l00191"></a>00191             foundNegX=<span class="keyword">false</span>;
<a name="l00192"></a>00192           }
<a name="l00193"></a>00193         }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195         <span class="comment">// search negative Y</span>
<a name="l00196"></a>00196         <span class="keywordflow">if</span> (y) {
<a name="l00197"></a>00197           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> kny( x, y-1, z, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00198"></a>00198           foundNegY = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, kny, idny,NULL,&amp;i) ;
<a name="l00199"></a>00199 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00200"></a>00200 <span class="preprocessor"></span>          <a class="code" href="odaBuildNlist_8C.html#06e9da9758e62f2e1c8302ea8ac3c32f">CHECK_FAST_MAX_LOWER_BOUND</a>(in,kny,idny,foundNegY)
<a name="l00201"></a>00201 <span class="preprocessor">#endif</span>
<a name="l00202"></a>00202 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( foundNegY &amp;&amp; (!( (in[idny].isAncestor(kny) ) || (in[idny] == kny) )) ) {
<a name="l00203"></a>00203               foundNegY=<span class="keyword">false</span>;
<a name="l00204"></a>00204             }
<a name="l00205"></a>00205           <span class="keywordflow">if</span> ( foundNegY &amp;&amp; (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*idny+1] == <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) ) {
<a name="l00206"></a>00206             foundNegY=<span class="keyword">false</span>;
<a name="l00207"></a>00207           }
<a name="l00208"></a>00208         }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210         <span class="comment">// search negative Z</span>
<a name="l00211"></a>00211         <span class="keywordflow">if</span> (z) {
<a name="l00212"></a>00212           <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> knz( x, y, z-1, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00213"></a>00213           foundNegZ = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, knz, idnz,NULL,&amp;i) ;
<a name="l00214"></a>00214 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00215"></a>00215 <span class="preprocessor"></span>          <a class="code" href="odaBuildNlist_8C.html#06e9da9758e62f2e1c8302ea8ac3c32f">CHECK_FAST_MAX_LOWER_BOUND</a>(in,knz,idnz,foundNegZ)
<a name="l00216"></a>00216 <span class="preprocessor">#endif</span>
<a name="l00217"></a>00217 <span class="preprocessor"></span>            <span class="keywordflow">if</span> ( foundNegZ &amp;&amp; (!( (in[idnz].isAncestor(knz) ) || (in[idnz] == knz) )) ) {
<a name="l00218"></a>00218               foundNegZ=<span class="keyword">false</span>;
<a name="l00219"></a>00219             }
<a name="l00220"></a>00220           <span class="keywordflow">if</span> ( foundNegZ &amp;&amp; (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*idnz+1] == <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) ) {
<a name="l00221"></a>00221             foundNegZ=<span class="keyword">false</span>;
<a name="l00222"></a>00222           }
<a name="l00223"></a>00223         }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="comment">// How we use the results of the negative search depends on the child number ...</span>
<a name="l00226"></a>00226         <span class="comment">// if here my is the current element and x, y, and z are the elements in the </span>
<a name="l00227"></a>00227         <span class="comment">// respective negative directions, then the default mapping sans corrections is</span>
<a name="l00228"></a>00228         <span class="comment">// </span>
<a name="l00229"></a>00229         <span class="comment">// my[0] = x[1] = y[2] = z[4]</span>
<a name="l00230"></a>00230         <span class="comment">// my[1] = y[3] = z[5]</span>
<a name="l00231"></a>00231         <span class="comment">// my[2] = x[3] = z[6]</span>
<a name="l00232"></a>00232         <span class="comment">// my[3] = z[7];</span>
<a name="l00233"></a>00233         <span class="comment">// my[4] = x[5] = y[6]</span>
<a name="l00234"></a>00234         <span class="comment">// my[5] = y[7];</span>
<a name="l00235"></a>00235         <span class="comment">// my[6] = x[7];</span>
<a name="l00236"></a>00236         <span class="comment">// </span>
<a name="l00237"></a>00237         <span class="comment">// The corrections will appear for all children except for child zero ... </span>
<a name="l00238"></a>00238         <span class="comment">// and will be explained when they are performed.</span>
<a name="l00239"></a>00239 
<a name="l00240"></a>00240 <span class="preprocessor">#define NEG_SEARCH_BLOCK1(idx,n1l,n1r,n2l,n2r,n3l,n3r,n4l,n4r) {\</span>
<a name="l00241"></a>00241 <span class="preprocessor">  if(nlist[8*idx+n1r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00242"></a>00242 <span class="preprocessor">    nlist[8*i+n1l] = nlist[8*idx+n1r];\</span>
<a name="l00243"></a>00243 <span class="preprocessor">    found[n1l] = true;\</span>
<a name="l00244"></a>00244 <span class="preprocessor">  }\</span>
<a name="l00245"></a>00245 <span class="preprocessor">  if(nlist[8*idx+n2r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00246"></a>00246 <span class="preprocessor">    nlist[8*i+n2l] = nlist[8*idx+n2r];\</span>
<a name="l00247"></a>00247 <span class="preprocessor">    found[n2l] = true;\</span>
<a name="l00248"></a>00248 <span class="preprocessor">  }\</span>
<a name="l00249"></a>00249 <span class="preprocessor">  if(nlist[8*idx+n3r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00250"></a>00250 <span class="preprocessor">    nlist[8*i+n3l] = nlist[8*idx+n3r];\</span>
<a name="l00251"></a>00251 <span class="preprocessor">    found[n3l] = true;\</span>
<a name="l00252"></a>00252 <span class="preprocessor">  }\</span>
<a name="l00253"></a>00253 <span class="preprocessor">  if(nlist[8*idx+n4r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00254"></a>00254 <span class="preprocessor">    nlist[8*i+n4l] = nlist[8*idx+n4r];\</span>
<a name="l00255"></a>00255 <span class="preprocessor">    found[n4l] = true;\</span>
<a name="l00256"></a>00256 <span class="preprocessor">  }\</span>
<a name="l00257"></a>00257 <span class="preprocessor">}</span>
<a name="l00258"></a>00258 <span class="preprocessor"></span>
<a name="l00259"></a>00259 <span class="preprocessor">#define NEG_SEARCH_BLOCK2(idx,n1l,n1r,n2l,n2r,n3l,n3r,n4l,n4r) {\</span>
<a name="l00260"></a>00260 <span class="preprocessor">  unsigned char negMask;\</span>
<a name="l00261"></a>00261 <span class="preprocessor">  if ( in[i].getLevel() != in[idx].getLevel()) {\</span>
<a name="l00262"></a>00262 <span class="preprocessor">    negMask = 0;\</span>
<a name="l00263"></a>00263 <span class="preprocessor">  } else {\</span>
<a name="l00264"></a>00264 <span class="preprocessor">    negMask = m_ucpLutMasks[2*idx+1];\</span>
<a name="l00265"></a>00265 <span class="preprocessor">  }\</span>
<a name="l00266"></a>00266 <span class="preprocessor">  if (negMask != ot::DA_FLAGS::FOREIGN) {\</span>
<a name="l00267"></a>00267 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n1r)) {\</span>
<a name="l00268"></a>00268 <span class="preprocessor">      if(nlist[8*idx+n1l] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00269"></a>00269 <span class="preprocessor">        nlist[8*i+n1l] = nlist[8*idx+n1l];\</span>
<a name="l00270"></a>00270 <span class="preprocessor">        found[n1l] = true;\</span>
<a name="l00271"></a>00271 <span class="preprocessor">      }\</span>
<a name="l00272"></a>00272 <span class="preprocessor">    } else {\</span>
<a name="l00273"></a>00273 <span class="preprocessor">      if(nlist[8*idx+n1r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00274"></a>00274 <span class="preprocessor">        nlist[8*i+n1l] = nlist[8*idx+n1r];\</span>
<a name="l00275"></a>00275 <span class="preprocessor">        found[n1l] = true;\</span>
<a name="l00276"></a>00276 <span class="preprocessor">      }\</span>
<a name="l00277"></a>00277 <span class="preprocessor">    }\</span>
<a name="l00278"></a>00278 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n2r)) {\</span>
<a name="l00279"></a>00279 <span class="preprocessor">      if(nlist[8*idx+n2l] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00280"></a>00280 <span class="preprocessor">        nlist[8*i+n2l] = nlist[8*idx+n2l];\</span>
<a name="l00281"></a>00281 <span class="preprocessor">        found[n2l] = true;\</span>
<a name="l00282"></a>00282 <span class="preprocessor">      }\</span>
<a name="l00283"></a>00283 <span class="preprocessor">    } else {\</span>
<a name="l00284"></a>00284 <span class="preprocessor">      if(nlist[8*idx+n2r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00285"></a>00285 <span class="preprocessor">        nlist[8*i+n2l] = nlist[8*idx+n2r];\</span>
<a name="l00286"></a>00286 <span class="preprocessor">        found[n2l] = true;\</span>
<a name="l00287"></a>00287 <span class="preprocessor">      }\</span>
<a name="l00288"></a>00288 <span class="preprocessor">    }\</span>
<a name="l00289"></a>00289 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n3r)) {\</span>
<a name="l00290"></a>00290 <span class="preprocessor">      if(nlist[8*idx+n3l] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00291"></a>00291 <span class="preprocessor">        nlist[8*i+n3l] = nlist[8*idx+n3l];\</span>
<a name="l00292"></a>00292 <span class="preprocessor">        found[n3l] = true;\</span>
<a name="l00293"></a>00293 <span class="preprocessor">      }\</span>
<a name="l00294"></a>00294 <span class="preprocessor">    } else {\</span>
<a name="l00295"></a>00295 <span class="preprocessor">      if(nlist[8*idx+n3r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00296"></a>00296 <span class="preprocessor">        nlist[8*i+n3l] = nlist[8*idx+n3r];\</span>
<a name="l00297"></a>00297 <span class="preprocessor">        found[n3l] = true;\</span>
<a name="l00298"></a>00298 <span class="preprocessor">      }\</span>
<a name="l00299"></a>00299 <span class="preprocessor">    }\</span>
<a name="l00300"></a>00300 <span class="preprocessor">    if ( negMask &amp; (1 &lt;&lt; n4r)) {\</span>
<a name="l00301"></a>00301 <span class="preprocessor">      if(nlist[8*idx+n4l] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00302"></a>00302 <span class="preprocessor">        nlist[8*i+n4l] = nlist[8*idx+n4l];\</span>
<a name="l00303"></a>00303 <span class="preprocessor">        found[n4l] = true;\</span>
<a name="l00304"></a>00304 <span class="preprocessor">      }\</span>
<a name="l00305"></a>00305 <span class="preprocessor">    } else {\</span>
<a name="l00306"></a>00306 <span class="preprocessor">      if(nlist[8*idx+n4r] &lt; m_uiLocalBufferSize) {\</span>
<a name="l00307"></a>00307 <span class="preprocessor">        nlist[8*i+n4l] = nlist[8*idx+n4r];\</span>
<a name="l00308"></a>00308 <span class="preprocessor">        found[n4l] = true;\</span>
<a name="l00309"></a>00309 <span class="preprocessor">      }\</span>
<a name="l00310"></a>00310 <span class="preprocessor">    }\</span>
<a name="l00311"></a>00311 <span class="preprocessor">  }\</span>
<a name="l00312"></a>00312 <span class="preprocessor">}</span>
<a name="l00313"></a>00313 <span class="preprocessor"></span>
<a name="l00314"></a>00314 <span class="preprocessor">#define NEG_SEARCH_BLOCK1X NEG_SEARCH_BLOCK1(idnx,0,1,2,3,4,5,6,7)</span>
<a name="l00315"></a>00315 <span class="preprocessor"></span><span class="preprocessor">#define NEG_SEARCH_BLOCK2X NEG_SEARCH_BLOCK2(idnx,0,1,2,3,4,5,6,7)</span>
<a name="l00316"></a>00316 <span class="preprocessor"></span>
<a name="l00317"></a>00317 <span class="preprocessor">#define NEG_SEARCH_BLOCK1Y NEG_SEARCH_BLOCK1(idny,0,2,1,3,4,6,5,7)</span>
<a name="l00318"></a>00318 <span class="preprocessor"></span><span class="preprocessor">#define NEG_SEARCH_BLOCK2Y NEG_SEARCH_BLOCK2(idny,0,2,1,3,4,6,5,7)</span>
<a name="l00319"></a>00319 <span class="preprocessor"></span>
<a name="l00320"></a>00320 <span class="preprocessor">#define NEG_SEARCH_BLOCK1Z NEG_SEARCH_BLOCK1(idnz,0,4,1,5,2,6,3,7)</span>
<a name="l00321"></a>00321 <span class="preprocessor"></span><span class="preprocessor">#define NEG_SEARCH_BLOCK2Z NEG_SEARCH_BLOCK2(idnz,0,4,1,5,2,6,3,7)</span>
<a name="l00322"></a>00322 <span class="preprocessor"></span>
<a name="l00323"></a>00323 <span class="keywordflow">switch</span> (ch_num) {
<a name="l00324"></a>00324   <span class="keywordflow">case</span> 0: {
<a name="l00325"></a>00325             <span class="comment">//No Negative brothers.</span>
<a name="l00326"></a>00326             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00327"></a>00327               <a class="code" href="odaBuildNlist_8C.html#bf8009eb31ee5903885d4dc420aef583">NEG_SEARCH_BLOCK1X</a>
<a name="l00328"></a>00328             }
<a name="l00329"></a>00329             <span class="keywordflow">if</span> (foundNegY) {
<a name="l00330"></a>00330               <a class="code" href="odaBuildNlist_8C.html#5c577d5d492365d649cae98964705d13">NEG_SEARCH_BLOCK1Y</a>
<a name="l00331"></a>00331             }
<a name="l00332"></a>00332             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00333"></a>00333               <a class="code" href="odaBuildNlist_8C.html#427bbd773692ce571e0f86935e91200e">NEG_SEARCH_BLOCK1Z</a>
<a name="l00334"></a>00334             }
<a name="l00335"></a>00335             <span class="keywordflow">break</span>;
<a name="l00336"></a>00336           }
<a name="l00337"></a>00337   <span class="keywordflow">case</span> 1: {
<a name="l00338"></a>00338             <span class="comment">//negX could be a brother. </span>
<a name="l00339"></a>00339             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00340"></a>00340               <a class="code" href="odaBuildNlist_8C.html#109f4eaf040e791f4a23ff5b82d02854">NEG_SEARCH_BLOCK2X</a>
<a name="l00341"></a>00341             }
<a name="l00342"></a>00342             <span class="keywordflow">if</span> (foundNegY) {
<a name="l00343"></a>00343               <a class="code" href="odaBuildNlist_8C.html#5c577d5d492365d649cae98964705d13">NEG_SEARCH_BLOCK1Y</a>
<a name="l00344"></a>00344             }
<a name="l00345"></a>00345             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00346"></a>00346               <a class="code" href="odaBuildNlist_8C.html#427bbd773692ce571e0f86935e91200e">NEG_SEARCH_BLOCK1Z</a>
<a name="l00347"></a>00347             }
<a name="l00348"></a>00348             <span class="keywordflow">break</span>;
<a name="l00349"></a>00349           }
<a name="l00350"></a>00350   <span class="keywordflow">case</span> 2: {
<a name="l00351"></a>00351             <span class="comment">//negY could be a brother.</span>
<a name="l00352"></a>00352             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00353"></a>00353               <a class="code" href="odaBuildNlist_8C.html#bf8009eb31ee5903885d4dc420aef583">NEG_SEARCH_BLOCK1X</a>
<a name="l00354"></a>00354             }
<a name="l00355"></a>00355             <span class="keywordflow">if</span> (foundNegY) {
<a name="l00356"></a>00356               <a class="code" href="odaBuildNlist_8C.html#1675b565d0078bb988d4ca8e605e8206">NEG_SEARCH_BLOCK2Y</a>
<a name="l00357"></a>00357             }
<a name="l00358"></a>00358             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00359"></a>00359               <a class="code" href="odaBuildNlist_8C.html#427bbd773692ce571e0f86935e91200e">NEG_SEARCH_BLOCK1Z</a>
<a name="l00360"></a>00360             }
<a name="l00361"></a>00361             <span class="keywordflow">break</span>;
<a name="l00362"></a>00362           }
<a name="l00363"></a>00363   <span class="keywordflow">case</span> 3: {
<a name="l00364"></a>00364             <span class="comment">//negX and negY could be brothers.</span>
<a name="l00365"></a>00365             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00366"></a>00366               <a class="code" href="odaBuildNlist_8C.html#109f4eaf040e791f4a23ff5b82d02854">NEG_SEARCH_BLOCK2X</a>
<a name="l00367"></a>00367             }
<a name="l00368"></a>00368             <span class="keywordflow">if</span> (foundNegY) {
<a name="l00369"></a>00369               <a class="code" href="odaBuildNlist_8C.html#1675b565d0078bb988d4ca8e605e8206">NEG_SEARCH_BLOCK2Y</a>
<a name="l00370"></a>00370             }
<a name="l00371"></a>00371             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00372"></a>00372               <a class="code" href="odaBuildNlist_8C.html#427bbd773692ce571e0f86935e91200e">NEG_SEARCH_BLOCK1Z</a>
<a name="l00373"></a>00373             }
<a name="l00374"></a>00374             <span class="keywordflow">break</span>;
<a name="l00375"></a>00375           }
<a name="l00376"></a>00376   <span class="keywordflow">case</span> 4: {
<a name="l00377"></a>00377             <span class="comment">//negZ could be a brother.</span>
<a name="l00378"></a>00378             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00379"></a>00379               <a class="code" href="odaBuildNlist_8C.html#bf8009eb31ee5903885d4dc420aef583">NEG_SEARCH_BLOCK1X</a>
<a name="l00380"></a>00380             }
<a name="l00381"></a>00381             <span class="keywordflow">if</span> (foundNegY) { 
<a name="l00382"></a>00382               <a class="code" href="odaBuildNlist_8C.html#5c577d5d492365d649cae98964705d13">NEG_SEARCH_BLOCK1Y</a>
<a name="l00383"></a>00383             }
<a name="l00384"></a>00384             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00385"></a>00385               <a class="code" href="odaBuildNlist_8C.html#07e5766f7870b20a5f1fa6d7b94d638f">NEG_SEARCH_BLOCK2Z</a>
<a name="l00386"></a>00386             }
<a name="l00387"></a>00387             <span class="keywordflow">break</span>;
<a name="l00388"></a>00388           }
<a name="l00389"></a>00389   <span class="keywordflow">case</span> 5: {
<a name="l00390"></a>00390             <span class="comment">//negX and negZ could be brothers.</span>
<a name="l00391"></a>00391             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00392"></a>00392               <a class="code" href="odaBuildNlist_8C.html#109f4eaf040e791f4a23ff5b82d02854">NEG_SEARCH_BLOCK2X</a>
<a name="l00393"></a>00393             }
<a name="l00394"></a>00394             <span class="keywordflow">if</span> (foundNegY) {  
<a name="l00395"></a>00395               <a class="code" href="odaBuildNlist_8C.html#5c577d5d492365d649cae98964705d13">NEG_SEARCH_BLOCK1Y</a>
<a name="l00396"></a>00396             }
<a name="l00397"></a>00397             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00398"></a>00398               <a class="code" href="odaBuildNlist_8C.html#07e5766f7870b20a5f1fa6d7b94d638f">NEG_SEARCH_BLOCK2Z</a>
<a name="l00399"></a>00399             }
<a name="l00400"></a>00400             <span class="keywordflow">break</span>;
<a name="l00401"></a>00401           }
<a name="l00402"></a>00402   <span class="keywordflow">case</span> 6: {
<a name="l00403"></a>00403             <span class="comment">//negY and negZ could be brothers.</span>
<a name="l00404"></a>00404             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00405"></a>00405               <a class="code" href="odaBuildNlist_8C.html#bf8009eb31ee5903885d4dc420aef583">NEG_SEARCH_BLOCK1X</a>
<a name="l00406"></a>00406             }
<a name="l00407"></a>00407             <span class="keywordflow">if</span> (foundNegY) {
<a name="l00408"></a>00408               <a class="code" href="odaBuildNlist_8C.html#1675b565d0078bb988d4ca8e605e8206">NEG_SEARCH_BLOCK2Y</a>
<a name="l00409"></a>00409             }
<a name="l00410"></a>00410             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00411"></a>00411               <a class="code" href="odaBuildNlist_8C.html#07e5766f7870b20a5f1fa6d7b94d638f">NEG_SEARCH_BLOCK2Z</a>
<a name="l00412"></a>00412             }
<a name="l00413"></a>00413             <span class="keywordflow">break</span>;
<a name="l00414"></a>00414           }
<a name="l00415"></a>00415   <span class="keywordflow">case</span> 7: {
<a name="l00416"></a>00416             <span class="comment">//negX negY and negZ could be brothers.</span>
<a name="l00417"></a>00417             <span class="keywordflow">if</span> (foundNegX) {
<a name="l00418"></a>00418               <a class="code" href="odaBuildNlist_8C.html#109f4eaf040e791f4a23ff5b82d02854">NEG_SEARCH_BLOCK2X</a>
<a name="l00419"></a>00419             }
<a name="l00420"></a>00420             <span class="keywordflow">if</span> (foundNegY) {
<a name="l00421"></a>00421               <a class="code" href="odaBuildNlist_8C.html#1675b565d0078bb988d4ca8e605e8206">NEG_SEARCH_BLOCK2Y</a>
<a name="l00422"></a>00422             }
<a name="l00423"></a>00423             <span class="keywordflow">if</span> (foundNegZ) {
<a name="l00424"></a>00424               <a class="code" href="odaBuildNlist_8C.html#07e5766f7870b20a5f1fa6d7b94d638f">NEG_SEARCH_BLOCK2Z</a>
<a name="l00425"></a>00425             }
<a name="l00426"></a>00426             <span class="keywordflow">break</span>;
<a name="l00427"></a>00427           }
<a name="l00428"></a>00428   <span class="keywordflow">default</span>: {
<a name="l00429"></a>00429              std::cerr &lt;&lt; <span class="stringliteral">"Wrong Child Number "</span> &lt;&lt; ch_num &lt;&lt; std::endl;
<a name="l00430"></a>00430              assert(<span class="keyword">false</span>);
<a name="l00431"></a>00431              <span class="keywordflow">break</span>;
<a name="l00432"></a>00432            }
<a name="l00433"></a>00433 }<span class="comment">//end cases</span>
<a name="l00434"></a>00434 }<span class="comment">//end if for negative</span>
<a name="l00435"></a>00435 
<a name="l00436"></a>00436 <span class="preprocessor">#undef NEG_SEARCH_BLOCK1X</span>
<a name="l00437"></a>00437 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2X</span>
<a name="l00438"></a>00438 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK1Y</span>
<a name="l00439"></a>00439 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2Y </span>
<a name="l00440"></a>00440 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK1Z </span>
<a name="l00441"></a>00441 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2Z</span>
<a name="l00442"></a>00442 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK1</span>
<a name="l00443"></a>00443 <span class="preprocessor"></span><span class="preprocessor">#undef NEG_SEARCH_BLOCK2</span>
<a name="l00444"></a>00444 <span class="preprocessor"></span>
<a name="l00445"></a>00445 <span class="comment">//~~~~~~~~~~~~~~~~~~~~~POSITIVE SEARCH~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="l00446"></a>00446 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00447"></a>00447 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult) CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult)</span>
<a name="l00448"></a>00448 <span class="preprocessor"></span>
<a name="l00449"></a>00449 <span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK1(debugV1,debugV2) {\</span>
<a name="l00450"></a>00450 <span class="preprocessor">  if ( (ch_num == debugV1) || (ch_num == debugV2) ) {\</span>
<a name="l00451"></a>00451 <span class="preprocessor">    std::cout &lt;&lt; "Failing for index " &lt;&lt; i &lt;&lt; " with child num " &lt;&lt; ch_num &lt;&lt; std::endl;\</span>
<a name="l00452"></a>00452 <span class="preprocessor">    assert(false);\</span>
<a name="l00453"></a>00453 <span class="preprocessor">  }\</span>
<a name="l00454"></a>00454 <span class="preprocessor">}</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>
<a name="l00456"></a>00456 <span class="preprocessor">#define  POS_SEARCH_DEBUG_BLOCK2 {\</span>
<a name="l00457"></a>00457 <span class="preprocessor">  assert(sKey &gt; in[m_uiPostGhostBegin - 1]);\</span>
<a name="l00458"></a>00458 <span class="preprocessor">  chkMissedPrimary.push_back(sKey);\</span>
<a name="l00459"></a>00459 <span class="preprocessor">}</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>
<a name="l00461"></a>00461 <span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK3 {\</span>
<a name="l00462"></a>00462 <span class="preprocessor">  assert( (idx+k) &lt; m_uiLocalBufferSize );\</span>
<a name="l00463"></a>00463 <span class="preprocessor">  assert( in[idx+k].getParent() == newKey );\</span>
<a name="l00464"></a>00464 <span class="preprocessor">  assert( !(in[idx+k].getFlag() &amp; ot::TreeNode::NODE) );\</span>
<a name="l00465"></a>00465 <span class="preprocessor">  assert( ((idx+k) &lt; m_uiElementBegin) || (((idx+k) &gt;= m_uiPostGhostBegin)) );\</span>
<a name="l00466"></a>00466 <span class="preprocessor">}</span>
<a name="l00467"></a>00467 <span class="preprocessor"></span>
<a name="l00468"></a>00468 <span class="preprocessor">#else</span>
<a name="l00469"></a>00469 <span class="preprocessor"></span><span class="preprocessor">#define DEBUG_CHECK_FAST_MAX_LOWER_BOUND(arr,key,fastIdx,fastResult) </span>
<a name="l00470"></a>00470 <span class="preprocessor"></span><span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK1(debugV1,debugV2)</span>
<a name="l00471"></a>00471 <span class="preprocessor"></span><span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK2</span>
<a name="l00472"></a>00472 <span class="preprocessor"></span><span class="preprocessor">#define POS_SEARCH_DEBUG_BLOCK3</span>
<a name="l00473"></a>00473 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00474"></a>00474 <span class="preprocessor"></span>
<a name="l00475"></a>00475 <span class="preprocessor">#define POS_SECONDARY_SEARCH_BLOCK(debugV1,debugV2) {\</span>
<a name="l00476"></a>00476 <span class="preprocessor">  </span><span class="comment">/* if this is not a node, i.e., it is hanging*/</span>\
<a name="l00477"></a>00477   POS_SEARCH_DEBUG_BLOCK1(debugV1,debugV2)\
<a name="l00478"></a>00478   <span class="comment">/* All other cNums are anchored at the parent+(2*sz,0,0).*/</span>\
<a name="l00479"></a>00479   sKey = parNodeLocations[j];\
<a name="l00480"></a>00480   lastLevel = d-1;\
<a name="l00481"></a>00481   foundKey = seq::maxLowerBound&lt;ot::TreeNode&gt;(in, sKey, idx,&amp;i,NULL);\
<a name="l00482"></a>00482   DEBUG_CHECK_FAST_MAX_LOWER_BOUND(in, sKey,idx, foundKey) \
<a name="l00483"></a>00483   if ( foundKey &amp;&amp; !((in[idx].getAnchor()==sKey.getAnchor()) &amp;&amp; (in[idx].getFlag()&amp;ot::TreeNode::NODE))) {\
<a name="l00484"></a>00484     foundKey=false;\
<a name="l00485"></a>00485   }\
<a name="l00486"></a>00486   if ( foundKey ) {\
<a name="l00487"></a>00487     nlist[8*i+j] = idx;\
<a name="l00488"></a>00488   } else {\
<a name="l00489"></a>00489     <span class="comment">/* Can happen for own elements too. */</span>\
<a name="l00490"></a>00490     findGhost = true;\
<a name="l00491"></a>00491   }\
<a name="l00492"></a>00492 }
<a name="l00493"></a>00493 
<a name="l00494"></a>00494 <span class="preprocessor">#define POS_SEARCH_BLOCK(debugV1,debugV2) {\</span>
<a name="l00495"></a>00495 <span class="preprocessor">  </span><span class="comment">/* first search in default location */</span>\
<a name="l00496"></a>00496   sKey = nodeLocations[j];\
<a name="l00497"></a>00497   lastLevel = d;\
<a name="l00498"></a>00498   foundKey = seq::maxLowerBound&lt;ot::TreeNode&gt;(in, sKey, idx,&amp;i,NULL);\
<a name="l00499"></a>00499   DEBUG_CHECK_FAST_MAX_LOWER_BOUND(in, sKey,idx, foundKey) \
<a name="l00500"></a>00500   if(foundKey &amp;&amp; !( (in[idx].isAncestor(sKey) ) || (in[idx]==sKey))) {\
<a name="l00501"></a>00501     foundKey=false;\
<a name="l00502"></a>00502   }\
<a name="l00503"></a>00503   if(foundKey) {\
<a name="l00504"></a>00504     <span class="comment">/*found somebody*/</span>\
<a name="l00505"></a>00505     if((in[idx].getAnchor()==sKey.getAnchor())&amp;&amp;(in[idx].getFlag() &amp; ot::TreeNode::NODE)) {\
<a name="l00506"></a>00506       <span class="comment">/*found a node, so set it.*/</span>\
<a name="l00507"></a>00507       nlist[8*i+j] = idx;\
<a name="l00508"></a>00508     } else {\
<a name="l00509"></a>00509       POS_SECONDARY_SEARCH_BLOCK(debugV1,debugV2)\
<a name="l00510"></a>00510     }\
<a name="l00511"></a>00511   } else {\
<a name="l00512"></a>00512     if(i &gt;= m_uiElementBegin) {\
<a name="l00513"></a>00513       <span class="comment">/*The primary search for some vertex of my own element failed*/</span>\
<a name="l00514"></a>00514       <span class="comment">/*This should only happen if the node we are looking for is*/</span>\
<a name="l00515"></a>00515       <span class="comment">/*a post-ghost and it is hanging. When we do the check later*/</span>\
<a name="l00516"></a>00516       <span class="comment">/*we must also test that this node is a real anchor. */</span>\
<a name="l00517"></a>00517       POS_SEARCH_DEBUG_BLOCK2\
<a name="l00518"></a>00518       <span class="comment">/*Treat this case just as if the search successfully returned*/</span>\
<a name="l00519"></a>00519       <span class="comment">/*a node, but it turned out to be hanging*/</span>\
<a name="l00520"></a>00520       POS_SECONDARY_SEARCH_BLOCK(debugV1,debugV2)\
<a name="l00521"></a>00521     } else {\
<a name="l00522"></a>00522       <span class="comment">/* this is a pre-ghost so it is normal*/</span>\
<a name="l00523"></a>00523       <span class="comment">/*to miss some primary searches */</span>\
<a name="l00524"></a>00524       findGhost=true;\
<a name="l00525"></a>00525     }\
<a name="l00526"></a>00526   }\
<a name="l00527"></a>00527   if ( findGhost ) {\
<a name="l00528"></a>00528     findGhost=false;\
<a name="l00529"></a>00529     <span class="comment">/* need to find the ghost. */</span>\
<a name="l00530"></a>00530     <span class="comment">/* check if idx+k is valid */</span>\
<a name="l00531"></a>00531     ot::TreeNode newKey(sKey.getX(),sKey.getY(),sKey.getZ(),\
<a name="l00532"></a>00532         lastLevel,m_uiDimension,m_uiMaxDepth);\
<a name="l00533"></a>00533     unsigned int k=1;\
<a name="l00534"></a>00534     while ( (idx+k) &lt; in.size() ) {\
<a name="l00535"></a>00535       if ( in[idx+k].getParent() == newKey ) {\
<a name="l00536"></a>00536         if ( in[idx+k].getFlag() &amp; ot::TreeNode::NODE ) {\
<a name="l00537"></a>00537           k++;\
<a name="l00538"></a>00538           continue;\
<a name="l00539"></a>00539         } else {\
<a name="l00540"></a>00540           <span class="comment">/* found the correct node. (hanging)*/</span>\
<a name="l00541"></a>00541           findGhost=true;\
<a name="l00542"></a>00542           break;\
<a name="l00543"></a>00543         }\
<a name="l00544"></a>00544       }\
<a name="l00545"></a>00545       if ( in[idx+k] &gt; newKey.getDLD() ) {\
<a name="l00546"></a>00546         findGhost = false;\
<a name="l00547"></a>00547         break;\
<a name="l00548"></a>00548       } else {\
<a name="l00549"></a>00549         k++;\
<a name="l00550"></a>00550       }\
<a name="l00551"></a>00551     }\
<a name="l00552"></a>00552     if (findGhost) {\
<a name="l00553"></a>00553       nlist[8*i+j] = idx+k;\
<a name="l00554"></a>00554       POS_SEARCH_DEBUG_BLOCK3\
<a name="l00555"></a>00555     } else {\
<a name="l00556"></a>00556       nlist[8*i+j] = m_uiLocalBufferSize;\
<a name="l00557"></a>00557     }\
<a name="l00558"></a>00558   }\
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 <span class="comment">// find the eight vertices ...</span>
<a name="l00562"></a>00562 <span class="comment">//Only 0 is a special case.</span>
<a name="l00563"></a>00563 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
<a name="l00564"></a>00564   <span class="keywordflow">if</span>(found[j]) {
<a name="l00565"></a>00565     <span class="keywordflow">continue</span>;
<a name="l00566"></a>00566   }
<a name="l00567"></a>00567   <span class="keywordtype">bool</span> foundKey=<span class="keyword">false</span>;
<a name="l00568"></a>00568   <span class="keywordtype">bool</span> findGhost=<span class="keyword">false</span>;
<a name="l00569"></a>00569   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
<a name="l00570"></a>00570   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastLevel;
<a name="l00571"></a>00571   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> sKey(<a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="keywordflow">switch</span> (j) {
<a name="l00574"></a>00574     <span class="keywordflow">case</span> 0: {
<a name="l00575"></a>00575               nodeLocations[j] =
<a name="l00576"></a>00576                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, z, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00577"></a>00577               parNodeLocations[j] = 
<a name="l00578"></a>00578                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY, parZ, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00579"></a>00579               <span class="comment">// first search is not required since we are searching for i</span>
<a name="l00580"></a>00580               <span class="keywordflow">if</span> ( !(in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a> ) ) {
<a name="l00581"></a>00581                 <span class="comment">// if this is not a node, i.e., it is hanging</span>
<a name="l00582"></a>00582 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00583"></a>00583 <span class="preprocessor"></span>                <span class="keywordflow">if</span> ( (ch_num == 0) || (ch_num == 7) ) {
<a name="l00584"></a>00584                   std::cout &lt;&lt; <span class="stringliteral">"Failing for index "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" with child num "</span> &lt;&lt; ch_num &lt;&lt; std::endl;
<a name="l00585"></a>00585                   assert(<span class="keyword">false</span>);
<a name="l00586"></a>00586                 }
<a name="l00587"></a>00587 <span class="preprocessor">#endif</span>
<a name="l00588"></a>00588 <span class="preprocessor"></span>                <span class="comment">// All other child numbers are anchored at the parent.</span>
<a name="l00589"></a>00589                 sKey = parNodeLocations[j];
<a name="l00590"></a>00590                 lastLevel = d-1;
<a name="l00591"></a>00591                 foundKey = seq::maxLowerBound&lt;ot::TreeNode&gt; (in, sKey, idx,NULL,&amp;i);
<a name="l00592"></a>00592 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span>                <a class="code" href="odaBuildNlist_8C.html#06e9da9758e62f2e1c8302ea8ac3c32f">CHECK_FAST_MAX_LOWER_BOUND</a>(in, sKey,idx, foundKey) 
<a name="l00594"></a>00594 <span class="preprocessor">#endif</span>
<a name="l00595"></a>00595 <span class="preprocessor"></span>                  <span class="keywordflow">if</span> ( foundKey &amp;&amp; 
<a name="l00596"></a>00596                       (!( (in[idx].getAnchor() == sKey.getAnchor()) &amp;&amp; (in[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; ot::TreeNode::NODE) )) ) {
<a name="l00597"></a>00597                     foundKey=<span class="keyword">false</span>;
<a name="l00598"></a>00598                   }
<a name="l00599"></a>00599                 <span class="keywordflow">if</span> ( !foundKey ) {
<a name="l00600"></a>00600 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00601"></a>00601 <span class="preprocessor"></span>                  <span class="comment">// should only happen for ghosts ...</span>
<a name="l00602"></a>00602                   <span class="keywordflow">if</span>(i &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) {
<a name="l00603"></a>00603                     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" i = "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" preGhostElemEnd "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>
<a name="l00604"></a>00604                       &lt;&lt;<span class="stringliteral">" elemBeg: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>&lt;&lt;<span class="stringliteral">" elemEnd: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#7663ba260ee97dcc80c083c9ab841f49">m_uiElementEnd</a>&lt;&lt;std::endl;
<a name="l00605"></a>00605                   }
<a name="l00606"></a>00606                   assert (i &lt; <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>);
<a name="l00607"></a>00607 <span class="preprocessor">#endif</span>
<a name="l00608"></a>00608 <span class="preprocessor"></span>                  <span class="comment">// for node zero, simply default to i.</span>
<a name="l00609"></a>00609                   nlist[8*i+j] = i;
<a name="l00610"></a>00610                 } <span class="keywordflow">else</span> {
<a name="l00611"></a>00611                   nlist[8*i+j] = idx;
<a name="l00612"></a>00612                 }
<a name="l00613"></a>00613               } <span class="keywordflow">else</span> {
<a name="l00614"></a>00614                 nlist[8*i+j] = i;
<a name="l00615"></a>00615               }
<a name="l00616"></a>00616               <span class="keywordflow">break</span>;
<a name="l00617"></a>00617             }
<a name="l00618"></a>00618     <span class="keywordflow">case</span> 1: {
<a name="l00619"></a>00619               nodeLocations[j] = 
<a name="l00620"></a>00620                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y, z, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00621"></a>00621               parNodeLocations[j] = 
<a name="l00622"></a>00622                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY, parZ, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00623"></a>00623               <a class="code" href="odaBuildNlist_8C.html#fdcfee3524f44e48c46532cb3bb4db7d">POS_SEARCH_BLOCK</a>(1,6) 
<a name="l00624"></a>00624                 <span class="keywordflow">break</span>;
<a name="l00625"></a>00625             }
<a name="l00626"></a>00626     <span class="keywordflow">case</span> 2: {
<a name="l00627"></a>00627               nodeLocations[j] = 
<a name="l00628"></a>00628                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y+sz, z, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00629"></a>00629               parNodeLocations[j] = 
<a name="l00630"></a>00630                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY+(sz&lt;&lt;1u), parZ, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00631"></a>00631               <a class="code" href="odaBuildNlist_8C.html#fdcfee3524f44e48c46532cb3bb4db7d">POS_SEARCH_BLOCK</a>(2,5) 
<a name="l00632"></a>00632                 <span class="keywordflow">break</span>;
<a name="l00633"></a>00633             }
<a name="l00634"></a>00634     <span class="keywordflow">case</span> 3: {
<a name="l00635"></a>00635               nodeLocations[j] = 
<a name="l00636"></a>00636                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y+sz, z, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00637"></a>00637               parNodeLocations[j] = 
<a name="l00638"></a>00638                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY+(sz&lt;&lt;1u), parZ, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00639"></a>00639               <a class="code" href="odaBuildNlist_8C.html#fdcfee3524f44e48c46532cb3bb4db7d">POS_SEARCH_BLOCK</a>(3,4) 
<a name="l00640"></a>00640                 <span class="keywordflow">break</span>;
<a name="l00641"></a>00641             }
<a name="l00642"></a>00642     <span class="keywordflow">case</span> 4: {
<a name="l00643"></a>00643               nodeLocations[j] = 
<a name="l00644"></a>00644                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, z+sz, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00645"></a>00645               parNodeLocations[j] = 
<a name="l00646"></a>00646                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY, parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00647"></a>00647               <a class="code" href="odaBuildNlist_8C.html#fdcfee3524f44e48c46532cb3bb4db7d">POS_SEARCH_BLOCK</a>(4,3) 
<a name="l00648"></a>00648                 <span class="keywordflow">break</span>;
<a name="l00649"></a>00649             }
<a name="l00650"></a>00650     <span class="keywordflow">case</span> 5: {
<a name="l00651"></a>00651               nodeLocations[j] = 
<a name="l00652"></a>00652                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y, z+sz, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00653"></a>00653               parNodeLocations[j] = 
<a name="l00654"></a>00654                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY, parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00655"></a>00655               <a class="code" href="odaBuildNlist_8C.html#fdcfee3524f44e48c46532cb3bb4db7d">POS_SEARCH_BLOCK</a>(5,2) 
<a name="l00656"></a>00656                 <span class="keywordflow">break</span>;
<a name="l00657"></a>00657             }
<a name="l00658"></a>00658     <span class="keywordflow">case</span> 6: {
<a name="l00659"></a>00659               nodeLocations[j] = 
<a name="l00660"></a>00660                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y+sz, z+sz, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00661"></a>00661               parNodeLocations[j] = 
<a name="l00662"></a>00662                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY+(sz&lt;&lt;1u), parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00663"></a>00663               <a class="code" href="odaBuildNlist_8C.html#fdcfee3524f44e48c46532cb3bb4db7d">POS_SEARCH_BLOCK</a>(6,1) 
<a name="l00664"></a>00664                 <span class="keywordflow">break</span>;
<a name="l00665"></a>00665             }
<a name="l00666"></a>00666     <span class="keywordflow">case</span> 7: {
<a name="l00667"></a>00667               nodeLocations[j] = 
<a name="l00668"></a>00668                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x+sz, y+sz, z+sz, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00669"></a>00669               parNodeLocations[j] = 
<a name="l00670"></a>00670                 <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX+(sz&lt;&lt;1u), parY+(sz&lt;&lt;1u), parZ+(sz&lt;&lt;1u), <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>, <a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>, <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00671"></a>00671               <a class="code" href="odaBuildNlist_8C.html#fdcfee3524f44e48c46532cb3bb4db7d">POS_SEARCH_BLOCK</a>(7,0) 
<a name="l00672"></a>00672                 <span class="keywordflow">break</span>;
<a name="l00673"></a>00673             }
<a name="l00674"></a>00674     <span class="keywordflow">default</span>: {
<a name="l00675"></a>00675                std::cerr &lt;&lt; <a class="code" href="colors_8h.html#61ef7a1b5082f8dc3761eec9833867c3">RED</a>&lt;&lt;<span class="stringliteral">"Wrong node number in "</span> &lt;&lt; __func__ &lt;&lt;<a class="code" href="colors_8h.html#a15368f9f838e27e7fab6d2a6379e7a1">NRM</a>&lt;&lt; std::endl;
<a name="l00676"></a>00676                assert(<span class="keyword">false</span>);
<a name="l00677"></a>00677                <span class="keywordflow">break</span>;
<a name="l00678"></a>00678              }
<a name="l00679"></a>00679   } <span class="comment">// end switch</span>
<a name="l00680"></a>00680 } <span class="comment">// end loop over the 8 vertices of this element...</span>
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="preprocessor">#undef POS_SEARCH_BLOCK</span>
<a name="l00683"></a>00683 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SECONDARY_SEARCH_BLOCK</span>
<a name="l00684"></a>00684 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SEARCH_DEBUG_BLOCK1</span>
<a name="l00685"></a>00685 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SEARCH_DEBUG_BLOCK2</span>
<a name="l00686"></a>00686 <span class="preprocessor"></span><span class="preprocessor">#undef POS_SEARCH_DEBUG_BLOCK3</span>
<a name="l00687"></a>00687 <span class="preprocessor"></span>
<a name="l00688"></a>00688 <span class="comment">// FINISHED Searching for Node Indices ...</span>
<a name="l00689"></a>00689 
<a name="l00690"></a>00690 <span class="comment">//Ensure that the anchor of the local element is not pointing to ghost.</span>
<a name="l00691"></a>00691 <span class="comment">//This can happen only if the octant in question is a singular block</span>
<a name="l00692"></a>00692 <span class="comment">//and its anchor is hanging and the 0th child of its parent is sitting on a different processor.</span>
<a name="l00693"></a>00693 <span class="comment">//BlockPart should have detected this case and prevented this.</span>
<a name="l00694"></a>00694 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00695"></a>00695 <span class="preprocessor"></span><span class="keywordflow">if</span> ( (i &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (i &lt; <a class="code" href="classot_1_1DA.html#7663ba260ee97dcc80c083c9ab841f49">m_uiElementEnd</a>) &amp;&amp;
<a name="l00696"></a>00696     ( (nlist[8*i] &lt; <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) || (nlist[8*i] &gt;= <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) ) ) {
<a name="l00697"></a>00697   std::cout &lt;&lt; <span class="stringliteral">"At index "</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">" anchor is at "</span> &lt;&lt; nlist[8*i] &lt;&lt;
<a name="l00698"></a>00698     <span class="stringliteral">" where elemBegin is at "</span> &lt;&lt; <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a> &lt;&lt; <span class="stringliteral">" and postGhBegin is "</span>
<a name="l00699"></a>00699     &lt;&lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a> &lt;&lt; std::endl;
<a name="l00700"></a>00700   std::cout &lt;&lt; <span class="stringliteral">"RANK is "</span> &lt;&lt; <a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a> &lt;&lt; std::endl;
<a name="l00701"></a>00701   std::cout &lt;&lt; <span class="stringliteral">"NList is "</span>;
<a name="l00702"></a>00702   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;8; j++) {
<a name="l00703"></a>00703     std::cout &lt;&lt; nlist[8*i+j] &lt;&lt; <span class="stringliteral">", "</span>;
<a name="l00704"></a>00704   }
<a name="l00705"></a>00705   std::cout &lt;&lt; std::endl;
<a name="l00706"></a>00706   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" failingOct: "</span>&lt;&lt;in[i]&lt;&lt;std::endl&lt;&lt;<span class="stringliteral">" it's parent: "</span>&lt;&lt;in[i].getParent()&lt;&lt;std::endl;
<a name="l00707"></a>00707   <span class="keywordflow">if</span>( nlist[8*i] &lt; in.size() ) {
<a name="l00708"></a>00708     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" failingOct's anchor is actually mapped to: "</span>&lt;&lt;in[nlist[8*i]]&lt;&lt;std::endl;  
<a name="l00709"></a>00709   }
<a name="l00710"></a>00710   assert(<span class="keyword">false</span>);
<a name="l00711"></a>00711 }
<a name="l00712"></a>00712 <span class="preprocessor">#endif</span>
<a name="l00713"></a>00713 <span class="preprocessor"></span>
<a name="l00714"></a>00714 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00715"></a>00715 <span class="preprocessor"></span><span class="comment">//Check if you sent yourself apriori (Second Ring). </span>
<a name="l00716"></a>00716 <span class="keywordflow">if</span>( (i &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (i &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) ) {
<a name="l00717"></a>00717   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt; 8; j++) {
<a name="l00718"></a>00718     <span class="keywordflow">if</span>(nlist[8*i + j] &lt; <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) {
<a name="l00719"></a>00719       std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Trying to send yourself as a Post Ghost ELEMENT for  i = "</span>
<a name="l00720"></a>00720         &lt;&lt;i&lt;&lt;<span class="stringliteral">" j = "</span>&lt;&lt;j&lt;&lt;std::endl;
<a name="l00721"></a>00721       assert(<span class="keyword">false</span>);
<a name="l00722"></a>00722     }
<a name="l00723"></a>00723     <span class="keywordflow">if</span>( (nlist[8*i+j] &gt;= <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) &amp;&amp; (nlist[8*i+j] &lt; <a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>) ) {
<a name="l00724"></a>00724       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmpToSend = in[nlist[8*i+j]];
<a name="l00725"></a>00725       tmpToSend.<a class="code" href="classot_1_1TreeNode.html#23b28cc19b7f1c987ea10d810f97f738">setWeight</a>(i);
<a name="l00726"></a>00726       checkSecondRing.push_back(tmpToSend);
<a name="l00727"></a>00727     }
<a name="l00728"></a>00728   }<span class="comment">//end for j</span>
<a name="l00729"></a>00729 }
<a name="l00730"></a>00730 <span class="preprocessor">#endif</span>
<a name="l00731"></a>00731 <span class="preprocessor"></span>
<a name="l00732"></a>00732 <span class="comment">// compute the hanging node mask for this element ...</span>
<a name="l00733"></a>00733 <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> _mask=0;
<a name="l00734"></a>00734 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numOutOfBounds = 0;
<a name="l00735"></a>00735 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;8; j++) {
<a name="l00736"></a>00736   <span class="keywordflow">if</span> ( ( nlist[8*i+j] &lt; <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a> ) || (nlist[8*i+j] &gt;= <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) ) {
<a name="l00737"></a>00737     numOutOfBounds++;
<a name="l00738"></a>00738   }
<a name="l00739"></a>00739 
<a name="l00740"></a>00740   <span class="keywordflow">if</span>(nlist[8*i+j] &gt;= <a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>) {
<a name="l00741"></a>00741     <span class="comment">//Skip setting mask for this vtx.</span>
<a name="l00742"></a>00742     <span class="keywordflow">continue</span>;
<a name="l00743"></a>00743   }
<a name="l00744"></a>00744 
<a name="l00745"></a>00745   <span class="comment">// check if any of the nodes is hanging ...</span>
<a name="l00746"></a>00746   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x,_y,_z, _d;
<a name="l00747"></a>00747   _x = in[nlist[8*i+j]].getX(); 
<a name="l00748"></a>00748   _y = in[nlist[8*i+j]].getY(); 
<a name="l00749"></a>00749   _z = in[nlist[8*i+j]].getZ(); 
<a name="l00750"></a>00750   _d = in[nlist[8*i+j]].getLevel();
<a name="l00751"></a>00751   <span class="keywordflow">if</span> ( !(in[nlist[8*i+j]].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a> ) ) {
<a name="l00752"></a>00752     <span class="comment">// std::cout &lt;&lt; "For i=" &lt;&lt; i &lt;&lt; " looking at parent" &lt;&lt; std::endl;</span>
<a name="l00753"></a>00753     _x  = ( ( _x &gt;&gt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - _d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - _d + 1 ) ); 
<a name="l00754"></a>00754     _y  = ( ( _y &gt;&gt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - _d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - _d + 1 ) );
<a name="l00755"></a>00755     _z  = ( ( _z &gt;&gt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - _d + 1 ) ) &lt;&lt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - _d + 1 ) );
<a name="l00756"></a>00756   }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758   <span class="keywordflow">switch</span> (j) {
<a name="l00759"></a>00759     <span class="keywordflow">case</span> 0:
<a name="l00760"></a>00760       <span class="keywordflow">if</span> ( !(in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; ot::TreeNode::NODE ) ) {
<a name="l00761"></a>00761         _mask |= (1 &lt;&lt; j);
<a name="l00762"></a>00762       }
<a name="l00763"></a>00763       <span class="keywordflow">break</span>;
<a name="l00764"></a>00764     <span class="keywordflow">case</span> 1:
<a name="l00765"></a>00765       <span class="comment">// look at the anchor of the +x neighbor</span>
<a name="l00766"></a>00766       <span class="comment">// if ( (x+sz) != _x ) {</span>
<a name="l00767"></a>00767       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( z != _z ) ) {
<a name="l00768"></a>00768         _mask |= (1 &lt;&lt; j);
<a name="l00769"></a>00769       }
<a name="l00770"></a>00770       <span class="keywordflow">break</span>;
<a name="l00771"></a>00771     <span class="keywordflow">case</span> 2:
<a name="l00772"></a>00772       <span class="comment">// look at the anchor of the +y neighbor</span>
<a name="l00773"></a>00773       <span class="comment">// if ( (y+sz) != _y ) {</span>
<a name="l00774"></a>00774       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
<a name="l00775"></a>00775         _mask |= (1 &lt;&lt; j);
<a name="l00776"></a>00776       }
<a name="l00777"></a>00777       <span class="keywordflow">break</span>;
<a name="l00778"></a>00778     <span class="keywordflow">case</span> 3:
<a name="l00779"></a>00779       <span class="comment">// look at both x and y anchors ...</span>
<a name="l00780"></a>00780       <span class="comment">// if ( ( (x+sz) != _x ) || ( (y+sz) != _y )  ) {</span>
<a name="l00781"></a>00781       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
<a name="l00782"></a>00782         _mask |= (1 &lt;&lt; j);
<a name="l00783"></a>00783       }
<a name="l00784"></a>00784       <span class="keywordflow">break</span>;
<a name="l00785"></a>00785     <span class="keywordflow">case</span> 4:
<a name="l00786"></a>00786       <span class="comment">// look at z anchor</span>
<a name="l00787"></a>00787       <span class="comment">// if ( (z+sz) != _z ) {</span>
<a name="l00788"></a>00788       <span class="keywordflow">if</span> ( ( x != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
<a name="l00789"></a>00789         _mask |= (1 &lt;&lt; j);
<a name="l00790"></a>00790       }
<a name="l00791"></a>00791       <span class="keywordflow">break</span>;
<a name="l00792"></a>00792     <span class="keywordflow">case</span> 5:
<a name="l00793"></a>00793       <span class="comment">// look at +z,+x</span>
<a name="l00794"></a>00794       <span class="comment">// if ( ( (x+sz) != _x ) || ( (z+sz) != _z )  ) {</span>
<a name="l00795"></a>00795       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
<a name="l00796"></a>00796         _mask |= (1 &lt;&lt; j);
<a name="l00797"></a>00797       }
<a name="l00798"></a>00798       <span class="keywordflow">break</span>;
<a name="l00799"></a>00799     <span class="keywordflow">case</span> 6:
<a name="l00800"></a>00800       <span class="comment">// look at +z, +y</span>
<a name="l00801"></a>00801       <span class="comment">// if ( ( (z+sz) != _z ) || ( (y+sz) != _y )  ) {</span>
<a name="l00802"></a>00802       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
<a name="l00803"></a>00803         _mask |= (1 &lt;&lt; j);
<a name="l00804"></a>00804       }
<a name="l00805"></a>00805       <span class="keywordflow">break</span>;
<a name="l00806"></a>00806     <span class="keywordflow">case</span> 7:
<a name="l00807"></a>00807       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
<a name="l00808"></a>00808         _mask |= (1 &lt;&lt; j);
<a name="l00809"></a>00809       }
<a name="l00810"></a>00810       <span class="keywordflow">break</span>;
<a name="l00811"></a>00811   }<span class="comment">//end switch-case</span>
<a name="l00812"></a>00812   }<span class="comment">//end for j</span>
<a name="l00813"></a>00813 
<a name="l00814"></a>00814   <span class="comment">// store the mask ...</span>
<a name="l00815"></a>00815   <span class="keywordflow">if</span> (numOutOfBounds == 8) {
<a name="l00816"></a>00816     <span class="comment">//This does not even have one writable node and hence this is not an element.</span>
<a name="l00817"></a>00817     _mask = <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>;
<a name="l00818"></a>00818   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (numOutOfBounds) {
<a name="l00819"></a>00819     <span class="comment">//A Dependent Element, is one which has atleast one writable node and atleast one ghosted node.</span>
<a name="l00820"></a>00820     in[i].orFlag(<a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99bfcb3641c24ad81053969b7b18d0a2fb4">ot::DA_FLAGS::DEP_ELEM</a>);        
<a name="l00821"></a>00821   }
<a name="l00822"></a>00822 
<a name="l00823"></a>00823   <span class="comment">//Prepare for the Ugly portion...</span>
<a name="l00824"></a>00824   <span class="comment">//Sometimes, we might find a primary key but it could turn out to be hanging</span>
<a name="l00825"></a>00825   <span class="comment">//and then we may not find the secondary key. In such cases, we still</span>
<a name="l00826"></a>00826   <span class="comment">//generate both the priimary and secondary keys and search for both in the</span>
<a name="l00827"></a>00827   <span class="comment">//following second ring correction phase. This might seem like an overkill</span>
<a name="l00828"></a>00828   <span class="comment">//but this situation occurs only for pre-ghosts and singular blocks. Suppose,</span>
<a name="l00829"></a>00829   <span class="comment">//the octant A searches for a secondary key B and does not find it and</span>
<a name="l00830"></a>00830   <span class="comment">//suppose A is not a pre-ghost (i.e. this processor owns A). Since B is one</span>
<a name="l00831"></a>00831   <span class="comment">//of the vertices of A's parent this means the sibling of A that shares the</span>
<a name="l00832"></a>00832   <span class="comment">//vertex B with A's parent is not on the same processor as A (since all</span>
<a name="l00833"></a>00833   <span class="comment">//direct vertices which are not hanging are communicated apriori and B can't</span>
<a name="l00834"></a>00834   <span class="comment">//be hanging). Hence, A is singular</span>
<a name="l00835"></a>00835   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;8; j++) {
<a name="l00836"></a>00836     <span class="keywordflow">if</span> (nlist[8*i+j] &gt;= <a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>) {
<a name="l00837"></a>00837       <span class="keywordflow">if</span> (_mask != <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) {
<a name="l00838"></a>00838 #ifdef __DEBUG_DA_NLIST__
<a name="l00839"></a>00839         assert(j);
<a name="l00840"></a>00840 <span class="preprocessor">#endif</span>
<a name="l00841"></a>00841 <span class="preprocessor"></span>        <span class="comment">// add to list ...</span>
<a name="l00842"></a>00842         nodeLocations[j].setWeight(<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>);
<a name="l00843"></a>00843         parNodeLocations[j].setWeight(<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>);
<a name="l00844"></a>00844         primaryKeys.push_back(nodeLocations[j]);
<a name="l00845"></a>00845         secondaryKeys.push_back(parNodeLocations[j]);
<a name="l00846"></a>00846         <span class="comment">// correct lookUp Table ...</span>
<a name="l00847"></a>00847         nlist[8*i+j] = <a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a> +
<a name="l00848"></a>00848           static_cast&lt;unsigned int&gt;(extraAtEnd.size());
<a name="l00849"></a>00849         nodeLocations[j].setWeight(i);
<a name="l00850"></a>00850         extraAtEnd.push_back(nodeLocations[j]);
<a name="l00851"></a>00851       }<span class="comment">//end if foreign</span>
<a name="l00852"></a>00852     }<span class="comment">//end if invalid</span>
<a name="l00853"></a>00853   }<span class="comment">//end for j</span>
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <span class="comment">// Store the hanging node mask</span>
<a name="l00856"></a>00856   <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i+1] = _mask;
<a name="l00857"></a>00857   } <span class="comment">// end for i: All elements in this set </span>
<a name="l00858"></a>00858 
<a name="l00859"></a>00859 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00860"></a>00860 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00861"></a>00861   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l00862"></a>00862     std::cout&lt;&lt;std::endl;
<a name="l00863"></a>00863     std::cout&lt;&lt;<span class="stringliteral">"Finished Elemental Loop for Set# "</span>&lt;&lt;numFullLoopCtr&lt;&lt;std::endl;
<a name="l00864"></a>00864     std::cout&lt;&lt;std::endl;
<a name="l00865"></a>00865   }
<a name="l00866"></a>00866   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00867"></a>00867 <span class="preprocessor">#endif</span>
<a name="l00868"></a>00868 <span class="preprocessor"></span>
<a name="l00869"></a>00869 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l00870"></a>00870 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00871"></a>00871   seq::makeVectorUnique&lt;ot::TreeNode&gt;(chkMissedPrimary, <span class="keyword">false</span>);
<a name="l00872"></a>00872   <span class="keywordtype">int</span>* chkMissedPrimarySendCounts = <span class="keyword">new</span> <span class="keywordtype">int</span>[<a class="code" href="classot_1_1DA.html#155de256c071717644c4ba2f5f643be7">m_iNpesActive</a>];
<a name="l00873"></a>00873   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#155de256c071717644c4ba2f5f643be7">m_iNpesActive</a>; i++) {
<a name="l00874"></a>00874     chkMissedPrimarySendCounts[i] = 0; 
<a name="l00875"></a>00875   }<span class="comment">//end for i</span>
<a name="l00876"></a>00876 
<a name="l00877"></a>00877   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; chkMissedPrimary.size(); i++) {
<a name="l00878"></a>00878     <span class="comment">//maxLB returns the last index in a sorted array such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
<a name="l00879"></a>00879     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
<a name="l00880"></a>00880     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(<a class="code" href="classot_1_1DA.html#70a52f230b37593f6110723037fc02b1">m_tnMinAllBlocks</a>, chkMissedPrimary[i], idx, NULL, NULL);
<a name="l00881"></a>00881     assert(found);
<a name="l00882"></a>00882     <span class="comment">//missed keys must be post-ghosts</span>
<a name="l00883"></a>00883     assert(idx &gt; <a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>);
<a name="l00884"></a>00884     chkMissedPrimarySendCounts[idx]++; 
<a name="l00885"></a>00885   }<span class="comment">//end for i</span>
<a name="l00886"></a>00886 
<a name="l00887"></a>00887   <span class="keywordtype">int</span>* chkMissedPrimaryRecvCounts = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l00888"></a>00888   par::Mpi_Alltoall&lt;int&gt;(chkMissedPrimarySendCounts, chkMissedPrimaryRecvCounts, 1, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00889"></a>00889 
<a name="l00890"></a>00890   <span class="keywordtype">int</span>* chkMissedPrimarySendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l00891"></a>00891   <span class="keywordtype">int</span>* chkMissedPrimaryRecvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l00892"></a>00892   chkMissedPrimarySendOffsets[0] = 0;
<a name="l00893"></a>00893   chkMissedPrimaryRecvOffsets[0] = 0;
<a name="l00894"></a>00894   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; m_iNpesActive; i++) {
<a name="l00895"></a>00895     chkMissedPrimarySendOffsets[i] = chkMissedPrimarySendOffsets[i-1] + chkMissedPrimarySendCounts[i-1] ;
<a name="l00896"></a>00896     chkMissedPrimaryRecvOffsets[i] = chkMissedPrimaryRecvOffsets[i-1] + chkMissedPrimaryRecvCounts[i-1] ;
<a name="l00897"></a>00897   }<span class="comment">//end for i</span>
<a name="l00898"></a>00898   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> chkMissedPrimaryRecvSz = chkMissedPrimaryRecvOffsets[m_iNpesActive - 1] +
<a name="l00899"></a>00899     chkMissedPrimaryRecvCounts[m_iNpesActive - 1];
<a name="l00900"></a>00900   std::vector&lt;ot::TreeNode&gt; chkMissedPrimaryRecvBuffer(chkMissedPrimaryRecvSz);
<a name="l00901"></a>00901   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* chkMissedPrimarySendPtr = NULL;
<a name="l00902"></a>00902   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* chkMissedPrimaryRecvPtr = NULL;
<a name="l00903"></a>00903   <span class="keywordflow">if</span>(!(chkMissedPrimary.empty())) {
<a name="l00904"></a>00904     chkMissedPrimarySendPtr = (&amp;(*(chkMissedPrimary.begin())));
<a name="l00905"></a>00905   }
<a name="l00906"></a>00906   <span class="keywordflow">if</span>(!(chkMissedPrimaryRecvBuffer.empty())) {
<a name="l00907"></a>00907     chkMissedPrimaryRecvPtr = (&amp;(*(chkMissedPrimaryRecvBuffer.begin())));
<a name="l00908"></a>00908   }
<a name="l00909"></a>00909   par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( chkMissedPrimarySendPtr, chkMissedPrimarySendCounts,
<a name="l00910"></a>00910       chkMissedPrimarySendOffsets, chkMissedPrimaryRecvPtr,
<a name="l00911"></a>00911       chkMissedPrimaryRecvCounts, chkMissedPrimaryRecvOffsets, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00912"></a>00912 
<a name="l00913"></a>00913   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; chkMissedPrimaryRecvBuffer.size(); i++) {
<a name="l00914"></a>00914     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
<a name="l00915"></a>00915     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(in, chkMissedPrimaryRecvBuffer[i], idx, NULL, NULL);
<a name="l00916"></a>00916     assert(found);
<a name="l00917"></a>00917     assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) );
<a name="l00918"></a>00918     <span class="comment">//Although this is a hanging node this is also some anchor</span>
<a name="l00919"></a>00919     assert(in[idx].getAnchor() == chkMissedPrimaryRecvBuffer[i].getAnchor());
<a name="l00920"></a>00920     assert( !(in[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a>) );
<a name="l00921"></a>00921   }<span class="comment">//end for i</span>
<a name="l00922"></a>00922 
<a name="l00923"></a>00923   <span class="keyword">delete</span> [] chkMissedPrimarySendCounts;
<a name="l00924"></a>00924   <span class="keyword">delete</span> [] chkMissedPrimaryRecvCounts;
<a name="l00925"></a>00925   <span class="keyword">delete</span> [] chkMissedPrimarySendOffsets;
<a name="l00926"></a>00926   <span class="keyword">delete</span> [] chkMissedPrimaryRecvOffsets;
<a name="l00927"></a>00927   chkMissedPrimaryRecvBuffer.clear();
<a name="l00928"></a>00928   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00929"></a>00929   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l00930"></a>00930     std::cout&lt;&lt;std::endl;
<a name="l00931"></a>00931     std::cout&lt;&lt;<span class="stringliteral">"Passed Test for Missed Primary "</span>&lt;&lt;numFullLoopCtr&lt;&lt;std::endl;
<a name="l00932"></a>00932     std::cout&lt;&lt;std::endl;
<a name="l00933"></a>00933   }
<a name="l00934"></a>00934   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l00935"></a>00935 <span class="preprocessor">#endif</span>
<a name="l00936"></a>00936 <span class="preprocessor"></span>
<a name="l00937"></a>00937   <span class="comment">/*</span>
<a name="l00938"></a>00938 <span class="comment">     NOW, The Ugly Parallel Book-keeping and Corrections for the Missing Entries in the Previous Step...</span>
<a name="l00939"></a>00939 <span class="comment">     */</span>
<a name="l00940"></a>00940 
<a name="l00941"></a>00941   <span class="comment">// ~~~~~~~~~~~~~~~~~~ SECONDARY ~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="l00942"></a>00942   std::vector&lt;unsigned int&gt;               ScndScatterMap;
<a name="l00943"></a>00943 
<a name="l00944"></a>00944   std::vector&lt;unsigned int&gt;               ScndSendProcs;
<a name="l00945"></a>00945   std::vector&lt;unsigned int&gt;               ScndSendCounts;
<a name="l00946"></a>00946 
<a name="l00947"></a>00947   std::vector&lt;unsigned int&gt;               ScndRecvProcs;
<a name="l00948"></a>00948   std::vector&lt;unsigned int&gt;               ScndRecvCounts;
<a name="l00949"></a>00949 
<a name="l00950"></a>00950   <span class="comment">//~~~~~~~~~~~~~~~~~~~~~~~~ Search for Failed Keys ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~//</span>
<a name="l00951"></a>00951   <span class="comment">/*</span>
<a name="l00952"></a>00952 <span class="comment">     1. Each octant which has a missing entry in its node-list would have generated a primary and secondary key for that entry.</span>
<a name="l00953"></a>00953 <span class="comment">     This is the last for-j loop within the main i-loop.</span>
<a name="l00954"></a>00954 <span class="comment">     2. Multiple octants might want the same entry. Hence, we make these keys unique before sending these requests</span>
<a name="l00955"></a>00955 <span class="comment">     to the respective processors.</span>
<a name="l00956"></a>00956 <span class="comment">     3. However, we need to map the results back to the octants which generated these keys.</span>
<a name="l00957"></a>00957 <span class="comment">     So we keep a back-up of the original list of keys. This list will have duplicates.</span>
<a name="l00958"></a>00958 <span class="comment">     4. Send the unique set of Primary and Secondary keys computed above to the processors which control those domains.</span>
<a name="l00959"></a>00959 <span class="comment">     5. Each processor recieves the keys that lie within its domain.</span>
<a name="l00960"></a>00960 <span class="comment">     Now, multiple processors might have requested for the same key. So, we make the list of keys recieved unique.</span>
<a name="l00961"></a>00961 <span class="comment">     We need to map them back to the processors that requested them. Hence, we store the pair of keys and </span>
<a name="l00962"></a>00962 <span class="comment">     a list of processors that requested that key. This is done using the NodeAndRanks class. The sort order</span>
<a name="l00963"></a>00963 <span class="comment">     for this class is defined only on TreeNode.</span>
<a name="l00964"></a>00964 <span class="comment">     6. Each processor performs a local search with this set of unique keys. Note only non-hanging nodes are considered as matches.</span>
<a name="l00965"></a>00965 <span class="comment">     7. The results are returned to the processors that requested the respective keys.</span>
<a name="l00966"></a>00966 <span class="comment">     8. The results are matched with the octants that generated the keys. </span>
<a name="l00967"></a>00967 <span class="comment">     9. If a primary key returned a positive result, then it is used else the secondary key is used. </span>
<a name="l00968"></a>00968 <span class="comment">     10. There is a special for the secondary key for the nlist of a pre-ghost element. It is possible that while the primary key was NOT recieved during the a-priori communication, but the secondary key was recieved. In such situations if the secondary key is to be selected, then we must select the copy that was recieved during the a-priori comm and not the one got from this second-ring correction. This must be done in order to prevent having duplicate elements in our local buffer.</span>
<a name="l00969"></a>00969 <span class="comment">     11. Each of the octants that were selected is given an unique id. This will be used to fix the nlist.</span>
<a name="l00970"></a>00970 <span class="comment">     12. The hanging masks need to be corrected as well.</span>
<a name="l00971"></a>00971 <span class="comment">     13. Since, the primary key could be owned by one processor and the secondary key by another. Only the processor which owns the octant that generated</span>
<a name="l00972"></a>00972 <span class="comment">     the keys can decide what key is actually picked. The decision is then communicated to the processors that own the keys.</span>
<a name="l00973"></a>00973 <span class="comment">     14. A processor might be sending some primary results and some secondary results to the same processor. So both the sets must be merged and</span>
<a name="l00974"></a>00974 <span class="comment">     a single scattermap is built. This is the secondary scattermap. This is from the primary scattermap, which is built in the constructor </span>
<a name="l00975"></a>00975 <span class="comment">     before entering this function (BuildNodeList).</span>
<a name="l00976"></a>00976 <span class="comment">     15. Finally, the same processor might have sent some of its elements in the first ring (apriori comm inside the constructor) and it</span>
<a name="l00977"></a>00977 <span class="comment">     might send some of its elements in the second ring (below). When the actual data is sent, we want the two sets to come together.</span>
<a name="l00978"></a>00978 <span class="comment">     We want both the first set of octants and the second set of octants to be merged and to be sorted.</span>
<a name="l00979"></a>00979 <span class="comment">     16. The first set of octants and the second set of octants have to be merged and sorted. All the second set of octants are marked as FOREIGNs. So, we don't loop over them in the MatVec and we don't build their LUTs. They are simply place holders for ghost values.</span>
<a name="l00980"></a>00980 <span class="comment">     17. The old LUT has to be re-mapped to the new LUT, since the indices will change after step 15.</span>
<a name="l00981"></a>00981 <span class="comment">     18. Similarly, the scattermaps must be merged and corrected to point to the new indices.</span>
<a name="l00982"></a>00982 <span class="comment">     19. We can have missing nodes both for pre-ghosts as well as own elements. Hence, this second ring correction is done inside the main outer loop (numFullLoopCtr).</span>
<a name="l00983"></a>00983 <span class="comment">     */</span>
<a name="l00984"></a>00984 
<a name="l00985"></a>00985   <span class="comment">//~~~~~~~~~~~Correction for Second Ring Begins~~~~~~~~~~~~~~~~~~//</span>
<a name="l00986"></a>00986   <span class="comment">//First Get the min and max from each processor.</span>
<a name="l00987"></a>00987 
<a name="l00988"></a>00988   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> rootNode(<a class="code" href="classot_1_1DA.html#1d45d3b010521c0b1b9724b6bb5eb859">m_uiDimension</a>,<a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>);
<a name="l00989"></a>00989 
<a name="l00990"></a>00990   assert(!in.empty());
<a name="l00991"></a>00991   assert(<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a> &lt; in.size());
<a name="l00992"></a>00992   assert(<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a> &gt;= 1);
<a name="l00993"></a>00993   assert((<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>-1) &lt; in.size());
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   std::vector&lt;ot::TreeNode&gt; failedPrimaryKeys = primaryKeys;
<a name="l00996"></a>00996   std::vector&lt;ot::TreeNode&gt; failedSecondaryKeys = secondaryKeys;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="comment">//Sort and Make Unique</span>
<a name="l00999"></a>00999   seq::makeVectorUnique&lt;ot::TreeNode&gt;(failedPrimaryKeys, <span class="keyword">false</span>);
<a name="l01000"></a>01000   seq::makeVectorUnique&lt;ot::TreeNode&gt;(failedSecondaryKeys, <span class="keyword">false</span>);
<a name="l01001"></a>01001 
<a name="l01002"></a>01002 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01003"></a>01003 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01004"></a>01004 
<a name="l01005"></a>01005   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l01006"></a>01006     std::cout&lt;&lt;std::endl;
<a name="l01007"></a>01007     std::cout&lt;&lt;<span class="stringliteral">"Made Failed Keys Unique. Finding Partition Next."</span>&lt;&lt;std::endl;
<a name="l01008"></a>01008     std::cout&lt;&lt;std::endl;
<a name="l01009"></a>01009   }
<a name="l01010"></a>01010   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01011"></a>01011 <span class="preprocessor">#endif</span>
<a name="l01012"></a>01012 <span class="preprocessor"></span>
<a name="l01013"></a>01013   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> PrimaryKeysSz = static_cast&lt;unsigned int&gt;(failedPrimaryKeys.size());
<a name="l01014"></a>01014   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> SecondaryKeysSz = static_cast&lt;unsigned int&gt;(failedSecondaryKeys.size());
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   <span class="comment">//Now determine the processors which own these keys.</span>
<a name="l01017"></a>01017   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partPrimary = NULL;
<a name="l01018"></a>01018   <span class="keywordflow">if</span>(PrimaryKeysSz) {
<a name="l01019"></a>01019     partPrimary = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[PrimaryKeysSz];    
<a name="l01020"></a>01020   }
<a name="l01021"></a>01021   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *partSecondary = NULL;
<a name="l01022"></a>01022   <span class="keywordflow">if</span>(SecondaryKeysSz) {
<a name="l01023"></a>01023     partSecondary = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[SecondaryKeysSz];    
<a name="l01024"></a>01024   }
<a name="l01025"></a>01025 
<a name="l01026"></a>01026   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;PrimaryKeysSz; i++) {
<a name="l01027"></a>01027     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
<a name="l01028"></a>01028     <span class="comment">//maxLB returns the last index in a sorted array such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
<a name="l01029"></a>01029     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(<a class="code" href="classot_1_1DA.html#70a52f230b37593f6110723037fc02b1">m_tnMinAllBlocks</a>, failedPrimaryKeys[i], idx, NULL, NULL);
<a name="l01030"></a>01030     assert(found);
<a name="l01031"></a>01031     partPrimary[i] = idx;
<a name="l01032"></a>01032   }<span class="comment">//end for i</span>
<a name="l01033"></a>01033 
<a name="l01034"></a>01034   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;SecondaryKeysSz; i++) {
<a name="l01035"></a>01035     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
<a name="l01036"></a>01036     <span class="comment">//maxLB returns the last index in a sorted array such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
<a name="l01037"></a>01037     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(<a class="code" href="classot_1_1DA.html#70a52f230b37593f6110723037fc02b1">m_tnMinAllBlocks</a>, failedSecondaryKeys[i], idx, NULL, NULL);
<a name="l01038"></a>01038     assert(found);
<a name="l01039"></a>01039     partSecondary[i] = idx;
<a name="l01040"></a>01040   }<span class="comment">//end for i</span>
<a name="l01041"></a>01041 
<a name="l01042"></a>01042   <span class="keywordtype">int</span> *numKeysSendP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l01043"></a>01043   <span class="keywordtype">int</span> *numKeysSendS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l01044"></a>01044   <span class="keywordtype">int</span> *numKeysRecvP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];    
<a name="l01045"></a>01045   <span class="keywordtype">int</span> *numKeysRecvS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l01046"></a>01046 
<a name="l01047"></a>01047   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m_iNpesActive; i++) {
<a name="l01048"></a>01048     numKeysSendP[i] = 0;
<a name="l01049"></a>01049     numKeysSendS[i] = 0;
<a name="l01050"></a>01050   }
<a name="l01051"></a>01051   <span class="comment">// calculate the number of keys to send ...</span>
<a name="l01052"></a>01052   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;PrimaryKeysSz; i++) {
<a name="l01053"></a>01053     numKeysSendP[partPrimary[i]]++;      
<a name="l01054"></a>01054   }
<a name="l01055"></a>01055   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;SecondaryKeysSz; i++) {
<a name="l01056"></a>01056     numKeysSendS[partSecondary[i]]++;
<a name="l01057"></a>01057   }    
<a name="l01058"></a>01058 
<a name="l01059"></a>01059 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01060"></a>01060 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01061"></a>01061   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l01062"></a>01062     std::cout&lt;&lt;std::endl;
<a name="l01063"></a>01063     std::cout&lt;&lt;<span class="stringliteral">"First ALL2ALL for Second Ring..."</span>&lt;&lt;std::endl;
<a name="l01064"></a>01064     std::cout&lt;&lt;std::endl;
<a name="l01065"></a>01065   }
<a name="l01066"></a>01066   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01067"></a>01067 <span class="preprocessor">#endif</span>
<a name="l01068"></a>01068 <span class="preprocessor"></span>
<a name="l01069"></a>01069 
<a name="l01070"></a>01070   <span class="comment">// Now do an All2All to get inumKeysRecv</span>
<a name="l01071"></a>01071   <a class="code" href="oda_8h.html#835a8172186986310f09107b5c88593a">PROF_BUILD_NLIST_COMM_BEGIN</a>
<a name="l01072"></a>01072 
<a name="l01073"></a>01073     par::Mpi_Alltoall&lt;int&gt;(numKeysSendP, numKeysRecvP, 1, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01074"></a>01074   par::Mpi_Alltoall&lt;int&gt;(numKeysSendS, numKeysRecvS, 1, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01075"></a>01075 
<a name="l01076"></a>01076   <a class="code" href="oda_8h.html#f1640be776c6f95c9b0230263304d5e6">PROF_BUILD_NLIST_COMM_END</a>
<a name="l01077"></a>01077 
<a name="l01078"></a>01078     <span class="comment">// Now create sendK</span>
<a name="l01079"></a>01079     <span class="keywordtype">int</span> *sendOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsP[0] = 0;
<a name="l01080"></a>01080   <span class="keywordtype">int</span> *recvOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsP[0] = 0;
<a name="l01081"></a>01081   <span class="keywordtype">int</span> *numKeysTmpP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; numKeysTmpP[0] = 0; 
<a name="l01082"></a>01082 
<a name="l01083"></a>01083   <span class="keywordtype">int</span> *sendOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsS[0] = 0;
<a name="l01084"></a>01084   <span class="keywordtype">int</span> *recvOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsS[0] = 0;
<a name="l01085"></a>01085   <span class="keywordtype">int</span> *numKeysTmpS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; numKeysTmpS[0] = 0; 
<a name="l01086"></a>01086 
<a name="l01087"></a>01087   <span class="comment">// compute offsets ...</span>
<a name="l01088"></a>01088   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; m_iNpesActive; i++) {
<a name="l01089"></a>01089     sendOffsetsP[i] = sendOffsetsP[i-1] + numKeysSendP[i-1];
<a name="l01090"></a>01090     recvOffsetsP[i] = recvOffsetsP[i-1] + numKeysRecvP[i-1];
<a name="l01091"></a>01091     numKeysTmpP[i] = 0; 
<a name="l01092"></a>01092 
<a name="l01093"></a>01093     sendOffsetsS[i] = sendOffsetsS[i-1] + numKeysSendS[i-1];
<a name="l01094"></a>01094     recvOffsetsS[i] = recvOffsetsS[i-1] + numKeysRecvS[i-1];
<a name="l01095"></a>01095     numKeysTmpS[i] = 0; 
<a name="l01096"></a>01096   }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098   <span class="comment">// create the send and recv buffers ...</span>
<a name="l01099"></a>01099   std::vector&lt;ot::TreeNode&gt; sendKp (PrimaryKeysSz);
<a name="l01100"></a>01100   std::vector&lt;ot::TreeNode&gt; recvKp (recvOffsetsP[m_iNpesActive-1] + numKeysRecvP[m_iNpesActive-1]);
<a name="l01101"></a>01101 
<a name="l01102"></a>01102   std::vector&lt;ot::TreeNode&gt; sendKs (SecondaryKeysSz);
<a name="l01103"></a>01103   std::vector&lt;ot::TreeNode&gt; recvKs (recvOffsetsS[m_iNpesActive-1] + numKeysRecvS[m_iNpesActive-1]);
<a name="l01104"></a>01104 
<a name="l01105"></a>01105   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; PrimaryKeysSz; i++) {
<a name="l01106"></a>01106     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmpP[partPrimary[i]];
<a name="l01107"></a>01107     numKeysTmpP[partPrimary[i]]++;
<a name="l01108"></a>01108     <span class="comment">// set entry ...</span>
<a name="l01109"></a>01109     sendKp[sendOffsetsP[partPrimary[i]] + ni] = failedPrimaryKeys[i];      
<a name="l01110"></a>01110   } 
<a name="l01111"></a>01111 
<a name="l01112"></a>01112   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; SecondaryKeysSz; i++) {
<a name="l01113"></a>01113     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmpS[partSecondary[i]];
<a name="l01114"></a>01114     numKeysTmpS[partSecondary[i]]++;
<a name="l01115"></a>01115     <span class="comment">// set entry ...</span>
<a name="l01116"></a>01116     sendKs[sendOffsetsS[partSecondary[i]] + ni] = failedSecondaryKeys[i];       
<a name="l01117"></a>01117   } 
<a name="l01118"></a>01118 
<a name="l01119"></a>01119   failedPrimaryKeys.clear();
<a name="l01120"></a>01120   failedSecondaryKeys.clear();
<a name="l01121"></a>01121 
<a name="l01122"></a>01122   <span class="keywordflow">if</span>(partPrimary) {
<a name="l01123"></a>01123     <span class="keyword">delete</span> [] partPrimary;
<a name="l01124"></a>01124     partPrimary = NULL;
<a name="l01125"></a>01125   }
<a name="l01126"></a>01126 
<a name="l01127"></a>01127   <span class="keywordflow">if</span>(partSecondary) {
<a name="l01128"></a>01128     <span class="keyword">delete</span> [] partSecondary;
<a name="l01129"></a>01129     partSecondary = NULL;
<a name="l01130"></a>01130   }
<a name="l01131"></a>01131 
<a name="l01132"></a>01132   <span class="keywordflow">if</span>(numKeysTmpP) {
<a name="l01133"></a>01133     <span class="keyword">delete</span> [] numKeysTmpP;    
<a name="l01134"></a>01134     numKeysTmpP = NULL;
<a name="l01135"></a>01135   }
<a name="l01136"></a>01136 
<a name="l01137"></a>01137   <span class="keywordflow">if</span>(numKeysTmpS) {
<a name="l01138"></a>01138     <span class="keyword">delete</span> [] numKeysTmpS;
<a name="l01139"></a>01139     numKeysTmpS = NULL;
<a name="l01140"></a>01140   }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKpPtr = NULL;
<a name="l01143"></a>01143   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKpPtr = NULL;
<a name="l01144"></a>01144   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKsPtr = NULL;
<a name="l01145"></a>01145   <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKsPtr = NULL;
<a name="l01146"></a>01146   <span class="keywordflow">if</span>(!sendKp.empty()) {
<a name="l01147"></a>01147     sendKpPtr = &amp;(*(sendKp.begin()));
<a name="l01148"></a>01148   }
<a name="l01149"></a>01149   <span class="keywordflow">if</span>(!recvKp.empty()) {
<a name="l01150"></a>01150     recvKpPtr = &amp;(*(recvKp.begin()));
<a name="l01151"></a>01151   }
<a name="l01152"></a>01152   <span class="keywordflow">if</span>(!sendKs.empty()) {
<a name="l01153"></a>01153     sendKsPtr = &amp;(*(sendKs.begin()));
<a name="l01154"></a>01154   }
<a name="l01155"></a>01155   <span class="keywordflow">if</span>(!recvKs.empty()) {
<a name="l01156"></a>01156     recvKsPtr = &amp;(*(recvKs.begin()));
<a name="l01157"></a>01157   }
<a name="l01158"></a>01158 
<a name="l01159"></a>01159   <a class="code" href="oda_8h.html#835a8172186986310f09107b5c88593a">PROF_BUILD_NLIST_COMM_BEGIN</a>
<a name="l01160"></a>01160 
<a name="l01161"></a>01161     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKpPtr, numKeysSendP, sendOffsetsP,
<a name="l01162"></a>01162         recvKpPtr, numKeysRecvP, recvOffsetsP, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01163"></a>01163 
<a name="l01164"></a>01164   par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKsPtr, numKeysSendS, sendOffsetsS,
<a name="l01165"></a>01165       recvKsPtr, numKeysRecvS, recvOffsetsS, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01166"></a>01166 
<a name="l01167"></a>01167   <a class="code" href="oda_8h.html#f1640be776c6f95c9b0230263304d5e6">PROF_BUILD_NLIST_COMM_END</a>
<a name="l01168"></a>01168 
<a name="l01169"></a>01169     sendKp.clear();
<a name="l01170"></a>01170   sendKs.clear();
<a name="l01171"></a>01171 
<a name="l01172"></a>01172   <span class="keyword">delete</span> [] sendOffsetsP;
<a name="l01173"></a>01173   sendOffsetsP = NULL;
<a name="l01174"></a>01174 
<a name="l01175"></a>01175   <span class="keyword">delete</span> [] recvOffsetsP;
<a name="l01176"></a>01176   recvOffsetsP = NULL;
<a name="l01177"></a>01177 
<a name="l01178"></a>01178   <span class="keyword">delete</span> [] numKeysSendP;
<a name="l01179"></a>01179   numKeysSendP = NULL;
<a name="l01180"></a>01180 
<a name="l01181"></a>01181   <span class="keyword">delete</span> [] numKeysRecvP;
<a name="l01182"></a>01182   numKeysRecvP = NULL;
<a name="l01183"></a>01183 
<a name="l01184"></a>01184   <span class="keyword">delete</span> [] sendOffsetsS;
<a name="l01185"></a>01185   sendOffsetsS = NULL;
<a name="l01186"></a>01186 
<a name="l01187"></a>01187   <span class="keyword">delete</span> [] recvOffsetsS;
<a name="l01188"></a>01188   recvOffsetsS = NULL;
<a name="l01189"></a>01189 
<a name="l01190"></a>01190   <span class="keyword">delete</span> [] numKeysSendS;
<a name="l01191"></a>01191   numKeysSendS = NULL;
<a name="l01192"></a>01192 
<a name="l01193"></a>01193   <span class="keyword">delete</span> [] numKeysRecvS;
<a name="l01194"></a>01194   numKeysRecvS = NULL;
<a name="l01195"></a>01195 
<a name="l01196"></a>01196   std::vector&lt;ot::NodeAndRanks&gt; recvK2P;
<a name="l01197"></a>01197   std::vector&lt;ot::NodeAndRanks&gt; recvK2S;
<a name="l01198"></a>01198   <span class="comment">//recvKp and recvKs are NOT sorted and NOT unique.</span>
<a name="l01199"></a>01199   <span class="comment">//First merge recvK into recvK2.</span>
<a name="l01200"></a>01200   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; recvKp.size(); i++) {
<a name="l01201"></a>01201     <a class="code" href="classot_1_1NodeAndRanks.html">ot::NodeAndRanks</a> tmp;
<a name="l01202"></a>01202     tmp.node = recvKp[i];
<a name="l01203"></a>01203     tmp.ranks.push_back(recvKp[i].getWeight());
<a name="l01204"></a>01204     recvK2P.push_back(tmp);
<a name="l01205"></a>01205   }
<a name="l01206"></a>01206 
<a name="l01207"></a>01207   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;recvKs.size();i++) {
<a name="l01208"></a>01208     <a class="code" href="classot_1_1NodeAndRanks.html">ot::NodeAndRanks</a> tmp;
<a name="l01209"></a>01209     tmp.node = recvKs[i];
<a name="l01210"></a>01210     tmp.ranks.push_back(recvKs[i].getWeight());
<a name="l01211"></a>01211     recvK2S.push_back(tmp);
<a name="l01212"></a>01212   }
<a name="l01213"></a>01213 
<a name="l01214"></a>01214   recvKp.clear();  
<a name="l01215"></a>01215   recvKs.clear();  
<a name="l01216"></a>01216 
<a name="l01217"></a>01217   <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">std::sort</a>(recvK2P.begin(),recvK2P.end());
<a name="l01218"></a>01218   <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">std::sort</a>(recvK2S.begin(),recvK2S.end());
<a name="l01219"></a>01219 
<a name="l01220"></a>01220   <span class="comment">//Make recvK2P Unique and concatenate ranks.</span>
<a name="l01221"></a>01221   <span class="keywordflow">if</span> (recvK2P.size() &gt;= 2) {
<a name="l01222"></a>01222     std::vector&lt;ot::NodeAndRanks&gt; tmp(recvK2P.size());
<a name="l01223"></a>01223     tmp[0] = recvK2P[0];
<a name="l01224"></a>01224     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSize=1;
<a name="l01225"></a>01225     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1;i&lt;recvK2P.size();i++) {
<a name="l01226"></a>01226       <span class="keywordflow">if</span> (tmp[tmpSize-1] != recvK2P[i]) {
<a name="l01227"></a>01227         <span class="comment">//new entry</span>
<a name="l01228"></a>01228         tmp[tmpSize] = recvK2P[i];
<a name="l01229"></a>01229         tmpSize++;
<a name="l01230"></a>01230       } <span class="keywordflow">else</span> {
<a name="l01231"></a>01231         tmp[tmpSize-1].ranks.push_back(recvK2P[i].ranks[0]);
<a name="l01232"></a>01232       }
<a name="l01233"></a>01233     }<span class="comment">//end for</span>
<a name="l01234"></a>01234     tmp.resize(tmpSize);
<a name="l01235"></a>01235     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;tmpSize;i++) {
<a name="l01236"></a>01236       seq::makeVectorUnique&lt;int&gt;(tmp[i].ranks,<span class="keyword">false</span>);
<a name="l01237"></a>01237     }
<a name="l01238"></a>01238     recvK2P = tmp; 
<a name="l01239"></a>01239     tmp.clear();
<a name="l01240"></a>01240   }
<a name="l01241"></a>01241 
<a name="l01242"></a>01242   <span class="comment">//Make recvK2S Unique and concatenate ranks.</span>
<a name="l01243"></a>01243   <span class="keywordflow">if</span> (recvK2S.size() &gt;= 2) {
<a name="l01244"></a>01244     std::vector&lt;ot::NodeAndRanks&gt; tmp(recvK2S.size());
<a name="l01245"></a>01245     tmp[0] = recvK2S[0];
<a name="l01246"></a>01246     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSize=1;
<a name="l01247"></a>01247     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1;i&lt;recvK2S.size();i++) {
<a name="l01248"></a>01248       <span class="keywordflow">if</span> (tmp[tmpSize-1] != recvK2S[i]) {
<a name="l01249"></a>01249         <span class="comment">//new entry</span>
<a name="l01250"></a>01250         tmp[tmpSize] = recvK2S[i];
<a name="l01251"></a>01251         tmpSize++;
<a name="l01252"></a>01252       } <span class="keywordflow">else</span> {
<a name="l01253"></a>01253         tmp[tmpSize-1].ranks.push_back(recvK2S[i].ranks[0]);
<a name="l01254"></a>01254       }
<a name="l01255"></a>01255     }<span class="comment">//end for</span>
<a name="l01256"></a>01256     tmp.resize(tmpSize);
<a name="l01257"></a>01257     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;tmpSize;i++) {
<a name="l01258"></a>01258       seq::makeVectorUnique&lt;int&gt;(tmp[i].ranks,<span class="keyword">false</span>);
<a name="l01259"></a>01259     }
<a name="l01260"></a>01260     recvK2S = tmp; 
<a name="l01261"></a>01261     tmp.clear();
<a name="l01262"></a>01262   }
<a name="l01263"></a>01263 
<a name="l01264"></a>01264   <span class="comment">//Local Search and update sendNodes and sendCnt.              </span>
<a name="l01265"></a>01265   std::vector&lt;std::vector&lt;ot::TreeNode&gt; &gt; sendNodesP(m_iNpesActive);
<a name="l01266"></a>01266   std::vector&lt;std::vector&lt;ot::TreeNode&gt; &gt; sendNodesS(m_iNpesActive);
<a name="l01267"></a>01267   <span class="comment">//int is necessary here. Set to -1 later.</span>
<a name="l01268"></a>01268   std::vector&lt;std::vector&lt;int&gt; &gt; idxP(m_iNpesActive);
<a name="l01269"></a>01269   std::vector&lt;std::vector&lt;int&gt; &gt; idxS(m_iNpesActive);
<a name="l01270"></a>01270 
<a name="l01271"></a>01271 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01272"></a>01272 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01273"></a>01273   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l01274"></a>01274     std::cout&lt;&lt;std::endl;
<a name="l01275"></a>01275     std::cout&lt;&lt;<span class="stringliteral">"Starting Local Search for Second Ring..."</span>&lt;&lt;std::endl;
<a name="l01276"></a>01276     std::cout&lt;&lt;std::endl;
<a name="l01277"></a>01277   }
<a name="l01278"></a>01278   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01279"></a>01279 <span class="preprocessor">#endif</span>
<a name="l01280"></a>01280 <span class="preprocessor"></span>
<a name="l01281"></a>01281   <span class="comment">//in is sorted and unique and linear and recvK2 is sorted and unique and linear.    </span>
<a name="l01282"></a>01282   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;recvK2P.size();i++) {
<a name="l01283"></a>01283     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
<a name="l01284"></a>01284     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;ot::TreeNode &gt;(in, recvK2P[i].node, idx,NULL,NULL);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286     <span class="keywordflow">if</span> (found) {
<a name="l01287"></a>01287 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01288"></a>01288 <span class="preprocessor"></span>      assert( (in[idx].isAncestor(recvK2P[i].node)) || (in[idx] == (recvK2P[i].node)) );
<a name="l01289"></a>01289       assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) );
<a name="l01290"></a>01290 <span class="preprocessor">#endif</span>
<a name="l01291"></a>01291 <span class="preprocessor"></span>
<a name="l01292"></a>01292       <span class="keywordflow">if</span> ( (in[idx].getAnchor() != recvK2P[i].node.getAnchor()) || 
<a name="l01293"></a>01293           (!(in[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a>)) ) {
<a name="l01294"></a>01294         found = <span class="keyword">false</span>;
<a name="l01295"></a>01295       }
<a name="l01296"></a>01296     }
<a name="l01297"></a>01297 
<a name="l01298"></a>01298     <span class="comment">//Send the result to all the processors that want it.</span>
<a name="l01299"></a>01299     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; recvK2P[i].ranks.size(); j++) {
<a name="l01300"></a>01300       <span class="keywordflow">if</span> ( found ) {
<a name="l01301"></a>01301         <span class="comment">//Send in[idx];</span>
<a name="l01302"></a>01302         sendNodesP[recvK2P[i].ranks[j]].push_back(in[idx]);          
<a name="l01303"></a>01303         idxP[recvK2P[i].ranks[j]].push_back(idx);
<a name="l01304"></a>01304       } <span class="keywordflow">else</span> {
<a name="l01305"></a>01305         <span class="comment">//Send rootNode;  </span>
<a name="l01306"></a>01306         sendNodesP[recvK2P[i].ranks[j]].push_back(rootNode);          
<a name="l01307"></a>01307         idxP[recvK2P[i].ranks[j]].push_back(-1);
<a name="l01308"></a>01308       }
<a name="l01309"></a>01309       sendNodesP[recvK2P[i].ranks[j]][sendNodesP[recvK2P[i].ranks[j]].size()-1].setWeight(<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>);
<a name="l01310"></a>01310     }<span class="comment">//end for j</span>
<a name="l01311"></a>01311   }<span class="comment">//end for i          </span>
<a name="l01312"></a>01312 
<a name="l01313"></a>01313   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;recvK2S.size();i++) {
<a name="l01314"></a>01314     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
<a name="l01315"></a>01315     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;ot::TreeNode &gt;(in, recvK2S[i].node, idx, NULL, NULL);
<a name="l01316"></a>01316     <span class="keywordflow">if</span> (found) {
<a name="l01317"></a>01317 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01318"></a>01318 <span class="preprocessor"></span>      assert( (in[idx].isAncestor(recvK2S[i].node)) || (in[idx] == (recvK2S[i].node)) );
<a name="l01319"></a>01319       assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) );
<a name="l01320"></a>01320 <span class="preprocessor">#endif</span>
<a name="l01321"></a>01321 <span class="preprocessor"></span>      <span class="keywordflow">if</span> ( (in[idx].getAnchor() != recvK2S[i].node.getAnchor()) || (!(in[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a>)) ) {
<a name="l01322"></a>01322         found = <span class="keyword">false</span>;
<a name="l01323"></a>01323       }
<a name="l01324"></a>01324     }
<a name="l01325"></a>01325     <span class="comment">//Send the result to all the processors that want it.</span>
<a name="l01326"></a>01326     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j &lt; recvK2S[i].ranks.size(); j++) {
<a name="l01327"></a>01327       <span class="keywordflow">if</span> ( found ) {
<a name="l01328"></a>01328         <span class="comment">//Send in[idx];</span>
<a name="l01329"></a>01329         sendNodesS[recvK2S[i].ranks[j]].push_back(in[idx]);
<a name="l01330"></a>01330         idxS[recvK2S[i].ranks[j]].push_back(idx);
<a name="l01331"></a>01331       } <span class="keywordflow">else</span> {
<a name="l01332"></a>01332         <span class="comment">//Send rootNode;  </span>
<a name="l01333"></a>01333         sendNodesS[recvK2S[i].ranks[j]].push_back(rootNode);
<a name="l01334"></a>01334         idxS[recvK2S[i].ranks[j]].push_back(-1);
<a name="l01335"></a>01335       }
<a name="l01336"></a>01336       sendNodesS[recvK2S[i].ranks[j]][sendNodesS[recvK2S[i].ranks[j]].size()-1].setWeight(<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>);
<a name="l01337"></a>01337     }
<a name="l01338"></a>01338   }<span class="comment">//end for i          </span>
<a name="l01339"></a>01339 
<a name="l01340"></a>01340   recvK2P.clear(); 
<a name="l01341"></a>01341   recvK2S.clear(); 
<a name="l01342"></a>01342 
<a name="l01343"></a>01343   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
<a name="l01344"></a>01344     seq::makeVectorUnique&lt;TreeNode&gt;(sendNodesP[i],<span class="keyword">false</span>);
<a name="l01345"></a>01345     seq::makeVectorUnique&lt;TreeNode&gt;(sendNodesS[i],<span class="keyword">false</span>);
<a name="l01346"></a>01346     seq::makeVectorUnique&lt;int&gt;(idxP[i],<span class="keyword">false</span>);
<a name="l01347"></a>01347     seq::makeVectorUnique&lt;int&gt;(idxS[i],<span class="keyword">false</span>);
<a name="l01348"></a>01348   }
<a name="l01349"></a>01349 
<a name="l01350"></a>01350   numKeysSendP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l01351"></a>01351   numKeysSendS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l01352"></a>01352   numKeysRecvP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];    
<a name="l01353"></a>01353   numKeysRecvS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive];
<a name="l01354"></a>01354 
<a name="l01355"></a>01355   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;m_iNpesActive; i++) {
<a name="l01356"></a>01356     numKeysSendP[i] = static_cast&lt;int&gt;(sendNodesP[i].size());
<a name="l01357"></a>01357     numKeysSendS[i] = static_cast&lt;int&gt;(sendNodesS[i].size());    
<a name="l01358"></a>01358   }        
<a name="l01359"></a>01359 
<a name="l01360"></a>01360 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01361"></a>01361 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01362"></a>01362   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l01363"></a>01363     std::cout&lt;&lt;std::endl;
<a name="l01364"></a>01364     std::cout&lt;&lt;<span class="stringliteral">"Sending Results after Local Search for Second Ring..."</span>&lt;&lt;std::endl;
<a name="l01365"></a>01365     std::cout&lt;&lt;std::endl;
<a name="l01366"></a>01366   }
<a name="l01367"></a>01367   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01368"></a>01368 <span class="preprocessor">#endif</span>
<a name="l01369"></a>01369 <span class="preprocessor"></span>
<a name="l01370"></a>01370   <span class="comment">// Now do an All2All to get inumKeysRecv</span>
<a name="l01371"></a>01371   <a class="code" href="oda_8h.html#835a8172186986310f09107b5c88593a">PROF_BUILD_NLIST_COMM_BEGIN</a>
<a name="l01372"></a>01372 
<a name="l01373"></a>01373     par::Mpi_Alltoall&lt;int&gt;(numKeysSendP, numKeysRecvP, 1, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01374"></a>01374   par::Mpi_Alltoall&lt;int&gt;(numKeysSendS, numKeysRecvS, 1, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);    
<a name="l01375"></a>01375 
<a name="l01376"></a>01376   <a class="code" href="oda_8h.html#f1640be776c6f95c9b0230263304d5e6">PROF_BUILD_NLIST_COMM_END</a>
<a name="l01377"></a>01377 
<a name="l01378"></a>01378     <span class="comment">// Now create sendK</span>
<a name="l01379"></a>01379     sendOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsP[0] = 0;
<a name="l01380"></a>01380   sendOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; sendOffsetsS[0] = 0;
<a name="l01381"></a>01381   recvOffsetsP = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsP[0] = 0;   
<a name="l01382"></a>01382   recvOffsetsS = <span class="keyword">new</span> <span class="keywordtype">int</span>[m_iNpesActive]; recvOffsetsS[0] = 0;
<a name="l01383"></a>01383 
<a name="l01384"></a>01384   <span class="comment">// compute offsets ...</span>
<a name="l01385"></a>01385   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;m_iNpesActive; i++) {
<a name="l01386"></a>01386     sendOffsetsP[i] = sendOffsetsP[i-1] + numKeysSendP[i-1];
<a name="l01387"></a>01387     recvOffsetsP[i] = recvOffsetsP[i-1] + numKeysRecvP[i-1];
<a name="l01388"></a>01388 
<a name="l01389"></a>01389     sendOffsetsS[i] = sendOffsetsS[i-1] + numKeysSendS[i-1];
<a name="l01390"></a>01390     recvOffsetsS[i] = recvOffsetsS[i-1] + numKeysRecvS[i-1];    
<a name="l01391"></a>01391   }
<a name="l01392"></a>01392 
<a name="l01393"></a>01393   <span class="comment">// create the send and recv buffers ...</span>
<a name="l01394"></a>01394   sendKp.resize(sendOffsetsP[m_iNpesActive-1] + numKeysSendP[m_iNpesActive-1]);
<a name="l01395"></a>01395   recvKp.resize(recvOffsetsP[m_iNpesActive-1] + numKeysRecvP[m_iNpesActive-1]);
<a name="l01396"></a>01396 
<a name="l01397"></a>01397   sendKs.resize(sendOffsetsS[m_iNpesActive-1] + numKeysSendS[m_iNpesActive-1]);
<a name="l01398"></a>01398   recvKs.resize(recvOffsetsS[m_iNpesActive-1] + numKeysRecvS[m_iNpesActive-1]);
<a name="l01399"></a>01399 
<a name="l01400"></a>01400   std::vector&lt;int&gt; idxSendKp(sendOffsetsP[m_iNpesActive-1] + numKeysSendP[m_iNpesActive-1]);
<a name="l01401"></a>01401   std::vector&lt;int&gt; idxSendKs(sendOffsetsS[m_iNpesActive-1] + numKeysSendS[m_iNpesActive-1]);
<a name="l01402"></a>01402 
<a name="l01403"></a>01403   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
<a name="l01404"></a>01404     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numKeysSendP[i]; j++) {
<a name="l01405"></a>01405       <span class="comment">// set entry ...</span>
<a name="l01406"></a>01406       sendKp[sendOffsetsP[i] + j] = sendNodesP[i][j];       
<a name="l01407"></a>01407       idxSendKp[sendOffsetsP[i] + j] = idxP[i][j];       
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01410"></a>01410 <span class="preprocessor"></span>      assert( ((sendKp[sendOffsetsP[i] + j] == rootNode) &amp;&amp; (idxSendKp[sendOffsetsP[i] + j] == -1)) ||
<a name="l01411"></a>01411           (in[idxSendKp[sendOffsetsP[i] + j]] == sendKp[sendOffsetsP[i] + j]) );
<a name="l01412"></a>01412 <span class="preprocessor">#endif</span>
<a name="l01413"></a>01413 <span class="preprocessor"></span>    }
<a name="l01414"></a>01414     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; numKeysSendS[i]; j++) {
<a name="l01415"></a>01415       <span class="comment">// set entry ...</span>
<a name="l01416"></a>01416       sendKs[sendOffsetsS[i] + j] = sendNodesS[i][j];    
<a name="l01417"></a>01417       idxSendKs[sendOffsetsS[i] + j] = idxS[i][j];       
<a name="l01418"></a>01418 
<a name="l01419"></a>01419 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01420"></a>01420 <span class="preprocessor"></span>      assert( ((sendKs[sendOffsetsS[i] + j] == rootNode) &amp;&amp; (idxSendKs[sendOffsetsS[i] + j] == -1)) ||
<a name="l01421"></a>01421           (in[idxSendKs[sendOffsetsS[i] + j]] == sendKs[sendOffsetsS[i] + j]) );
<a name="l01422"></a>01422 <span class="preprocessor">#endif</span>
<a name="l01423"></a>01423 <span class="preprocessor"></span>    }
<a name="l01424"></a>01424   } 
<a name="l01425"></a>01425 
<a name="l01426"></a>01426   sendNodesP.clear();
<a name="l01427"></a>01427   sendNodesS.clear();
<a name="l01428"></a>01428 
<a name="l01429"></a>01429   idxP.clear();
<a name="l01430"></a>01430   idxS.clear();
<a name="l01431"></a>01431 
<a name="l01432"></a>01432   sendKpPtr = NULL;
<a name="l01433"></a>01433   recvKpPtr = NULL;
<a name="l01434"></a>01434   sendKsPtr = NULL;
<a name="l01435"></a>01435   recvKsPtr = NULL;
<a name="l01436"></a>01436   <span class="keywordflow">if</span>(!sendKp.empty()) {
<a name="l01437"></a>01437     sendKpPtr = &amp;(*(sendKp.begin()));
<a name="l01438"></a>01438   }
<a name="l01439"></a>01439   <span class="keywordflow">if</span>(!sendKs.empty()) {
<a name="l01440"></a>01440     sendKsPtr = &amp;(*(sendKs.begin()));
<a name="l01441"></a>01441   }
<a name="l01442"></a>01442   <span class="keywordflow">if</span>(!recvKp.empty()) {
<a name="l01443"></a>01443     recvKpPtr = &amp;(*(recvKp.begin()));
<a name="l01444"></a>01444   }
<a name="l01445"></a>01445   <span class="keywordflow">if</span>(!recvKs.empty()) {
<a name="l01446"></a>01446     recvKsPtr = &amp;(*(recvKs.begin()));
<a name="l01447"></a>01447   }
<a name="l01448"></a>01448 
<a name="l01449"></a>01449   <a class="code" href="oda_8h.html#835a8172186986310f09107b5c88593a">PROF_BUILD_NLIST_COMM_BEGIN</a>
<a name="l01450"></a>01450 
<a name="l01451"></a>01451     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKpPtr, numKeysSendP, sendOffsetsP,
<a name="l01452"></a>01452         recvKpPtr, numKeysRecvP, recvOffsetsP, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01453"></a>01453 
<a name="l01454"></a>01454   par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;( sendKsPtr, numKeysSendS, sendOffsetsS,
<a name="l01455"></a>01455       recvKsPtr, numKeysRecvS, recvOffsetsS, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01456"></a>01456 
<a name="l01457"></a>01457   <a class="code" href="oda_8h.html#f1640be776c6f95c9b0230263304d5e6">PROF_BUILD_NLIST_COMM_END</a>
<a name="l01458"></a>01458 
<a name="l01459"></a>01459     <span class="comment">//Store the sizes, will need it later</span>
<a name="l01460"></a>01460     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> actualRecvKpSz = static_cast&lt;unsigned int&gt;(recvKp.size());
<a name="l01461"></a>01461   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> actualRecvKsSz = static_cast&lt;unsigned int&gt;(recvKs.size());
<a name="l01462"></a>01462 
<a name="l01463"></a>01463   <span class="comment">//The result is sorted except for the fact that there might be multiple</span>
<a name="l01464"></a>01464   <span class="comment">//roots in the middle. So remove all roots.</span>
<a name="l01465"></a>01465   std::vector&lt;TreeNode&gt; tmpRecvKp;
<a name="l01466"></a>01466   std::vector&lt;TreeNode&gt; tmpRecvKs;
<a name="l01467"></a>01467 
<a name="l01468"></a>01468   std::vector&lt;unsigned int&gt; kp2ActualKp;
<a name="l01469"></a>01469   std::vector&lt;unsigned int&gt; ks2ActualKs;
<a name="l01470"></a>01470 
<a name="l01471"></a>01471   tmpRecvKp.push_back(rootNode);
<a name="l01472"></a>01472   kp2ActualKp.push_back(recvKp.size());
<a name="l01473"></a>01473   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; recvKp.size(); i++) {
<a name="l01474"></a>01474     <span class="keywordflow">if</span>(recvKp[i] &gt; rootNode) {      
<a name="l01475"></a>01475       tmpRecvKp.push_back(recvKp[i]);
<a name="l01476"></a>01476       kp2ActualKp.push_back(i);
<a name="l01477"></a>01477     }
<a name="l01478"></a>01478   }
<a name="l01479"></a>01479 
<a name="l01480"></a>01480   tmpRecvKs.push_back(rootNode);
<a name="l01481"></a>01481   ks2ActualKs.push_back(recvKs.size());
<a name="l01482"></a>01482   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; recvKs.size(); i++) {
<a name="l01483"></a>01483     <span class="keywordflow">if</span>(recvKs[i] &gt; rootNode) {
<a name="l01484"></a>01484       tmpRecvKs.push_back(recvKs[i]);
<a name="l01485"></a>01485       ks2ActualKs.push_back(i);
<a name="l01486"></a>01486     }
<a name="l01487"></a>01487   }
<a name="l01488"></a>01488 
<a name="l01489"></a>01489   recvKp = tmpRecvKp;
<a name="l01490"></a>01490   recvKs = tmpRecvKs;
<a name="l01491"></a>01491 
<a name="l01492"></a>01492   tmpRecvKp.clear();
<a name="l01493"></a>01493   tmpRecvKs.clear();
<a name="l01494"></a>01494 
<a name="l01495"></a>01495 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01496"></a>01496 <span class="preprocessor"></span>  MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01497"></a>01497   assert(<a class="code" href="namespaceseq_1_1test.html#1c2cc3f843faf778a0513185f54fcf9f">seq::test::isUniqueAndSorted</a>(recvKp));
<a name="l01498"></a>01498   assert(<a class="code" href="namespaceseq_1_1test.html#1c2cc3f843faf778a0513185f54fcf9f">seq::test::isUniqueAndSorted</a>(recvKs));
<a name="l01499"></a>01499   <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l01500"></a>01500     std::cout&lt;&lt;std::endl;
<a name="l01501"></a>01501     std::cout&lt;&lt;<span class="stringliteral">"Processing Results in Second Ring..."</span>&lt;&lt;std::endl;
<a name="l01502"></a>01502     std::cout&lt;&lt;std::endl;
<a name="l01503"></a>01503   }
<a name="l01504"></a>01504   MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01505"></a>01505 <span class="preprocessor">#endif</span>
<a name="l01506"></a>01506 <span class="preprocessor"></span>
<a name="l01507"></a>01507   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *oldToNewIdx = NULL;
<a name="l01508"></a>01508   <span class="keywordtype">bool</span> *fromPrimary = NULL;
<a name="l01509"></a>01509   <span class="keywordtype">bool</span> *fromSecondary = NULL;
<a name="l01510"></a>01510   <span class="keywordflow">if</span>(!extraAtEnd.empty()) {
<a name="l01511"></a>01511     oldToNewIdx = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[extraAtEnd.size()];
<a name="l01512"></a>01512     fromPrimary = <span class="keyword">new</span> <span class="keywordtype">bool</span>[extraAtEnd.size()];
<a name="l01513"></a>01513     fromSecondary = <span class="keyword">new</span> <span class="keywordtype">bool</span>[extraAtEnd.size()];
<a name="l01514"></a>01514   }
<a name="l01515"></a>01515   std::vector&lt;seq::IndexHolder&lt;ot::TreeNode&gt; &gt; extraIndices (extraAtEnd.size());
<a name="l01516"></a>01516 
<a name="l01517"></a>01517   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; extraAtEnd.size(); i++) {
<a name="l01518"></a>01518     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
<a name="l01519"></a>01519     <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;ot::TreeNode &gt;(recvKp, primaryKeys[i], idx, NULL, NULL);
<a name="l01520"></a>01520 
<a name="l01521"></a>01521     <span class="keywordflow">if</span> (found) {
<a name="l01522"></a>01522 
<a name="l01523"></a>01523       <span class="keywordflow">if</span> (recvKp[idx] == rootNode) {
<a name="l01524"></a>01524         found = <span class="keyword">false</span>;
<a name="l01525"></a>01525         fromPrimary[i] = <span class="keyword">false</span>;
<a name="l01526"></a>01526       } <span class="keywordflow">else</span> {
<a name="l01527"></a>01527 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01528"></a>01528 <span class="preprocessor"></span>        assert( recvKp[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a> );
<a name="l01529"></a>01529 <span class="preprocessor">#endif</span>
<a name="l01530"></a>01530 <span class="preprocessor"></span>        <span class="keywordflow">if</span>( recvKp[idx].getAnchor() != primaryKeys[i].getAnchor() ) {
<a name="l01531"></a>01531           <span class="comment">//Treat just like it was root.</span>
<a name="l01532"></a>01532           found = <span class="keyword">false</span>;
<a name="l01533"></a>01533           fromPrimary[i] = <span class="keyword">false</span>;
<a name="l01534"></a>01534         }<span class="keywordflow">else</span> {
<a name="l01535"></a>01535           oldToNewIdx[i] = idx; 
<a name="l01536"></a>01536           fromPrimary[i] = <span class="keyword">true</span>;
<a name="l01537"></a>01537           fromSecondary[i] = <span class="keyword">false</span>;
<a name="l01538"></a>01538           <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp = recvKp[idx];
<a name="l01539"></a>01539           tmp.<a class="code" href="classot_1_1TreeNode.html#23b28cc19b7f1c987ea10d810f97f738">setWeight</a>(extraAtEnd[i].getWeight());
<a name="l01540"></a>01540           extraAtEnd[i] = tmp;
<a name="l01541"></a>01541           extraIndices[i].value = &amp;(extraAtEnd[i]);
<a name="l01542"></a>01542           extraIndices[i].index = i;
<a name="l01543"></a>01543         }
<a name="l01544"></a>01544       }        
<a name="l01545"></a>01545     }<span class="keywordflow">else</span> {
<a name="l01546"></a>01546       assert(<span class="keyword">false</span>);
<a name="l01547"></a>01547     }
<a name="l01548"></a>01548 
<a name="l01549"></a>01549     <span class="keywordflow">if</span> (!found) {
<a name="l01550"></a>01550       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;    
<a name="l01551"></a>01551       found = seq::maxLowerBound&lt;ot::TreeNode &gt;(recvKs, secondaryKeys[i], idx, NULL, NULL);
<a name="l01552"></a>01552 
<a name="l01553"></a>01553 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01554"></a>01554 <span class="preprocessor"></span>      assert( found );
<a name="l01555"></a>01555       assert( recvKs[idx] != rootNode );
<a name="l01556"></a>01556       assert( recvKs[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a> );
<a name="l01557"></a>01557       assert( recvKs[idx].getAnchor() == secondaryKeys[i].getAnchor() );
<a name="l01558"></a>01558 <span class="preprocessor">#endif</span>
<a name="l01559"></a>01559 <span class="preprocessor"></span>      <span class="comment">/*</span>
<a name="l01560"></a>01560 <span class="comment">         Handle Special Case: When a pre-ghost element did not find its primary key in the local search, the secondary key is never searched for. In such situations, when the primary result is not usable and we must pick the secondary result got from the explicit parallel search, we must first check if this secondary result is already present in the local buffer (either own or elements got through a-priori comm.) If so, we must use the one that is already present and discard the one got through the parallel search. This must be done in order to avoid duplicate octants in the local buffer.</span>
<a name="l01561"></a>01561 <span class="comment">         */</span>
<a name="l01562"></a>01562       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idxTmp;
<a name="l01563"></a>01563       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* inPtr = NULL;
<a name="l01564"></a>01564       <span class="keywordflow">if</span>(!in.empty()) {
<a name="l01565"></a>01565         inPtr = &amp;(*(in.begin()));
<a name="l01566"></a>01566       }
<a name="l01567"></a>01567       found = seq::BinarySearch&lt;ot::TreeNode&gt;(inPtr,
<a name="l01568"></a>01568           static_cast&lt;unsigned int&gt;(in.size()), recvKs[idx], &amp;idxTmp);
<a name="l01569"></a>01569 
<a name="l01570"></a>01570       <span class="keywordflow">if</span>(found) {
<a name="l01571"></a>01571         fromSecondary[i] = <span class="keyword">false</span>;
<a name="l01572"></a>01572         oldToNewIdx[i] = idxTmp;
<a name="l01573"></a>01573         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp = in[idxTmp];
<a name="l01574"></a>01574         tmp.<a class="code" href="classot_1_1TreeNode.html#23b28cc19b7f1c987ea10d810f97f738">setWeight</a>(extraAtEnd[i].getWeight());
<a name="l01575"></a>01575         extraAtEnd[i] = tmp;
<a name="l01576"></a>01576         extraIndices[i].value = &amp;(extraAtEnd[i]);
<a name="l01577"></a>01577         extraIndices[i].index = i;
<a name="l01578"></a>01578       }<span class="keywordflow">else</span> {    
<a name="l01579"></a>01579         fromSecondary[i] = <span class="keyword">true</span>;
<a name="l01580"></a>01580         oldToNewIdx[i] = idx; 
<a name="l01581"></a>01581         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp = recvKs[idx];
<a name="l01582"></a>01582         tmp.<a class="code" href="classot_1_1TreeNode.html#23b28cc19b7f1c987ea10d810f97f738">setWeight</a>(extraAtEnd[i].getWeight());
<a name="l01583"></a>01583         extraAtEnd[i] = tmp;
<a name="l01584"></a>01584         extraIndices[i].value = &amp;(extraAtEnd[i]);
<a name="l01585"></a>01585         extraIndices[i].index = i;
<a name="l01586"></a>01586       }
<a name="l01587"></a>01587     }
<a name="l01588"></a>01588   }<span class="comment">//end for i</span>
<a name="l01589"></a>01589 
<a name="l01590"></a>01590   primaryKeys.clear();
<a name="l01591"></a>01591   secondaryKeys.clear();
<a name="l01592"></a>01592   extraAtEnd.clear();
<a name="l01593"></a>01593 
<a name="l01594"></a>01594   <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">std::sort</a>(extraIndices.begin(),extraIndices.end());
<a name="l01595"></a>01595 
<a name="l01596"></a>01596   std::vector&lt;ot::TreeNode&gt; sortedUniqueExtras(extraIndices.size());    
<a name="l01597"></a>01597   std::vector&lt;unsigned int&gt; chosenIndexIntoOld(extraIndices.size());
<a name="l01598"></a>01598 
<a name="l01599"></a>01599   <span class="comment">//Old refers to the unsorted and non-unique extraAtEnd list </span>
<a name="l01600"></a>01600   std::vector&lt;std::vector&lt; unsigned int&gt; &gt; indicesIntoOld(extraIndices.size());
<a name="l01601"></a>01601 
<a name="l01602"></a>01602   <span class="comment">//LUT refers to localOcts (in)</span>
<a name="l01603"></a>01603   std::vector&lt;std::vector&lt; unsigned int&gt; &gt; indicesIntoLUT(extraIndices.size());
<a name="l01604"></a>01604 
<a name="l01605"></a>01605   <span class="keywordflow">if</span> (!extraIndices.empty()) {
<a name="l01606"></a>01606     sortedUniqueExtras[0] = *(extraIndices[0].value);
<a name="l01607"></a>01607     chosenIndexIntoOld[0] = extraIndices[0].index;
<a name="l01608"></a>01608 
<a name="l01609"></a>01609     indicesIntoOld[0].push_back(extraIndices[0].index);
<a name="l01610"></a>01610     indicesIntoLUT[0].push_back(extraIndices[0].value-&gt;getWeight());
<a name="l01611"></a>01611   }
<a name="l01612"></a>01612   <span class="comment">//Make  Unique and concatenate ranks.</span>
<a name="l01613"></a>01613   <span class="keywordflow">if</span> (extraIndices.size() &gt;= 2) {
<a name="l01614"></a>01614     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpSize=1;
<a name="l01615"></a>01615     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1;i&lt;extraIndices.size();i++) {
<a name="l01616"></a>01616       <span class="keywordflow">if</span> (sortedUniqueExtras[tmpSize-1] != *(extraIndices[i].value)) {
<a name="l01617"></a>01617         <span class="comment">//New entry</span>
<a name="l01618"></a>01618         sortedUniqueExtras[tmpSize] = *(extraIndices[i].value);
<a name="l01619"></a>01619         chosenIndexIntoOld[tmpSize] =  extraIndices[i].index;
<a name="l01620"></a>01620 
<a name="l01621"></a>01621         indicesIntoOld[tmpSize].push_back(extraIndices[i].index);
<a name="l01622"></a>01622         indicesIntoLUT[tmpSize].push_back(extraIndices[i].value-&gt;getWeight());
<a name="l01623"></a>01623         tmpSize++;
<a name="l01624"></a>01624       } <span class="keywordflow">else</span> {
<a name="l01625"></a>01625         indicesIntoOld[tmpSize-1].push_back(extraIndices[i].index);
<a name="l01626"></a>01626         indicesIntoLUT[tmpSize-1].push_back(extraIndices[i].value-&gt;getWeight());
<a name="l01627"></a>01627       }
<a name="l01628"></a>01628     }<span class="comment">//end for</span>
<a name="l01629"></a>01629 
<a name="l01630"></a>01630     sortedUniqueExtras.resize(tmpSize);
<a name="l01631"></a>01631 
<a name="l01632"></a>01632 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01633"></a>01633 <span class="preprocessor"></span>    assert(seq::test::isUniqueAndSorted&lt;TreeNode &gt;(sortedUniqueExtras));
<a name="l01634"></a>01634 <span class="preprocessor">#endif</span>
<a name="l01635"></a>01635 <span class="preprocessor"></span>
<a name="l01636"></a>01636     chosenIndexIntoOld.resize(tmpSize);
<a name="l01637"></a>01637 
<a name="l01638"></a>01638     indicesIntoOld.resize(tmpSize);
<a name="l01639"></a>01639     indicesIntoLUT.resize(tmpSize);      
<a name="l01640"></a>01640 
<a name="l01641"></a>01641     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;tmpSize;i++) {
<a name="l01642"></a>01642       <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">std::sort</a>(indicesIntoOld[i].begin(),indicesIntoOld[i].<a class="code" href="classot_1_1DA.html#33f979f3370f310e7c17bd9f3ae94a9b">end</a>());
<a name="l01643"></a>01643       <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">std::sort</a>(indicesIntoLUT[i].begin(),indicesIntoLUT[i].<a class="code" href="classot_1_1DA.html#33f979f3370f310e7c17bd9f3ae94a9b">end</a>());        
<a name="l01644"></a>01644 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01645"></a>01645 <span class="preprocessor"></span>      <span class="comment">//Ensuring that all the 8 vertices of an element map to different indices. </span>
<a name="l01646"></a>01646       assert(seq::test::isUniqueAndSorted&lt;unsigned int&gt;(indicesIntoOld[i]));
<a name="l01647"></a>01647       assert(seq::test::isUniqueAndSorted&lt;unsigned int&gt;(indicesIntoLUT[i]));
<a name="l01648"></a>01648 <span class="preprocessor">#endif</span>
<a name="l01649"></a>01649 <span class="preprocessor"></span>    }<span class="comment">//end for i      </span>
<a name="l01650"></a>01650 
<a name="l01651"></a>01651   }
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   extraIndices.clear();
<a name="l01654"></a>01654 
<a name="l01655"></a>01655   <span class="comment">/*</span>
<a name="l01656"></a>01656 <span class="comment">     std::vector&lt;bool&gt; pickPrimary(sortedUniqueExtras.size());</span>
<a name="l01657"></a>01657 <span class="comment">     std::vector&lt;unsigned int&gt; oldIndex(sortedUniqueExtras.size());</span>
<a name="l01658"></a>01658 <span class="comment"></span>
<a name="l01659"></a>01659 <span class="comment">  //The same extra key can come from primary or secondary and from multiple</span>
<a name="l01660"></a>01660 <span class="comment">  //pre-ghosts. So pick one.</span>
<a name="l01661"></a>01661 <span class="comment">  //Some arbit default rule is used to make this decision...</span>
<a name="l01662"></a>01662 <span class="comment">  //Here. The rule is simply if this key was some element's primary key use</span>
<a name="l01663"></a>01663 <span class="comment">  //that. In this case, the smallest element is chosen. Else, the last</span>
<a name="l01664"></a>01664 <span class="comment">  //element is chosen (secondary key).</span>
<a name="l01665"></a>01665 <span class="comment">  //Note: indicesIntoOld[i] is sorted and unique.</span>
<a name="l01666"></a>01666 <span class="comment">  for (unsigned int i=0; i &lt; sortedUniqueExtras.size(); i++) {</span>
<a name="l01667"></a>01667 <span class="comment">  pickPrimary[i] = false;</span>
<a name="l01668"></a>01668 <span class="comment">  for (unsigned int j = 0; j &lt; indicesIntoOld[i].size(); j++) {</span>
<a name="l01669"></a>01669 <span class="comment">  oldIndex[i] = indicesIntoOld[i][j];</span>
<a name="l01670"></a>01670 <span class="comment">  if (fromPrimary[indicesIntoOld[i][j]]) {</span>
<a name="l01671"></a>01671 <span class="comment">  pickPrimary[i] = true;         </span>
<a name="l01672"></a>01672 <span class="comment">  break;       </span>
<a name="l01673"></a>01673 <span class="comment">  }</span>
<a name="l01674"></a>01674 <span class="comment">  }//end for j</span>
<a name="l01675"></a>01675 <span class="comment">  }//end for i</span>
<a name="l01676"></a>01676 <span class="comment">  */</span>
<a name="l01677"></a>01677 
<a name="l01678"></a>01678   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *recvCntsExtras = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[m_iNpesActive];        
<a name="l01679"></a>01679 
<a name="l01680"></a>01680   std::vector&lt;char&gt; pickingP(actualRecvKpSz);
<a name="l01681"></a>01681   std::vector&lt;char&gt; pickingS(actualRecvKsSz);
<a name="l01682"></a>01682 
<a name="l01683"></a>01683   std::vector&lt;char&gt; pickedP(sendKp.size());
<a name="l01684"></a>01684   std::vector&lt;char&gt; pickedS(sendKs.size());
<a name="l01685"></a>01685 
<a name="l01686"></a>01686   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; actualRecvKpSz; i++) {
<a name="l01687"></a>01687     pickingP[i] = 0;
<a name="l01688"></a>01688   }
<a name="l01689"></a>01689 
<a name="l01690"></a>01690   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; actualRecvKsSz; i++) {
<a name="l01691"></a>01691     pickingS[i] = 0;
<a name="l01692"></a>01692   }
<a name="l01693"></a>01693 
<a name="l01694"></a>01694   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
<a name="l01695"></a>01695     recvCntsExtras[i] = 0;
<a name="l01696"></a>01696   }
<a name="l01697"></a>01697 
<a name="l01698"></a>01698   <span class="comment">// std::cout &lt;&lt; m_iRankActive &lt;&lt; " Correcting LuTs" &lt;&lt; std::endl;</span>
<a name="l01699"></a>01699 
<a name="l01700"></a>01700   <span class="comment">//Do not do an in-place update of nlist. Instead store the corrections. </span>
<a name="l01701"></a>01701   std::vector&lt; std::vector&lt;unsigned int&gt; &gt; secondRingCorrections;
<a name="l01702"></a>01702 
<a name="l01703"></a>01703   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;sortedUniqueExtras.size();i++) {
<a name="l01704"></a>01704 
<a name="l01705"></a>01705     <span class="comment">/*</span>
<a name="l01706"></a>01706 <span class="comment">       if (pickPrimary[i]) {</span>
<a name="l01707"></a>01707 <span class="comment">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01708"></a>01708 <span class="comment">assert( recvKp[oldToNewIdx[oldIndex[i]]] == sortedUniqueExtras[i] );</span>
<a name="l01709"></a>01709 <span class="comment">assert( recvKp[oldToNewIdx[oldIndex[i]]] != rootNode );</span>
<a name="l01710"></a>01710 <span class="comment">#endif</span>
<a name="l01711"></a>01711 <span class="comment">in.push_back(recvKp[oldToNewIdx[oldIndex[i]]]);        </span>
<a name="l01712"></a>01712 <span class="comment">recvCntsExtras[recvKp[oldToNewIdx[oldIndex[i]]].getWeight()]++;</span>
<a name="l01713"></a>01713 <span class="comment">pickingP[kp2ActualKp[oldToNewIdx[oldIndex[i]]]] = 1;</span>
<a name="l01714"></a>01714 <span class="comment">} else {</span>
<a name="l01715"></a>01715 <span class="comment">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01716"></a>01716 <span class="comment">assert( recvKs[oldToNewIdx[oldIndex[i]]] == sortedUniqueExtras[i] );</span>
<a name="l01717"></a>01717 <span class="comment">assert( recvKs[oldToNewIdx[oldIndex[i]]] != rootNode );</span>
<a name="l01718"></a>01718 <span class="comment">#endif</span>
<a name="l01719"></a>01719 <span class="comment">in.push_back(recvKs[oldToNewIdx[oldIndex[i]]]);        </span>
<a name="l01720"></a>01720 <span class="comment">recvCntsExtras[recvKs[oldToNewIdx[oldIndex[i]]].getWeight()]++;</span>
<a name="l01721"></a>01721 <span class="comment">pickingS[ks2ActualKs[oldToNewIdx[oldIndex[i]]]] = 1;</span>
<a name="l01722"></a>01722 <span class="comment">}</span>
<a name="l01723"></a>01723 <span class="comment"></span>
<a name="l01724"></a>01724 <span class="comment">for (unsigned int j =0;j &lt; indicesIntoLUT[i].size(); j++) {</span>
<a name="l01725"></a>01725 <span class="comment">for (unsigned int k=0; k &lt; 8; k++) {</span>
<a name="l01726"></a>01726 <span class="comment">for (unsigned int l = 0;l &lt; indicesIntoOld[i].size(); l++) {</span>
<a name="l01727"></a>01727 <span class="comment">if (nlist[8*(indicesIntoLUT[i][j])+k] == (m_uiLocalBufferSize + indicesIntoOld[i][l])) {</span>
<a name="l01728"></a>01728 <span class="comment">std::vector&lt;unsigned int&gt; ringCorrectionsTuple(3);</span>
<a name="l01729"></a>01729 <span class="comment">ringCorrectionsTuple[0] = indicesIntoLUT[i][j];</span>
<a name="l01730"></a>01730 <span class="comment">ringCorrectionsTuple[1] = k;</span>
<a name="l01731"></a>01731 <span class="comment">ringCorrectionsTuple[2] = (in.size()-1);</span>
<a name="l01732"></a>01732 <span class="comment">secondRingCorrections.push_back(ringCorrectionsTuple);</span>
<a name="l01733"></a>01733 <span class="comment">break;</span>
<a name="l01734"></a>01734 <span class="comment">} // if </span>
<a name="l01735"></a>01735 <span class="comment">} // for l                   </span>
<a name="l01736"></a>01736 <span class="comment">}  // for k     </span>
<a name="l01737"></a>01737 <span class="comment">} // for j</span>
<a name="l01738"></a>01738 <span class="comment">*/</span>
<a name="l01739"></a>01739 
<a name="l01740"></a>01740   <span class="keywordflow">if</span> (fromPrimary[chosenIndexIntoOld[i]]) {
<a name="l01741"></a>01741 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01742"></a>01742 <span class="preprocessor"></span>    assert( recvKp[oldToNewIdx[chosenIndexIntoOld[i]]] == sortedUniqueExtras[i] );
<a name="l01743"></a>01743     assert( recvKp[oldToNewIdx[chosenIndexIntoOld[i]]] != rootNode );
<a name="l01744"></a>01744 <span class="preprocessor">#endif</span>
<a name="l01745"></a>01745 <span class="preprocessor"></span>    in.push_back(recvKp[oldToNewIdx[chosenIndexIntoOld[i]]]);        
<a name="l01746"></a>01746     recvCntsExtras[recvKp[oldToNewIdx[chosenIndexIntoOld[i]]].getWeight()]++;
<a name="l01747"></a>01747     pickingP[kp2ActualKp[oldToNewIdx[chosenIndexIntoOld[i]]]] = 1;
<a name="l01748"></a>01748   } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(fromSecondary[chosenIndexIntoOld[i]]) {
<a name="l01749"></a>01749 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01750"></a>01750 <span class="preprocessor"></span>    assert( recvKs[oldToNewIdx[chosenIndexIntoOld[i]]] == sortedUniqueExtras[i] );
<a name="l01751"></a>01751     assert( recvKs[oldToNewIdx[chosenIndexIntoOld[i]]] != rootNode );
<a name="l01752"></a>01752 <span class="preprocessor">#endif</span>
<a name="l01753"></a>01753 <span class="preprocessor"></span>    in.push_back(recvKs[oldToNewIdx[chosenIndexIntoOld[i]]]);        
<a name="l01754"></a>01754     recvCntsExtras[recvKs[oldToNewIdx[chosenIndexIntoOld[i]]].getWeight()]++;
<a name="l01755"></a>01755     pickingS[ks2ActualKs[oldToNewIdx[chosenIndexIntoOld[i]]]] = 1;
<a name="l01756"></a>01756   }
<a name="l01757"></a>01757 
<a name="l01758"></a>01758 <span class="comment">//If the element is neither in primary nor in secondary,</span>
<a name="l01759"></a>01759 <span class="comment">//then 'in' already has it. So no need to append it into 'in' again.</span>
<a name="l01760"></a>01760 <span class="comment">//Note, that we will never select a copy of sortedUniqueExtras[i] from primary or secondary if the element already exists within in.</span>
<a name="l01761"></a>01761 
<a name="l01762"></a>01762 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j =0;j &lt; indicesIntoLUT[i].size(); j++) {
<a name="l01763"></a>01763   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k=0; k &lt; 8; k++) {
<a name="l01764"></a>01764     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> l = 0;l &lt; indicesIntoOld[i].size(); l++) {
<a name="l01765"></a>01765       <span class="keywordflow">if</span> (nlist[8*(indicesIntoLUT[i][j])+k] == (<a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a> + indicesIntoOld[i][l])) {
<a name="l01766"></a>01766         std::vector&lt;unsigned int&gt; ringCorrectionsTuple(3);
<a name="l01767"></a>01767         ringCorrectionsTuple[0] = indicesIntoLUT[i][j];
<a name="l01768"></a>01768         ringCorrectionsTuple[1] = k;
<a name="l01769"></a>01769 
<a name="l01770"></a>01770         <span class="keywordflow">if</span>( fromPrimary[chosenIndexIntoOld[i]] || fromSecondary[chosenIndexIntoOld[i]] ) {
<a name="l01771"></a>01771           ringCorrectionsTuple[2] = (static_cast&lt;unsigned int&gt;(in.size()) - 1);
<a name="l01772"></a>01772         }<span class="keywordflow">else</span> {
<a name="l01773"></a>01773           ringCorrectionsTuple[2] = oldToNewIdx[chosenIndexIntoOld[i]];
<a name="l01774"></a>01774         }
<a name="l01775"></a>01775 
<a name="l01776"></a>01776         secondRingCorrections.push_back(ringCorrectionsTuple);
<a name="l01777"></a>01777         <span class="keywordflow">break</span>;
<a name="l01778"></a>01778       } <span class="comment">// if </span>
<a name="l01779"></a>01779     } <span class="comment">// for l                   </span>
<a name="l01780"></a>01780   }  <span class="comment">// for k     </span>
<a name="l01781"></a>01781 } <span class="comment">// for j</span>
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 } <span class="comment">// for i</span>
<a name="l01784"></a>01784 
<a name="l01785"></a>01785 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; secondRingCorrections.size(); i++) {
<a name="l01786"></a>01786   <span class="comment">//Actual Correction here...</span>
<a name="l01787"></a>01787   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elemId = secondRingCorrections[i][0];
<a name="l01788"></a>01788   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> vtxId = secondRingCorrections[i][1];
<a name="l01789"></a>01789   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lutVal = secondRingCorrections[i][2];
<a name="l01790"></a>01790   nlist[8*elemId+vtxId] = lutVal;
<a name="l01791"></a>01791 
<a name="l01792"></a>01792 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01793"></a>01793 <span class="preprocessor"></span>  assert( lutVal &lt; in.size() );
<a name="l01794"></a>01794 <span class="preprocessor">#endif</span>
<a name="l01795"></a>01795 <span class="preprocessor"></span>
<a name="l01796"></a>01796   <span class="comment">// correct hanging node mask ...</span>
<a name="l01797"></a>01797   <span class="comment">// check if any of the nodes is hanging ...</span>
<a name="l01798"></a>01798   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x,_y,_z;
<a name="l01799"></a>01799 
<a name="l01800"></a>01800   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[elemId].getX();
<a name="l01801"></a>01801   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[elemId].getY();
<a name="l01802"></a>01802   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[elemId].getZ();
<a name="l01803"></a>01803   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[elemId].getLevel();
<a name="l01804"></a>01804   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = (1u &lt;&lt; (<a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d));
<a name="l01805"></a>01805 
<a name="l01806"></a>01806 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01807"></a>01807 <span class="preprocessor"></span>  <span class="comment">//You might have to find the actual node via final corrections</span>
<a name="l01808"></a>01808   <span class="comment">//(explicit parallel search) although you sent yourself apriori</span>
<a name="l01809"></a>01809   <span class="comment">//(Second Ring). </span>
<a name="l01810"></a>01810   <span class="keywordflow">if</span>( (elemId &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (elemId &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) ) {
<a name="l01811"></a>01811     <span class="keywordflow">if</span>(in[lutVal] &lt; in[<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>]) {
<a name="l01812"></a>01812       std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Trying to send yourself as a Post Ghost ELEMENT for  elemId = "</span>
<a name="l01813"></a>01813         &lt;&lt;elemId&lt;&lt;<span class="stringliteral">" vtxId = "</span>&lt;&lt;vtxId&lt;&lt;std::endl;
<a name="l01814"></a>01814       assert(<span class="keyword">false</span>);
<a name="l01815"></a>01815     }
<a name="l01816"></a>01816     <span class="keywordflow">if</span>( (<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a> &lt; in.size()) &amp;&amp; (in[lutVal] &gt;= in[<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>]) ) {
<a name="l01817"></a>01817       <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmpToSend = in[lutVal];
<a name="l01818"></a>01818       tmpToSend.setWeight(elemId);
<a name="l01819"></a>01819       checkSecondRing.push_back(tmpToSend);
<a name="l01820"></a>01820     }
<a name="l01821"></a>01821   }
<a name="l01822"></a>01822 <span class="preprocessor">#endif</span>
<a name="l01823"></a>01823 <span class="preprocessor"></span>
<a name="l01824"></a>01824   _x = in[lutVal].getX(); 
<a name="l01825"></a>01825   _y = in[lutVal].getY(); 
<a name="l01826"></a>01826   _z = in[lutVal].getZ(); 
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01829"></a>01829 <span class="preprocessor"></span>  <span class="keywordflow">if</span> ( !(in[lutVal].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a> ) ) {
<a name="l01830"></a>01830     <span class="comment">//Second ring must find a node only </span>
<a name="l01831"></a>01831     assert(<span class="keyword">false</span>);
<a name="l01832"></a>01832   }
<a name="l01833"></a>01833 <span class="preprocessor">#endif</span>
<a name="l01834"></a>01834 <span class="preprocessor"></span>
<a name="l01835"></a>01835   <span class="keywordflow">switch</span> (vtxId) {
<a name="l01836"></a>01836     <span class="keywordflow">case</span> 0:
<a name="l01837"></a>01837       assert(<span class="keyword">false</span>);
<a name="l01838"></a>01838       <span class="keywordflow">break</span>;
<a name="l01839"></a>01839     <span class="keywordflow">case</span> 1:
<a name="l01840"></a>01840       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( z != _z ) ) {
<a name="l01841"></a>01841         <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
<a name="l01842"></a>01842       }
<a name="l01843"></a>01843       <span class="keywordflow">break</span>;
<a name="l01844"></a>01844     <span class="keywordflow">case</span> 2:
<a name="l01845"></a>01845       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
<a name="l01846"></a>01846         <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
<a name="l01847"></a>01847       }
<a name="l01848"></a>01848       <span class="keywordflow">break</span>;
<a name="l01849"></a>01849     <span class="keywordflow">case</span> 3:
<a name="l01850"></a>01850       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( z != _z ) ) {
<a name="l01851"></a>01851         <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
<a name="l01852"></a>01852       }
<a name="l01853"></a>01853       <span class="keywordflow">break</span>;
<a name="l01854"></a>01854     <span class="keywordflow">case</span> 4:
<a name="l01855"></a>01855       <span class="keywordflow">if</span> ( ( x != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
<a name="l01856"></a>01856         <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
<a name="l01857"></a>01857       }
<a name="l01858"></a>01858       <span class="keywordflow">break</span>;
<a name="l01859"></a>01859     <span class="keywordflow">case</span> 5:
<a name="l01860"></a>01860       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( y != _y ) || ( (z+sz) != _z ) ) {
<a name="l01861"></a>01861         <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
<a name="l01862"></a>01862       }
<a name="l01863"></a>01863       <span class="keywordflow">break</span>;
<a name="l01864"></a>01864     <span class="keywordflow">case</span> 6:
<a name="l01865"></a>01865       <span class="keywordflow">if</span> ( ( x != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
<a name="l01866"></a>01866         <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
<a name="l01867"></a>01867       }
<a name="l01868"></a>01868       <span class="keywordflow">break</span>;
<a name="l01869"></a>01869     <span class="keywordflow">case</span> 7:
<a name="l01870"></a>01870       <span class="keywordflow">if</span> ( ( (x+sz) != _x ) || ( (y+sz) != _y ) || ( (z+sz) != _z ) ) {
<a name="l01871"></a>01871         <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*elemId+1] |= (1 &lt;&lt; vtxId);
<a name="l01872"></a>01872       }
<a name="l01873"></a>01873       <span class="keywordflow">break</span>;
<a name="l01874"></a>01874   } <span class="comment">// switch (vtxId)</span>
<a name="l01875"></a>01875 
<a name="l01876"></a>01876 }<span class="comment">//end for i</span>
<a name="l01877"></a>01877 
<a name="l01878"></a>01878 secondRingCorrections.clear();
<a name="l01879"></a>01879 
<a name="l01880"></a>01880 <span class="comment">//pickPrimary.clear();</span>
<a name="l01881"></a>01881 <span class="comment">//oldIndex.clear();</span>
<a name="l01882"></a>01882 
<a name="l01883"></a>01883 sortedUniqueExtras.clear();
<a name="l01884"></a>01884 chosenIndexIntoOld.clear();
<a name="l01885"></a>01885 
<a name="l01886"></a>01886 indicesIntoLUT.clear();
<a name="l01887"></a>01887 indicesIntoOld.clear();
<a name="l01888"></a>01888 
<a name="l01889"></a>01889 kp2ActualKp.clear();
<a name="l01890"></a>01890 ks2ActualKs.clear();
<a name="l01891"></a>01891 
<a name="l01892"></a>01892 sendKp.clear();
<a name="l01893"></a>01893 sendKs.clear();
<a name="l01894"></a>01894 recvKp.clear(); 
<a name="l01895"></a>01895 recvKs.clear();  
<a name="l01896"></a>01896 
<a name="l01897"></a>01897 <span class="keywordflow">if</span>(oldToNewIdx) {
<a name="l01898"></a>01898   <span class="keyword">delete</span> [] oldToNewIdx;
<a name="l01899"></a>01899   oldToNewIdx = NULL;
<a name="l01900"></a>01900 }
<a name="l01901"></a>01901 
<a name="l01902"></a>01902 <span class="keywordflow">if</span>(fromPrimary) {
<a name="l01903"></a>01903   <span class="keyword">delete</span> [] fromPrimary;    
<a name="l01904"></a>01904   fromPrimary = NULL;
<a name="l01905"></a>01905 }
<a name="l01906"></a>01906 
<a name="l01907"></a>01907 <span class="keywordflow">if</span>(fromSecondary) {
<a name="l01908"></a>01908   <span class="keyword">delete</span> [] fromSecondary;
<a name="l01909"></a>01909   fromSecondary = NULL;
<a name="l01910"></a>01910 }
<a name="l01911"></a>01911 
<a name="l01912"></a>01912 <span class="comment">// Set secondary comm variables ...</span>
<a name="l01913"></a>01913 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;m_iNpesActive; i++) {
<a name="l01914"></a>01914   <span class="keywordflow">if</span> (recvCntsExtras[i]) {
<a name="l01915"></a>01915     ScndRecvProcs.push_back(i);
<a name="l01916"></a>01916     ScndRecvCounts.push_back(recvCntsExtras[i]); 
<a name="l01917"></a>01917 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01918"></a>01918 <span class="preprocessor"></span>    std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Scnd Recv P : "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" Scnd Recv C : "</span>&lt;&lt; recvCntsExtras[i]&lt;&lt;std::endl;
<a name="l01919"></a>01919     assert(i != <a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>);
<a name="l01920"></a>01920 <span class="preprocessor">#endif</span>
<a name="l01921"></a>01921 <span class="preprocessor"></span>  }
<a name="l01922"></a>01922 }
<a name="l01923"></a>01923 
<a name="l01924"></a>01924 <span class="keywordflow">if</span>(recvCntsExtras) {
<a name="l01925"></a>01925   <span class="keyword">delete</span> [] recvCntsExtras;    
<a name="l01926"></a>01926   recvCntsExtras = NULL;
<a name="l01927"></a>01927 }
<a name="l01928"></a>01928 
<a name="l01929"></a>01929 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01930"></a>01930 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01931"></a>01931 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l01932"></a>01932   std::cout&lt;&lt;std::endl;
<a name="l01933"></a>01933   std::cout&lt;&lt;<span class="stringliteral">"Returning Selection in Second Ring..."</span>&lt;&lt;std::endl;
<a name="l01934"></a>01934   std::cout&lt;&lt;std::endl;
<a name="l01935"></a>01935 }
<a name="l01936"></a>01936 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01937"></a>01937 <span class="preprocessor">#endif</span>
<a name="l01938"></a>01938 <span class="preprocessor"></span>
<a name="l01939"></a>01939 <span class="keywordtype">char</span>* pickingPptr = NULL;
<a name="l01940"></a>01940 <span class="keywordtype">char</span>* pickedPptr = NULL;
<a name="l01941"></a>01941 <span class="keywordtype">char</span>* pickingSptr = NULL;
<a name="l01942"></a>01942 <span class="keywordtype">char</span>* pickedSptr = NULL;
<a name="l01943"></a>01943 
<a name="l01944"></a>01944 <span class="keywordflow">if</span>(!pickingP.empty()) {
<a name="l01945"></a>01945   pickingPptr = &amp;(*(pickingP.begin()));
<a name="l01946"></a>01946 }
<a name="l01947"></a>01947 <span class="keywordflow">if</span>(!pickingS.empty()) {
<a name="l01948"></a>01948   pickingSptr = &amp;(*(pickingS.begin()));
<a name="l01949"></a>01949 }
<a name="l01950"></a>01950 <span class="keywordflow">if</span>(!pickedP.empty()) {
<a name="l01951"></a>01951   pickedPptr = &amp;(*(pickedP.begin()));
<a name="l01952"></a>01952 }
<a name="l01953"></a>01953 <span class="keywordflow">if</span>(!pickedS.empty()) {
<a name="l01954"></a>01954   pickedSptr = &amp;(*(pickedS.begin()));
<a name="l01955"></a>01955 }
<a name="l01956"></a>01956 
<a name="l01957"></a>01957 <a class="code" href="oda_8h.html#835a8172186986310f09107b5c88593a">PROF_BUILD_NLIST_COMM_BEGIN</a>
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 par::Mpi_Alltoallv_sparse&lt;char&gt;(pickingPptr ,numKeysRecvP, recvOffsetsP , 
<a name="l01960"></a>01960     pickedPptr, numKeysSendP, sendOffsetsP, <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01961"></a>01961 
<a name="l01962"></a>01962 par::Mpi_Alltoallv_sparse&lt;char&gt;(pickingSptr ,numKeysRecvS, recvOffsetsS, 
<a name="l01963"></a>01963     pickedSptr, numKeysSendS, sendOffsetsS , <a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01964"></a>01964 
<a name="l01965"></a>01965 <a class="code" href="oda_8h.html#f1640be776c6f95c9b0230263304d5e6">PROF_BUILD_NLIST_COMM_END</a>
<a name="l01966"></a>01966 
<a name="l01967"></a>01967 pickingP.clear();
<a name="l01968"></a>01968 pickingS.clear();
<a name="l01969"></a>01969 
<a name="l01970"></a>01970 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l01971"></a>01971 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01972"></a>01972 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l01973"></a>01973   std::cout&lt;&lt;std::endl;
<a name="l01974"></a>01974   std::cout&lt;&lt;<span class="stringliteral">"Second ScatterMap..."</span>&lt;&lt;std::endl;
<a name="l01975"></a>01975   std::cout&lt;&lt;std::endl;
<a name="l01976"></a>01976 }
<a name="l01977"></a>01977 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l01978"></a>01978 <span class="preprocessor">#endif</span>
<a name="l01979"></a>01979 <span class="preprocessor"></span>
<a name="l01980"></a>01980 <span class="comment">//Create ScatterMap here using sendKp, recvKp, pickedP...</span>
<a name="l01981"></a>01981 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cnt=0, pickedCnt=0;
<a name="l01982"></a>01982 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pCnt=0, sCnt=0;
<a name="l01983"></a>01983 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; static_cast&lt;unsigned int&gt;(m_iNpesActive); i++) {
<a name="l01984"></a>01984   cnt=0;
<a name="l01985"></a>01985   pickedCnt=0;
<a name="l01986"></a>01986   <span class="comment">// merge and pick entries from both primary and secondary lists being sent to procs ...</span>
<a name="l01987"></a>01987   <span class="keywordflow">while</span> (cnt &lt; (numKeysSendP[i] + numKeysSendS[i]) ) {
<a name="l01988"></a>01988     <span class="comment">// sOver := sCnt &gt;= (sendOffsetsS[i] + numKeysSendS[i]);</span>
<a name="l01989"></a>01989     <span class="comment">// pOver := pCnt &gt;= (sendOffsetsP[i] + numKeysSendP[i]);</span>
<a name="l01990"></a>01990     <span class="comment">// sRemains = sCnt &lt; (sendOffsetsS[i] + numKeysSendS[i]);</span>
<a name="l01991"></a>01991     <span class="comment">// pRemains = pCnt &lt; (sendOffsetsP[i] + numKeysSendP[i]);</span>
<a name="l01992"></a>01992     <span class="keywordflow">if</span> ( (sCnt &gt;= (sendOffsetsS[i] + numKeysSendS[i])) ||
<a name="l01993"></a>01993         ( ( pCnt &lt; (sendOffsetsP[i] + numKeysSendP[i]) ) &amp;&amp;
<a name="l01994"></a>01994           ( idxSendKp[pCnt] &lt;= idxSendKs[sCnt]) ) ) {
<a name="l01995"></a>01995 #ifdef __DEBUG_DA_NLIST__
<a name="l01996"></a>01996       <span class="keywordflow">if</span>(idxSendKp[pCnt] == -1) {
<a name="l01997"></a>01997         assert(!pickedP[pCnt]);
<a name="l01998"></a>01998       }
<a name="l01999"></a>01999 <span class="preprocessor">#endif</span>
<a name="l02000"></a>02000 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (pickedP[pCnt]) {
<a name="l02001"></a>02001         ScndScatterMap.push_back(idxSendKp[pCnt]);
<a name="l02002"></a>02002         pickedCnt++;
<a name="l02003"></a>02003       }
<a name="l02004"></a>02004       pCnt++;
<a name="l02005"></a>02005     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( ( pCnt &gt;=
<a name="l02006"></a>02006           static_cast&lt;unsigned int&gt;(sendOffsetsP[i] + numKeysSendP[i]) ) ||
<a name="l02007"></a>02007         ( sCnt &lt; static_cast&lt;unsigned int&gt;(sendOffsetsS[i] + numKeysSendS[i]) ) ) {
<a name="l02008"></a>02008 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02009"></a>02009 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(idxSendKs[sCnt] == -1) {
<a name="l02010"></a>02010         assert(!pickedS[sCnt]);
<a name="l02011"></a>02011       }
<a name="l02012"></a>02012 <span class="preprocessor">#endif</span>
<a name="l02013"></a>02013 <span class="preprocessor"></span>      <span class="keywordflow">if</span> (pickedS[sCnt]) {
<a name="l02014"></a>02014         ScndScatterMap.push_back(idxSendKs[sCnt]);
<a name="l02015"></a>02015         pickedCnt++;
<a name="l02016"></a>02016       }
<a name="l02017"></a>02017       sCnt++;
<a name="l02018"></a>02018     } <span class="keywordflow">else</span> {
<a name="l02019"></a>02019       std::cout &lt;&lt; <span class="stringliteral">"Scnd skipped both"</span> &lt;&lt; std::endl;
<a name="l02020"></a>02020     }
<a name="l02021"></a>02021     cnt++;
<a name="l02022"></a>02022   }<span class="comment">//end while</span>
<a name="l02023"></a>02023   <span class="keywordflow">if</span> (pickedCnt) {
<a name="l02024"></a>02024     ScndSendProcs.push_back(i);  
<a name="l02025"></a>02025     ScndSendCounts.push_back(pickedCnt);
<a name="l02026"></a>02026 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02027"></a>02027 <span class="preprocessor"></span>    std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Scnd Send P : "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" Scnd Send C : "</span>&lt;&lt; pickedCnt&lt;&lt;std::endl;
<a name="l02028"></a>02028     assert(i != <a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>);
<a name="l02029"></a>02029 <span class="preprocessor">#endif</span>
<a name="l02030"></a>02030 <span class="preprocessor"></span>  }
<a name="l02031"></a>02031 }<span class="comment">//end for i</span>
<a name="l02032"></a>02032 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02033"></a>02033 <span class="preprocessor"></span><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
<a name="l02034"></a>02034   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numToSend_i = 0;
<a name="l02035"></a>02035   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = sendOffsetsP[i]; j &lt; (sendOffsetsP[i] + numKeysSendP[i]); j++) {
<a name="l02036"></a>02036     <span class="keywordflow">if</span>(pickedP[j]) {
<a name="l02037"></a>02037       numToSend_i++;
<a name="l02038"></a>02038     }
<a name="l02039"></a>02039   }<span class="comment">//end for j</span>
<a name="l02040"></a>02040   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = sendOffsetsS[i]; j &lt; (sendOffsetsS[i] + numKeysSendS[i]); j++) {
<a name="l02041"></a>02041     <span class="keywordflow">if</span>(pickedS[j]) {
<a name="l02042"></a>02042       numToSend_i++;
<a name="l02043"></a>02043     }
<a name="l02044"></a>02044   }<span class="comment">//end for j</span>
<a name="l02045"></a>02045   <span class="keywordflow">if</span>(numToSend_i) {
<a name="l02046"></a>02046     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Actually should send "</span>&lt;&lt;numToSend_i&lt;&lt;<span class="stringliteral">" to "</span>&lt;&lt;i&lt;&lt;std::endl;
<a name="l02047"></a>02047   }
<a name="l02048"></a>02048 }<span class="comment">//end for i</span>
<a name="l02049"></a>02049 <span class="preprocessor">#endif</span>
<a name="l02050"></a>02050 <span class="preprocessor"></span>
<a name="l02051"></a>02051 <span class="comment">//Reset LocalBuffer Size</span>
<a name="l02052"></a>02052 <a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a> = static_cast&lt;unsigned int&gt;(in.size());
<a name="l02053"></a>02053 
<a name="l02054"></a>02054 idxSendKp.clear();
<a name="l02055"></a>02055 idxSendKs.clear();
<a name="l02056"></a>02056 
<a name="l02057"></a>02057 <span class="keyword">delete</span> [] sendOffsetsP;
<a name="l02058"></a>02058 sendOffsetsP = NULL;
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 <span class="keyword">delete</span> [] sendOffsetsS;
<a name="l02061"></a>02061 sendOffsetsS = NULL;
<a name="l02062"></a>02062 
<a name="l02063"></a>02063 <span class="keyword">delete</span> [] numKeysSendP;
<a name="l02064"></a>02064 numKeysSendP = NULL;
<a name="l02065"></a>02065 
<a name="l02066"></a>02066 <span class="keyword">delete</span> [] numKeysSendS;
<a name="l02067"></a>02067 numKeysSendS = NULL;
<a name="l02068"></a>02068 
<a name="l02069"></a>02069 <span class="keyword">delete</span> [] numKeysRecvP;
<a name="l02070"></a>02070 numKeysRecvP = NULL;
<a name="l02071"></a>02071 
<a name="l02072"></a>02072 <span class="keyword">delete</span> [] recvOffsetsP;    
<a name="l02073"></a>02073 recvOffsetsP = NULL;
<a name="l02074"></a>02074 
<a name="l02075"></a>02075 <span class="keyword">delete</span> [] recvOffsetsS;
<a name="l02076"></a>02076 recvOffsetsS = NULL;
<a name="l02077"></a>02077 
<a name="l02078"></a>02078 <span class="keyword">delete</span> [] numKeysRecvS;
<a name="l02079"></a>02079 numKeysRecvS = NULL;
<a name="l02080"></a>02080 
<a name="l02081"></a>02081 pickedP.clear();
<a name="l02082"></a>02082 pickedS.clear();   
<a name="l02083"></a>02083 
<a name="l02084"></a>02084 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02085"></a>02085 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02086"></a>02086 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02087"></a>02087   std::cout&lt;&lt;std::endl;
<a name="l02088"></a>02088   std::cout&lt;&lt;<span class="stringliteral">"Finished Correction for Second Ring..."</span>&lt;&lt;std::endl;
<a name="l02089"></a>02089   std::cout&lt;&lt;std::endl;
<a name="l02090"></a>02090 }
<a name="l02091"></a>02091 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02092"></a>02092 <span class="preprocessor">#endif</span>
<a name="l02093"></a>02093 <span class="preprocessor"></span>
<a name="l02094"></a>02094 <span class="comment">//~~~~~~~~~~~~~~~~Correction for Second Ring Ends~~~~~~~~~~~~~~//</span>
<a name="l02095"></a>02095 
<a name="l02096"></a>02096 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02097"></a>02097 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02098"></a>02098 <span class="comment">//CHECK if apriori comm for Second ring actually works.</span>
<a name="l02099"></a>02099 <span class="comment">//Check if primary scattermap contains the right element and if it is</span>
<a name="l02100"></a>02100 <span class="comment">//sent to the right processor</span>
<a name="l02101"></a>02101 <span class="comment">//checkSecondRing[i] is a post-ghost element on the local proc, to which one of</span>
<a name="l02102"></a>02102 <span class="comment">//my own elements are pointing to. The corresponding index of my own element is</span>
<a name="l02103"></a>02103 <span class="comment">//stored in the weight of checkSecondRing[i]. </span>
<a name="l02104"></a>02104 std::vector&lt;std::vector&lt;unsigned int&gt; &gt; secondRingExpectedScatterMap(m_iNpesActive);
<a name="l02105"></a>02105 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; checkSecondRing.size(); i++) {
<a name="l02106"></a>02106   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bId;
<a name="l02107"></a>02107   <span class="comment">//Find the processor that owns the node.</span>
<a name="l02108"></a>02108   <span class="keywordtype">bool</span> bucketFound = seq::maxLowerBound&lt;ot::TreeNode&gt;(<a class="code" href="classot_1_1DA.html#70a52f230b37593f6110723037fc02b1">m_tnMinAllBlocks</a>, checkSecondRing[i], bId, NULL, NULL);
<a name="l02109"></a>02109   assert(bucketFound);
<a name="l02110"></a>02110   assert(bId &lt; m_iNpesActive);
<a name="l02111"></a>02111   assert( m_tnMinAllBlocks[bId] &lt;= checkSecondRing[i] );
<a name="l02112"></a>02112   secondRingExpectedScatterMap[bId].push_back(checkSecondRing[i].getWeight());
<a name="l02113"></a>02113 }
<a name="l02114"></a>02114 
<a name="l02115"></a>02115 assert(<a class="code" href="namespaceseq_1_1test.html#1c2cc3f843faf778a0513185f54fcf9f">seq::test::isUniqueAndSorted</a>(<a class="code" href="classot_1_1DA.html#c1cf50f4fa19a3d2d9a9c990d8cf1cfd">m_uipSendProcs</a>));
<a name="l02116"></a>02116 
<a name="l02117"></a>02117 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> toSendCnt = 0;
<a name="l02118"></a>02118 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currOffset = 0;
<a name="l02119"></a>02119 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_iNpesActive; i++) {
<a name="l02120"></a>02120   seq::makeVectorUnique&lt;unsigned int&gt;(secondRingExpectedScatterMap[i], <span class="keyword">false</span>) ;
<a name="l02121"></a>02121   <span class="keywordflow">if</span>( (toSendCnt &lt; m_uipSendProcs.size()) &amp;&amp; (m_uipSendProcs[toSendCnt] == i) ) {
<a name="l02122"></a>02122     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = currOffset; j &lt; (currOffset + <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[toSendCnt] - 1); j++ ) {
<a name="l02123"></a>02123       assert(<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[j] &lt; <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[j+1]);
<a name="l02124"></a>02124     }
<a name="l02125"></a>02125     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> st = 0;    
<a name="l02126"></a>02126     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; secondRingExpectedScatterMap[i].size(); j++) {
<a name="l02127"></a>02127       <span class="keywordtype">bool</span> foundIt = <span class="keyword">false</span>;
<a name="l02128"></a>02128       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = st; k &lt; <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[toSendCnt]; k++) {
<a name="l02129"></a>02129         assert( (currOffset + k) &lt; <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>.size() );
<a name="l02130"></a>02130         <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[currOffset + k] == secondRingExpectedScatterMap[i][j] ) {
<a name="l02131"></a>02131           foundIt = <span class="keyword">true</span>;
<a name="l02132"></a>02132           <span class="comment">//secondRingExpectedScatterMap[i] is Sorted and Unique.</span>
<a name="l02133"></a>02133           <span class="comment">//Primary ScatterMap is also sorted and Unique for each processor </span>
<a name="l02134"></a>02134           st = (k+1); 
<a name="l02135"></a>02135           <span class="keywordflow">break</span>;
<a name="l02136"></a>02136         }
<a name="l02137"></a>02137       }<span class="comment">//end for k</span>
<a name="l02138"></a>02138       <span class="keywordflow">if</span>(!foundIt) {
<a name="l02139"></a>02139         std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" should have sent in["</span>&lt;&lt;
<a name="l02140"></a>02140           secondRingExpectedScatterMap[i][j]&lt;&lt;<span class="stringliteral">"]: "</span>&lt;&lt;in[secondRingExpectedScatterMap[i][j]]
<a name="l02141"></a>02141           &lt;&lt;<span class="stringliteral">"  to "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" in primary. But did not."</span>&lt;&lt;std::endl; 
<a name="l02142"></a>02142         assert(<span class="keyword">false</span>);
<a name="l02143"></a>02143       }
<a name="l02144"></a>02144     }<span class="comment">//end for j</span>
<a name="l02145"></a>02145     currOffset += <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[toSendCnt];
<a name="l02146"></a>02146     toSendCnt++;
<a name="l02147"></a>02147   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( !(secondRingExpectedScatterMap[i].empty()) ) {
<a name="l02148"></a>02148     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" should have sent some elements to "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">" in primary."</span>
<a name="l02149"></a>02149       &lt;&lt;<span class="stringliteral">" But did not. toSendCnt: "</span>&lt;&lt;toSendCnt&lt;&lt;<span class="stringliteral">" primarySz: "</span>&lt;&lt;(m_uipSendProcs.size())&lt;&lt;std::endl; 
<a name="l02150"></a>02150     std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" For example, This element was not found in primary ScatterMap: "</span>
<a name="l02151"></a>02151       &lt;&lt;in[secondRingExpectedScatterMap[i][0]]&lt;&lt;std::endl;
<a name="l02152"></a>02152     assert(<span class="keyword">false</span>);
<a name="l02153"></a>02153   }<span class="comment">//end if ranks match</span>
<a name="l02154"></a>02154 }<span class="comment">//end for i</span>
<a name="l02155"></a>02155 
<a name="l02156"></a>02156 secondRingExpectedScatterMap.clear();
<a name="l02157"></a>02157 checkSecondRing.clear();
<a name="l02158"></a>02158 
<a name="l02159"></a>02159 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02160"></a>02160   std::cout&lt;&lt;<span class="stringliteral">" Finished Checking Apriori send for Second Ring.."</span>&lt;&lt;std::endl;
<a name="l02161"></a>02161 }
<a name="l02162"></a>02162 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02163"></a>02163 <span class="preprocessor">#endif</span>
<a name="l02164"></a>02164 <span class="preprocessor"></span>
<a name="l02165"></a>02165 <span class="comment">//~~~~~~~~~~~Sort In, Flag Corrections as FOREIGN, update Luts~~~~~~~~~~~~~~~~~</span>
<a name="l02166"></a>02166 
<a name="l02167"></a>02167 <span class="comment">// Now resort in, and correct nlist and scattermap.</span>
<a name="l02168"></a>02168 std::vector&lt;seq::IndexHolder&lt;ot::TreeNode&gt; &gt; inHolder(in.size());
<a name="l02169"></a>02169 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; in.size(); i++) {
<a name="l02170"></a>02170   in[i].setWeight(i);
<a name="l02171"></a>02171   inHolder[i].value = &amp;in[i];
<a name="l02172"></a>02172   <span class="keywordflow">if</span>( (i &gt;= nelem) || ( (i &lt; iLoopEnd) &amp;&amp;
<a name="l02173"></a>02173         (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[(2*i) + 1] == <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) ) ) {
<a name="l02174"></a>02174     <span class="comment">//Mark old Foreign, new octants, postghosts and boundaries</span>
<a name="l02175"></a>02175     inHolder[i].index = 0;
<a name="l02176"></a>02176   } <span class="keywordflow">else</span> {
<a name="l02177"></a>02177     inHolder[i].index = 1;
<a name="l02178"></a>02178   }
<a name="l02179"></a>02179 } <span class="comment">// end i for resort set weights ...</span>
<a name="l02180"></a>02180 
<a name="l02181"></a>02181 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02182"></a>02182 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02183"></a>02183 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02184"></a>02184   std::cout&lt;&lt;std::endl;
<a name="l02185"></a>02185   std::cout&lt;&lt;<span class="stringliteral">"created inHolder..."</span>&lt;&lt;std::endl;
<a name="l02186"></a>02186   std::cout&lt;&lt;std::endl;
<a name="l02187"></a>02187 }
<a name="l02188"></a>02188 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02189"></a>02189 <span class="preprocessor">#endif</span>
<a name="l02190"></a>02190 <span class="preprocessor"></span>
<a name="l02191"></a>02191 <span class="comment">// Now resort ...</span>
<a name="l02192"></a>02192 <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">std::sort</a>( inHolder.begin(), inHolder.end() );
<a name="l02193"></a>02193 
<a name="l02194"></a>02194 assert(<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a> &lt; in.size());
<a name="l02195"></a>02195 <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  myFirstOctant = in[<a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>];
<a name="l02196"></a>02196 assert( (<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a> - 1) &lt; in.size() );
<a name="l02197"></a>02197 <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  myLastOctant = in[<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a> - 1];
<a name="l02198"></a>02198 
<a name="l02199"></a>02199 <span class="comment">//Correct nelem...</span>
<a name="l02200"></a>02200 nelem = 0;
<a name="l02201"></a>02201 <span class="keywordflow">if</span>(m_uiElementSize) {
<a name="l02202"></a>02202   <span class="keywordflow">while</span>( (nelem &lt; in.size()) &amp;&amp;
<a name="l02203"></a>02203       ((*(inHolder[nelem].value)) &lt;= in[<a class="code" href="classot_1_1DA.html#7663ba260ee97dcc80c083c9ab841f49">m_uiElementEnd</a> - 1]) ) {
<a name="l02204"></a>02204     nelem++; 
<a name="l02205"></a>02205   }
<a name="l02206"></a>02206 } <span class="keywordflow">else</span> {
<a name="l02207"></a>02207   <span class="keywordflow">while</span>( ( nelem &lt; in.size() ) &amp;&amp;
<a name="l02208"></a>02208       ( (*(inHolder[nelem].value)) &lt; myFirstOctant ) &amp;&amp;
<a name="l02209"></a>02209       ( !((inHolder[nelem].value)-&gt;<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf80696c30ddbe9ec3ea80a7e88f5c24e0a">ot::TreeNode::BOUNDARY</a>) ) ) {
<a name="l02210"></a>02210     nelem++; 
<a name="l02211"></a>02211   }
<a name="l02212"></a>02212 }
<a name="l02213"></a>02213 
<a name="l02214"></a>02214 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02215"></a>02215 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02216"></a>02216 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02217"></a>02217   std::cout&lt;&lt;std::endl;
<a name="l02218"></a>02218   std::cout&lt;&lt;<span class="stringliteral">"Corrected NELEM..."</span>&lt;&lt;std::endl;
<a name="l02219"></a>02219   std::cout&lt;&lt;std::endl;
<a name="l02220"></a>02220 }
<a name="l02221"></a>02221 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02222"></a>02222 <span class="preprocessor">#endif</span>
<a name="l02223"></a>02223 <span class="preprocessor"></span>
<a name="l02224"></a>02224 <span class="comment">// Wts of in gives us new-&gt;old mapping. However to correct</span>
<a name="l02225"></a>02225 <span class="comment">// nlist we need old-&gt;new mapping. So we need to generate this.</span>
<a name="l02226"></a>02226 std::vector&lt;unsigned int&gt; oldToNew(in.size());
<a name="l02227"></a>02227 
<a name="l02228"></a>02228 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
<a name="l02229"></a>02229   oldToNew[inHolder[i].value-&gt;getWeight()] = i;
<a name="l02230"></a>02230 } <span class="comment">// end i for remap indices</span>
<a name="l02231"></a>02231 
<a name="l02232"></a>02232 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02233"></a>02233 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02234"></a>02234 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02235"></a>02235   std::cout&lt;&lt;std::endl;
<a name="l02236"></a>02236   std::cout&lt;&lt;<span class="stringliteral">"Computed Old2New..."</span>&lt;&lt;std::endl;
<a name="l02237"></a>02237   std::cout&lt;&lt;std::endl;
<a name="l02238"></a>02238 }
<a name="l02239"></a>02239 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02240"></a>02240 <span class="preprocessor">#endif</span>
<a name="l02241"></a>02241 <span class="preprocessor"></span>
<a name="l02242"></a>02242 <span class="comment">//Re-shuffle in.</span>
<a name="l02243"></a>02243 std::vector&lt;ot::TreeNode&gt; tmpIn(in.size());
<a name="l02244"></a>02244 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0;  i &lt; in.size(); i++) {
<a name="l02245"></a>02245   tmpIn[i] = *(inHolder[i].value);
<a name="l02246"></a>02246   tmpIn[i].setWeight(inHolder[i].index);
<a name="l02247"></a>02247 }<span class="comment">//end for i</span>
<a name="l02248"></a>02248 
<a name="l02249"></a>02249 in = tmpIn;
<a name="l02250"></a>02250 tmpIn.clear();
<a name="l02251"></a>02251 inHolder.clear();
<a name="l02252"></a>02252 
<a name="l02253"></a>02253 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02254"></a>02254 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02255"></a>02255 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02256"></a>02256   std::cout&lt;&lt;std::endl;
<a name="l02257"></a>02257   std::cout&lt;&lt;<span class="stringliteral">"Reshuffled In."</span>&lt;&lt;std::endl;
<a name="l02258"></a>02258   std::cout&lt;&lt;std::endl;
<a name="l02259"></a>02259 }
<a name="l02260"></a>02260 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02261"></a>02261 <span class="preprocessor">#endif</span>
<a name="l02262"></a>02262 <span class="preprocessor"></span>
<a name="l02263"></a>02263 <span class="comment">//Reset Counters...</span>
<a name="l02264"></a>02264 <span class="comment">// PreGhosts ....</span>
<a name="l02265"></a>02265 <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a> = 0;
<a name="l02266"></a>02266 <span class="keywordflow">while</span>( (<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a> &lt; in.size()) &amp;&amp; (in[<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>] &lt; myFirstOctant) ) {
<a name="l02267"></a>02267   <span class="keywordflow">if</span> ( !(in[<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf80696c30ddbe9ec3ea80a7e88f5c24e0a">ot::TreeNode::BOUNDARY</a>) ) {
<a name="l02268"></a>02268     m_uiPreGhostElementSize++;
<a name="l02269"></a>02269   }<span class="keywordflow">else</span> {
<a name="l02270"></a>02270     <span class="keywordflow">break</span>;
<a name="l02271"></a>02271   }
<a name="l02272"></a>02272 }<span class="comment">//end while</span>
<a name="l02273"></a>02273 
<a name="l02274"></a>02274 <span class="keywordflow">if</span>(nelem != (<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a> + m_uiElementSize) ) {
<a name="l02275"></a>02275   std::cout&lt;&lt;<span class="stringliteral">"Processor "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#e34a09c8e0884eccaa493c8d72f8b364">m_iRankAll</a>&lt;&lt;<span class="stringliteral">" failing: nelem = "</span>&lt;&lt;nelem
<a name="l02276"></a>02276     &lt;&lt;<span class="stringliteral">" pgElemSz = "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>&lt;&lt;<span class="stringliteral">" elemSz = "</span>&lt;&lt;m_uiElementSize&lt;&lt;std::endl;
<a name="l02277"></a>02277 }
<a name="l02278"></a>02278 assert( nelem == (<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a> + m_uiElementSize) );
<a name="l02279"></a>02279 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02280"></a>02280 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02281"></a>02281 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02282"></a>02282   std::cout&lt;&lt;std::endl;
<a name="l02283"></a>02283   std::cout&lt;&lt;<span class="stringliteral">"PreGhost Counters Reset."</span>&lt;&lt;std::endl;
<a name="l02284"></a>02284   std::cout&lt;&lt;std::endl;
<a name="l02285"></a>02285 }
<a name="l02286"></a>02286 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02287"></a>02287 <span class="preprocessor">#endif</span>
<a name="l02288"></a>02288 <span class="preprocessor"></span>
<a name="l02289"></a>02289 <span class="comment">//Mine ...</span>
<a name="l02290"></a>02290 <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a> = <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>;
<a name="l02291"></a>02291 <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a> = <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>;
<a name="l02292"></a>02292 <span class="keywordflow">while</span>( (<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a> &lt; in.size()) &amp;&amp; (in[<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>] &lt;= myLastOctant) ) {
<a name="l02293"></a>02293   <span class="keywordflow">if</span>(in[<a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>] &lt; myFirstOctant) {
<a name="l02294"></a>02294     <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>++;
<a name="l02295"></a>02295   }
<a name="l02296"></a>02296   <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>++;
<a name="l02297"></a>02297 }<span class="comment">//end while</span>
<a name="l02298"></a>02298 <a class="code" href="classot_1_1DA.html#7663ba260ee97dcc80c083c9ab841f49">m_uiElementEnd</a> = <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a> + m_uiElementSize;
<a name="l02299"></a>02299 
<a name="l02300"></a>02300 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02301"></a>02301 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02302"></a>02302 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02303"></a>02303   std::cout&lt;&lt;std::endl;
<a name="l02304"></a>02304   std::cout&lt;&lt;<span class="stringliteral">"All Counters Reset."</span>&lt;&lt;std::endl;
<a name="l02305"></a>02305   std::cout&lt;&lt;std::endl;
<a name="l02306"></a>02306 }
<a name="l02307"></a>02307 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02308"></a>02308 <span class="preprocessor">#endif</span>
<a name="l02309"></a>02309 <span class="preprocessor"></span>
<a name="l02310"></a>02310 std::vector&lt;unsigned int&gt; nlistNew(8*nelem);
<a name="l02311"></a>02311 std::vector&lt;unsigned char&gt; hnMaskNew(nelem);
<a name="l02312"></a>02312 
<a name="l02313"></a>02313 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02314"></a>02314 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02315"></a>02315 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02316"></a>02316   std::cout&lt;&lt;std::endl;
<a name="l02317"></a>02317   std::cout&lt;&lt;<span class="stringliteral">"Allocated memory for the new nlist and masks."</span>&lt;&lt;std::endl;
<a name="l02318"></a>02318   std::cout&lt;&lt;std::endl;
<a name="l02319"></a>02319 }
<a name="l02320"></a>02320 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02321"></a>02321 <span class="preprocessor">#endif</span>
<a name="l02322"></a>02322 <span class="preprocessor"></span>
<a name="l02323"></a>02323 <span class="comment">// correct nLists ...</span>
<a name="l02324"></a>02324 <span class="comment">// The loop is in the order of the old Indices ...</span>
<a name="l02325"></a>02325 <span class="comment">//The first time only the nlist of preghosts are corrected.</span>
<a name="l02326"></a>02326 <span class="comment">//Since, the nlist of own elements are not built in the first</span>
<a name="l02327"></a>02327 <span class="comment">//outer-loop (numFullLoopCtr).</span>
<a name="l02328"></a>02328 <span class="comment">//The second time the preghosts will be visited once again.</span>
<a name="l02329"></a>02329 <span class="comment">//Skip correction of nlist for Foreigns </span>
<a name="l02330"></a>02330 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; iLoopEnd; i++) {
<a name="l02331"></a>02331 #ifdef __DEBUG_DA_NLIST__
<a name="l02332"></a>02332   assert(i &lt; oldToNew.size() );
<a name="l02333"></a>02333   assert(oldToNew[i] &lt; nelem);
<a name="l02334"></a>02334   <span class="keywordflow">if</span>( numFullLoopCtr == 0 ) {
<a name="l02335"></a>02335     assert(oldToNew[i] &lt; <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>);
<a name="l02336"></a>02336   }
<a name="l02337"></a>02337   assert( (2*i+1) &lt; <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>.size() );
<a name="l02338"></a>02338 <span class="preprocessor">#endif</span>
<a name="l02339"></a>02339 <span class="preprocessor"></span>
<a name="l02340"></a>02340   hnMaskNew[oldToNew[i]] = <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i + 1];
<a name="l02341"></a>02341 
<a name="l02342"></a>02342   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i+1] == <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) {
<a name="l02343"></a>02343     <span class="keywordflow">continue</span>;
<a name="l02344"></a>02344   }
<a name="l02345"></a>02345 
<a name="l02346"></a>02346   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iiOld = 8*i;
<a name="l02347"></a>02347   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> iiNew = 8*oldToNew[i];
<a name="l02348"></a>02348   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;8; j++) {
<a name="l02349"></a>02349     <span class="comment">// remap ...</span>
<a name="l02350"></a>02350 #ifdef __DEBUG_DA_NLIST__
<a name="l02351"></a>02351     assert( (iiNew + j) &lt; nlistNew.size() );
<a name="l02352"></a>02352     assert( (iiOld + j) &lt; nlist.size()  );
<a name="l02353"></a>02353     <span class="keywordflow">if</span>( nlist[iiOld + j] &gt;= oldToNew.size() ) {
<a name="l02354"></a>02354       std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">": oldToNew.size(): "</span>&lt;&lt;oldToNew.size()&lt;&lt;<span class="stringliteral">" nlist[8*"</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"+"</span>&lt;&lt;j&lt;&lt;<span class="stringliteral">"]: "</span>&lt;&lt;nlist[iiOld+j]&lt;&lt;std::endl 
<a name="l02355"></a>02355                                                        &lt;&lt;<span class="stringliteral">"oldToNew["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;oldToNew[i]&lt;&lt;<span class="stringliteral">" elem: "</span>&lt;&lt;in[oldToNew[i]]&lt;&lt;std::endl;                                        
<a name="l02356"></a>02356       assert(<span class="keyword">false</span>);
<a name="l02357"></a>02357     }
<a name="l02358"></a>02358 <span class="preprocessor">#endif</span>
<a name="l02359"></a>02359 <span class="preprocessor"></span>
<a name="l02360"></a>02360     nlistNew[iiNew + j] = oldToNew[ nlist[iiOld + j] ];
<a name="l02361"></a>02361   }<span class="comment">//end for j</span>
<a name="l02362"></a>02362 }<span class="comment">//end for i</span>
<a name="l02363"></a>02363 
<a name="l02364"></a>02364 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02365"></a>02365 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02366"></a>02366 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02367"></a>02367   std::cout&lt;&lt;std::endl;
<a name="l02368"></a>02368   std::cout&lt;&lt;<span class="stringliteral">"Corrected Nlist."</span>&lt;&lt;std::endl;
<a name="l02369"></a>02369   std::cout&lt;&lt;std::endl;
<a name="l02370"></a>02370 }
<a name="l02371"></a>02371 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02372"></a>02372 <span class="preprocessor">#endif</span>
<a name="l02373"></a>02373 <span class="preprocessor"></span>
<a name="l02374"></a>02374 <span class="comment">//Replace the old lists by the new lists and clear the new</span>
<a name="l02375"></a>02375 <span class="comment">//lists...</span>
<a name="l02376"></a>02376 
<a name="l02377"></a>02377 <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>.resize(2*nelem);
<a name="l02378"></a>02378 <span class="keywordflow">if</span>(numFullLoopCtr) {
<a name="l02379"></a>02379   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nelem; i++) {
<a name="l02380"></a>02380     <span class="keywordflow">if</span>(in[i].getWeight() == 0) {
<a name="l02381"></a>02381       <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i + 1] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>;
<a name="l02382"></a>02382     }<span class="keywordflow">else</span> {
<a name="l02383"></a>02383       <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i + 1] = hnMaskNew[i];
<a name="l02384"></a>02384     }
<a name="l02385"></a>02385   }<span class="comment">//end for i</span>
<a name="l02386"></a>02386 }<span class="keywordflow">else</span> {
<a name="l02387"></a>02387   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>; i++) {
<a name="l02388"></a>02388     <span class="keywordflow">if</span>(in[i].getWeight() == 0) {
<a name="l02389"></a>02389       <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i + 1] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>;
<a name="l02390"></a>02390     }<span class="keywordflow">else</span> {
<a name="l02391"></a>02391       <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i + 1] = hnMaskNew[i];
<a name="l02392"></a>02392     }
<a name="l02393"></a>02393   }<span class="comment">//end for i</span>
<a name="l02394"></a>02394 }
<a name="l02395"></a>02395 hnMaskNew.clear();
<a name="l02396"></a>02396 
<a name="l02397"></a>02397 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
<a name="l02398"></a>02398   in[i].setWeight(1);
<a name="l02399"></a>02399 }
<a name="l02400"></a>02400 
<a name="l02401"></a>02401 nlist = nlistNew;
<a name="l02402"></a>02402 nlistNew.clear();
<a name="l02403"></a>02403 
<a name="l02404"></a>02404 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02405"></a>02405 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02406"></a>02406 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02407"></a>02407   std::cout&lt;&lt;std::endl;
<a name="l02408"></a>02408   std::cout&lt;&lt;<span class="stringliteral">"Corrected HnMasks and Nlists."</span>&lt;&lt;std::endl;
<a name="l02409"></a>02409   std::cout&lt;&lt;std::endl;
<a name="l02410"></a>02410 }
<a name="l02411"></a>02411 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02412"></a>02412 <span class="preprocessor">#endif</span>
<a name="l02413"></a>02413 <span class="preprocessor"></span>
<a name="l02414"></a>02414 <span class="comment">// Merge scattermap and scnScatterMap</span>
<a name="l02415"></a>02415 std::vector&lt;unsigned int&gt;               tmpScatterMap;
<a name="l02416"></a>02416 std::vector&lt;unsigned int&gt;               tmpSendProcs;
<a name="l02417"></a>02417 std::vector&lt;unsigned int&gt;               tmpSendCounts;
<a name="l02418"></a>02418 std::vector&lt;unsigned int&gt;               tmpRecvProcs;
<a name="l02419"></a>02419 std::vector&lt;unsigned int&gt;               tmpRecvCounts;
<a name="l02420"></a>02420 
<a name="l02421"></a>02421 <span class="comment">//Assumes primary and secondary lists to be sorted independently. the</span>
<a name="l02422"></a>02422 <span class="comment">//result will be sorted.</span>
<a name="l02423"></a>02423 <span class="comment">//There is a 1-1 mapping between counts and procs.</span>
<a name="l02424"></a>02424 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primaryCnt = 0;
<a name="l02425"></a>02425 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> secondaryCnt = 0;
<a name="l02426"></a>02426 <span class="keywordflow">while</span>( (primaryCnt &lt; m_uipSendProcs.size()) &amp;&amp; (secondaryCnt &lt; ScndSendProcs.size()) ) {
<a name="l02427"></a>02427   <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &lt; ScndSendProcs[secondaryCnt] ) {
<a name="l02428"></a>02428     tmpSendProcs.push_back(m_uipSendProcs[primaryCnt]);
<a name="l02429"></a>02429     tmpSendCounts.push_back(<a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[primaryCnt]);
<a name="l02430"></a>02430     primaryCnt++;
<a name="l02431"></a>02431   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &gt; ScndSendProcs[secondaryCnt] ) {
<a name="l02432"></a>02432     tmpSendProcs.push_back(ScndSendProcs[secondaryCnt]);
<a name="l02433"></a>02433     tmpSendCounts.push_back(ScndSendCounts[secondaryCnt]);
<a name="l02434"></a>02434     secondaryCnt++;
<a name="l02435"></a>02435   }<span class="keywordflow">else</span> {
<a name="l02436"></a>02436     <span class="comment">//if both are equal select p only from one. Arbitrarily, the default</span>
<a name="l02437"></a>02437     <span class="comment">//is picked as primary</span>
<a name="l02438"></a>02438     tmpSendProcs.push_back(m_uipSendProcs[primaryCnt]);
<a name="l02439"></a>02439     <span class="comment">//Sum the counts from the primary and secondary...</span>
<a name="l02440"></a>02440     tmpSendCounts.push_back(<a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[primaryCnt] + ScndSendCounts[secondaryCnt]);
<a name="l02441"></a>02441     primaryCnt++;
<a name="l02442"></a>02442     <span class="comment">//skip secondary</span>
<a name="l02443"></a>02443     secondaryCnt++;
<a name="l02444"></a>02444   }
<a name="l02445"></a>02445 }<span class="comment">//end while</span>
<a name="l02446"></a>02446 
<a name="l02447"></a>02447 <span class="comment">//only primary remains</span>
<a name="l02448"></a>02448 <span class="keywordflow">while</span>( primaryCnt &lt; m_uipSendProcs.size() ) {
<a name="l02449"></a>02449   tmpSendProcs.push_back(m_uipSendProcs[primaryCnt]);
<a name="l02450"></a>02450   tmpSendCounts.push_back(<a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[primaryCnt]);
<a name="l02451"></a>02451   primaryCnt++;
<a name="l02452"></a>02452 }
<a name="l02453"></a>02453 
<a name="l02454"></a>02454 <span class="comment">//only secondary remains</span>
<a name="l02455"></a>02455 <span class="keywordflow">while</span>( secondaryCnt &lt; ScndSendProcs.size() ) {
<a name="l02456"></a>02456   tmpSendProcs.push_back(ScndSendProcs[secondaryCnt]);
<a name="l02457"></a>02457   tmpSendCounts.push_back(ScndSendCounts[secondaryCnt]);
<a name="l02458"></a>02458   secondaryCnt++;
<a name="l02459"></a>02459 }
<a name="l02460"></a>02460 
<a name="l02461"></a>02461 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02462"></a>02462 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02463"></a>02463 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(m_uipSendProcs) );
<a name="l02464"></a>02464 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(ScndSendProcs) );
<a name="l02465"></a>02465 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(tmpSendProcs) );
<a name="l02466"></a>02466 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uipSendProcs.size(); i++) {
<a name="l02467"></a>02467   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" --&gt; "</span>&lt;&lt;m_uipSendProcs[i]&lt;&lt;<span class="stringliteral">" (P) "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[i]&lt;&lt;std::endl;
<a name="l02468"></a>02468 }
<a name="l02469"></a>02469 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" P-Scatter: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>.size()&lt;&lt;std::endl;
<a name="l02470"></a>02470 assert( m_uipSendProcs.size() == <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>.size() );
<a name="l02471"></a>02471 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02472"></a>02472 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ScndSendProcs.size(); i++) {
<a name="l02473"></a>02473   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" --&gt; "</span>&lt;&lt;ScndSendProcs[i]&lt;&lt;<span class="stringliteral">" (S) "</span>&lt;&lt;ScndSendCounts[i]&lt;&lt;std::endl;
<a name="l02474"></a>02474 }
<a name="l02475"></a>02475 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" S-Scatter: "</span>&lt;&lt;ScndScatterMap.size()&lt;&lt;std::endl;
<a name="l02476"></a>02476 assert( ScndSendProcs.size() == ScndSendCounts.size() );
<a name="l02477"></a>02477 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02478"></a>02478 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; tmpSendProcs.size(); i++) {
<a name="l02479"></a>02479   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" --&gt; "</span>&lt;&lt;tmpSendProcs[i]&lt;&lt;<span class="stringliteral">" (T) "</span>&lt;&lt;tmpSendCounts[i]&lt;&lt;std::endl;
<a name="l02480"></a>02480 }
<a name="l02481"></a>02481 assert( tmpSendProcs.size() == tmpSendCounts.size() );
<a name="l02482"></a>02482 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02483"></a>02483 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02484"></a>02484   std::cout&lt;&lt;std::endl;
<a name="l02485"></a>02485   std::cout&lt;&lt;<span class="stringliteral">"Corrected SendCnts and SendProcs."</span>&lt;&lt;std::endl;
<a name="l02486"></a>02486   std::cout&lt;&lt;std::endl;
<a name="l02487"></a>02487 }
<a name="l02488"></a>02488 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02489"></a>02489 <span class="preprocessor">#endif</span>
<a name="l02490"></a>02490 <span class="preprocessor"></span>
<a name="l02491"></a>02491 <span class="comment">//Assumes primary and secondary Scattermaps to be sorted</span>
<a name="l02492"></a>02492 <span class="comment">//independently for each processors portion. the</span>
<a name="l02493"></a>02493 <span class="comment">//result will also be sorted in chunks.</span>
<a name="l02494"></a>02494 primaryCnt = 0;
<a name="l02495"></a>02495 secondaryCnt = 0;
<a name="l02496"></a>02496 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> primarySz = 0;
<a name="l02497"></a>02497 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> secondarySz = 0;
<a name="l02498"></a>02498 <span class="keywordflow">while</span>( (primaryCnt &lt; m_uipSendProcs.size()) &amp;&amp; (secondaryCnt &lt; ScndSendProcs.size()) ) {
<a name="l02499"></a>02499   <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &lt; ScndSendProcs[secondaryCnt] ) {
<a name="l02500"></a>02500     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numSent = 0;
<a name="l02501"></a>02501     <span class="keywordflow">while</span>( numSent &lt; <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[primaryCnt] ) {
<a name="l02502"></a>02502       tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz++]]);
<a name="l02503"></a>02503       numSent++;
<a name="l02504"></a>02504     }
<a name="l02505"></a>02505     primaryCnt++;
<a name="l02506"></a>02506   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( m_uipSendProcs[primaryCnt] &gt; ScndSendProcs[secondaryCnt] ) {
<a name="l02507"></a>02507     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numSent = 0;
<a name="l02508"></a>02508     <span class="keywordflow">while</span>( numSent &lt; ScndSendCounts[secondaryCnt] ) {
<a name="l02509"></a>02509       tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
<a name="l02510"></a>02510       numSent++;
<a name="l02511"></a>02511     }
<a name="l02512"></a>02512     secondaryCnt++;
<a name="l02513"></a>02513   }<span class="keywordflow">else</span> {
<a name="l02514"></a>02514     <span class="comment">//Both primary and secondary are sending to the same processor so</span>
<a name="l02515"></a>02515     <span class="comment">//merge.</span>
<a name="l02516"></a>02516     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nP = 0;
<a name="l02517"></a>02517     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nS = 0;
<a name="l02518"></a>02518 
<a name="l02519"></a>02519     <span class="comment">//Both are not over.</span>
<a name="l02520"></a>02520     <span class="keywordflow">while</span>( ( nP &lt; <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[primaryCnt] ) &amp;&amp; ( nS &lt; ScndSendCounts[secondaryCnt] ) ) {
<a name="l02521"></a>02521 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02522"></a>02522 <span class="preprocessor"></span>      <span class="comment">//The same octant can not be sent to the same processor in both</span>
<a name="l02523"></a>02523       <span class="comment">//the primary and secondary lists.</span>
<a name="l02524"></a>02524       <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz] == ScndScatterMap[secondarySz] ) {
<a name="l02525"></a>02525         std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" is sending "</span>&lt;&lt;
<a name="l02526"></a>02526           in[oldToNew[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz]]]&lt;&lt;<span class="stringliteral">" to "</span>
<a name="l02527"></a>02527           &lt;&lt;m_uipSendProcs[primaryCnt]&lt;&lt;<span class="stringliteral">" in both primary and secondary."</span>&lt;&lt;std::endl;
<a name="l02528"></a>02528         assert(<span class="keyword">false</span>);
<a name="l02529"></a>02529       }
<a name="l02530"></a>02530 <span class="preprocessor">#endif</span>
<a name="l02531"></a>02531 <span class="preprocessor"></span>      <span class="comment">//Both primary and secondary can only send own elements, the</span>
<a name="l02532"></a>02532       <span class="comment">//relative ordering of the own elements in the old and new</span>
<a name="l02533"></a>02533       <span class="comment">//ordering should be the same.</span>
<a name="l02534"></a>02534       <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz] &lt; ScndScatterMap[secondarySz] ) {
<a name="l02535"></a>02535 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02536"></a>02536 <span class="preprocessor"></span>        assert( oldToNew[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz]] &lt; oldToNew[ScndScatterMap[secondarySz]] );
<a name="l02537"></a>02537 <span class="preprocessor">#endif</span>
<a name="l02538"></a>02538 <span class="preprocessor"></span>        tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz++]]);
<a name="l02539"></a>02539         nP++;
<a name="l02540"></a>02540       }<span class="keywordflow">else</span> {
<a name="l02541"></a>02541 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02542"></a>02542 <span class="preprocessor"></span>        assert( oldToNew[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz]] &gt; oldToNew[ScndScatterMap[secondarySz]] );
<a name="l02543"></a>02543 <span class="preprocessor">#endif</span>
<a name="l02544"></a>02544 <span class="preprocessor"></span>        tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
<a name="l02545"></a>02545         nS++;
<a name="l02546"></a>02546       }
<a name="l02547"></a>02547     }
<a name="l02548"></a>02548 
<a name="l02549"></a>02549     <span class="comment">//Only primary remains</span>
<a name="l02550"></a>02550     <span class="keywordflow">while</span>( nP &lt; <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[primaryCnt] ) {
<a name="l02551"></a>02551       tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz++]]);
<a name="l02552"></a>02552       nP++;
<a name="l02553"></a>02553     }
<a name="l02554"></a>02554 
<a name="l02555"></a>02555     <span class="comment">//only secondary remains</span>
<a name="l02556"></a>02556     <span class="keywordflow">while</span>( nS &lt; ScndSendCounts[secondaryCnt] ) {
<a name="l02557"></a>02557       tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
<a name="l02558"></a>02558       nS++;
<a name="l02559"></a>02559     }
<a name="l02560"></a>02560 
<a name="l02561"></a>02561     primaryCnt++;
<a name="l02562"></a>02562     secondaryCnt++;
<a name="l02563"></a>02563   }<span class="comment">//end if-else</span>
<a name="l02564"></a>02564 }<span class="comment">//end while</span>
<a name="l02565"></a>02565 
<a name="l02566"></a>02566 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02567"></a>02567 <span class="preprocessor"></span><span class="comment">//ScatterMaps and Procs must finish together.</span>
<a name="l02568"></a>02568 <span class="keywordflow">if</span>( primarySz &lt; <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>.size() ) {
<a name="l02569"></a>02569   assert(primaryCnt &lt; m_uipSendProcs.size());
<a name="l02570"></a>02570 }<span class="keywordflow">else</span> {
<a name="l02571"></a>02571   assert(primaryCnt == m_uipSendProcs.size());
<a name="l02572"></a>02572 }
<a name="l02573"></a>02573 
<a name="l02574"></a>02574 <span class="keywordflow">if</span>( secondarySz &lt; ScndScatterMap.size() ) {
<a name="l02575"></a>02575   assert(secondaryCnt &lt; ScndSendProcs.size());
<a name="l02576"></a>02576 }<span class="keywordflow">else</span> {
<a name="l02577"></a>02577   assert(secondaryCnt == ScndSendProcs.size());
<a name="l02578"></a>02578 }
<a name="l02579"></a>02579 <span class="preprocessor">#endif</span>
<a name="l02580"></a>02580 <span class="preprocessor"></span>
<a name="l02581"></a>02581 <span class="comment">//Only primary remains.</span>
<a name="l02582"></a>02582 <span class="keywordflow">while</span>( primarySz &lt; <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>.size() ) {
<a name="l02583"></a>02583   tmpScatterMap.push_back(oldToNew[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[primarySz++]]);
<a name="l02584"></a>02584 }
<a name="l02585"></a>02585 
<a name="l02586"></a>02586 <span class="comment">//Only secondary remains.</span>
<a name="l02587"></a>02587 <span class="keywordflow">while</span>( secondarySz &lt; ScndScatterMap.size() ) {
<a name="l02588"></a>02588   tmpScatterMap.push_back(oldToNew[ScndScatterMap[secondarySz++]]);
<a name="l02589"></a>02589 }
<a name="l02590"></a>02590 
<a name="l02591"></a>02591 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02592"></a>02592 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02593"></a>02593 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02594"></a>02594   std::cout&lt;&lt;std::endl;
<a name="l02595"></a>02595   std::cout&lt;&lt;<span class="stringliteral">"Merged Primary and Secondary Scatter Maps."</span>&lt;&lt;std::endl;
<a name="l02596"></a>02596   std::cout&lt;&lt;std::endl;
<a name="l02597"></a>02597 }
<a name="l02598"></a>02598 
<a name="l02599"></a>02599 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" pScatterSz: "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>.size()&lt;&lt;<span class="stringliteral">" sScatterSz: "</span>
<a name="l02600"></a>02600 &lt;&lt;ScndScatterMap.size()&lt;&lt;<span class="stringliteral">" tScatterSz: "</span>&lt;&lt;tmpScatterMap.size()&lt;&lt;std::endl;
<a name="l02601"></a>02601 
<a name="l02602"></a>02602 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_pCnt = 0;
<a name="l02603"></a>02603 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_sCnt = 0;
<a name="l02604"></a>02604 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_tCnt = 0;
<a name="l02605"></a>02605 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_pOff = 0;
<a name="l02606"></a>02606 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_sOff = 0;
<a name="l02607"></a>02607 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> debug_tOff = 0;
<a name="l02608"></a>02608 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i&lt; m_iNpesActive; i++) {
<a name="l02609"></a>02609   std::vector&lt;unsigned int&gt;  pSctList;
<a name="l02610"></a>02610   std::vector&lt;unsigned int&gt;  sSctList;
<a name="l02611"></a>02611   std::vector&lt;unsigned int&gt;  tSctList;
<a name="l02612"></a>02612   <span class="keywordflow">if</span>( (debug_pCnt &lt; m_uipSendProcs.size()) &amp;&amp; (m_uipSendProcs[debug_pCnt] == i) ) {
<a name="l02613"></a>02613     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[debug_pCnt]; j++) {
<a name="l02614"></a>02614       pSctList.push_back(<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[debug_pOff + j]);
<a name="l02615"></a>02615     }
<a name="l02616"></a>02616     debug_pOff += m_uipSendCounts[debug_pCnt];
<a name="l02617"></a>02617     debug_pCnt++;
<a name="l02618"></a>02618   }
<a name="l02619"></a>02619   <span class="keywordflow">if</span>( (debug_sCnt &lt; ScndSendProcs.size()) &amp;&amp; (ScndSendProcs[debug_sCnt] == i) ) {
<a name="l02620"></a>02620     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; ScndSendCounts[debug_sCnt]; j++) {
<a name="l02621"></a>02621       sSctList.push_back(ScndScatterMap[debug_sOff + j]);
<a name="l02622"></a>02622     }
<a name="l02623"></a>02623     debug_sOff += ScndSendCounts[debug_sCnt];
<a name="l02624"></a>02624     debug_sCnt++;
<a name="l02625"></a>02625   }
<a name="l02626"></a>02626   <span class="keywordflow">if</span>( (debug_tCnt &lt; tmpSendProcs.size()) &amp;&amp; (tmpSendProcs[debug_tCnt] == i) ) {
<a name="l02627"></a>02627     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; tmpSendCounts[debug_tCnt]; j++) {
<a name="l02628"></a>02628       tSctList.push_back(tmpScatterMap[debug_tOff + j]);
<a name="l02629"></a>02629     }
<a name="l02630"></a>02630     debug_tOff += tmpSendCounts[debug_tCnt];
<a name="l02631"></a>02631     debug_tCnt++;
<a name="l02632"></a>02632   }
<a name="l02633"></a>02633 
<a name="l02634"></a>02634   assert( tSctList.size() == (pSctList.size() + sSctList.size()) );
<a name="l02635"></a>02635 
<a name="l02636"></a>02636   assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(pSctList) );
<a name="l02637"></a>02637   assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(sSctList) );
<a name="l02638"></a>02638 
<a name="l02639"></a>02639   <span class="comment">//Explicitly merge p and s into tt.</span>
<a name="l02640"></a>02640   std::vector&lt;unsigned int&gt; ttList;
<a name="l02641"></a>02641   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; sSctList.size(); j++) {
<a name="l02642"></a>02642     ttList.push_back(oldToNew[sSctList[j]]);
<a name="l02643"></a>02643   }
<a name="l02644"></a>02644   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; pSctList.size(); j++) {
<a name="l02645"></a>02645     ttList.push_back(oldToNew[pSctList[j]]);
<a name="l02646"></a>02646   }
<a name="l02647"></a>02647 
<a name="l02648"></a>02648   <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">sort</a>(ttList.begin(),ttList.end());
<a name="l02649"></a>02649   assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(ttList) );
<a name="l02650"></a>02650 
<a name="l02651"></a>02651   <span class="comment">// was assert(ttList == tSctList);</span>
<a name="l02652"></a>02652   assert(ttList.size() == tSctList.size());
<a name="l02653"></a>02653   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; ttList.size(); j++) {
<a name="l02654"></a>02654     <span class="keywordflow">if</span> (ttList[j] != tSctList[j]) {
<a name="l02655"></a>02655       std::cout &lt;&lt; <a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a> &lt;&lt; <span class="stringliteral">": MergeFailed at "</span> &lt;&lt; j &lt;&lt; std::endl;
<a name="l02656"></a>02656       std::cout &lt;&lt; ttList[j] &lt;&lt; <span class="stringliteral">" != "</span>  &lt;&lt; tSctList[j] &lt;&lt; std::endl;
<a name="l02657"></a>02657       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; pSctList.size(); k++) {
<a name="l02658"></a>02658         std::cout &lt;&lt; ttList[k] &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; tSctList[k]
<a name="l02659"></a>02659           &lt;&lt; <span class="stringliteral">", "</span> &lt;&lt; pSctList[k] &lt;&lt; std::endl;
<a name="l02660"></a>02660       }
<a name="l02661"></a>02661       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; sSctList.size(); k++) {
<a name="l02662"></a>02662         std::cout &lt;&lt; sSctList[k] &lt;&lt; std::endl;
<a name="l02663"></a>02663       }
<a name="l02664"></a>02664       assert(<span class="keyword">false</span>);
<a name="l02665"></a>02665     }
<a name="l02666"></a>02666   }<span class="comment">//end for j</span>
<a name="l02667"></a>02667 
<a name="l02668"></a>02668   ttList.clear();
<a name="l02669"></a>02669   pSctList.clear();
<a name="l02670"></a>02670   sSctList.clear();
<a name="l02671"></a>02671   tSctList.clear();
<a name="l02672"></a>02672 }<span class="comment">//end for i</span>
<a name="l02673"></a>02673 
<a name="l02674"></a>02674 assert( debug_pCnt == m_uipSendProcs.size() );
<a name="l02675"></a>02675 assert( debug_sCnt == ScndSendProcs.size() );
<a name="l02676"></a>02676 assert( debug_tCnt == tmpSendProcs.size() );
<a name="l02677"></a>02677 
<a name="l02678"></a>02678 assert( tmpScatterMap.size() == (<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>.size() + ScndScatterMap.size()) );
<a name="l02679"></a>02679 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02680"></a>02680 <span class="preprocessor">#endif</span>
<a name="l02681"></a>02681 <span class="preprocessor"></span>
<a name="l02682"></a>02682 oldToNew.clear();
<a name="l02683"></a>02683 
<a name="l02684"></a>02684 primaryCnt = 0;
<a name="l02685"></a>02685 secondaryCnt = 0;
<a name="l02686"></a>02686 <span class="keywordflow">while</span>( (primaryCnt &lt; <a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>.size()) &amp;&amp; (secondaryCnt &lt; ScndRecvProcs.size()) ) {
<a name="l02687"></a>02687   <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[primaryCnt] &lt; ScndRecvProcs[secondaryCnt] ) {
<a name="l02688"></a>02688     tmpRecvProcs.push_back(<a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[primaryCnt]);
<a name="l02689"></a>02689     tmpRecvCounts.push_back(<a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>[primaryCnt]);
<a name="l02690"></a>02690     primaryCnt++;
<a name="l02691"></a>02691   }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( <a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[primaryCnt] &gt; ScndRecvProcs[secondaryCnt] ) {
<a name="l02692"></a>02692     tmpRecvProcs.push_back(ScndRecvProcs[secondaryCnt]);
<a name="l02693"></a>02693     tmpRecvCounts.push_back(ScndRecvCounts[secondaryCnt]);
<a name="l02694"></a>02694     secondaryCnt++;
<a name="l02695"></a>02695   }<span class="keywordflow">else</span> {
<a name="l02696"></a>02696     <span class="comment">//if both are equal select only from primary</span>
<a name="l02697"></a>02697     tmpRecvProcs.push_back(<a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[primaryCnt]);
<a name="l02698"></a>02698     tmpRecvCounts.push_back(<a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>[primaryCnt] + ScndRecvCounts[secondaryCnt]);
<a name="l02699"></a>02699     primaryCnt++;
<a name="l02700"></a>02700     <span class="comment">//skip secondary</span>
<a name="l02701"></a>02701     secondaryCnt++;
<a name="l02702"></a>02702   }
<a name="l02703"></a>02703 }
<a name="l02704"></a>02704 
<a name="l02705"></a>02705 <span class="keywordflow">while</span>( primaryCnt &lt; <a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>.size() ) {
<a name="l02706"></a>02706   tmpRecvProcs.push_back(<a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[primaryCnt]);
<a name="l02707"></a>02707   tmpRecvCounts.push_back(<a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>[primaryCnt]);
<a name="l02708"></a>02708   primaryCnt++;
<a name="l02709"></a>02709 }
<a name="l02710"></a>02710 
<a name="l02711"></a>02711 <span class="keywordflow">while</span>( secondaryCnt &lt; ScndRecvProcs.size() ) {
<a name="l02712"></a>02712   tmpRecvProcs.push_back(ScndRecvProcs[secondaryCnt]);
<a name="l02713"></a>02713   tmpRecvCounts.push_back(ScndRecvCounts[secondaryCnt]);
<a name="l02714"></a>02714   secondaryCnt++;
<a name="l02715"></a>02715 }
<a name="l02716"></a>02716 
<a name="l02717"></a>02717 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02718"></a>02718 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02719"></a>02719 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>) );
<a name="l02720"></a>02720 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(ScndRecvProcs) );
<a name="l02721"></a>02721 assert( seq::test::isUniqueAndSorted&lt;unsigned int&gt;(tmpRecvProcs) );
<a name="l02722"></a>02722 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uipRecvProcs.size(); i++) {
<a name="l02723"></a>02723   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" &lt;-- "</span>&lt;&lt;m_uipRecvProcs[i]&lt;&lt;<span class="stringliteral">" (P) "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>[i]&lt;&lt;std::endl;
<a name="l02724"></a>02724 }
<a name="l02725"></a>02725 assert( m_uipRecvProcs.size() == <a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>.size() );
<a name="l02726"></a>02726 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02727"></a>02727 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; ScndRecvProcs.size(); i++) {
<a name="l02728"></a>02728   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" &lt;-- "</span>&lt;&lt;ScndRecvProcs[i]&lt;&lt;<span class="stringliteral">" (S) "</span>&lt;&lt;ScndRecvCounts[i]&lt;&lt;std::endl;
<a name="l02729"></a>02729 }
<a name="l02730"></a>02730 assert( ScndRecvProcs.size() == ScndRecvCounts.size() );
<a name="l02731"></a>02731 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02732"></a>02732 <span class="keywordflow">for</span>( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; tmpRecvProcs.size(); i++) {
<a name="l02733"></a>02733   std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" &lt;-- "</span>&lt;&lt;tmpRecvProcs[i]&lt;&lt;<span class="stringliteral">" (T) "</span>&lt;&lt;tmpRecvCounts[i]&lt;&lt;std::endl;
<a name="l02734"></a>02734 }
<a name="l02735"></a>02735 assert( tmpRecvProcs.size() == tmpRecvCounts.size() );
<a name="l02736"></a>02736 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02737"></a>02737 <span class="preprocessor">#endif</span>
<a name="l02738"></a>02738 <span class="preprocessor"></span>
<a name="l02739"></a>02739 ScndScatterMap.clear();
<a name="l02740"></a>02740 ScndSendProcs.clear();
<a name="l02741"></a>02741 ScndSendCounts.clear();
<a name="l02742"></a>02742 ScndRecvProcs.clear();
<a name="l02743"></a>02743 ScndRecvCounts.clear();
<a name="l02744"></a>02744 
<a name="l02745"></a>02745 <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>  =  tmpScatterMap;
<a name="l02746"></a>02746 m_uipSendProcs   =  tmpSendProcs;
<a name="l02747"></a>02747 <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>  =  tmpSendCounts;
<a name="l02748"></a>02748 m_uipRecvProcs   =  tmpRecvProcs;
<a name="l02749"></a>02749 <a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>  =  tmpRecvCounts;
<a name="l02750"></a>02750 
<a name="l02751"></a>02751 tmpScatterMap.clear();
<a name="l02752"></a>02752 tmpSendProcs.clear();
<a name="l02753"></a>02753 tmpSendCounts.clear();
<a name="l02754"></a>02754 tmpRecvProcs.clear();
<a name="l02755"></a>02755 tmpRecvCounts.clear();
<a name="l02756"></a>02756 
<a name="l02757"></a>02757 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02758"></a>02758 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02759"></a>02759 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02760"></a>02760   std::cout&lt;&lt;std::endl;
<a name="l02761"></a>02761   std::cout&lt;&lt;<span class="stringliteral">"Corrected RecvCounts and RecvProcs."</span>&lt;&lt;std::endl;
<a name="l02762"></a>02762   std::cout&lt;&lt;std::endl;
<a name="l02763"></a>02763 }
<a name="l02764"></a>02764 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02765"></a>02765 <span class="preprocessor">#endif</span>
<a name="l02766"></a>02766 <span class="preprocessor"></span>
<a name="l02767"></a>02767 }<span class="comment">//end for numFullLoopCtr</span>
<a name="l02768"></a>02768 
<a name="l02769"></a>02769 <span class="comment">// Compute and store the new offsets ...</span>
<a name="l02770"></a>02770 <a class="code" href="classot_1_1DA.html#6dcea85eb0519fe1a92dd0d325ddf2f8">m_uipSendOffsets</a>.resize(<a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>.size());
<a name="l02771"></a>02771 <a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>.resize(<a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>.size());
<a name="l02772"></a>02772 
<a name="l02773"></a>02773 <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>.size() ) {
<a name="l02774"></a>02774   <a class="code" href="classot_1_1DA.html#6dcea85eb0519fe1a92dd0d325ddf2f8">m_uipSendOffsets</a>[0] = 0;
<a name="l02775"></a>02775   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i &lt; <a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>.size(); i++) {
<a name="l02776"></a>02776     <a class="code" href="classot_1_1DA.html#6dcea85eb0519fe1a92dd0d325ddf2f8">m_uipSendOffsets</a>[i] = (<a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[i-1] + <a class="code" href="classot_1_1DA.html#6dcea85eb0519fe1a92dd0d325ddf2f8">m_uipSendOffsets</a>[i-1]);
<a name="l02777"></a>02777   }
<a name="l02778"></a>02778 }
<a name="l02779"></a>02779 
<a name="l02780"></a>02780 <span class="keywordflow">if</span> ( <a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>.size() ) {
<a name="l02781"></a>02781   <span class="keywordtype">bool</span> adjustedAlready = <span class="keyword">false</span>;
<a name="l02782"></a>02782   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[0] &lt; static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>)) {
<a name="l02783"></a>02783     <a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[0] = 0;
<a name="l02784"></a>02784   }<span class="keywordflow">else</span> {
<a name="l02785"></a>02785     <a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[0] = <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>;
<a name="l02786"></a>02786     adjustedAlready = <span class="keyword">true</span>;
<a name="l02787"></a>02787   }
<a name="l02788"></a>02788   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=1; i &lt; <a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>.size(); i++) {
<a name="l02789"></a>02789     <span class="keywordflow">if</span>( (<a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[i] &lt; m_iRankActive) || adjustedAlready ) {
<a name="l02790"></a>02790       <a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[i] = (<a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>[i-1] + <a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[i-1]);
<a name="l02791"></a>02791     }<span class="keywordflow">else</span> {
<a name="l02792"></a>02792       <a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[i] = <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>;
<a name="l02793"></a>02793       adjustedAlready = <span class="keyword">true</span>;
<a name="l02794"></a>02794     }
<a name="l02795"></a>02795   }<span class="comment">//end for i</span>
<a name="l02796"></a>02796 }
<a name="l02797"></a>02797 
<a name="l02798"></a>02798 <span class="comment">//Store a copy of the original scattermap first. This will be required for</span>
<a name="l02799"></a>02799 <span class="comment">//communicating ghost elements. Since there are no post-ghost element, we only</span>
<a name="l02800"></a>02800 <span class="comment">//need to send to processors with ranks greater than my rank.</span>
<a name="l02801"></a>02801 <a class="code" href="classot_1_1DA.html#5c02b1aa2478981e3dd9975468ee5db2">m_uipElemScatterMap</a>.clear();
<a name="l02802"></a>02802 <a class="code" href="classot_1_1DA.html#826f24205cbdbb900dc156a08d95a8a5">m_uipElemSendOffsets</a>.clear();
<a name="l02803"></a>02803 <a class="code" href="classot_1_1DA.html#8f834fdf0a9fcac74c282d713329e9f9">m_uipElemSendProcs</a>.clear();
<a name="l02804"></a>02804 <a class="code" href="classot_1_1DA.html#7bca018e04d1055bf703cd92a08cdaa8">m_uipElemSendCounts</a>.clear();
<a name="l02805"></a>02805 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#c1cf50f4fa19a3d2d9a9c990d8cf1cfd">m_uipSendProcs</a>.size(); i++) {
<a name="l02806"></a>02806   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#c1cf50f4fa19a3d2d9a9c990d8cf1cfd">m_uipSendProcs</a>[i] &gt; static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>)) {
<a name="l02807"></a>02807     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numElemProcs = static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#826f24205cbdbb900dc156a08d95a8a5">m_uipElemSendOffsets</a>.size());
<a name="l02808"></a>02808     <a class="code" href="classot_1_1DA.html#826f24205cbdbb900dc156a08d95a8a5">m_uipElemSendOffsets</a>.push_back(<a class="code" href="classot_1_1DA.html#5c02b1aa2478981e3dd9975468ee5db2">m_uipElemScatterMap</a>.size());
<a name="l02809"></a>02809     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = <a class="code" href="classot_1_1DA.html#6dcea85eb0519fe1a92dd0d325ddf2f8">m_uipSendOffsets</a>[i]; j &lt; (<a class="code" href="classot_1_1DA.html#276b6eb959bc06cab5f087c383322980">m_uipSendCounts</a>[i] + <a class="code" href="classot_1_1DA.html#6dcea85eb0519fe1a92dd0d325ddf2f8">m_uipSendOffsets</a>[i]); j++) {
<a name="l02810"></a>02810       <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[j] &lt; <a class="code" href="classot_1_1DA.html#7663ba260ee97dcc80c083c9ab841f49">m_uiElementEnd</a>) {
<a name="l02811"></a>02811         <a class="code" href="classot_1_1DA.html#5c02b1aa2478981e3dd9975468ee5db2">m_uipElemScatterMap</a>.push_back(<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[j]);
<a name="l02812"></a>02812       }<span class="keywordflow">else</span> {
<a name="l02813"></a>02813         <span class="keywordflow">break</span>;
<a name="l02814"></a>02814       }
<a name="l02815"></a>02815     }<span class="comment">//end for j    </span>
<a name="l02816"></a>02816     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currCount = 
<a name="l02817"></a>02817       (static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#5c02b1aa2478981e3dd9975468ee5db2">m_uipElemScatterMap</a>.size())
<a name="l02818"></a>02818        - <a class="code" href="classot_1_1DA.html#826f24205cbdbb900dc156a08d95a8a5">m_uipElemSendOffsets</a>[numElemProcs]);
<a name="l02819"></a>02819     <span class="keywordflow">if</span>(currCount) {
<a name="l02820"></a>02820       <a class="code" href="classot_1_1DA.html#8f834fdf0a9fcac74c282d713329e9f9">m_uipElemSendProcs</a>.push_back(<a class="code" href="classot_1_1DA.html#c1cf50f4fa19a3d2d9a9c990d8cf1cfd">m_uipSendProcs</a>[i]);
<a name="l02821"></a>02821       <a class="code" href="classot_1_1DA.html#7bca018e04d1055bf703cd92a08cdaa8">m_uipElemSendCounts</a>.push_back(currCount);
<a name="l02822"></a>02822     }<span class="keywordflow">else</span> {
<a name="l02823"></a>02823       <a class="code" href="classot_1_1DA.html#826f24205cbdbb900dc156a08d95a8a5">m_uipElemSendOffsets</a>.resize(numElemProcs);
<a name="l02824"></a>02824     }
<a name="l02825"></a>02825   }
<a name="l02826"></a>02826 }<span class="comment">//end for i</span>
<a name="l02827"></a>02827 
<a name="l02828"></a>02828 <a class="code" href="classot_1_1DA.html#a16b6dddf92133d046dad4ac25412465">m_uipElemRecvOffsets</a>.clear();
<a name="l02829"></a>02829 <a class="code" href="classot_1_1DA.html#9369d3b72fcff32e8d0340e884894d95">m_uipElemRecvProcs</a>.clear();
<a name="l02830"></a>02830 <a class="code" href="classot_1_1DA.html#5a8d6d581c3621c2726843b3f590edd4">m_uipElemRecvCounts</a>.clear();
<a name="l02831"></a>02831 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>.size(); i++) {
<a name="l02832"></a>02832   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[i] &lt; <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>) {
<a name="l02833"></a>02833     <span class="comment">//Planning to recieve at least 1 pre-ghost element from this processor</span>
<a name="l02834"></a>02834     <a class="code" href="classot_1_1DA.html#9369d3b72fcff32e8d0340e884894d95">m_uipElemRecvProcs</a>.push_back(<a class="code" href="classot_1_1DA.html#0e0dae2af2862d622d0076eebc36848e">m_uipRecvProcs</a>[i]);
<a name="l02835"></a>02835     <a class="code" href="classot_1_1DA.html#a16b6dddf92133d046dad4ac25412465">m_uipElemRecvOffsets</a>.push_back(<a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[i]);
<a name="l02836"></a>02836     <span class="keywordflow">if</span>( (<a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[i] + <a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>[i]) &lt;= <a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a>) {
<a name="l02837"></a>02837       <a class="code" href="classot_1_1DA.html#5a8d6d581c3621c2726843b3f590edd4">m_uipElemRecvCounts</a>.push_back(<a class="code" href="classot_1_1DA.html#fd40cb2d7a125a5a2b27413278a6b6b4">m_uipRecvCounts</a>[i]);
<a name="l02838"></a>02838     } <span class="keywordflow">else</span> {
<a name="l02839"></a>02839       <a class="code" href="classot_1_1DA.html#5a8d6d581c3621c2726843b3f590edd4">m_uipElemRecvCounts</a>.push_back(<a class="code" href="classot_1_1DA.html#7cdd60ba0d53e89894b4f4a28cfa1403">m_uiPreGhostElementSize</a> - <a class="code" href="classot_1_1DA.html#413f1bd8d680e94ad508fbd7bbd7f739">m_uipRecvOffsets</a>[i]);
<a name="l02840"></a>02840     }
<a name="l02841"></a>02841   }
<a name="l02842"></a>02842 }<span class="comment">//end for i</span>
<a name="l02843"></a>02843 
<a name="l02844"></a>02844 <span class="comment">// Correct the scatter-map so that hanging nodes get correct info ...</span>
<a name="l02845"></a>02845 <span class="comment">//  Logic is to find if any entry in the scatter map is hanging, and if</span>
<a name="l02846"></a>02846 <span class="comment">//  so, we simply correct the scatter map so that it points to the</span>
<a name="l02847"></a>02847 <span class="comment">//  correct anchor instead.</span>
<a name="l02848"></a>02848 
<a name="l02849"></a>02849 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>.size(); i++) {
<a name="l02850"></a>02850   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[i];
<a name="l02851"></a>02851 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02852"></a>02852 <span class="preprocessor"></span>  assert( (idx &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (idx &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) );
<a name="l02853"></a>02853 <span class="preprocessor">#endif</span>
<a name="l02854"></a>02854 <span class="preprocessor"></span>  <span class="comment">// if idx is an elem ... use nlist ...</span>
<a name="l02855"></a>02855   <span class="keywordflow">if</span> ( idx &lt; nelem) {
<a name="l02856"></a>02856     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*idx + 1] &amp; 1) {
<a name="l02857"></a>02857 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02858"></a>02858 <span class="preprocessor"></span>      assert( !(in[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a>) );
<a name="l02859"></a>02859 <span class="preprocessor">#endif</span>
<a name="l02860"></a>02860 <span class="preprocessor"></span>      <span class="comment">// anchor is hanging, so let us correct this ...</span>
<a name="l02861"></a>02861       <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[i] = nlist[8*idx];
<a name="l02862"></a>02862     }
<a name="l02863"></a>02863   } <span class="keywordflow">else</span> {
<a name="l02864"></a>02864     <span class="comment">// if idx points to a boundary node,</span>
<a name="l02865"></a>02865     <span class="comment">// get the parent of in[idx] ...</span>
<a name="l02866"></a>02866     <span class="keywordflow">if</span> ( !(in[idx].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a>)) {
<a name="l02867"></a>02867       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> tn = in[idx].getParent();
<a name="l02868"></a>02868       <span class="keywordflow">while</span> ( in[idx] &gt; tn) {
<a name="l02869"></a>02869         idx--;
<a name="l02870"></a>02870       }
<a name="l02871"></a>02871       <span class="comment">//At the end of the above while loop, in[idx] will point to 1 element</span>
<a name="l02872"></a>02872       <span class="comment">//before the first child of tn.</span>
<a name="l02873"></a>02873       idx++;
<a name="l02874"></a>02874       <a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[i] = idx;
<a name="l02875"></a>02875 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02876"></a>02876 <span class="preprocessor"></span>      assert( in[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[i]].getAnchor() == tn.<a class="code" href="classot_1_1TreeNode.html#f75d51e320d74a8fd04182e2c228a11c">getAnchor</a>() );
<a name="l02877"></a>02877       assert( (<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[i] &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[i] &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) );
<a name="l02878"></a>02878       assert( in[<a class="code" href="classot_1_1DA.html#8552503942a98b59c8f498422c91c04e">m_uipScatterMap</a>[i]].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; ot::TreeNode::NODE );
<a name="l02879"></a>02879 <span class="preprocessor">#endif</span>
<a name="l02880"></a>02880 <span class="preprocessor"></span>    }
<a name="l02881"></a>02881   }
<a name="l02882"></a>02882 }<span class="comment">//end for i</span>
<a name="l02883"></a>02883 
<a name="l02884"></a>02884 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02885"></a>02885 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02886"></a>02886 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02887"></a>02887   std::cout&lt;&lt;std::endl;
<a name="l02888"></a>02888   std::cout&lt;&lt;<span class="stringliteral">"Corrected New Scatter Map for hanging anchors."</span>&lt;&lt;std::endl;
<a name="l02889"></a>02889   std::cout&lt;&lt;std::endl;
<a name="l02890"></a>02890 }
<a name="l02891"></a>02891 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02892"></a>02892 <span class="preprocessor">#endif</span>
<a name="l02893"></a>02893 <span class="preprocessor"></span>
<a name="l02894"></a>02894 <span class="comment">//Correct nlist of all FOREIGNs....</span>
<a name="l02895"></a>02895 <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;nelem;i++) {
<a name="l02896"></a>02896   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i+1] == <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) {
<a name="l02897"></a>02897     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0;j&lt;8;j++) {
<a name="l02898"></a>02898       nlist[8*i + j] = i;
<a name="l02899"></a>02899     }
<a name="l02900"></a>02900   }
<a name="l02901"></a>02901 }<span class="comment">//end for i</span>
<a name="l02902"></a>02902 
<a name="l02903"></a>02903 <span class="comment">//~~~~~~~~~~~~~~~~~~~~Mark NODES~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<a name="l02904"></a>02904 <span class="keywordtype">bool</span> *<a class="code" href="classot_1_1DA.html#8a1e9bd81f99c239cdecbd83c92f363f">isNode</a> = NULL;
<a name="l02905"></a>02905 <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>) {
<a name="l02906"></a>02906   isNode = <span class="keyword">new</span> <span class="keywordtype">bool</span>[<a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>];
<a name="l02907"></a>02907 }
<a name="l02908"></a>02908 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#ee267aceeaeac5b4fd2ac15f8d3d3ee1">m_uiLocalBufferSize</a>; i++) {
<a name="l02909"></a>02909   isNode[i] = <span class="keyword">false</span>;
<a name="l02910"></a>02910 }
<a name="l02911"></a>02911 <span class="comment">// loop through the LUT, and tag everybody as being nodes or not ...</span>
<a name="l02912"></a>02912 <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nelem; i++) {
<a name="l02913"></a>02913   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i+1] == <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) {
<a name="l02914"></a>02914     <span class="keywordflow">continue</span>;
<a name="l02915"></a>02915   }
<a name="l02916"></a>02916   <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
<a name="l02917"></a>02917 #ifdef __DEBUG_DA_NLIST__
<a name="l02918"></a>02918     assert(nlist[8*i + j] &lt; m_uiLocalBufferSize);
<a name="l02919"></a>02919 <span class="preprocessor">#endif</span>
<a name="l02920"></a>02920 <span class="preprocessor"></span>    isNode[nlist[8*i + j]] = <span class="keyword">true</span>;
<a name="l02921"></a>02921   }
<a name="l02922"></a>02922 }
<a name="l02923"></a>02923 
<a name="l02924"></a>02924 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; m_uiLocalBufferSize; i++) {
<a name="l02925"></a>02925   <span class="keywordflow">if</span> ( isNode[i] ) {
<a name="l02926"></a>02926 #ifdef __DEBUG_DA_NLIST__
<a name="l02927"></a>02927     <span class="keywordflow">if</span> ( (i &gt;= <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>) &amp;&amp; (i &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>) ) {
<a name="l02928"></a>02928       assert( (in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a>) );
<a name="l02929"></a>02929     }
<a name="l02930"></a>02930 <span class="preprocessor">#endif</span>
<a name="l02931"></a>02931 <span class="preprocessor"></span>    in[i].orFlag( <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf8f70c442b84b886210653a9d4663e3184">ot::TreeNode::NODE</a> );
<a name="l02932"></a>02932   }
<a name="l02933"></a>02933 }<span class="comment">//end for i</span>
<a name="l02934"></a>02934 
<a name="l02935"></a>02935 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02936"></a>02936 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02937"></a>02937 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02938"></a>02938   std::cout&lt;&lt;std::endl;
<a name="l02939"></a>02939   std::cout&lt;&lt;<span class="stringliteral">"Finished is NODE..."</span>&lt;&lt;std::endl;
<a name="l02940"></a>02940   std::cout&lt;&lt;std::endl;
<a name="l02941"></a>02941 }
<a name="l02942"></a>02942 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02943"></a>02943 <span class="preprocessor">#endif</span>
<a name="l02944"></a>02944 <span class="preprocessor"></span>
<a name="l02945"></a>02945 <span class="comment">// Now compute the elem node size, and boundary node sizes ...</span>
<a name="l02946"></a>02946 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> elemNodeSz = 0;
<a name="l02947"></a>02947 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bndNodeSz = 0;
<a name="l02948"></a>02948 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> preGhostNodeSz = 0;
<a name="l02949"></a>02949 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> preBndNodeSz = 0;
<a name="l02950"></a>02950 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> postGhostNodeSz = 0;
<a name="l02951"></a>02951 <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> postBndNodeSz = 0;
<a name="l02952"></a>02952 
<a name="l02953"></a>02953 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; <a class="code" href="classot_1_1DA.html#ec575a8d42f1a5de683e2598f2872e52">m_uiElementBegin</a>; i++) {
<a name="l02954"></a>02954   <span class="keywordflow">if</span> ( isNode[i]  &amp;&amp; (!(in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf80696c30ddbe9ec3ea80a7e88f5c24e0a">ot::TreeNode::BOUNDARY</a>)) ) {
<a name="l02955"></a>02955     preGhostNodeSz++;                    
<a name="l02956"></a>02956   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNode[i]) {
<a name="l02957"></a>02957     preBndNodeSz++;
<a name="l02958"></a>02958   }
<a name="l02959"></a>02959 }
<a name="l02960"></a>02960 
<a name="l02961"></a>02961 <span class="comment">//My Elements which are also nodes.</span>
<a name="l02962"></a>02962 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementBegin; i &lt; <a class="code" href="classot_1_1DA.html#7663ba260ee97dcc80c083c9ab841f49">m_uiElementEnd</a>; i++) {
<a name="l02963"></a>02963   <span class="keywordflow">if</span> (isNode[i]) {
<a name="l02964"></a>02964     elemNodeSz++;        
<a name="l02965"></a>02965   }
<a name="l02966"></a>02966 }
<a name="l02967"></a>02967 
<a name="l02968"></a>02968 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiElementEnd; i &lt; <a class="code" href="classot_1_1DA.html#c725550f5361a5fb7664c89b685f0b36">m_uiPostGhostBegin</a>; i++) {
<a name="l02969"></a>02969   <span class="keywordflow">if</span> (isNode[i]) {
<a name="l02970"></a>02970     bndNodeSz++;          
<a name="l02971"></a>02971   }
<a name="l02972"></a>02972 }
<a name="l02973"></a>02973 
<a name="l02974"></a>02974 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = m_uiPostGhostBegin; i &lt; m_uiLocalBufferSize; i++) {
<a name="l02975"></a>02975   <span class="keywordflow">if</span> (isNode[i] &amp;&amp; (!(in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="classot_1_1TreeNode.html#eb7e20b10a13a07386f6a940ae7aecf80696c30ddbe9ec3ea80a7e88f5c24e0a">ot::TreeNode::BOUNDARY</a>)) ) {
<a name="l02976"></a>02976     postGhostNodeSz++;
<a name="l02977"></a>02977   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (isNode[i]) {
<a name="l02978"></a>02978     postBndNodeSz++;
<a name="l02979"></a>02979   }
<a name="l02980"></a>02980 }
<a name="l02981"></a>02981 
<a name="l02982"></a>02982 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l02983"></a>02983 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02984"></a>02984 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>) {
<a name="l02985"></a>02985   std::cout&lt;&lt;std::endl;
<a name="l02986"></a>02986   std::cout&lt;&lt;<span class="stringliteral">"Finished setting sizes..."</span>&lt;&lt;std::endl;
<a name="l02987"></a>02987   std::cout&lt;&lt;std::endl;
<a name="l02988"></a>02988 }
<a name="l02989"></a>02989 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l02990"></a>02990 <span class="preprocessor">#endif</span>
<a name="l02991"></a>02991 <span class="preprocessor"></span>
<a name="l02992"></a>02992 <span class="keywordflow">if</span>(isNode) {
<a name="l02993"></a>02993   <span class="keyword">delete</span> [] isNode;
<a name="l02994"></a>02994   isNode = NULL;
<a name="l02995"></a>02995 }
<a name="l02996"></a>02996 
<a name="l02997"></a>02997 <span class="comment">//Store the sizes.</span>
<a name="l02998"></a>02998 <a class="code" href="classot_1_1DA.html#4acaa17153e51832bbad68de95c0f661">m_uiPreGhostNodeSize</a> = preGhostNodeSz;
<a name="l02999"></a>02999 <a class="code" href="classot_1_1DA.html#4f42e5f1333ff8b4e9fa2f4177deaf42">m_uiPreGhostBoundaryNodeSize</a> = preBndNodeSz;
<a name="l03000"></a>03000 <a class="code" href="classot_1_1DA.html#2fdec1f3f79683ea29581c718b8b9248">m_uiPostGhostNodeSize</a> = postGhostNodeSz + postBndNodeSz;
<a name="l03001"></a>03001 <a class="code" href="classot_1_1DA.html#ffd578ece2a48620101fc61974b6e594">m_uiNodeSize</a> = elemNodeSz;
<a name="l03002"></a>03002 <a class="code" href="classot_1_1DA.html#178745a9bfdd853a4a258628c48d884d">m_uiBoundaryNodeSize</a> = bndNodeSz;
<a name="l03003"></a>03003 
<a name="l03004"></a>03004 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l03005"></a>03005 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l03006"></a>03006 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Just Before Compression...."</span>&lt;&lt;std::endl&lt;&lt;std::endl;
<a name="l03007"></a>03007 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#4acaa17153e51832bbad68de95c0f661">m_uiPreGhostNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#4f42e5f1333ff8b4e9fa2f4177deaf42">m_uiPreGhostBoundaryNodeSize</a>
<a name="l03008"></a>03008 &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#2fdec1f3f79683ea29581c718b8b9248">m_uiPostGhostNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#ffd578ece2a48620101fc61974b6e594">m_uiNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>
<a name="l03009"></a>03009 &lt;&lt;<a class="code" href="classot_1_1DA.html#178745a9bfdd853a4a258628c48d884d">m_uiBoundaryNodeSize</a>&lt;&lt;std::endl&lt;&lt;std::endl;
<a name="l03010"></a>03010 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l03011"></a>03011 <span class="preprocessor">#endif</span>
<a name="l03012"></a>03012 <span class="preprocessor"></span>
<a name="l03013"></a>03013 <span class="comment">// All done ... Now COMPRESS</span>
<a name="l03014"></a>03014 <span class="comment">// Now compress the node list ...</span>
<a name="l03015"></a>03015 
<a name="l03016"></a>03016 <span class="comment">// allocate a small buffer to unsort ...</span>
<a name="l03017"></a>03017 <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#07422a283f8ca46485f41e217511179d">m_bCompressLut</a>) {
<a name="l03018"></a>03018   <a class="code" href="classot_1_1DA.html#67afca98a0862ef09bb4801d846ab935">m_ucpLutRemainders</a>.resize(8*nelem);
<a name="l03019"></a>03019   <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>.resize(nelem);
<a name="l03020"></a>03020 }
<a name="l03021"></a>03021 
<a name="l03022"></a>03022 <span class="keywordtype">bool</span> foundBeg = <span class="keyword">false</span>;
<a name="l03023"></a>03023 <span class="keywordtype">bool</span> foundEnd = <span class="keyword">false</span>;
<a name="l03024"></a>03024 
<a name="l03025"></a>03025 <a class="code" href="classot_1_1DA.html#b13df6ac4087f95a71c4fb982c018591">m_uiIndependentElementSize</a> = 0;
<a name="l03026"></a>03026 <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; nelem; i++) {
<a name="l03027"></a>03027   <span class="comment">// get basic info ...</span>
<a name="l03028"></a>03028   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ii = 8*i;
<a name="l03029"></a>03029 
<a name="l03030"></a>03030   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[i].getX();
<a name="l03031"></a>03031   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[i].getY();
<a name="l03032"></a>03032   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[i].getZ();
<a name="l03033"></a>03033 
<a name="l03034"></a>03034   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#07422a283f8ca46485f41e217511179d">m_bCompressLut</a>) {
<a name="l03035"></a>03035     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[i].getLevel();
<a name="l03036"></a>03036     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = 1u &lt;&lt; (<a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a> - d);
<a name="l03037"></a>03037     <span class="comment">//compute and store the sort order for the non-hanging case.</span>
<a name="l03038"></a>03038     <span class="keywordflow">if</span>(!(<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i+1])){
<a name="l03039"></a>03039       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xp = x + sz;
<a name="l03040"></a>03040       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yp = y + sz;
<a name="l03041"></a>03041       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zp = z + sz;
<a name="l03042"></a>03042 
<a name="l03043"></a>03043       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x = x^xp;
<a name="l03044"></a>03044       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _y = y^yp;
<a name="l03045"></a>03045       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _z = z^zp;
<a name="l03046"></a>03046 
<a name="l03047"></a>03047       <span class="keywordflow">if</span> (_x &gt; _y) {
<a name="l03048"></a>03048         <span class="keywordflow">if</span> ( _y &gt; _z) {
<a name="l03049"></a>03049           <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>[i] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#d088255da4e941b0e3ec5f0ceb77da852f6610fbcbcdd5275909e1fcd27e9c7b">ot::DA_FLAGS::ZYX</a>;
<a name="l03050"></a>03050         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _x &gt; _z ) {
<a name="l03051"></a>03051           <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>[i] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#d088255da4e941b0e3ec5f0ceb77da85872ad896f894285e66ca43073ef1c028">ot::DA_FLAGS::YZX</a>;
<a name="l03052"></a>03052         } <span class="keywordflow">else</span> {
<a name="l03053"></a>03053           <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>[i] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#d088255da4e941b0e3ec5f0ceb77da85da4078ca49c550c681a354bde4d15439">ot::DA_FLAGS::YXZ</a>;
<a name="l03054"></a>03054         }
<a name="l03055"></a>03055       } <span class="keywordflow">else</span> {
<a name="l03056"></a>03056         <span class="keywordflow">if</span> ( _x &gt; _z) {
<a name="l03057"></a>03057           <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>[i] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#d088255da4e941b0e3ec5f0ceb77da850d1c868ffae2e335e971e8ef850ba837">ot::DA_FLAGS::ZXY</a>;
<a name="l03058"></a>03058         } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _y &gt; _z ) {
<a name="l03059"></a>03059           <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>[i] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#d088255da4e941b0e3ec5f0ceb77da853abb154c91bbe596fb7cd7419faaf9d1">ot::DA_FLAGS::XZY</a>;
<a name="l03060"></a>03060         } <span class="keywordflow">else</span> {
<a name="l03061"></a>03061           <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>[i] = <a class="code" href="namespaceot_1_1DA__FLAGS.html#d088255da4e941b0e3ec5f0ceb77da851cc8b8d7244e5a256af64b60d1f6a580">ot::DA_FLAGS::XYZ</a>;
<a name="l03062"></a>03062         }
<a name="l03063"></a>03063       }
<a name="l03064"></a>03064     }<span class="keywordflow">else</span> {
<a name="l03065"></a>03065       <span class="comment">//store the childnumber instead for the hanging cases.</span>
<a name="l03066"></a>03066       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len_par = (<span class="keywordtype">unsigned</span> int)(1u &lt;&lt; ( <a class="code" href="classot_1_1DA.html#74995e7d8504c75ec557b95588784355">m_uiMaxDepth</a>  - d +1 ) );
<a name="l03067"></a>03067 
<a name="l03068"></a>03068       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> a = x % len_par;
<a name="l03069"></a>03069       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> b = y % len_par;
<a name="l03070"></a>03070       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> c = z % len_par;
<a name="l03071"></a>03071 
<a name="l03072"></a>03072       a /= sz;
<a name="l03073"></a>03073       b /= sz;
<a name="l03074"></a>03074       c /= sz;
<a name="l03075"></a>03075 
<a name="l03076"></a>03076       <a class="code" href="classot_1_1DA.html#70264ccfce790b1ede010fdbe9cfbf53">m_ucpSortOrders</a>[i]  = (4*c + 2*b + a);
<a name="l03077"></a>03077     }<span class="comment">//end sortOrderRegular block</span>
<a name="l03078"></a>03078   }<span class="comment">//end if Lut compressed</span>
<a name="l03079"></a>03079 
<a name="l03080"></a>03080   <span class="comment">// use this loop to also detect the begining and end of dependent.</span>
<a name="l03081"></a>03081   <span class="keywordflow">if</span> ( !foundBeg &amp;&amp; !(in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99bfcb3641c24ad81053969b7b18d0a2fb4">ot::DA_FLAGS::DEP_ELEM</a>)
<a name="l03082"></a>03082       &amp;&amp; (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i+1] != <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) ) {
<a name="l03083"></a>03083     <span class="comment">//std::cout &lt;&lt; GRN"FOUND BEGINING OF INDEPENDENT "NRM &lt;&lt; i &lt;&lt; std::endl;</span>
<a name="l03084"></a>03084     foundBeg = <span class="keyword">true</span>;
<a name="l03085"></a>03085     <a class="code" href="classot_1_1DA.html#0d623803bdb6e63ff06770f5f5636577">m_uiIndependentElementBegin</a> = i;
<a name="l03086"></a>03086     <a class="code" href="classot_1_1DA.html#dcbd6984c6246d901311205c08e45a07">m_ptIndependentOffset</a> = <a class="code" href="classPoint.html">Point</a>(x,y,z);
<a name="l03087"></a>03087   }
<a name="l03088"></a>03088 
<a name="l03089"></a>03089   <span class="comment">// reverse loop to find end ...</span>
<a name="l03090"></a>03090   <span class="keywordflow">if</span> ( !foundEnd &amp;&amp; !(in[nelem-i-1].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; ot::DA_FLAGS::DEP_ELEM)
<a name="l03091"></a>03091       &amp;&amp; (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*(nelem-i-1)+1] != <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) ) {
<a name="l03092"></a>03092     <span class="comment">//std::cout &lt;&lt; GRN"FOUND END OF INDEPENDENT "NRM &lt;&lt; nelem - i &lt;&lt; std::endl;</span>
<a name="l03093"></a>03093     foundEnd = <span class="keyword">true</span>;
<a name="l03094"></a>03094     <a class="code" href="classot_1_1DA.html#cb08aac52c0bd77b47fb2da535162865">m_uiIndependentElementEnd</a> = nelem - i;
<a name="l03095"></a>03095   }
<a name="l03096"></a>03096 
<a name="l03097"></a>03097   <span class="comment">//Actual number of Independent elements. In between IndependentElementBegin</span>
<a name="l03098"></a>03098   <span class="comment">//and IndependentElementEnd, we can also have dependent elements and so</span>
<a name="l03099"></a>03099   <span class="comment">//simply taking the difference of end and begin will not work</span>
<a name="l03100"></a>03100   <span class="keywordflow">if</span>( (!(in[i].<a class="code" href="classot_1_1DA.html#ec1386f5ce907cee7e1d8d2ba4fe62bd">getFlag</a>() &amp; ot::DA_FLAGS::DEP_ELEM)) &amp;&amp;
<a name="l03101"></a>03101       (<a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i+1] != <a class="code" href="namespaceot_1_1DA__FLAGS.html#9e97fc02c79ce0dc041c0ea2e3c6e99b711a7b92fe02f2b9849d19a3be2a671b">ot::DA_FLAGS::FOREIGN</a>) ) {
<a name="l03102"></a>03102     <a class="code" href="classot_1_1DA.html#b13df6ac4087f95a71c4fb982c018591">m_uiIndependentElementSize</a>++;
<a name="l03103"></a>03103   }
<a name="l03104"></a>03104 
<a name="l03105"></a>03105   <span class="keywordflow">if</span> ( i == m_uiElementBegin ) {
<a name="l03106"></a>03106     <a class="code" href="classot_1_1DA.html#33332b0074a41a8fd1a71b88d58dc7c3">m_uiElementQuotient</a> = static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#8b84170b0e36f02dc85e03219abfdb9c">m_uspLutQuotients</a>.size());
<a name="l03107"></a>03107   }
<a name="l03108"></a>03108 
<a name="l03109"></a>03109   <span class="keywordflow">if</span> ( i == <a class="code" href="classot_1_1DA.html#0d623803bdb6e63ff06770f5f5636577">m_uiIndependentElementBegin</a> ) {
<a name="l03110"></a>03110     <a class="code" href="classot_1_1DA.html#8469400a3b8122dc7be3bf32b20e0103">m_uiIndependentElementQuotient</a> = static_cast&lt;unsigned int&gt;(<a class="code" href="classot_1_1DA.html#8b84170b0e36f02dc85e03219abfdb9c">m_uspLutQuotients</a>.size());
<a name="l03111"></a>03111   }
<a name="l03112"></a>03112 
<a name="l03113"></a>03113   <span class="comment">//First initialize Masks...</span>
<a name="l03114"></a>03114   <a class="code" href="classot_1_1DA.html#d4800b646ac8feee9e818a82bca36732">m_ucpLutMasks</a>[2*i] = 0;
<a name="l03115"></a>03115 
<a name="l03116"></a>03116   <span class="comment">// locally sort ...</span>
<a name="l03117"></a>03117   <span class="keywordflow">if</span>(<a class="code" href="classot_1_1DA.html#07422a283f8ca46485f41e217511179d">m_bCompressLut</a>) {
<a name="l03118"></a>03118     <span class="comment">// Perform Golomb-Rice encoding</span>
<a name="l03119"></a>03119     <span class="comment">//Assumes that the highest 8 bits in offset are not significant, i.e. they will be all 0.</span>
<a name="l03120"></a>03120     <span class="comment">//This means offset can not be more than (2^24-1) = 16,777,215.</span>
<a name="l03121"></a>03121     <span class="comment">//Since the number of octants on a processor will not be more than 16M,</span>
<a name="l03122"></a>03122     <span class="comment">//this does not pose any kind of difficulty.</span>
<a name="l03123"></a>03123 
<a name="l03124"></a>03124     <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> q;
<a name="l03125"></a>03125     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> offset;
<a name="l03126"></a>03126     std::vector&lt;unsigned int&gt; nl(8);
<a name="l03127"></a>03127     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ij = 0; ij &lt; 8; ij++) {
<a name="l03128"></a>03128       nl[ij] = nlist[ii+ij];
<a name="l03129"></a>03129     }
<a name="l03130"></a>03130     <a class="code" href="Sort_8h.html#9f400c32a5c1d9494caa0dfd766ec976">std::sort</a>(nl.begin(), nl.end());
<a name="l03131"></a>03131 
<a name="l03132"></a>03132     <span class="comment">// 0 is special, it computes the offset wrt i.</span>
<a name="l03133"></a>03133     <span class="comment">// 0, we have a negative offset .. or 0</span>
<a name="l03134"></a>03134     offset = i - nl[0];
<a name="l03135"></a>03135     q = (offset &gt;&gt; 8);
<a name="l03136"></a>03136     <a class="code" href="classot_1_1DA.html#67afca98a0862ef09bb4801d846ab935">m_ucpLutRemainders</a>[8*i] = (offset%256);
<a name="l03137"></a>03137     <span class="keywordflow">if</span> (q) {
<a name="l03138"></a>03138       m_ucpLutMasks[2*i] |= 1;
<a name="l03139"></a>03139       <a class="code" href="classot_1_1DA.html#8b84170b0e36f02dc85e03219abfdb9c">m_uspLutQuotients</a>.push_back(q);
<a name="l03140"></a>03140     }
<a name="l03141"></a>03141 
<a name="l03142"></a>03142     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 1; j &lt; 8; j++) {
<a name="l03143"></a>03143       offset =  nl[j] - nl[j-1];
<a name="l03144"></a>03144       q = (offset &gt;&gt; 8);
<a name="l03145"></a>03145       <a class="code" href="classot_1_1DA.html#67afca98a0862ef09bb4801d846ab935">m_ucpLutRemainders</a>[8*i + j] = (offset%256);
<a name="l03146"></a>03146       <span class="keywordflow">if</span> (q) {
<a name="l03147"></a>03147         m_ucpLutMasks[2*i] |= (1 &lt;&lt; j);
<a name="l03148"></a>03148         <a class="code" href="classot_1_1DA.html#8b84170b0e36f02dc85e03219abfdb9c">m_uspLutQuotients</a>.push_back(q);
<a name="l03149"></a>03149       }
<a name="l03150"></a>03150     } <span class="comment">// for j ...</span>
<a name="l03151"></a>03151     nl.clear();
<a name="l03152"></a>03152   }<span class="comment">//end if compress</span>
<a name="l03153"></a>03153 
<a name="l03154"></a>03154 } <span class="comment">// for i</span>
<a name="l03155"></a>03155 
<a name="l03156"></a>03156 <span class="comment">//Store Nlist if you are not compressing...</span>
<a name="l03157"></a>03157 <span class="keywordflow">if</span>(!<a class="code" href="classot_1_1DA.html#07422a283f8ca46485f41e217511179d">m_bCompressLut</a>) {
<a name="l03158"></a>03158   <a class="code" href="classot_1_1DA.html#277df6fea9f30f6f3834ab229604b782">m_uiNlist</a> = nlist; 
<a name="l03159"></a>03159 }
<a name="l03160"></a>03160 
<a name="l03161"></a>03161 <span class="comment">// free up</span>
<a name="l03162"></a>03162 nlist.clear();
<a name="l03163"></a>03163 
<a name="l03164"></a>03164 <span class="preprocessor">#ifdef __DEBUG_DA_NLIST__</span>
<a name="l03165"></a>03165 <span class="preprocessor"></span>MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l03166"></a>03166 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" Just After Compression...."</span>&lt;&lt;std::endl&lt;&lt;std::endl;
<a name="l03167"></a>03167 std::cout&lt;&lt;<a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#4acaa17153e51832bbad68de95c0f661">m_uiPreGhostNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>
<a name="l03168"></a>03168 &lt;&lt;<a class="code" href="classot_1_1DA.html#4f42e5f1333ff8b4e9fa2f4177deaf42">m_uiPreGhostBoundaryNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#2fdec1f3f79683ea29581c718b8b9248">m_uiPostGhostNodeSize</a>
<a name="l03169"></a>03169 &lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#ffd578ece2a48620101fc61974b6e594">m_uiNodeSize</a>&lt;&lt;<span class="stringliteral">" "</span>&lt;&lt;<a class="code" href="classot_1_1DA.html#178745a9bfdd853a4a258628c48d884d">m_uiBoundaryNodeSize</a>&lt;&lt;std::endl&lt;&lt;std::endl;
<a name="l03170"></a>03170 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l03171"></a>03171 std::cout &lt;&lt; <a class="code" href="classot_1_1DA.html#80f6c375324f6c5a6aaf706721a6e8f7">m_iRankActive</a> &lt;&lt; <span class="stringliteral">": Leaving "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
<a name="l03172"></a>03172 MPI_Barrier(<a class="code" href="classot_1_1DA.html#045d787547f61d31379f4b02a867c89a">m_mpiCommActive</a>);
<a name="l03173"></a>03173 <span class="preprocessor">#endif</span>
<a name="l03174"></a>03174 <span class="preprocessor"></span>
<a name="l03175"></a>03175 <a class="code" href="oda_8h.html#b8be1f0f9c6eb54cc96faefe18dd8a76">PROF_BUILD_NLIST_END</a>
<a name="l03176"></a>03176 
<a name="l03177"></a>03177 }<span class="comment">//end 4-way BuildNode List</span>
<a name="l03178"></a>03178 }<span class="comment">//end namespace ot</span>
<a name="l03179"></a>03179 
<a name="l03180"></a>03180 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Fri Mar 19 16:26:45 2010 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
