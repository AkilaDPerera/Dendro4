<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/include/par/parUtils.txx Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000007.html">par</a></div>
<h1>parUtils.txx</h1><a href="parUtils_8txx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00011 <span class="preprocessor">#include "<a class="code" href="binUtils_8h.html">binUtils.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="dtypes_8h.html">dtypes.h</a>"</span>
00014 <span class="preprocessor">#include &lt;cassert&gt;</span>
00015 <span class="preprocessor">#include &lt;iostream&gt;</span>
00016 <span class="preprocessor">#include "<a class="code" href="dendro_8h.html">dendro.h</a>"</span>
00017 
00018 <span class="preprocessor">#ifdef __DEBUG__</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_PAR__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_PAR__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00023 <span class="preprocessor"></span>
00024 <span class="keyword">namespace </span>par {
00025 
00026   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00027"></a><a class="code" href="namespacepar.html#a5">00027</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a5">Mpi_Issend</a>(T* buf, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> dest, <span class="keywordtype">int</span> tag,
00028         MPI_Comm comm, MPI_Request* request) {
00029 
00030       MPI_Issend(buf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(),
00031           dest, tag, comm, request);
00032 
00033       <span class="keywordflow">return</span> 1;
00034 
00035     }
00036 
00037   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00038"></a><a class="code" href="namespacepar.html#a6">00038</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a6">Mpi_Recv</a>(T* buf, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> source, <span class="keywordtype">int</span> tag,
00039         MPI_Comm comm, MPI_Status* status) {
00040 
00041       MPI_Recv(buf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(),
00042           source, tag, comm, status);
00043 
00044       <span class="keywordflow">return</span> 1;
00045 
00046     }
00047 
00048   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00049"></a><a class="code" href="namespacepar.html#a7">00049</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a7">Mpi_Irecv</a>(T* buf, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> source, <span class="keywordtype">int</span> tag,
00050         MPI_Comm comm, MPI_Request* request) {
00051 
00052       MPI_Irecv(buf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(),
00053           source, tag, comm, request);
00054 
00055       <span class="keywordflow">return</span> 1;
00056 
00057     }
00058 
00059   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> S&gt;
<a name="l00060"></a><a class="code" href="namespacepar.html#a9">00060</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a9">Mpi_Sendrecv</a>( T* sendBuf, <span class="keywordtype">int</span> sendCount, <span class="keywordtype">int</span> dest, <span class="keywordtype">int</span> sendTag,
00061         S* recvBuf, <span class="keywordtype">int</span> recvCount, <span class="keywordtype">int</span> source, <span class="keywordtype">int</span> recvTag,
00062         MPI_Comm comm, MPI_Status* status) {
00063       <a class="code" href="parUtils_8h.html#a7">PROF_PAR_SENDRECV_BEGIN</a>
00064 
00065         MPI_Sendrecv(sendBuf, sendCount, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), dest, sendTag,
00066             recvBuf, recvCount, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;S&gt;</a>::value(), source, recvTag, comm, status);
00067 
00068       <a class="code" href="parUtils_8h.html#a27">PROF_PAR_SENDRECV_END</a>
00069     }
00070 
00071   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00072"></a><a class="code" href="namespacepar.html#a11">00072</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a11">Mpi_Scan</a>( T* sendbuf, T* recvbuf, <span class="keywordtype">int</span> count, MPI_Op op, MPI_Comm comm) {
00073 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00074 <span class="preprocessor"></span>      MPI_Barrier(comm);
00075 <span class="preprocessor">#endif</span>
00076 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a10">PROF_PAR_SCAN_BEGIN</a>
00077 
00078         MPI_Scan(sendbuf, recvbuf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), op, comm);
00079 
00080       <a class="code" href="parUtils_8h.html#a30">PROF_PAR_SCAN_END</a>
00081     }
00082 
00083   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00084"></a><a class="code" href="namespacepar.html#a13">00084</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a13">Mpi_Allreduce</a>(T* sendbuf, T* recvbuf, <span class="keywordtype">int</span> count, MPI_Op op, MPI_Comm comm) {
00085 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00086 <span class="preprocessor"></span>      MPI_Barrier(comm);
00087 <span class="preprocessor">#endif</span>
00088 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a12">PROF_PAR_ALLREDUCE_BEGIN</a>
00089 
00090         MPI_Allreduce(sendbuf, recvbuf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), op, comm);
00091 
00092       <a class="code" href="parUtils_8h.html#a32">PROF_PAR_ALLREDUCE_END</a>
00093     }
00094 
00095   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00096"></a><a class="code" href="namespacepar.html#a14">00096</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a14">Mpi_Alltoall</a>(T* sendbuf, T* recvbuf, <span class="keywordtype">int</span> count, MPI_Comm comm) {
00097 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00098 <span class="preprocessor"></span>      MPI_Barrier(comm);
00099 <span class="preprocessor">#endif</span>
00100 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a13">PROF_PAR_ALL2ALL_BEGIN</a>
00101 
00102         MPI_Alltoall(sendbuf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(),
00103             recvbuf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), comm);
00104 
00105       <a class="code" href="parUtils_8h.html#a33">PROF_PAR_ALL2ALL_END</a>
00106     }
00107 
00108   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00109"></a><a class="code" href="namespacepar.html#a8">00109</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a8">Mpi_Gather</a>( T* sendBuffer, T* recvBuffer, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> root, MPI_Comm comm) {
00110 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00111 <span class="preprocessor"></span>      MPI_Barrier(comm);
00112 <span class="preprocessor">#endif</span>
00113 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a9">PROF_PAR_GATHER_BEGIN</a>
00114 
00115         MPI_Gather(sendBuffer, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(),
00116             recvBuffer, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), root, comm);
00117 
00118       <a class="code" href="parUtils_8h.html#a29">PROF_PAR_GATHER_END</a>
00119     }
00120 
00121   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00122"></a><a class="code" href="namespacepar.html#a10">00122</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a10">Mpi_Bcast</a>(T* buffer, <span class="keywordtype">int</span> count, <span class="keywordtype">int</span> root, MPI_Comm comm) {
00123 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00124 <span class="preprocessor"></span>      MPI_Barrier(comm);
00125 <span class="preprocessor">#endif</span>
00126 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a8">PROF_PAR_BCAST_BEGIN</a>
00127 
00128         MPI_Bcast(buffer, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), root, comm);
00129 
00130       <a class="code" href="parUtils_8h.html#a28">PROF_PAR_BCAST_END</a>
00131     }
00132 
00133   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00134"></a><a class="code" href="namespacepar.html#a12">00134</a>     <span class="keyword">inline</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a12">Mpi_Reduce</a>(T* sendbuf, T* recvbuf, <span class="keywordtype">int</span> count, MPI_Op op, <span class="keywordtype">int</span> root, MPI_Comm comm) {
00135 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00136 <span class="preprocessor"></span>      MPI_Barrier(comm);
00137 <span class="preprocessor">#endif</span>
00138 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a11">PROF_PAR_REDUCE_BEGIN</a>
00139 
00140         MPI_Reduce(sendbuf, recvbuf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), op, root, comm);
00141 
00142       <a class="code" href="parUtils_8h.html#a31">PROF_PAR_REDUCE_END</a>
00143     }
00144 
00145   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00146"></a><a class="code" href="namespacepar.html#a15">00146</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a15">Mpi_Allgatherv</a>(T* sendBuf, <span class="keywordtype">int</span> sendCount, T* recvBuf, 
00147         <span class="keywordtype">int</span>* recvCounts, <span class="keywordtype">int</span>* displs, MPI_Comm comm) {
00148 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00149 <span class="preprocessor"></span>      MPI_Barrier(comm);
00150 <span class="preprocessor">#endif</span>
00151 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a14">PROF_PAR_ALLGATHERV_BEGIN</a>
00152 
00153 <span class="preprocessor">#ifdef __USE_A2A_FOR_MPI_ALLGATHER__</span>
00154 <span class="preprocessor"></span>
00155         <span class="keywordtype">int</span> maxSendCount;
00156       <span class="keywordtype">int</span> npes, rank;
00157 
00158       MPI_Comm_size(comm, &amp;npes);
00159       MPI_Comm_rank(comm, &amp;rank);
00160 
00161       par::Mpi_Allreduce&lt;int&gt;(&amp;sendCount, &amp;maxSendCount, 1, MPI_MAX, comm);
00162 
00163       T* dummySendBuf = <span class="keyword">new</span> T[maxSendCount*npes];
00164 
00165       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00166         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; sendCount; j++) {
00167           dummySendBuf[(i*maxSendCount) + j] = sendBuf[j];
00168         }
00169       }
00170 
00171       T* dummyRecvBuf = <span class="keyword">new</span> T[maxSendCount*npes];
00172 
00173       par::Mpi_Alltoall&lt;T&gt;(dummySendBuf, dummyRecvBuf, maxSendCount, comm);
00174 
00175       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00176         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; recvCounts[i]; j++) {
00177           recvBuf[displs[i] + j] = dummyRecvBuf[(i*maxSendCount) + j];
00178         }
00179       }
00180 
00181       <span class="keyword">delete</span> [] dummySendBuf;
00182       <span class="keyword">delete</span> [] dummyRecvBuf;
00183 
00184 <span class="preprocessor">#else</span>
00185 <span class="preprocessor"></span>
00186       MPI_Allgatherv(sendBuf, sendCount, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(),
00187           recvBuf, recvCounts, displs, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), comm);
00188 
00189 <span class="preprocessor">#endif</span>
00190 <span class="preprocessor"></span>
00191       <a class="code" href="parUtils_8h.html#a34">PROF_PAR_ALLGATHERV_END</a>
00192     }
00193 
00194   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00195"></a><a class="code" href="namespacepar.html#a16">00195</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a16">Mpi_Allgather</a>(T* sendBuf, T* recvBuf, <span class="keywordtype">int</span> count, MPI_Comm comm) {
00196 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00197 <span class="preprocessor"></span>      MPI_Barrier(comm);
00198 <span class="preprocessor">#endif</span>
00199 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a15">PROF_PAR_ALLGATHER_BEGIN</a>
00200 
00201 <span class="preprocessor">#ifdef __USE_A2A_FOR_MPI_ALLGATHER__</span>
00202 <span class="preprocessor"></span>
00203         <span class="keywordtype">int</span> npes;
00204       MPI_Comm_size(comm, &amp;npes);
00205       T* dummySendBuf = <span class="keyword">new</span> T[count*npes];
00206       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00207         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; count; j++) {
00208           dummySendBuf[(i*count) + j] = sendBuf[j];
00209         }
00210       }
00211       par::Mpi_Alltoall&lt;T&gt;(dummySendBuf, recvBuf, count, comm);
00212       <span class="keyword">delete</span> [] dummySendBuf;
00213 
00214 <span class="preprocessor">#else</span>
00215 <span class="preprocessor"></span>
00216       MPI_Allgather(sendBuf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), 
00217           recvBuf, count, <a class="code" href="classpar_1_1Mpi__datatype.html">par::Mpi_datatype&lt;T&gt;</a>::value(), comm);
00218 
00219 <span class="preprocessor">#endif</span>
00220 <span class="preprocessor"></span>
00221       <a class="code" href="parUtils_8h.html#a35">PROF_PAR_ALLGATHER_END</a>
00222     }
00223 
00224   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00225"></a><a class="code" href="namespacepar.html#a17">00225</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a17">Mpi_Alltoallv_sparse</a>(T* sendbuf, <span class="keywordtype">int</span>* sendcnts, <span class="keywordtype">int</span>* sdispls, 
00226         T* recvbuf, <span class="keywordtype">int</span>* recvcnts, <span class="keywordtype">int</span>* rdispls, MPI_Comm comm) {
00227 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00228 <span class="preprocessor"></span>      MPI_Barrier(comm);
00229 <span class="preprocessor">#endif</span>
00230 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a16">PROF_PAR_ALL2ALLV_SPARSE_BEGIN</a>
00231 
00232         <span class="keywordtype">int</span> npes, rank;
00233       MPI_Comm_size(comm, &amp;npes);
00234       MPI_Comm_rank(comm, &amp;rank);
00235 
00236       <span class="keywordtype">int</span> commCnt = 0;
00237 
00238       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
00239         <span class="keywordflow">if</span>(sendcnts[i] &gt; 0) {
00240           commCnt++;
00241         }
00242         <span class="keywordflow">if</span>(recvcnts[i] &gt; 0) {
00243           commCnt++;
00244         }
00245       }
00246 
00247       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank+1); i &lt; npes; i++) {
00248         <span class="keywordflow">if</span>(sendcnts[i] &gt; 0) {
00249           commCnt++;
00250         }
00251         <span class="keywordflow">if</span>(recvcnts[i] &gt; 0) {
00252           commCnt++;
00253         }
00254       }
00255 
00256       MPI_Request* requests = <span class="keyword">new</span> MPI_Request[commCnt];
00257       MPI_Status* statuses = <span class="keyword">new</span> MPI_Status[commCnt];
00258 
00259       commCnt = 0;
00260 
00261       <span class="comment">//First place all recv requests. Do not recv from self.</span>
00262       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
00263         <span class="keywordflow">if</span>(recvcnts[i] &gt; 0) {
00264           par::Mpi_Irecv&lt;T&gt;( &amp;(recvbuf[rdispls[i]]) , recvcnts[i], i, 1,
00265               comm, &amp;(requests[commCnt]) );
00266           commCnt++;
00267         }
00268       }
00269 
00270       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
00271         <span class="keywordflow">if</span>(recvcnts[i] &gt; 0) {
00272           par::Mpi_Irecv&lt;T&gt;( &amp;(recvbuf[rdispls[i]]) , recvcnts[i], i, 1,
00273               comm, &amp;(requests[commCnt]) );
00274           commCnt++;
00275         }
00276       }
00277 
00278       <span class="comment">//Next send the messages. Do not send to self.</span>
00279       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
00280         <span class="keywordflow">if</span>(sendcnts[i] &gt; 0) {
00281           par::Mpi_Issend&lt;T&gt;( &amp;(sendbuf[sdispls[i]]), sendcnts[i], i, 1,
00282               comm, &amp;(requests[commCnt]) );
00283           commCnt++;
00284         }
00285       }
00286 
00287       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
00288         <span class="keywordflow">if</span>(sendcnts[i] &gt; 0) {
00289           par::Mpi_Issend&lt;T&gt;( &amp;(sendbuf[sdispls[i]]), sendcnts[i], 
00290               i, 1, comm, &amp;(requests[commCnt]) );
00291           commCnt++;
00292         }
00293       }
00294 
00295       <span class="comment">//Now copy local portion.</span>
00296 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
00297 <span class="preprocessor"></span>      assert(sendcnts[rank] == recvcnts[rank]);
00298 <span class="preprocessor">#endif</span>
00299 <span class="preprocessor"></span>
00300       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; sendcnts[rank]; i++) {
00301         recvbuf[rdispls[rank] + i] = sendbuf[sdispls[rank] + i];
00302       }
00303 
00304       <a class="code" href="parUtils_8h.html#a2">PROF_A2AV_WAIT_BEGIN</a>
00305 
00306         MPI_Waitall(commCnt, requests, statuses);
00307 
00308       <a class="code" href="parUtils_8h.html#a22">PROF_A2AV_WAIT_END</a>
00309 
00310         <span class="keyword">delete</span> [] requests;
00311       <span class="keyword">delete</span> [] statuses;
00312 
00313       <a class="code" href="parUtils_8h.html#a36">PROF_PAR_ALL2ALLV_SPARSE_END</a>
00314     }
00315 
00316   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00317"></a><a class="code" href="namespacepar.html#a18">00317</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a18">Mpi_Alltoallv_dense</a>(T* sendbuf, <span class="keywordtype">int</span>* sendcnts, <span class="keywordtype">int</span>* sdispls, 
00318         T* recvbuf, <span class="keywordtype">int</span>* recvcnts, <span class="keywordtype">int</span>* rdispls, MPI_Comm comm) {
00319 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00320 <span class="preprocessor"></span>      MPI_Barrier(comm);
00321 <span class="preprocessor">#endif</span>
00322 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a17">PROF_PAR_ALL2ALLV_DENSE_BEGIN</a>
00323 
00324         <span class="keywordtype">int</span> npes, rank;
00325       MPI_Comm_size(comm, &amp;npes);
00326       MPI_Comm_rank(comm, &amp;rank);
00327 
00328       <span class="comment">//Processors may send a lot of information to themselves and a lesser</span>
00329       <span class="comment">//amount to others. If so, we don't want to waste communication by</span>
00330       <span class="comment">//including the local copy size in the max message size. </span>
00331       <span class="keywordtype">int</span> maxNumElemSend = 0;
00332       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
00333         <span class="keywordflow">if</span>(sendcnts[i] &gt; maxNumElemSend) {
00334           maxNumElemSend = sendcnts[i];
00335         }
00336       }
00337 
00338       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
00339         <span class="keywordflow">if</span>(sendcnts[i] &gt; maxNumElemSend) {
00340           maxNumElemSend = sendcnts[i];
00341         }
00342       }
00343 
00344       <span class="keywordtype">int</span> allToAllCount;
00345       par::Mpi_Allreduce&lt;int&gt;(&amp;maxNumElemSend, &amp;allToAllCount, 1, MPI_MAX, comm);
00346 
00347       T* tmpSendBuf = <span class="keyword">new</span> T[allToAllCount*npes];
00348       T* tmpRecvBuf = <span class="keyword">new</span> T[allToAllCount*npes];
00349 
00350       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
00351         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; sendcnts[i]; j++) {
00352           tmpSendBuf[(allToAllCount*i) + j] = sendbuf[sdispls[i] + j];            
00353         }
00354       }
00355 
00356       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
00357         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; sendcnts[i]; j++) {
00358           tmpSendBuf[(allToAllCount*i) + j] = sendbuf[sdispls[i] + j];            
00359         }
00360       }
00361 
00362       par::Mpi_Alltoall&lt;T&gt;(tmpSendBuf, tmpRecvBuf, allToAllCount, comm);
00363 
00364       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
00365         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; recvcnts[i]; j++) {
00366           recvbuf[rdispls[i] + j] = tmpRecvBuf[(allToAllCount*i) + j];      
00367         }
00368       }
00369 
00370       <span class="comment">//Now copy local portion.</span>
00371 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
00372 <span class="preprocessor"></span>      assert(sendcnts[rank] == recvcnts[rank]);
00373 <span class="preprocessor">#endif</span>
00374 <span class="preprocessor"></span>
00375       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; recvcnts[rank]; j++) {
00376         recvbuf[rdispls[rank] + j] = sendbuf[sdispls[rank] + j];      
00377       }
00378 
00379       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
00380         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; recvcnts[i]; j++) {
00381           recvbuf[rdispls[i] + j] = tmpRecvBuf[(allToAllCount*i) + j];      
00382         }
00383       }
00384 
00385       <span class="keyword">delete</span> [] tmpSendBuf;
00386       <span class="keyword">delete</span> [] tmpRecvBuf;
00387 
00388       <a class="code" href="parUtils_8h.html#a37">PROF_PAR_ALL2ALLV_DENSE_END</a>
00389     }
00390 
00391   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00392"></a><a class="code" href="namespacepar.html#a21">00392</a>     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a21">defaultWeight</a>(<span class="keyword">const</span> T *a){
00393       <span class="keywordflow">return</span> 1;
00394     }
00395 
00396   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 
<a name="l00397"></a><a class="code" href="namespacepar.html#a19">00397</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a19">scatterValues</a>(std::vector&lt;T&gt; &amp; in, std::vector&lt;T&gt; &amp; out, 
00398         DendroIntL outSz, MPI_Comm comm ) {
00399 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00400 <span class="preprocessor"></span>      MPI_Barrier(comm);
00401 <span class="preprocessor">#endif</span>
00402 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a6">PROF_PAR_SCATTER_BEGIN</a>
00403 
00404         <span class="keywordtype">int</span> rank, npes;
00405 
00406       MPI_Comm_size(comm, &amp;npes);
00407       MPI_Comm_rank(comm, &amp;rank);
00408 
00409       MPI_Request request;
00410       MPI_Status status;
00411 
00412       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> inSz = in.size();
00413       out.resize(outSz);
00414 
00415       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> off1 = 0, off2 = 0;
00416       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> * scnIn = NULL;
00417       <span class="keywordflow">if</span>(inSz) {  
00418         scnIn = <span class="keyword">new</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a> [inSz]; 
00419       }
00420 
00421       <span class="comment">// perform a local scan first ...</span>
00422       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> zero = 0;
00423       <span class="keywordflow">if</span>(inSz) {
00424         scnIn[0] = 1;
00425         <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 1; i &lt; inSz; i++) {
00426           scnIn[i] = scnIn[i-1] + 1;
00427         }<span class="comment">//end for</span>
00428         <span class="comment">// now scan with the final members of </span>
00429         par::Mpi_Scan&lt;DendroIntL&gt;(scnIn+inSz-1, &amp;off1, 1, MPI_SUM, comm ); 
00430       } <span class="keywordflow">else</span>{
00431         par::Mpi_Scan&lt;DendroIntL&gt;(&amp;zero, &amp;off1, 1, MPI_SUM, comm ); 
00432       }
00433 
00434       <span class="comment">// communicate the offsets ...</span>
00435       <span class="keywordflow">if</span> (rank &lt; (npes-1)){
00436         par::Mpi_Issend&lt;DendroIntL&gt;( &amp;off1, 1, (rank + 1), 0, comm, &amp;request );
00437       }
00438       <span class="keywordflow">if</span> (rank){
00439         par::Mpi_Recv&lt;DendroIntL&gt;( &amp;off2, 1, (rank - 1), 0, comm, &amp;status );
00440       } <span class="keywordflow">else</span>{
00441         off2 = 0; 
00442       }
00443 
00444       <span class="comment">// add offset to local array</span>
00445       <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 0; i &lt; inSz; i++) {
00446         scnIn[i] = scnIn[i] + off2;  <span class="comment">// This has the global scan results now ...</span>
00447       }<span class="comment">//end for</span>
00448 
00449       <span class="comment">//Gather Scan of outCnts</span>
00450       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> *outCnts;
00451       outCnts = <span class="keyword">new</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a>[npes];
00452 
00453       <span class="keywordflow">if</span>(rank &lt; (npes-1)) {
00454         MPI_Status statusWait;
00455         MPI_Wait(&amp;request,&amp;statusWait);
00456       }
00457 
00458       <span class="keywordflow">if</span>( outSz ) {
00459         par::Mpi_Scan&lt;DendroIntL&gt;( &amp;outSz, &amp;off1, 1, MPI_SUM, comm ); 
00460       }<span class="keywordflow">else</span> {
00461         par::Mpi_Scan&lt;DendroIntL&gt;( &amp;zero, &amp;off1, 1, MPI_SUM, comm ); 
00462       }
00463 
00464       par::Mpi_Allgather&lt;DendroIntL&gt;( &amp;off1, outCnts, 1, comm);
00465 
00466       <span class="keywordtype">int</span> * sendSz = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
00467       <span class="keywordtype">int</span> * recvSz = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
00468       <span class="keywordtype">int</span> * sendOff = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
00469       <span class="keywordtype">int</span> * recvOff = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
00470 
00471       <span class="comment">// compute the partition offsets and sizes so that All2Allv can be performed.</span>
00472       <span class="comment">// initialize ...</span>
00473       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00474         sendSz[i] = 0;
00475       }
00476 
00477       <span class="comment">//The Heart of the algorithm....</span>
00478       <span class="comment">//scnIn and outCnts are both sorted </span>
00479       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> inCnt = 0;
00480       <span class="keywordtype">int</span> pCnt = 0;
00481       <span class="keywordflow">while</span>( (inCnt &lt; inSz) &amp;&amp; (pCnt &lt; npes) ) {
00482         <span class="keywordflow">if</span>( scnIn[inCnt] &lt;= outCnts[pCnt]  ) {
00483           sendSz[pCnt]++;
00484           inCnt++;
00485         }<span class="keywordflow">else</span> {
00486           pCnt++;
00487         }
00488       }
00489 
00490       <span class="comment">// communicate with other procs how many you shall be sending and get how</span>
00491       <span class="comment">// many to recieve from whom.</span>
00492       par::Mpi_Alltoall&lt;int&gt;(sendSz, recvSz, 1, comm);
00493 
00494       <span class="keywordtype">int</span> nn=0; <span class="comment">// new value of nlSize, ie the local nodes.</span>
00495       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;npes; i++) {
00496         nn += recvSz[i];
00497       }
00498 
00499       <span class="comment">// compute offsets ...</span>
00500       sendOff[0] = 0;
00501       recvOff[0] = 0;
00502       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=1; i&lt;npes; i++) {
00503         sendOff[i] = sendOff[i-1] + sendSz[i-1];
00504         recvOff[i] = recvOff[i-1] + recvSz[i-1];
00505       }
00506 
00507       assert(static_cast&lt;unsigned int&gt;(nn) == outSz);
00508       <span class="comment">// perform All2All  ... </span>
00509       T* inPtr = NULL;
00510       T* outPtr = NULL;
00511       <span class="keywordflow">if</span>(!in.empty()) {
00512         inPtr = &amp;(*(in.begin()));
00513       }
00514       <span class="keywordflow">if</span>(!out.empty()) {
00515         outPtr = &amp;(*(out.begin()));
00516       }
00517       par::Mpi_Alltoallv_sparse&lt;T&gt;(inPtr, sendSz, sendOff, 
00518           outPtr, recvSz, recvOff, comm);
00519 
00520       <span class="comment">// clean up...</span>
00521       <span class="keywordflow">if</span>(scnIn) {
00522         <span class="keyword">delete</span> [] scnIn;
00523         scnIn = NULL;
00524       }
00525 
00526       <span class="keyword">delete</span> [] outCnts;
00527       outCnts = NULL;
00528 
00529       <span class="keyword">delete</span> [] sendSz;
00530       sendSz = NULL;
00531 
00532       <span class="keyword">delete</span> [] sendOff;
00533       sendOff = NULL;
00534 
00535       <span class="keyword">delete</span> [] recvSz;
00536       recvSz = NULL;
00537 
00538       <span class="keyword">delete</span> [] recvOff;
00539       recvOff = NULL;
00540 
00541       <a class="code" href="parUtils_8h.html#a26">PROF_PAR_SCATTER_END</a>
00542     }
00543 
00544 
00545   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00546"></a><a class="code" href="namespacepar.html#a23">00546</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a23">concatenate</a>(std::vector&lt;T&gt; &amp; listA, std::vector&lt;T&gt; &amp; listB,
00547         MPI_Comm comm) {
00548 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00549 <span class="preprocessor"></span>      MPI_Barrier(comm);
00550 <span class="preprocessor">#endif</span>
00551 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a18">PROF_PAR_CONCAT_BEGIN</a>
00552 
00553         <span class="keywordtype">int</span> rank;
00554       <span class="keywordtype">int</span> npes;
00555 
00556       MPI_Comm_rank(comm, &amp;rank);
00557       MPI_Comm_size(comm, &amp;npes);
00558 
00559       assert(!(listA.empty()));
00560 
00561       <span class="comment">//1. First perform Allreduce to get total listA size</span>
00562       <span class="comment">//and total listB size; </span>
00563 
00564       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> locAsz_locBsz[2];
00565       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> globAsz_globBsz[2];
00566 
00567       locAsz_locBsz[0] = listA.size();
00568       locAsz_locBsz[1] = listB.size();
00569       globAsz_globBsz[0] = 0;
00570       globAsz_globBsz[1] = 0;
00571 
00572       par::Mpi_Allreduce&lt;DendroIntL&gt;(locAsz_locBsz, globAsz_globBsz, 2, MPI_SUM, comm);
00573 
00574       <span class="comment">//2. Re-distribute A and B independently so that</span>
00575       <span class="comment">//B is distributed only on the high rank processors</span>
00576       <span class="comment">//and A is distribute only on the low rank processors.</span>
00577 
00578       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgTotalSize = ((globAsz_globBsz[0] + globAsz_globBsz[1])/npes);
00579 
00580       <span class="comment">//since listA is not empty on any of the active procs,</span>
00581       <span class="comment">//globASz &gt; npes so avgTotalSize &gt;= 1</span>
00582 
00583       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> remTotalSize = ((globAsz_globBsz[0] + globAsz_globBsz[1])%npes);
00584 
00585       <span class="keywordtype">int</span> numSmallProcs = (npes - remTotalSize);
00586 
00587       <span class="comment">//In the final merged list, there will be exactly remTotalSize number</span>
00588       <span class="comment">//of processors each having (avgTotalSize + 1) elements and there will</span>
00589       <span class="comment">//be exactly numSmallProcs number of processors each having</span>
00590       <span class="comment">//avgTotalSize elements. </span>
00591       <span class="comment">//Also, len(A) + len(B) = (numSmallProcs*avg) + (remTotalSize*(avg+1))</span>
00592 
00593       std::vector&lt;T&gt; tmpA;
00594       std::vector&lt;T&gt; tmpB;
00595 
00596       <span class="keywordtype">int</span> numAhighProcs;
00597       <span class="keywordtype">int</span> numAlowProcs;
00598       <span class="keywordtype">int</span> numBothProcs;
00599       <span class="keywordtype">int</span> numBhighProcs;
00600       <span class="keywordtype">int</span> numBlowProcs;
00601       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> aSizeForBoth;
00602       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> bSizeForBoth;
00603 
00604       <span class="keywordflow">if</span>( globAsz_globBsz[1] &lt;= (numSmallProcs*avgTotalSize) ) {
00605         numBhighProcs = 0;
00606         numBlowProcs = ((globAsz_globBsz[1])/avgTotalSize); 
00607         bSizeForBoth = ((globAsz_globBsz[1])%avgTotalSize);
00608 
00609         assert(numBlowProcs &lt;= numSmallProcs);
00610 
00611         <span class="comment">//remBsize is &lt; avgTotalSize. So it will fit on one proc.</span>
00612         <span class="keywordflow">if</span>(bSizeForBoth) {
00613           numBothProcs = 1;
00614           <span class="keywordflow">if</span>(numBlowProcs &lt; numSmallProcs) {
00615             <span class="comment">//We don't know if remTotalSize is 0 or not. </span>
00616             <span class="comment">//So, let the common proc be a low proc.</span>
00617             aSizeForBoth = (avgTotalSize - bSizeForBoth);
00618             numAhighProcs = remTotalSize;
00619             numAlowProcs = (numSmallProcs - (1 + numBlowProcs));
00620           } <span class="keywordflow">else</span> {             
00621             <span class="comment">//No more room for small procs. The common has to be a high proc.</span>
00622             aSizeForBoth = ((avgTotalSize + 1) - bSizeForBoth);
00623             numAhighProcs = (remTotalSize - 1);
00624             numAlowProcs = 0;
00625           }
00626         } <span class="keywordflow">else</span> {
00627           numBothProcs = 0;
00628           aSizeForBoth = 0;
00629           numAhighProcs = remTotalSize;
00630           numAlowProcs = (numSmallProcs - numBlowProcs);
00631         }
00632       } <span class="keywordflow">else</span> {
00633         <span class="comment">//Some B procs will have (avgTotalSize+1) elements</span>
00634         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> numBusingAvgPlus1 = ((globAsz_globBsz[1])/(avgTotalSize + 1));
00635         <a class="code" href="dendro_8h.html#a0">DendroIntL</a> remBusingAvgPlus1 = ((globAsz_globBsz[1])%(avgTotalSize + 1));
00636         <span class="keywordflow">if</span> (numBusingAvgPlus1 &lt;= remTotalSize) {
00637           <span class="comment">//Each block can use (avg+1) elements each, since there will be some</span>
00638           <span class="comment">//remaining for A  </span>
00639           numBhighProcs = numBusingAvgPlus1;
00640           numBlowProcs = 0;
00641           bSizeForBoth = remBusingAvgPlus1;
00642           <span class="keywordflow">if</span>(bSizeForBoth) {
00643             numBothProcs = 1;
00644             <span class="keywordflow">if</span> (numBhighProcs &lt; remTotalSize) {
00645               <span class="comment">//We don't know if numSmallProcs is 0 or not.</span>
00646               <span class="comment">//So, let the common proc be a high proc </span>
00647               aSizeForBoth = ((avgTotalSize + 1) - bSizeForBoth);
00648               numAhighProcs = (remTotalSize - (numBhighProcs + 1));
00649               numAlowProcs = numSmallProcs;
00650             } <span class="keywordflow">else</span> {
00651               <span class="comment">//No more room for high procs. The common has to be a low proc. </span>
00652               aSizeForBoth = (avgTotalSize - bSizeForBoth);
00653               numAhighProcs = 0;
00654               numAlowProcs = (numSmallProcs - 1);
00655             }
00656           } <span class="keywordflow">else</span> {
00657             numBothProcs = 0;
00658             aSizeForBoth = 0;
00659             numAhighProcs = (remTotalSize - numBhighProcs);
00660             numAlowProcs = numSmallProcs;
00661           }
00662         } <span class="keywordflow">else</span> {
00663           <span class="comment">//Since numBusingAvgPlus1 &gt; remTotalSize*(avg+1) </span>
00664           <span class="comment">//=&gt; len(B) &gt; remTotalSize*(avg+1)</span>
00665           <span class="comment">//=&gt; len(A) &lt; numSmallProcs*avg</span>
00666           <span class="comment">//This is identical to the first case (except for </span>
00667           <span class="comment">//the equality), with A and B swapped.</span>
00668 
00669           assert( globAsz_globBsz[0] &lt; (numSmallProcs*avgTotalSize) );
00670 
00671           numAhighProcs = 0;
00672           numAlowProcs = ((globAsz_globBsz[0])/avgTotalSize); 
00673           aSizeForBoth = ((globAsz_globBsz[0])%avgTotalSize);
00674 
00675           assert(numAlowProcs &lt; numSmallProcs);
00676 
00677           <span class="comment">//remAsize is &lt; avgTotalSize. So it will fit on one proc.</span>
00678           <span class="keywordflow">if</span>(aSizeForBoth) {
00679             numBothProcs = 1;
00680             <span class="comment">//We don't know if remTotalSize is 0 or not. </span>
00681             <span class="comment">//So, let the common proc be a low proc.</span>
00682             bSizeForBoth = (avgTotalSize - aSizeForBoth);
00683             numBhighProcs = remTotalSize;
00684             numBlowProcs = (numSmallProcs - (1 + numAlowProcs));
00685           } <span class="keywordflow">else</span> {
00686             numBothProcs = 0;
00687             bSizeForBoth = 0;
00688             numBhighProcs = remTotalSize;
00689             numBlowProcs = (numSmallProcs - numAlowProcs);
00690           }
00691         }
00692       }
00693 
00694       assert((numAhighProcs + numAlowProcs + numBothProcs
00695             + numBhighProcs + numBlowProcs) == npes);
00696 
00697       assert((aSizeForBoth + bSizeForBoth) &lt;= (avgTotalSize+1));
00698 
00699       <span class="keywordflow">if</span>(numBothProcs) {
00700         assert((aSizeForBoth + bSizeForBoth) &gt;= avgTotalSize);
00701       } <span class="keywordflow">else</span> {
00702         assert(aSizeForBoth == 0); 
00703         assert(bSizeForBoth == 0); 
00704       }
00705 
00706       <span class="keywordflow">if</span>((aSizeForBoth + bSizeForBoth) == (avgTotalSize + 1)) {
00707         assert((numAhighProcs + numBothProcs + numBhighProcs) == remTotalSize);
00708         assert((numAlowProcs + numBlowProcs) == numSmallProcs);
00709       } <span class="keywordflow">else</span> {
00710         assert((numAhighProcs + numBhighProcs) == remTotalSize);
00711         assert((numAlowProcs + numBothProcs + numBlowProcs) == numSmallProcs);
00712       }
00713 
00714       <span class="comment">//The partition is as follow:</span>
00715       <span class="comment">//1. numAhighProcs with (avg+1) elements each exclusively from A,</span>
00716       <span class="comment">//2. numAlowProcs with avg elements each exclusively from A</span>
00717       <span class="comment">//3. numBothProcs with aSizeForBoth elements from A and</span>
00718       <span class="comment">// bSizeForBoth elements from B</span>
00719       <span class="comment">//4. numBhighProcs with (avg+1) elements each exclusively from B.</span>
00720       <span class="comment">//5. numBlowProcs with avg elements each exclusively from B.</span>
00721 
00722       <span class="keywordflow">if</span>(rank &lt; numAhighProcs) {
00723         par::scatterValues&lt;T&gt;(listA, tmpA, (avgTotalSize + 1), comm);
00724         par::scatterValues&lt;T&gt;(listB, tmpB, 0, comm);
00725       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rank &lt; (numAhighProcs + numAlowProcs)) {
00726         par::scatterValues&lt;T&gt;(listA, tmpA, avgTotalSize, comm);
00727         par::scatterValues&lt;T&gt;(listB, tmpB, 0, comm);
00728       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rank &lt; (numAhighProcs + numAlowProcs + numBothProcs)) {
00729         par::scatterValues&lt;T&gt;(listA, tmpA, aSizeForBoth, comm);
00730         par::scatterValues&lt;T&gt;(listB, tmpB, bSizeForBoth, comm);
00731       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (rank &lt;
00732           (numAhighProcs + numAlowProcs + numBothProcs + numBhighProcs)) {
00733         par::scatterValues&lt;T&gt;(listA, tmpA, 0, comm);
00734         par::scatterValues&lt;T&gt;(listB, tmpB, (avgTotalSize + 1), comm);
00735       } <span class="keywordflow">else</span> {
00736         par::scatterValues&lt;T&gt;(listA, tmpA, 0, comm);
00737         par::scatterValues&lt;T&gt;(listB, tmpB, avgTotalSize, comm);
00738       }
00739 
00740       listA = tmpA;
00741       listB = tmpB;
00742       tmpA.clear();
00743       tmpB.clear();
00744 
00745       <span class="comment">//3. Finally do a simple concatenation A = A + B. If the previous step</span>
00746       <span class="comment">//was performed correctly, there will be atmost 1 processor, which has both</span>
00747       <span class="comment">//non-empty A and non-empty B. On other processors one of the two lists</span>
00748       <span class="comment">//will be empty</span>
00749       <span class="keywordflow">if</span>(listA.empty()) {
00750         listA = listB;
00751       } <span class="keywordflow">else</span> {
00752         <span class="keywordflow">if</span>(!(listB.empty())) {
00753           listA.insert(listA.end(), listB.begin(), listB.end());
00754         }
00755       }
00756 
00757       listB.clear();
00758 
00759       <a class="code" href="parUtils_8h.html#a38">PROF_PAR_CONCAT_END</a>
00760     }
00761 
00762   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00763"></a><a class="code" href="namespacepar.html#a20">00763</a>     <span class="keywordtype">int</span> <a class="code" href="namespaceseq.html#a4">maxLowerBound</a>(<span class="keyword">const</span> std::vector&lt;T&gt; &amp; keys, <span class="keyword">const</span> std::vector&lt;T&gt; &amp; searchList,
00764         std::vector&lt;T&gt; &amp; results, MPI_Comm comm) {
00765       <a class="code" href="parUtils_8h.html#a5">PROF_SEARCH_BEGIN</a>
00766 
00767         <span class="keywordtype">int</span> rank, npes;
00768 
00769       MPI_Comm_size(comm, &amp;npes);
00770       MPI_Comm_rank(comm, &amp;rank);
00771 
00772       <span class="comment">// allocate memory for the mins array</span>
00773       std::vector&lt;T&gt; mins (npes);
00774       assert(!searchList.empty());
00775 
00776       T* searchListPtr = NULL;
00777       T* minsPtr = NULL;
00778       <span class="keywordflow">if</span>(!searchList.empty()) {
00779         searchListPtr = &amp;(*(searchList.begin()));
00780       }
00781       <span class="keywordflow">if</span>(!mins.empty()) {
00782         minsPtr = &amp;(*(mins.begin()));
00783       }
00784       par::Mpi_Allgather&lt;T&gt;(searchListPtr, minsPtr, 1, comm);
00785 
00786       <span class="comment">//For each key decide which processor to send to</span>
00787       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *part = NULL;
00788 
00789       <span class="keywordflow">if</span>(keys.size()) {
00790         part = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keys.size()];
00791       }
00792 
00793       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keys.size(); i++ ) {
00794         <span class="comment">//maxLB returns the smallest index in a sorted array such</span>
00795         <span class="comment">//that a[ind] &lt;= key and  a[index +1] &gt; key</span>
00796         <span class="keywordtype">bool</span> found = par::maxLowerBound&lt;T&gt;(mins,keys[i], part+i,NULL,NULL);
00797         <span class="keywordflow">if</span> ( !found ) {
00798           <span class="comment">//This key is smaller than the mins from every processor.</span>
00799           <span class="comment">//No point in searching.</span>
00800           part[i] = rank;
00801         }
00802       }
00803 
00804       mins.clear();
00805 
00806       <span class="keywordtype">int</span> *numKeysSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00807       <span class="keywordtype">int</span> *numKeysRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00808 
00809 
00810       <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;npes; i++ ) {
00811         numKeysSend[i] = 0;
00812       }
00813 
00814       <span class="comment">// calculate the number of keys to send ...</span>
00815       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;keys.size(); i++ ) {
00816         numKeysSend[part[i]]++;
00817       }
00818 
00819       <span class="comment">// Now do an All2All to get numKeysRecv</span>
00820       par::Mpi_Alltoall&lt;int&gt;(numKeysSend, numKeysRecv, 1, comm);
00821 
00822       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalKeys=0; <span class="comment">// total number of local keys ...</span>
00823       <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=0; i&lt;npes; i++ ) {
00824         totalKeys += numKeysRecv[i];
00825       }
00826 
00827       <span class="comment">// create the send and recv buffers ...</span>
00828       std::vector&lt;T&gt; sendK (keys.size());
00829       std::vector&lt;T&gt; recvK (totalKeys);
00830 
00831       <span class="comment">// the mapping ..</span>
00832       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * comm_map = NULL;
00833 
00834       <span class="keywordflow">if</span>(keys.size()) {
00835         comm_map = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> [keys.size()];
00836       }
00837 
00838       <span class="comment">// Now create sendK</span>
00839       <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; sendOffsets[0] = 0;
00840       <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; recvOffsets[0] = 0;
00841       <span class="keywordtype">int</span> *numKeysTmp = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; numKeysTmp[0] = 0; 
00842 
00843       <span class="comment">// compute offsets ...</span>
00844       <span class="keywordflow">for</span> ( <span class="keywordtype">int</span> i=1; i&lt;npes; i++ ) {
00845         sendOffsets[i] = sendOffsets[i-1] + numKeysSend[i-1];
00846         recvOffsets[i] = recvOffsets[i-1] + numKeysRecv[i-1];
00847         numKeysTmp[i] = 0; 
00848       }
00849 
00850       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt; keys.size(); i++ ) {
00851         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmp[part[i]];
00852         numKeysTmp[part[i]]++;
00853         <span class="comment">// set entry ...</span>
00854         sendK[sendOffsets[part[i]] + ni] = keys[i];
00855         <span class="comment">// save mapping .. will need it later ...</span>
00856         comm_map[i] = sendOffsets[part[i]] + ni;
00857       }
00858 
00859       <span class="keywordflow">if</span>(part) {
00860         <span class="keyword">delete</span> [] part;
00861       }
00862 
00863       <span class="keyword">delete</span> [] numKeysTmp;
00864       numKeysTmp = NULL;
00865 
00866       T* sendKptr = NULL;
00867       T* recvKptr = NULL;
00868       <span class="keywordflow">if</span>(!sendK.empty()) {
00869         sendKptr = &amp;(*(sendK.begin()));
00870       }
00871       <span class="keywordflow">if</span>(!recvK.empty()) {
00872         recvKptr = &amp;(*(recvK.begin()));
00873       }
00874 
00875       par::Mpi_Alltoallv_sparse&lt;T&gt;(sendKptr, numKeysSend, sendOffsets, 
00876           recvKptr, numKeysRecv, recvOffsets, comm);
00877 
00878 
00879       std::vector&lt;T&gt;  resSend (totalKeys);
00880       std::vector&lt;T&gt;  resRecv (keys.size());
00881 
00882       <span class="comment">//Final local search.</span>
00883       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;totalKeys;i++) {
00884         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00885         <span class="keywordtype">bool</span> found = par::maxLowerBound&lt;T&gt;( searchList, recvK[i], &amp;idx,NULL,NULL );
00886         <span class="keywordflow">if</span>(found) {
00887           resSend[i] = searchList[idx];
00888         }
00889       }<span class="comment">//end for i</span>
00890 
00891       <span class="comment">//Exchange Results</span>
00892       <span class="comment">//Return what you received in the earlier communication.</span>
00893       T* resSendPtr = NULL;
00894       T* resRecvPtr = NULL;
00895       <span class="keywordflow">if</span>(!resSend.empty()) {
00896         resSendPtr = &amp;(*(resSend.begin()));
00897       }
00898       <span class="keywordflow">if</span>(!resRecv.empty()) {
00899         resRecvPtr = &amp;(*(resRecv.begin()));
00900       }
00901       par::Mpi_Alltoallv_sparse&lt;T&gt;(resSendPtr, numKeysRecv, recvOffsets, 
00902           resRecvPtr, numKeysSend, sendOffsets, comm);
00903 
00904       <span class="keyword">delete</span> [] sendOffsets;
00905       sendOffsets = NULL;
00906 
00907       <span class="keyword">delete</span> [] recvOffsets;
00908       recvOffsets = NULL;
00909 
00910       <span class="keyword">delete</span> [] numKeysSend;
00911       numKeysSend = NULL;
00912 
00913       <span class="keyword">delete</span> [] numKeysRecv;
00914       numKeysRecv = NULL;
00915 
00916       <span class="keywordflow">for</span> ( <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i &lt; keys.size(); i++ ) {
00917         results[i] = resRecv[comm_map[i]];  
00918       }<span class="comment">//end for</span>
00919 
00920       <span class="comment">// Clean up ...</span>
00921       <span class="keywordflow">if</span>(comm_map) {
00922         <span class="keyword">delete</span> [] comm_map;
00923       }
00924 
00925       <a class="code" href="parUtils_8h.html#a25">PROF_SEARCH_END</a>
00926     }
00927 
00928   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l00929"></a><a class="code" href="namespacepar.html#a22">00929</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a22">partitionW</a>(std::vector&lt;T&gt;&amp; nodeList, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> (*getWeight)(<span class="keyword">const</span> T *), MPI_Comm comm){
00930 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
00931 <span class="preprocessor"></span>      MPI_Barrier(comm);
00932 <span class="preprocessor">#endif</span>
00933 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a21">PROF_PARTW_BEGIN</a>
00934 
00935         <span class="keywordtype">int</span> npes;
00936 
00937       MPI_Comm_size(comm, &amp;npes);
00938 
00939       <span class="keywordflow">if</span>(npes == 1) {
00940         <a class="code" href="parUtils_8h.html#a41">PROF_PARTW_END</a>
00941       }
00942 
00943       <span class="keywordflow">if</span>(getWeight == NULL) {
00944         getWeight = par::defaultWeight&lt;T&gt;;
00945       }
00946 
00947       <span class="keywordtype">int</span> rank;
00948 
00949       MPI_Comm_rank(comm, &amp;rank);
00950 
00951       MPI_Request request;
00952       MPI_Status status;
00953       <span class="keyword">const</span> <span class="keywordtype">bool</span> nEmpty = nodeList.empty();
00954 
00955       <a class="code" href="dendro_8h.html#a0">DendroIntL</a>  off1= 0, off2= 0, localWt= 0, totalWt = 0;
00956 
00957       <a class="code" href="dendro_8h.html#a0">DendroIntL</a>* wts = NULL;
00958       <a class="code" href="dendro_8h.html#a0">DendroIntL</a>* lscn = NULL;
00959       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nlSize = nodeList.size();
00960       <span class="keywordflow">if</span>(nlSize) {
00961         wts = <span class="keyword">new</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a>[nlSize];
00962         lscn= <span class="keyword">new</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a>[nlSize]; 
00963       }
00964 
00965       <span class="comment">// First construct arrays of id and wts.</span>
00966       <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 0; i &lt; nlSize; i++) {
00967         wts[i] = (*getWeight)( &amp;(nodeList[i]) );
00968         localWt += wts[i];
00969       }
00970 
00971 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
00972 <span class="preprocessor"></span>      MPI_Barrier(comm);
00973       <span class="keywordflow">if</span>(!rank) {
00974         std::cout&lt;&lt;<span class="stringliteral">"Partition: Stage-1 passed."</span>&lt;&lt;std::endl;
00975       }
00976       MPI_Barrier(comm);
00977 <span class="preprocessor">#endif</span>
00978 <span class="preprocessor"></span>
00979       <span class="comment">// compute the total weight of the problem ...</span>
00980       par::Mpi_Allreduce&lt;DendroIntL&gt;(&amp;localWt, &amp;totalWt, 1, MPI_SUM, comm);
00981 
00982       <span class="comment">// perform a local scan on the weights first ...</span>
00983       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> zero = 0;
00984       <span class="keywordflow">if</span>(!nEmpty) {
00985         lscn[0]=wts[0];
00986         <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 1; i &lt; nlSize; i++) {
00987           lscn[i] = wts[i] + lscn[i-1];
00988         }<span class="comment">//end for</span>
00989         <span class="comment">// now scan with the final members of </span>
00990         par::Mpi_Scan&lt;DendroIntL&gt;(lscn+nlSize-1, &amp;off1, 1, MPI_SUM, comm ); 
00991       } <span class="keywordflow">else</span>{
00992         par::Mpi_Scan&lt;DendroIntL&gt;(&amp;zero, &amp;off1, 1, MPI_SUM, comm ); 
00993       }
00994 
00995       <span class="comment">// communicate the offsets ...</span>
00996       <span class="keywordflow">if</span> (rank &lt; (npes-1)){
00997         par::Mpi_Issend&lt;DendroIntL&gt;( &amp;off1, 1, rank+1, 0, comm, &amp;request );
00998       }
00999       <span class="keywordflow">if</span> (rank){
01000         par::Mpi_Recv&lt;DendroIntL&gt;( &amp;off2, 1, rank-1, 0, comm, &amp;status );
01001       }
01002       <span class="keywordflow">else</span>{
01003         off2 = 0; 
01004       }
01005 
01006       <span class="comment">// add offset to local array</span>
01007       <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 0; i &lt; nlSize; i++) {
01008         lscn[i] = lscn[i] + off2;       <span class="comment">// This has the global scan results now ...</span>
01009       }<span class="comment">//end for</span>
01010 
01011 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01012 <span class="preprocessor"></span>      MPI_Barrier(comm);
01013       <span class="keywordflow">if</span>(!rank) {
01014         std::cout&lt;&lt;<span class="stringliteral">"Partition: Stage-2 passed."</span>&lt;&lt;std::endl;
01015       }
01016       MPI_Barrier(comm);
01017 <span class="preprocessor">#endif</span>
01018 <span class="preprocessor"></span>
01019       <span class="keywordtype">int</span> * sendSz = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
01020       <span class="keywordtype">int</span> * recvSz = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes];
01021       <span class="keywordtype">int</span> * sendOff = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes]; sendOff[0] = 0;
01022       <span class="keywordtype">int</span> * recvOff = <span class="keyword">new</span> <span class="keywordtype">int</span> [npes]; recvOff[0] = 0;
01023 
01024       <span class="comment">// compute the partition offsets and sizes so that All2Allv can be performed.</span>
01025       <span class="comment">// initialize ...</span>
01026 
01027       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01028         sendSz[i] = 0;
01029       }
01030 
01031       <span class="comment">// Now determine the average load ...</span>
01032       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> npesLong = npes;
01033       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> avgLoad = (totalWt/npesLong);
01034 
01035       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> extra = (totalWt%npesLong);
01036 
01037       <span class="comment">//The Heart of the algorithm....</span>
01038       <span class="keywordflow">if</span>(avgLoad &gt; 0) {
01039         <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> i = 0; i &lt; nlSize; i++) {
01040           <span class="keywordflow">if</span>(lscn[i] == 0) {            
01041             sendSz[0]++;
01042           }<span class="keywordflow">else</span> {
01043             <span class="keywordtype">int</span> ind=0;
01044             <span class="keywordflow">if</span> ( lscn[i] &lt;= (extra*(avgLoad + 1)) ) {
01045               ind = ((lscn[i] - 1)/(avgLoad + 1));
01046             }<span class="keywordflow">else</span> {
01047               ind = ((lscn[i] - (1 + extra))/avgLoad);
01048             }
01049             assert(ind &lt; npes);
01050             sendSz[ind]++;
01051           }<span class="comment">//end if-else</span>
01052         }<span class="comment">//end for </span>
01053       }<span class="keywordflow">else</span> {
01054         sendSz[0]+= nlSize;
01055       }<span class="comment">//end if-else</span>
01056 
01057 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01058 <span class="preprocessor"></span>      MPI_Barrier(comm);
01059       <span class="keywordflow">if</span>(!rank) {
01060         std::cout&lt;&lt;<span class="stringliteral">"Partition: Stage-3 passed."</span>&lt;&lt;std::endl;
01061       }
01062       MPI_Barrier(comm);
01063 <span class="preprocessor">#endif</span>
01064 <span class="preprocessor"></span>
01065       <span class="keywordflow">if</span>(rank &lt; (npes-1)) {
01066         MPI_Status statusWait;
01067         MPI_Wait(&amp;request, &amp;statusWait);
01068       }
01069 
01070       <span class="comment">// communicate with other procs how many you shall be sending and get how</span>
01071       <span class="comment">// many to recieve from whom.</span>
01072       par::Mpi_Alltoall&lt;int&gt;(sendSz, recvSz, 1, comm);
01073 
01074 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01075 <span class="preprocessor"></span>      <a class="code" href="dendro_8h.html#a0">DendroIntL</a> totSendToOthers = 0;
01076       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> totRecvFromOthers = 0;
01077       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01078         <span class="keywordflow">if</span>(rank != i) {
01079           totSendToOthers += sendSz[i];
01080           totRecvFromOthers += recvSz[i];
01081         }
01082       }
01083 <span class="preprocessor">#endif</span>
01084 <span class="preprocessor"></span>
01085       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nn=0; <span class="comment">// new value of nlSize, ie the local nodes.</span>
01086       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01087         nn += recvSz[i];
01088       }
01089 
01090       <span class="comment">// compute offsets ...</span>
01091       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; npes; i++) {
01092         sendOff[i] = sendOff[i-1] + sendSz[i-1];
01093         recvOff[i] = recvOff[i-1] + recvSz[i-1];
01094       }
01095 
01096 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01097 <span class="preprocessor"></span>      MPI_Barrier(comm);
01098       <span class="keywordflow">if</span>(!rank) {
01099         std::cout&lt;&lt;<span class="stringliteral">"Partition: Stage-4 passed."</span>&lt;&lt;std::endl;
01100       }
01101       MPI_Barrier(comm);
01102       <span class="comment">/*</span>
01103 <span class="comment">         std::cout&lt;&lt;rank&lt;&lt;": newSize: "&lt;&lt;nn&lt;&lt;" oldSize: "&lt;&lt;(nodeList.size())</span>
01104 <span class="comment">         &lt;&lt;" send: "&lt;&lt;totSendToOthers&lt;&lt;" recv: "&lt;&lt;totRecvFromOthers&lt;&lt;std::endl;</span>
01105 <span class="comment">         */</span>
01106       MPI_Barrier(comm);
01107 <span class="preprocessor">#endif</span>
01108 <span class="preprocessor"></span>
01109       <span class="comment">// allocate memory for the new arrays ...</span>
01110       std::vector&lt;T &gt; newNodes(nn);
01111 
01112 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01113 <span class="preprocessor"></span>      MPI_Barrier(comm);
01114       <span class="keywordflow">if</span>(!rank) {
01115         std::cout&lt;&lt;<span class="stringliteral">"Partition: Final alloc successful."</span>&lt;&lt;std::endl;
01116       }
01117       MPI_Barrier(comm);
01118 <span class="preprocessor">#endif</span>
01119 <span class="preprocessor"></span>
01120       <span class="comment">// perform All2All  ... </span>
01121       T* nodeListPtr = NULL;
01122       T* newNodesPtr = NULL;
01123       <span class="keywordflow">if</span>(!nodeList.empty()) {
01124         nodeListPtr = &amp;(*(nodeList.begin()));
01125       }
01126       <span class="keywordflow">if</span>(!newNodes.empty()) {
01127         newNodesPtr = &amp;(*(newNodes.begin()));
01128       }
01129       par::Mpi_Alltoallv_sparse&lt;T&gt;(nodeListPtr, sendSz, sendOff, 
01130           newNodesPtr, recvSz, recvOff, comm);
01131 
01132 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01133 <span class="preprocessor"></span>      MPI_Barrier(comm);
01134       <span class="keywordflow">if</span>(!rank) {
01135         std::cout&lt;&lt;<span class="stringliteral">"Partition: Stage-5 passed."</span>&lt;&lt;std::endl;
01136       }
01137       MPI_Barrier(comm);
01138 <span class="preprocessor">#endif</span>
01139 <span class="preprocessor"></span>
01140       <span class="comment">// reset the pointer ...</span>
01141       nodeList = newNodes;
01142       newNodes.clear();
01143 
01144       <span class="comment">// clean up...</span>
01145       <span class="keywordflow">if</span>(!nEmpty) {
01146         <span class="keyword">delete</span> [] lscn;
01147         <span class="keyword">delete</span> [] wts;
01148       }
01149       <span class="keyword">delete</span> [] sendSz;
01150       sendSz = NULL;
01151 
01152       <span class="keyword">delete</span> [] sendOff;
01153       sendOff = NULL;
01154 
01155       <span class="keyword">delete</span> [] recvSz;
01156       recvSz = NULL;
01157 
01158       <span class="keyword">delete</span> [] recvOff;
01159       recvOff = NULL;
01160 
01161 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01162 <span class="preprocessor"></span>      MPI_Barrier(comm);
01163       <span class="keywordflow">if</span>(!rank) {
01164         std::cout&lt;&lt;<span class="stringliteral">"Partition: Stage-6 passed."</span>&lt;&lt;std::endl;
01165       }
01166       MPI_Barrier(comm);
01167 <span class="preprocessor">#endif</span>
01168 <span class="preprocessor"></span>
01169       <a class="code" href="parUtils_8h.html#a41">PROF_PARTW_END</a>
01170     }<span class="comment">//end function</span>
01171 
01172   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l01173"></a><a class="code" href="namespacepar.html#a25">01173</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a25">removeDuplicates</a>(std::vector&lt;T&gt;&amp; vecT, <span class="keywordtype">bool</span> isSorted, MPI_Comm comm){
01174 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
01175 <span class="preprocessor"></span>      MPI_Barrier(comm);
01176 <span class="preprocessor">#endif</span>
01177 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a20">PROF_REMDUP_BEGIN</a>
01178         <span class="keywordtype">int</span> size, rank;
01179       MPI_Comm_size(comm,&amp;size);
01180       MPI_Comm_rank(comm,&amp;rank);
01181 
01182       std::vector&lt;T&gt; tmpVec;
01183       <span class="keywordflow">if</span>(!isSorted) {           
01184         <span class="comment">//Sort partitions vecT and tmpVec internally.</span>
01185         par::sampleSort&lt;T&gt;(vecT, tmpVec, comm);                         
01186       }<span class="keywordflow">else</span> {
01187         tmpVec = vecT;
01188       }
01189 
01190 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01191 <span class="preprocessor"></span>      MPI_Barrier(comm);
01192       <span class="keywordflow">if</span>(!rank) {
01193         std::cout&lt;&lt;<span class="stringliteral">"RemDup: Stage-1 passed."</span>&lt;&lt;std::endl;
01194       }
01195       MPI_Barrier(comm);
01196 <span class="preprocessor">#endif</span>
01197 <span class="preprocessor"></span>
01198       vecT.clear();
01199       par::partitionW&lt;T&gt;(tmpVec, NULL, comm);
01200 
01201 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01202 <span class="preprocessor"></span>      MPI_Barrier(comm);
01203       <span class="keywordflow">if</span>(!rank) {
01204         std::cout&lt;&lt;<span class="stringliteral">"RemDup: Stage-2 passed."</span>&lt;&lt;std::endl;
01205       }
01206       MPI_Barrier(comm);
01207 <span class="preprocessor">#endif</span>
01208 <span class="preprocessor"></span>
01209       <span class="comment">//Remove duplicates locally</span>
01210       seq::makeVectorUnique&lt;T&gt;(tmpVec,<span class="keyword">true</span>); 
01211 
01212 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01213 <span class="preprocessor"></span>      MPI_Barrier(comm);
01214       <span class="keywordflow">if</span>(!rank) {
01215         std::cout&lt;&lt;<span class="stringliteral">"RemDup: Stage-3 passed."</span>&lt;&lt;std::endl;
01216       }
01217       MPI_Barrier(comm);
01218 <span class="preprocessor">#endif</span>
01219 <span class="preprocessor"></span>
01220       <span class="comment">//Creating groups</span>
01221 
01222       <span class="keywordtype">int</span> new_rank, new_size; 
01223       MPI_Comm   new_comm;
01224       <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(tmpVec.empty(), &amp;new_comm, comm);
01225 
01226       MPI_Comm_rank (new_comm, &amp;new_rank);
01227       MPI_Comm_size (new_comm, &amp;new_size);
01228 
01229 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01230 <span class="preprocessor"></span>      MPI_Barrier(comm);
01231       <span class="keywordflow">if</span>(!rank) {
01232         std::cout&lt;&lt;<span class="stringliteral">"RemDup: Stage-4 passed."</span>&lt;&lt;std::endl;
01233       }
01234       MPI_Barrier(comm);
01235 <span class="preprocessor">#endif</span>
01236 <span class="preprocessor"></span>
01237       <span class="comment">//Checking boundaries... </span>
01238       <span class="keywordflow">if</span>(!tmpVec.empty()) {
01239         T end = tmpVec[tmpVec.size()-1];          
01240         T endRecv;
01241 
01242         <span class="comment">//communicate end to the next processor.</span>
01243         MPI_Status status;
01244 
01245         par::Mpi_Sendrecv&lt;T, T&gt;(&amp;end, 1, ((new_rank &lt;(new_size-1))?(new_rank+1):0), 1, &amp;endRecv,
01246             1, ((new_rank &gt; 0)?(new_rank-1):(new_size-1)), 1, new_comm, &amp;status);
01247 
01248         <span class="comment">//Remove endRecv if it exists (There can be no more than one copy of this)</span>
01249         <span class="keywordflow">if</span>(new_rank) {
01250           <span class="keyword">typename</span> std::vector&lt;T&gt;::iterator Iter = find(tmpVec.begin(),tmpVec.end(),endRecv);
01251           <span class="keywordflow">if</span>(Iter != tmpVec.end()) {
01252             tmpVec.erase(Iter);
01253           }<span class="comment">//end if found    </span>
01254         }<span class="comment">//end if p not 0         </span>
01255       }<span class="comment">//end if not empty</span>
01256 
01257 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01258 <span class="preprocessor"></span>      MPI_Barrier(comm);
01259       <span class="keywordflow">if</span>(!rank) {
01260         std::cout&lt;&lt;<span class="stringliteral">"RemDup: Stage-5 passed."</span>&lt;&lt;std::endl;
01261       }
01262       MPI_Barrier(comm);
01263 <span class="preprocessor">#endif</span>
01264 <span class="preprocessor"></span>
01265       vecT = tmpVec;
01266       tmpVec.clear();
01267       par::partitionW&lt;T&gt;(vecT, NULL, comm);
01268 
01269 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01270 <span class="preprocessor"></span>      MPI_Barrier(comm);
01271       <span class="keywordflow">if</span>(!rank) {
01272         std::cout&lt;&lt;<span class="stringliteral">"RemDup: Stage-6 passed."</span>&lt;&lt;std::endl;
01273       }
01274       MPI_Barrier(comm);
01275 <span class="preprocessor">#endif</span>
01276 <span class="preprocessor"></span>
01277       <a class="code" href="parUtils_8h.html#a40">PROF_REMDUP_END</a>
01278     }<span class="comment">//end function</span>
01279 
01280   <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;
<a name="l01281"></a><a class="code" href="namespacepar.html#a24">01281</a>     <span class="keywordtype">int</span> <a class="code" href="namespacepar.html#a24">sampleSort</a>(std::vector&lt;T&gt;&amp; arr, std::vector&lt;T&gt; &amp; SortedElem, MPI_Comm comm){ 
01282 <span class="preprocessor">#ifdef __PROFILE_WITH_BARRIER__</span>
01283 <span class="preprocessor"></span>      MPI_Barrier(comm);
01284 <span class="preprocessor">#endif</span>
01285 <span class="preprocessor"></span>      <a class="code" href="parUtils_8h.html#a19">PROF_SORT_BEGIN</a>
01286 
01287         <span class="keywordtype">int</span> npes;
01288 
01289       MPI_Comm_size(comm, &amp;npes);
01290 
01291       <span class="keywordflow">if</span> (npes == 1) {
01292         std::cout &lt;&lt;<span class="stringliteral">" have to use seq. sort"</span>
01293           &lt;&lt;<span class="stringliteral">" since npes = 1 . inpSize: "</span>&lt;&lt;(arr.size()) &lt;&lt;std::endl;
01294         <a class="code" href="Sort_8h.html#a7">std::sort</a>(arr.begin(), arr.end());
01295         SortedElem  = arr;
01296         <a class="code" href="parUtils_8h.html#a39">PROF_SORT_END</a>
01297       } 
01298 
01299       std::vector&lt;T&gt;  splitters;
01300       std::vector&lt;T&gt;  allsplitters;
01301 
01302       <span class="keywordtype">int</span> myrank;
01303       MPI_Comm_rank(comm, &amp;myrank);
01304 
01305       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nelem = arr.size();
01306       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nelemCopy = nelem;
01307       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> totSize;
01308       par::Mpi_Allreduce&lt;DendroIntL&gt;(&amp;nelemCopy, &amp;totSize, 1, MPI_SUM, comm);
01309 
01310       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> npesLong = npes;
01311       <span class="keyword">const</span> <a class="code" href="dendro_8h.html#a0">DendroIntL</a> FIVE = 5;
01312 
01313       <span class="keywordflow">if</span>(totSize &lt; (FIVE*npesLong*npesLong)) {
01314         <span class="keywordflow">if</span>(!myrank) {
01315           std::cout &lt;&lt;<span class="stringliteral">" Using bitonic sort since totSize &lt; (5*(npes^2)). totSize: "</span>
01316             &lt;&lt;totSize&lt;&lt;<span class="stringliteral">" npes: "</span>&lt;&lt;npes &lt;&lt;std::endl;
01317         }
01318         par::partitionW&lt;T&gt;(arr, NULL, comm);
01319 
01320 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01321 <span class="preprocessor"></span>        MPI_Barrier(comm);
01322         <span class="keywordflow">if</span>(!myrank) {
01323           std::cout&lt;&lt;<span class="stringliteral">"SampleSort (small n): Stage-1 passed."</span>&lt;&lt;std::endl;
01324         }
01325         MPI_Barrier(comm);
01326 <span class="preprocessor">#endif</span>
01327 <span class="preprocessor"></span>
01328         SortedElem = arr; 
01329         MPI_Comm new_comm;
01330         <span class="keywordflow">if</span>(totSize &lt; npesLong) {
01331           <span class="keywordflow">if</span>(!myrank) {
01332             std::cout&lt;&lt;<span class="stringliteral">" Input to sort is small. splittingComm: "</span>
01333               &lt;&lt;npes&lt;&lt;<span class="stringliteral">" -&gt; "</span>&lt;&lt; totSize&lt;&lt;std::endl;
01334           }
01335           <a class="code" href="namespacepar.html#a3">par::splitCommUsingSplittingRank</a>(static_cast&lt;int&gt;(totSize), &amp;new_comm, comm);
01336         } <span class="keywordflow">else</span> {
01337           new_comm = comm;
01338         }
01339 
01340 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01341 <span class="preprocessor"></span>        MPI_Barrier(comm);
01342         <span class="keywordflow">if</span>(!myrank) {
01343           std::cout&lt;&lt;<span class="stringliteral">"SampleSort (small n): Stage-2 passed."</span>&lt;&lt;std::endl;
01344         }
01345         MPI_Barrier(comm);
01346 <span class="preprocessor">#endif</span>
01347 <span class="preprocessor"></span>
01348         <span class="keywordflow">if</span>(!SortedElem.empty()) {
01349           par::bitonicSort&lt;T&gt;(SortedElem, new_comm);
01350         }
01351 
01352 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01353 <span class="preprocessor"></span>        MPI_Barrier(comm);
01354         <span class="keywordflow">if</span>(!myrank) {
01355           std::cout&lt;&lt;<span class="stringliteral">"SampleSort (small n): Stage-3 passed."</span>&lt;&lt;std::endl;
01356         }
01357         MPI_Barrier(comm);
01358 <span class="preprocessor">#endif</span>
01359 <span class="preprocessor"></span>
01360         <a class="code" href="parUtils_8h.html#a39">PROF_SORT_END</a>
01361       }<span class="comment">// end if</span>
01362 
01363 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01364 <span class="preprocessor"></span>      <span class="keywordflow">if</span>(!myrank) {
01365         std::cout&lt;&lt;<span class="stringliteral">"Using sample sort to sort nodes. n/p^2 is fine."</span>&lt;&lt;std::endl;
01366       }
01367 <span class="preprocessor">#endif</span>
01368 <span class="preprocessor"></span>
01369       <span class="comment">//Re-part arr so that each proc. has atleast p elements.</span>
01370       par::partitionW&lt;T&gt;(arr, NULL, comm);
01371 
01372       nelem = arr.size();
01373 
01374       <a class="code" href="Sort_8h.html#a7">std::sort</a>(arr.begin(),arr.end());
01375 
01376       std::vector&lt;T&gt; sendSplits(npes-1);
01377       splitters.resize(npes);
01378 
01379       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; npes; i++)      {
01380         sendSplits[i-1] = arr[i*nelem/npes];    
01381       }<span class="comment">//end for i</span>
01382 
01383       <span class="comment">// sort sendSplits using bitonic ...</span>
01384       par::bitonicSort&lt;T&gt;(sendSplits,comm);
01385 
01386       <span class="comment">// All gather with last element of splitters.</span>
01387       T* sendSplitsPtr = NULL;
01388       T* splittersPtr = NULL;
01389       <span class="keywordflow">if</span>(sendSplits.size() &gt; static_cast&lt;unsigned int&gt;(npes-2)) {
01390         sendSplitsPtr = &amp;(*(sendSplits.begin() + (npes -2)));
01391       }
01392       <span class="keywordflow">if</span>(!splitters.empty()) {
01393         splittersPtr = &amp;(*(splitters.begin()));
01394       }
01395       par::Mpi_Allgather&lt;T&gt;(sendSplitsPtr, splittersPtr, 1, comm);
01396 
01397       sendSplits.clear();
01398 
01399       <span class="keywordtype">int</span> *sendcnts = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01400       <span class="keywordtype">int</span> * recvcnts = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01401       <span class="keywordtype">int</span> * sdispls = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01402       <span class="keywordtype">int</span> * rdispls = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01403 
01404       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; npes; k++){
01405         sendcnts[k] = 0;
01406       }
01407 
01408       <span class="keywordtype">int</span> k = 0;
01409 
01410       <span class="keywordflow">for</span> (<a class="code" href="dendro_8h.html#a0">DendroIntL</a> j = 0; j &lt; nelem; j++) {
01411         <span class="keywordflow">if</span> (arr[j] &lt;= splitters[k]) {
01412           sendcnts[k]++;
01413         } <span class="keywordflow">else</span>{
01414           k = seq::UpperBound&lt;T&gt;(npes-1, splittersPtr, k+1, arr[j]);
01415           <span class="keywordflow">if</span> (k == (npes-1) ){
01416             <span class="comment">//could not find any splitter &gt;= arr[j]</span>
01417             sendcnts[k] = (nelem - j);
01418             <span class="keywordflow">break</span>;
01419           } <span class="keywordflow">else</span> {
01420             assert(k &lt; (npes-1));
01421             assert(splitters[k] &gt;= arr[j]);
01422             sendcnts[k]++;
01423           }
01424         }<span class="comment">//end if-else</span>
01425       }<span class="comment">//end for j</span>
01426 
01427       par::Mpi_Alltoall&lt;int&gt;(sendcnts, recvcnts, 1, comm);
01428 
01429       sdispls[0] = 0; rdispls[0] = 0;
01430       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 1; j &lt; npes; j++){
01431         sdispls[j] = sdispls[j-1] + sendcnts[j-1];
01432         rdispls[j] = rdispls[j-1] + recvcnts[j-1];
01433       }
01434 
01435       <a class="code" href="dendro_8h.html#a0">DendroIntL</a> nsorted = rdispls[npes-1] + recvcnts[npes-1];
01436       SortedElem.resize(nsorted);
01437 
01438       T* arrPtr = NULL;
01439       T* SortedElemPtr = NULL;
01440       <span class="keywordflow">if</span>(!arr.empty()) {
01441         arrPtr = &amp;(*(arr.begin()));
01442       }
01443       <span class="keywordflow">if</span>(!SortedElem.empty()) {
01444         SortedElemPtr = &amp;(*(SortedElem.begin()));
01445       }
01446       par::Mpi_Alltoallv_sparse&lt;T&gt;(arrPtr, sendcnts, sdispls,
01447           SortedElemPtr, recvcnts, rdispls, comm);
01448 
01449       arr.clear();
01450 
01451       <span class="keyword">delete</span> [] sendcnts;
01452       sendcnts = NULL;
01453 
01454       <span class="keyword">delete</span> [] recvcnts;
01455       recvcnts = NULL;
01456 
01457       <span class="keyword">delete</span> [] sdispls;
01458       sdispls = NULL;
01459 
01460       <span class="keyword">delete</span> [] rdispls;
01461       rdispls = NULL;
01462 
01463       <a class="code" href="Sort_8h.html#a7">sort</a>(SortedElem.begin(), SortedElem.end());
01464 
01465       <a class="code" href="parUtils_8h.html#a39">PROF_SORT_END</a>
01466     }<span class="comment">//end function</span>
01467 
01468   <span class="comment">/********************************************************************/</span>
01469   <span class="comment">/*</span>
01470 <span class="comment">   * which_keys is one of KEEP_HIGH or KEEP_LOW</span>
01471 <span class="comment">   * partner    is the processor with which to Merge and Split.</span>
01472 <span class="comment">   *</span>
01473 <span class="comment">   */</span>
01474   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01475"></a><a class="code" href="namespacepar.html#a27">01475</a>     <span class="keywordtype">void</span> <a class="code" href="namespacepar.html#a27">MergeSplit</a>( std::vector&lt;T&gt; &amp;local_list, <span class="keywordtype">int</span> which_keys, <span class="keywordtype">int</span> partner, MPI_Comm  comm) {
01476 
01477       MPI_Status status;
01478       <span class="keywordtype">int</span> send_size = local_list.size();
01479       <span class="keywordtype">int</span> recv_size = 0;
01480 
01481       <span class="comment">// first communicate how many you will send and how many you will receive ...</span>
01482 
01483       par::Mpi_Sendrecv&lt;int, int&gt;( &amp;send_size , 1, partner, 0,
01484           &amp;recv_size, 1, partner, 0, comm, &amp;status);
01485 
01486       std::vector&lt;T&gt; temp_list( recv_size );
01487 
01488       T* local_listPtr = NULL;
01489       T* temp_listPtr = NULL;
01490       <span class="keywordflow">if</span>(!local_list.empty()) {
01491         local_listPtr = &amp;(*(local_list.begin()));
01492       }
01493       <span class="keywordflow">if</span>(!temp_list.empty()) {
01494         temp_listPtr = &amp;(*(temp_list.begin()));
01495       }
01496 
01497       par::Mpi_Sendrecv&lt;T, T&gt;( local_listPtr, send_size, partner,
01498           1, temp_listPtr, recv_size, partner, 1, comm, &amp;status);
01499 
01500       MergeLists&lt;T&gt;(local_list, temp_list, which_keys);
01501 
01502       temp_list.clear();
01503     } <span class="comment">// Merge_split </span>
01504 
01505   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01506"></a><a class="code" href="namespacepar.html#a28">01506</a>     <span class="keywordtype">void</span> <a class="code" href="namespacepar.html#a28">Par_bitonic_sort_incr</a>( std::vector&lt;T&gt; &amp;local_list, <span class="keywordtype">int</span> proc_set_size, MPI_Comm  comm ) {
01507       <span class="keywordtype">int</span>  eor_bit;
01508       <span class="keywordtype">int</span>       proc_set_dim;
01509       <span class="keywordtype">int</span>       stage;
01510       <span class="keywordtype">int</span>       partner;
01511       <span class="keywordtype">int</span>       my_rank;
01512 
01513       MPI_Comm_rank(comm, &amp;my_rank);
01514 
01515       proc_set_dim = 0;
01516       <span class="keywordtype">int</span> x = proc_set_size;
01517       <span class="keywordflow">while</span> (x &gt; 1) {
01518         x = x &gt;&gt; 1;
01519         proc_set_dim++;
01520       }
01521 
01522       eor_bit = (1 &lt;&lt; (proc_set_dim - 1) );
01523       <span class="keywordflow">for</span> (stage = 0; stage &lt; proc_set_dim; stage++) {
01524         partner = (my_rank ^ eor_bit);
01525 
01526         <span class="keywordflow">if</span> (my_rank &lt; partner) {
01527           MergeSplit&lt;T&gt; ( local_list,  KEEP_LOW, partner, comm);
01528         } <span class="keywordflow">else</span> {
01529           MergeSplit&lt;T&gt; ( local_list, KEEP_HIGH, partner, comm);
01530         }
01531 
01532         eor_bit = (eor_bit &gt;&gt; 1);
01533       }
01534     }  <span class="comment">// Par_bitonic_sort_incr </span>
01535 
01536 
01537   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01538"></a><a class="code" href="namespacepar.html#a29">01538</a>     <span class="keywordtype">void</span> <a class="code" href="namespacepar.html#a29">Par_bitonic_sort_decr</a>( std::vector&lt;T&gt; &amp;local_list, <span class="keywordtype">int</span> proc_set_size, MPI_Comm  comm) {
01539       <span class="keywordtype">int</span>  eor_bit;
01540       <span class="keywordtype">int</span>       proc_set_dim;
01541       <span class="keywordtype">int</span>       stage;
01542       <span class="keywordtype">int</span>       partner;
01543       <span class="keywordtype">int</span>       my_rank;
01544 
01545       MPI_Comm_rank(comm, &amp;my_rank);
01546 
01547       proc_set_dim = 0;
01548       <span class="keywordtype">int</span> x = proc_set_size;
01549       <span class="keywordflow">while</span> (x &gt; 1) {
01550         x = x &gt;&gt; 1;
01551         proc_set_dim++;
01552       }
01553 
01554       eor_bit = (1 &lt;&lt; (proc_set_dim - 1));
01555       <span class="keywordflow">for</span> (stage = 0; stage &lt; proc_set_dim; stage++) {
01556         partner = my_rank ^ eor_bit;
01557 
01558         <span class="keywordflow">if</span> (my_rank &gt; partner) {
01559           MergeSplit&lt;T&gt; ( local_list,  KEEP_LOW, partner, comm);
01560         } <span class="keywordflow">else</span> {
01561           MergeSplit&lt;T&gt; ( local_list, KEEP_HIGH, partner, comm);
01562         }
01563 
01564         eor_bit = (eor_bit &gt;&gt; 1);
01565       }
01566 
01567     } <span class="comment">// Par_bitonic_sort_decr </span>
01568 
01569   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01570"></a><a class="code" href="namespacepar.html#a30">01570</a>     <span class="keywordtype">void</span> <a class="code" href="namespacepar.html#a30">Par_bitonic_merge_incr</a>( std::vector&lt;T&gt; &amp;local_list, <span class="keywordtype">int</span> proc_set_size, MPI_Comm  comm ) {
01571       <span class="keywordtype">int</span>       partner;
01572       <span class="keywordtype">int</span>       rank, npes;
01573 
01574       MPI_Comm_rank(comm, &amp;rank);
01575       MPI_Comm_size(comm, &amp;npes);
01576 
01577       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_left  =  <a class="code" href="namespacebinOp.html#a6">binOp::getPrevHighestPowerOfTwo</a>(npes);
01578       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num_right = npes - num_left;
01579 
01580       <span class="comment">// 1, Do merge between the k right procs and the highest k left procs.</span>
01581       <span class="keywordflow">if</span> ( (static_cast&lt;unsigned int&gt;(rank) &lt; num_left) &amp;&amp;
01582           (static_cast&lt;unsigned int&gt;(rank) &gt;= (num_left - num_right)) ) {
01583         partner = static_cast&lt;unsigned int&gt;(rank) + num_right;
01584         MergeSplit&lt;T&gt; ( local_list,  KEEP_LOW, partner, comm);
01585       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;(rank) &gt;= num_left) {
01586         partner = static_cast&lt;unsigned int&gt;(rank) - num_right;
01587         MergeSplit&lt;T&gt; ( local_list,  KEEP_HIGH, partner, comm);
01588       }
01589     }
01590 
01591   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01592"></a><a class="code" href="namespacepar.html#a31">01592</a>     <span class="keywordtype">void</span> <a class="code" href="namespacepar.html#a31">bitonicSort_binary</a>(std::vector&lt;T&gt; &amp; in, MPI_Comm comm) {
01593       <span class="keywordtype">int</span>                   proc_set_size;
01594       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>          and_bit;
01595       <span class="keywordtype">int</span>               rank;
01596       <span class="keywordtype">int</span>               npes;
01597 
01598       MPI_Comm_size(comm, &amp;npes);
01599 
01600 <span class="preprocessor">#ifdef __DEBUG_PAR__</span>
01601 <span class="preprocessor"></span>      assert(npes &gt; 1);
01602       assert(!(npes &amp; (npes-1)));
01603       assert(!(in.empty()));
01604 <span class="preprocessor">#endif</span>
01605 <span class="preprocessor"></span>
01606       MPI_Comm_rank(comm, &amp;rank);
01607 
01608       <span class="keywordflow">for</span> (proc_set_size = 2, and_bit = 2;
01609           proc_set_size &lt;= npes;
01610           proc_set_size = proc_set_size*2, 
01611           and_bit = and_bit &lt;&lt; 1) {
01612 
01613         <span class="keywordflow">if</span> ((rank &amp; and_bit) == 0) {
01614           Par_bitonic_sort_incr&lt;T&gt;( in, proc_set_size, comm);
01615         } <span class="keywordflow">else</span> {
01616           Par_bitonic_sort_decr&lt;T&gt;( in, proc_set_size, comm);
01617         }
01618       }<span class="comment">//end for</span>
01619     }
01620 
01621   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01622"></a><a class="code" href="namespacepar.html#a32">01622</a>     <span class="keywordtype">void</span> <a class="code" href="namespacepar.html#a32">bitonicSort</a>(std::vector&lt;T&gt; &amp; in, MPI_Comm comm) {
01623       <span class="keywordtype">int</span>               rank;
01624       <span class="keywordtype">int</span>               npes;
01625 
01626       MPI_Comm_size(comm, &amp;npes);
01627       MPI_Comm_rank(comm, &amp;rank);
01628 
01629       assert(!(in.empty()));
01630 
01631       <span class="comment">//Local Sort first</span>
01632       <a class="code" href="Sort_8h.html#a7">std::sort</a>(in.begin(),in.end());
01633 
01634       <span class="keywordflow">if</span>(npes &gt; 1) {
01635 
01636         <span class="comment">// check if npes is a power of two ...</span>
01637         <span class="keywordtype">bool</span> isPower = (!(npes &amp; (npes - 1)));
01638 
01639         <span class="keywordflow">if</span> ( isPower ) {
01640           bitonicSort_binary&lt;T&gt;(in, comm);
01641         } <span class="keywordflow">else</span> {
01642           MPI_Comm new_comm;
01643 
01644           <span class="comment">// Since npes is not a power of two, we shall split the problem in two ...</span>
01645           <span class="comment">//</span>
01646           <span class="comment">// 1. Create 2 comm groups ... one for the 2^d portion and one for the</span>
01647           <span class="comment">// remainder.</span>
01648           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> splitter = <a class="code" href="namespacepar.html#a0">splitCommBinary</a>(comm, &amp;new_comm);
01649 
01650           <span class="keywordflow">if</span> ( static_cast&lt;unsigned int&gt;(rank) &lt; splitter) {
01651             bitonicSort_binary&lt;T&gt;(in, new_comm);
01652           } <span class="keywordflow">else</span> {
01653             bitonicSort&lt;T&gt;(in, new_comm);
01654           }
01655 
01656           <span class="comment">// 3. Do a special merge of the two segments. (original comm).</span>
01657           <a class="code" href="namespacepar.html#a30">Par_bitonic_merge_incr</a>( in,  binOp::getNextHighestPowerOfTwo(npes), comm );
01658 
01659           splitter = <a class="code" href="namespacepar.html#a1">splitCommBinaryNoFlip</a>(comm, &amp;new_comm);
01660 
01661           <span class="comment">// 4. Now a final sort on the segments.</span>
01662           <span class="keywordflow">if</span> (static_cast&lt;unsigned int&gt;(rank) &lt; splitter) {
01663             bitonicSort_binary&lt;T&gt;(in, new_comm);
01664           } <span class="keywordflow">else</span> {
01665             bitonicSort&lt;T&gt;(in, new_comm);
01666           }
01667         }<span class="comment">//end if isPower of 2</span>
01668       }<span class="comment">//end if single processor</span>
01669     }<span class="comment">//end function</span>
01670 
01671   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01672"></a><a class="code" href="namespacepar.html#a26">01672</a>     <span class="keywordtype">void</span> <a class="code" href="namespacepar.html#a26">MergeLists</a>( std::vector&lt;T&gt; &amp;listA, std::vector&lt;T&gt; &amp;listB,
01673         <span class="keywordtype">int</span> KEEP_WHAT) {
01674 
01675       T _low, _high;
01676 
01677       assert(!(listA.empty()));
01678       assert(!(listB.empty()));
01679 
01680       _low  = ( (listA[0] &gt; listB[0]) ? listA[0] : listB[0]);
01681       _high = ( (listA[listA.size()-1] &lt; listB[listB.size()-1]) ?
01682           listA[listA.size()-1] : listB[listB.size()-1]);
01683 
01684       <span class="comment">// We will do a full merge first ...</span>
01685       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> list_size = static_cast&lt;unsigned int&gt;(listA.size() + listB.size());
01686 
01687       std::vector&lt;T&gt; scratch_list(list_size);
01688 
01689       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  index1 = 0;
01690       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  index2 = 0; 
01691 
01692       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; list_size; i++) {
01693         <span class="comment">//The order of (A || B) is important here, </span>
01694         <span class="comment">//so that index2 remains within bounds</span>
01695         <span class="keywordflow">if</span> ( (index1 &lt; listA.size()) &amp;&amp; 
01696             ( (index2 &gt;= listB.size()) ||
01697               (listA[index1] &lt;= listB[index2]) ) ) {
01698           scratch_list[i] = listA[index1];
01699           index1++;
01700         } <span class="keywordflow">else</span> {
01701           scratch_list[i] = listB[index2];
01702           index2++;     
01703         }
01704       }
01705 
01706       <span class="comment">//Scratch list is sorted at this point.</span>
01707 
01708       listA.clear();
01709       listB.clear();
01710       <span class="keywordflow">if</span> ( KEEP_WHAT == KEEP_LOW ) {
01711         <span class="keywordtype">int</span> ii=0;
01712         <span class="keywordflow">while</span> ( ( (scratch_list[ii] &lt; _low) ||
01713               (ii &lt; (list_size/2)) )
01714             &amp;&amp; (scratch_list[ii] &lt;= _high) ) {
01715           ii++; 
01716         }
01717         <span class="keywordflow">if</span>(ii) {
01718           listA.insert(listA.end(), scratch_list.begin(),
01719               (scratch_list.begin() + ii));
01720         }
01721       } <span class="keywordflow">else</span> {
01722         <span class="keywordtype">int</span> ii = (list_size - 1);
01723         <span class="keywordflow">while</span> ( ( (ii &gt;= (list_size/2)) 
01724               &amp;&amp; (scratch_list[ii] &gt;= _low) )
01725             || (scratch_list[ii] &gt; _high) ) {
01726           ii--; 
01727         }
01728         <span class="keywordflow">if</span>(ii &lt; (list_size - 1) ) {
01729           listA.insert(listA.begin(), (scratch_list.begin() + (ii + 1)),
01730               (scratch_list.begin() + list_size));
01731         }
01732       }
01733       scratch_list.clear();
01734     }<span class="comment">//end function</span>
01735 
01736 }<span class="comment">//end namespace</span>
01737 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:30 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
