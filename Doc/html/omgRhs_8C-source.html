<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/examples/omgRhs.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">examples</a></div>
<h1>omgRhs.C</h1><a href="omgRhs_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "petsc.h"</span>
00008 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="omg_8h.html">omg.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="odaJac_8h.html">odaJac.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="omgJac_8h.html">omgJac.h</a>"</span>
00014 <span class="preprocessor">#include "<a class="code" href="nodeAndValues_8h.html">nodeAndValues.h</a>"</span>
00015 
00016 <span class="keyword">extern</span> <span class="keywordtype">double</span>****** ShapeFnStencil;
00017 <span class="keyword">extern</span> <span class="keywordtype">double</span>**** ShapeFnCoeffs;
00018 
<a name="l00019"></a><a class="code" href="omgRhs_8C.html#a0">00019</a> <span class="preprocessor">#define square(x) ((x)*(x))</span>
00020 <span class="preprocessor"></span>
<a name="l00021"></a><a class="code" href="omgRhs_8C.html#a1">00021</a> <span class="preprocessor">#define EVAL_FN(x,y,z,result) {\</span>
00022 <span class="preprocessor">  result = 0.0;\</span>
00023 <span class="preprocessor">  if( ((x) &gt;= 0.0) &amp;&amp; ((y) &gt;= 0.0) &amp;&amp; ((z) &gt;= 0.0) &amp;&amp; \</span>
00024 <span class="preprocessor">      ((x) &lt; 0.2) &amp;&amp; ((y) &lt; 0.2) &amp;&amp; ((z) &lt; 0.2) ) {\</span>
00025 <span class="preprocessor">    double dx = ((x) - 0.1);\</span>
00026 <span class="preprocessor">    double dy = ((y) - 0.1);\</span>
00027 <span class="preprocessor">    double dz = ((z) - 0.1);\</span>
00028 <span class="preprocessor">    result += exp(-((square(dx) + square(dy) + square(dz))/0.005));\</span>
00029 <span class="preprocessor">  }\</span>
00030 <span class="preprocessor">  if( ((x) &gt;= 0.2) &amp;&amp; ((y) &gt;= 0.2) &amp;&amp; ((z) &gt;= 0.2) &amp;&amp; \</span>
00031 <span class="preprocessor">      ((x) &lt;= 0.4) &amp;&amp; ((y) &lt;= 0.4) &amp;&amp; ((z) &lt;= 0.4) ) {\</span>
00032 <span class="preprocessor">    double dx = ((x) - 0.3);\</span>
00033 <span class="preprocessor">    double dy = ((y) - 0.3);\</span>
00034 <span class="preprocessor">    double dz = ((z) - 0.3);\</span>
00035 <span class="preprocessor">    result += exp(-((square(dx) + square(dy) + square(dz))/0.005));\</span>
00036 <span class="preprocessor">  }\</span>
00037 <span class="preprocessor">  if( ((x) &gt;= 0.5) &amp;&amp; ((y) &gt;= 0.5) &amp;&amp; ((z) &gt;= 0.5) &amp;&amp; \</span>
00038 <span class="preprocessor">      ((x) &lt;= 0.7) &amp;&amp; ((y) &lt;= 0.7) &amp;&amp; ((z) &lt;= 0.7) ) {\</span>
00039 <span class="preprocessor">    double dx = ((x) - 0.6);\</span>
00040 <span class="preprocessor">    double dy = ((y) - 0.6);\</span>
00041 <span class="preprocessor">    double dz = ((z) - 0.6);\</span>
00042 <span class="preprocessor">    result += exp(-((square(dx) + square(dy) + square(dz))/0.005));\</span>
00043 <span class="preprocessor">  }\</span>
00044 <span class="preprocessor">}</span>
00045 <span class="preprocessor"></span>
00046 <span class="comment">//Rhs = sum of 3 gaussian functions centered at different points.</span>
00047 <span class="comment">//Rhs is assembled using 3-pt gauss-quadrature integration per dimension. This is exact to</span>
00048 <span class="comment">//polynomials of degree 5 or less</span>
00049 <span class="comment">//w1 =8/9, x1 =0, w2=w3 =5/9, x2 = +sqrt(3/5), x3 = -sqrt(3/5)</span>
00050 <span class="comment">//int_a_to_b(f) = ((b-a)/2)*sum(wi*f((((b-a)/2)*xi) + ((b+a)/2)))</span>
<a name="l00051"></a><a class="code" href="omgRhs_8C.html#a4">00051</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a4">ComputeRHS2</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00052   PetscFunctionBegin;            
00053   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00054   PetscScalar *inarray;
00055 
00056   <span class="comment">//In PETSc's debug mode they use an Allreduce where all processors (active</span>
00057   <span class="comment">//and inactive) participate. Hence, VecZeroEntries must be called by active</span>
00058   <span class="comment">//and inactive processors.</span>
00059   VecZeroEntries(in);
00060   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00061 
00062   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00063   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD;
00064 
00065   <span class="keywordtype">double</span> wts[3] = { (8.0/9.0), (5.0/9.0), (5.0/9.0) };
00066   <span class="keywordtype">double</span> gPts[3] = { 0.0, sqrt((3.0/5.0)), -sqrt((3.0/5.0)) };
00067 
00068   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00069     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00070     balOctmaxD = maxD - 1;
00071     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;();
00072         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00073         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00074     {
00075       <a class="code" href="classPoint.html">Point</a> pt;
00076       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00077       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00078       <span class="keywordtype">unsigned</span> levelhere = (da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx) - 1);
00079       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00080       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00081       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00082       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00083       <span class="keywordtype">double</span> fac = ((hxOct*hxOct*hxOct)/8.0);
00084       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00085       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00086       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00087       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(idx);
00088       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00089       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00090         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00091           <span class="keywordtype">double</span> integral = 0.0;
00092           <span class="comment">//Quadrature Rule</span>
00093           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00094             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00095               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00096                 <span class="keywordtype">double</span> fnVal = 0.0;
00097                 <span class="keywordtype">double</span> xPt = ( (hxOct*(1.0 +gPts[m])*0.5) + x );
00098                 <span class="keywordtype">double</span> yPt = ( (hxOct*(1.0 + gPts[n])*0.5) + y );
00099                 <span class="keywordtype">double</span> zPt = ( (hxOct*(1.0 + gPts[p])*0.5) + z );
00100                 <a class="code" href="omgRhs_8C.html#a1">EVAL_FN</a>(xPt,yPt,zPt,fnVal) 
00101                   integral +=
00102                   (wts[m]*wts[n]*wts[p]*fnVal*
00103                    <a class="code" href="checkError_8C.html#a5">ShapeFnStencil</a>[childNum][elemType][j][m][n][p]);
00104               }
00105             }
00106           }
00107           inarray[indices[j]] += (fac*integral);
00108         }<span class="comment">//end for j</span>
00109     }<span class="comment">//end for i</span>
00110   }<span class="comment">//end if active</span>
00111 
00112   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00113 
00114   PetscFunctionReturn(0);
00115 }
00116 
00117 <span class="preprocessor">#undef square</span>
00118 <span class="preprocessor"></span><span class="preprocessor">#undef EVAL_FN </span>
00119 <span class="preprocessor"></span>
<a name="l00120"></a><a class="code" href="omgRhs_8C.html#a5">00120</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a5">ComputeSol</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec expectedSol) {
00121   PetscFunctionBegin;            
00122   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00123   PetscScalar *solArray;
00124   VecZeroEntries(expectedSol);
00125   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(expectedSol,solArray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00126 
00127   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00128   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD;
00129 
00130   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00131     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00132     balOctmaxD = maxD - 1;
00133     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); 
00134         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00135         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00136     {
00137       <a class="code" href="classPoint.html">Point</a> pt;
00138       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00139       <span class="keywordtype">unsigned</span> levelhere = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()) - 1;
00140       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00141       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00142       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00143       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00144 
00145       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00146       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00147       <span class="keywordtype">double</span> coord[8][3] = {
00148         {0.0,0.0,0.0},
00149         {1.0,0.0,0.0},
00150         {0.0,1.0,0.0},
00151         {1.0,1.0,0.0},
00152         {0.0,0.0,1.0},
00153         {1.0,0.0,1.0},
00154         {0.0,1.0,1.0},
00155         {1.0,1.0,1.0}
00156       };
00157       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hn = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00158 
00159       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)
00160       {
00161         <span class="keywordflow">if</span> (!(hn &amp; (1 &lt;&lt; i))){
00162           <span class="keywordtype">double</span> xhere, yhere, zhere;
00163           xhere = x + coord[i][0]*hxOct ; yhere = y + coord[i][1]*hxOct; zhere = z + coord[i][2]*hxOct; 
00164           <span class="keywordtype">double</span> solSum = 0.0;
00165           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> freqCnt = 1; freqCnt &lt; 10; freqCnt++) {
00166             <span class="keywordtype">double</span> facsol = freqCnt;
00167             solSum  += cos(facsol*M_PI*xhere)*cos(facsol*M_PI*yhere)*cos(facsol*M_PI*zhere);                                           
00168           }
00169           solArray[indices[i]] = solSum;
00170         }
00171       }
00172     }
00173   }
00174 
00175   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(expectedSol,solArray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1); 
00176 
00177   PetscFunctionReturn(0);
00178 }
00179 
<a name="l00180"></a><a class="code" href="omgRhs_8C.html#a6">00180</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a6">ComputeRHS0</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00181   PetscFunctionBegin;
00182   VecZeroEntries(in);
00183   PetscFunctionReturn(0);
00184 }
00185 
<a name="l00186"></a><a class="code" href="omgRhs_8C.html#a7">00186</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a7">ComputeRandomRHS</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00187   PetscFunctionBegin;
00188   PetscRandom rctx;  
00189   PetscRandomCreate(PETSC_COMM_WORLD,&amp;rctx);
00190   PetscRandomSetType(rctx,PETSCRAND48);
00191   PetscInt randomSeed = 12345;
00192   PetscOptionsGetInt(0,<span class="stringliteral">"-randomSeed"</span>,&amp;randomSeed,0);
00193   <span class="keywordtype">int</span> rank;
00194   MPI_Comm_rank(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>,&amp;rank);
00195   <span class="keywordflow">if</span>(!rank) {
00196     std::cout&lt;&lt;<span class="stringliteral">"Using Random Seed: "</span>&lt;&lt;randomSeed&lt;&lt;std::endl;
00197   }
00198   PetscRandomSetSeed(rctx,randomSeed);
00199   PetscRandomSeed(rctx);
00200   PetscRandomSetFromOptions(rctx);
00201   VecSetRandom(in,rctx);
00202   PetscRandomDestroy(rctx);
00203 
00204   PetscReal norm2;
00205   PetscReal normInf;
00206   VecNorm(in, NORM_INFINITY, &amp;normInf);
00207   VecNorm(in, NORM_2, &amp;norm2);
00208   <span class="keywordflow">if</span>(!rank) {
00209     std::cout&lt;&lt;<span class="stringliteral">"Random Rhs norm-2: "</span>&lt;&lt;norm2&lt;&lt;<span class="stringliteral">" normInf: "</span>&lt;&lt;normInf&lt;&lt;std::endl; 
00210   }
00211 
00212   PetscFunctionReturn(0);
00213 }
00214 
00215 <span class="comment">//Consistent Random RHS</span>
<a name="l00216"></a><a class="code" href="omgRhs_8C.html#a8">00216</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a8">ComputeRHS3</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00217   PetscFunctionBegin;
00218 
00219   <span class="keywordtype">int</span> rank;
00220   MPI_Comm_rank(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>,&amp;rank);
00221   Vec tmp;
00222   VecDuplicate(in,&amp;tmp);
00223   <a class="code" href="omgRhs_8C.html#a7">ComputeRandomRHS</a>(damg,tmp);
00224   Mat massMat;
00225   <a class="code" href="omgJac_8h.html#a9">CreateAndComputeMassMatrix</a>(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>,&amp;massMat);
00226   MatMult(massMat,tmp,in);
00227   MatDestroy(massMat);
00228   VecDestroy(tmp);
00229 
00230   PetscReal norm2;
00231   PetscReal normInf;
00232   VecNorm(in, NORM_INFINITY, &amp;normInf);
00233   VecNorm(in, NORM_2, &amp;norm2);
00234   <span class="keywordflow">if</span>(!rank) {
00235     std::cout&lt;&lt;<span class="stringliteral">"End of RHS-3: Rhs norm-2: "</span>&lt;&lt;norm2&lt;&lt;<span class="stringliteral">" normInf: "</span>&lt;&lt;normInf&lt;&lt;std::endl; 
00236   }
00237   PetscFunctionReturn(0);
00238 }
00239 
00240 <span class="comment">//Random Solution Consistent RHS</span>
<a name="l00241"></a><a class="code" href="omgRhs_8C.html#a9">00241</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a9">ComputeRHS4</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Vec in) {
00242   PetscFunctionBegin;
00243   <span class="keywordtype">int</span> rank;
00244   MPI_Comm_rank(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, &amp;rank);
00245   Vec tmp;
00246   VecDuplicate(in, &amp;tmp);
00247   <a class="code" href="omgRhs_8C.html#a7">ComputeRandomRHS</a>(damg, tmp);
00248 
00249   MatMult(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a>, tmp, in);
00250   VecDestroy(tmp);
00251 
00252   PetscReal norm2;
00253   PetscReal normInf;
00254   VecNorm(in, NORM_INFINITY, &amp;normInf);
00255   VecNorm(in, NORM_2, &amp;norm2);
00256 
00257   <span class="keywordflow">if</span>(!rank) {
00258     std::cout&lt;&lt;<span class="stringliteral">" End of RHS-4: Rhs norm-2: "</span>&lt;&lt;norm2&lt;&lt;<span class="stringliteral">" normInf: "</span>&lt;&lt;normInf&lt;&lt;std::endl; 
00259   }
00260 
00261   PetscFunctionReturn(0);
00262 }
00263 
<a name="l00264"></a><a class="code" href="omgRhs_8C.html#a10">00264</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a10">ComputeRHS1</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00265   PetscFunctionBegin;            
00266   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00267   Vec tmp;
00268   VecDuplicate(in,&amp;tmp);
00269   PetscScalar *inarray;
00270   VecZeroEntries(tmp);
00271   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(tmp,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00272 
00273   <span class="keywordtype">int</span> rank;
00274   MPI_Comm_rank(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>,&amp;rank);
00275   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00276   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD;
00277 
00278   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00279     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00280     balOctmaxD = maxD - 1;
00281     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00282     {
00283       <a class="code" href="classPoint.html">Point</a> pt;
00284       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00285       <span class="keywordtype">unsigned</span> levelhere = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()) - 1;
00286       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00287       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00288       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00289       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00290 
00291       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00292       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00293       <span class="keywordtype">double</span> coord[8][3] = {
00294         {0.0,0.0,0.0},
00295         {1.0,0.0,0.0},
00296         {0.0,1.0,0.0},
00297         {1.0,1.0,0.0},
00298         {0.0,0.0,1.0},
00299         {1.0,0.0,1.0},
00300         {0.0,1.0,1.0},
00301         {1.0,1.0,1.0}
00302       };
00303       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hn = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00304 
00305       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)
00306       {
00307         <span class="keywordflow">if</span> (!(hn &amp; (1 &lt;&lt; i))){
00308           <span class="keywordtype">double</span> xhere, yhere, zhere;
00309           xhere = x + coord[i][0]*hxOct ; yhere = y + coord[i][1]*hxOct; zhere = z + coord[i][2]*hxOct; 
00310           <span class="keywordtype">double</span> rhsSum = 0.0;
00311           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> freqCnt = 1; freqCnt &lt; 10; freqCnt++) {
00312             <span class="keywordtype">double</span> facsol = freqCnt;
00313             rhsSum  += (1.0 + 3*facsol*facsol*M_PI*M_PI)*cos(facsol*M_PI*xhere)*
00314               cos(facsol*M_PI*yhere)*cos(facsol*M_PI*zhere);                                           
00315           }
00316           inarray[indices[i]] = rhsSum;
00317         }
00318       }
00319     }
00320   }
00321 
00322   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(tmp,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1); 
00323 
00324   PetscReal norm2;
00325   PetscReal normInf;
00326 
00327   VecNorm(tmp, NORM_INFINITY, &amp;normInf);
00328   VecNorm(tmp, NORM_2, &amp;norm2);
00329   <span class="keywordflow">if</span>(!rank) {
00330     std::cout&lt;&lt;<span class="stringliteral">"tmpRhs norm-2: "</span>&lt;&lt;norm2&lt;&lt;<span class="stringliteral">" normInf: "</span>&lt;&lt;normInf&lt;&lt;std::endl; 
00331   }
00332 
00333   Mat massMat;
00334   <a class="code" href="omgJac_8h.html#a9">CreateAndComputeMassMatrix</a>(da,&amp;massMat);
00335   MatMult(massMat,tmp,in);
00336   MatDestroy(massMat);
00337   VecDestroy(tmp);
00338 
00339   VecNorm(in, NORM_INFINITY, &amp;normInf);
00340   VecNorm(in, NORM_2, &amp;norm2);
00341   <span class="keywordflow">if</span>(!rank) {
00342     std::cout&lt;&lt;<span class="stringliteral">"End of RHS-1: Rhs norm-2: "</span>&lt;&lt;norm2&lt;&lt;<span class="stringliteral">" normInf: "</span>&lt;&lt;normInf&lt;&lt;std::endl; 
00343   }
00344 
00345   PetscFunctionReturn(0);
00346 }
00347 
00348 
00349 
00350 <span class="comment">/*</span>
00351 <span class="comment">   RHS corresponding to the homogeneous neumann, variable coefficient, scalar, poisson problem</span>
00352 <span class="comment">   with solution = cos(2*pi*x)cos(2*pi*y)cos(2*pi*z) and</span>
00353 <span class="comment">   epsilon = 1 + 10^6[cos^2(2*pi*x) + cos^2(2*pi*y) + cos^2(2*pi*z)] and</span>
00354 <span class="comment">   alpha  = 1</span>
00355 <span class="comment">   */</span>
<a name="l00356"></a><a class="code" href="omgRhs_8C.html#a11">00356</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a11">ComputeRHS5</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00357   PetscFunctionBegin;            
00358   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00359   Vec tmp;
00360   VecDuplicate(in, &amp;tmp);
00361   PetscScalar *inarray;
00362   VecZeroEntries(tmp);
00363   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(tmp, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
00364 
00365   PetscReal lapFac = 0.0;
00366   PetscTruth optFound;
00367   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00368   <span class="keywordtype">int</span> rank;
00369   MPI_Comm_rank(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>,&amp;rank);
00370   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00371   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD;
00372 
00373   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00374     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00375     balOctmaxD = maxD - 1;
00376     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00377     {
00378       <a class="code" href="classPoint.html">Point</a> pt;
00379       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00380       <span class="keywordtype">unsigned</span> levelhere = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()) - 1;
00381       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00382       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00383       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00384       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00385 
00386       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00387       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00388       <span class="keywordtype">double</span> coord[8][3] = {
00389         {0.0,0.0,0.0},
00390         {1.0,0.0,0.0},
00391         {0.0,1.0,0.0},
00392         {1.0,1.0,0.0},
00393         {0.0,0.0,1.0},
00394         {1.0,0.0,1.0},
00395         {0.0,1.0,1.0},
00396         {1.0,1.0,1.0}
00397       };
00398       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hn = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00399 
00400       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)
00401       {
00402         <span class="keywordflow">if</span> (!(hn &amp; (1 &lt;&lt; i))){
00403           <span class="keywordtype">double</span> xhere, yhere, zhere;
00404           xhere = x + (coord[i][0]*hxOct);
00405           yhere = y + (coord[i][1]*hxOct);
00406           zhere = z + (coord[i][2]*hxOct); 
00407           <span class="keywordtype">double</span> solVal = cos(2.0*M_PI*xhere)*cos(2.0*M_PI*yhere)*cos(2.0*M_PI*zhere); 
00408           <span class="keywordtype">double</span> epVal = (1.0 + (lapFac*(
00409                   (cos(2.0*M_PI*xhere)*cos(2.0*M_PI*xhere)) +
00410                   (cos(2.0*M_PI*yhere)*cos(2.0*M_PI*yhere)) +
00411                   (cos(2.0*M_PI*zhere)*cos(2.0*M_PI*zhere)) 
00412                   )));
00413           <span class="keywordtype">double</span> rhsVal = (solVal + (12.0*(M_PI*M_PI)*solVal*epVal)
00414               - (8.0*(M_PI*M_PI)*lapFac*solVal*(
00415                   (sin(2.0*M_PI*xhere)*sin(2.0*M_PI*xhere)) +
00416                   (sin(2.0*M_PI*yhere)*sin(2.0*M_PI*yhere)) +
00417                   (sin(2.0*M_PI*zhere)*sin(2.0*M_PI*zhere)) 
00418                   )));
00419           inarray[indices[i]] = rhsVal;
00420         }
00421       }
00422     }
00423   }
00424 
00425   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(tmp, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1); 
00426 
00427   PetscReal norm2;
00428   PetscReal normInf;
00429 
00430   VecNorm(tmp, NORM_INFINITY, &amp;normInf);
00431   VecNorm(tmp, NORM_2, &amp;norm2);
00432   <span class="keywordflow">if</span>(!rank) {
00433     std::cout&lt;&lt;<span class="stringliteral">"tmpRhs-5 norm-2: "</span>&lt;&lt;norm2&lt;&lt;<span class="stringliteral">" normInf: "</span>&lt;&lt;normInf&lt;&lt;std::endl; 
00434   }
00435 
00436   Mat massMat;
00437   <a class="code" href="omgJac_8h.html#a9">CreateAndComputeMassMatrix</a>(da,&amp;massMat);
00438   MatMult(massMat,tmp,in);
00439   MatDestroy(massMat);
00440   VecDestroy(tmp);
00441 
00442   VecNorm(in, NORM_INFINITY, &amp;normInf);
00443   VecNorm(in, NORM_2, &amp;norm2);
00444   <span class="keywordflow">if</span>(!rank) {
00445     std::cout&lt;&lt;<span class="stringliteral">"End of RHS-5: Rhs norm-2: "</span>&lt;&lt;norm2&lt;&lt;<span class="stringliteral">" normInf: "</span>&lt;&lt;normInf&lt;&lt;std::endl; 
00446   }
00447 
00448   PetscFunctionReturn(0);
00449 }
00450 
<a name="l00454"></a><a class="code" href="omgRhs_8C.html#a12">00454</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a12">ComputeRHS6</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00455   PetscFunctionBegin;            
00456   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00457   Vec tmp;
00458   VecDuplicate(in, &amp;tmp);
00459   <a class="code" href="omgRhs_8C.html#a15">SetSolution5</a>(da,tmp);
00460   MatMult(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o7">J</a>, tmp, in);
00461   VecDestroy(tmp);
00462   PetscFunctionReturn(0);
00463 }
00464 
<a name="l00476"></a><a class="code" href="omgRhs_8C.html#a13">00476</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a13">ComputeRHS7</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00477   PetscFunctionBegin;            
00478   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00479   PetscScalar *inarray;
00480   VecZeroEntries(in);
00481   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00482 
00483   PetscReal lapFac = 0.0;
00484   PetscTruth optFound;
00485   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00486 
00487   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00488   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD;
00489 
00490   <span class="keywordtype">double</span> wts[3] = { (8.0/9.0), (5.0/9.0), (5.0/9.0) };
00491   <span class="keywordtype">double</span> gPts[3] = { 0.0, sqrt((3.0/5.0)), -sqrt((3.0/5.0)) };
00492 
00493   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00494     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00495     balOctmaxD = maxD - 1;
00496     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;();
00497         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00498         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00499     {
00500       <a class="code" href="classPoint.html">Point</a> pt;
00501       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00502       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00503       <span class="keywordtype">unsigned</span> levelhere = (da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx) - 1);
00504       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00505       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00506       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00507       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00508       <span class="keywordtype">double</span> fac = ((hxOct*hxOct*hxOct)/8.0);
00509       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00510       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00511       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00512       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(idx);
00513       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00514       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00515         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00516           <span class="keywordtype">double</span> integral = 0.0;
00517           <span class="comment">//Quadrature Rule</span>
00518           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00519             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00520               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00521                 <span class="keywordtype">double</span> xPt = ( (hxOct*(1.0 +gPts[m])*0.5) + x );
00522                 <span class="keywordtype">double</span> yPt = ( (hxOct*(1.0 + gPts[n])*0.5) + y );
00523                 <span class="keywordtype">double</span> zPt = ( (hxOct*(1.0 + gPts[p])*0.5) + z );
00524                 <span class="keywordtype">double</span> solVal = cos(2.0*M_PI*xPt)*cos(2.0*M_PI*yPt)*cos(2.0*M_PI*zPt); 
00525                 <span class="keywordtype">double</span> epVal = (1.0 + (lapFac*(
00526                         (cos(2.0*M_PI*xPt)*cos(2.0*M_PI*xPt)) +
00527                         (cos(2.0*M_PI*yPt)*cos(2.0*M_PI*yPt)) +
00528                         (cos(2.0*M_PI*zPt)*cos(2.0*M_PI*zPt)) 
00529                         )));
00530                 <span class="keywordtype">double</span> rhsVal = (solVal + (12.0*(M_PI*M_PI)*solVal*epVal)
00531                     - (8.0*(M_PI*M_PI)*lapFac*solVal*(
00532                         (sin(2.0*M_PI*xPt)*sin(2.0*M_PI*xPt)) +
00533                         (sin(2.0*M_PI*yPt)*sin(2.0*M_PI*yPt)) +
00534                         (sin(2.0*M_PI*zPt)*sin(2.0*M_PI*zPt)) 
00535                         )));
00536                 integral += (wts[m]*wts[n]*wts[p]*rhsVal*
00537                     <a class="code" href="checkError_8C.html#a5">ShapeFnStencil</a>[childNum][elemType][j][m][n][p]);
00538               }
00539             }
00540           }
00541           inarray[indices[j]] += (fac*integral);
00542         }<span class="comment">//end for j</span>
00543     }<span class="comment">//end for i</span>
00544   }<span class="comment">//end if active</span>
00545 
00546   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00547 
00548   PetscFunctionReturn(0);
00549 }
00550 
<a name="l00562"></a><a class="code" href="omgRhs_8C.html#a14">00562</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a14">ComputeRHS8</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00563   PetscFunctionBegin;            
00564   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00565   PetscScalar *inarray;
00566   VecZeroEntries(in);
00567   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00568 
00569   PetscReal lapFac = 0.0;
00570   PetscTruth optFound;
00571   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00572 
00573   PetscInt numGaussPts = 0;
00574   PetscOptionsGetInt(0,<span class="stringliteral">"-numGaussPts"</span>,&amp;numGaussPts,0);
00575 
00576   assert(numGaussPts &lt;= 7);
00577   assert(numGaussPts &gt;= 2);
00578 
00579   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00580   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD;
00581 
00582   std::vector&lt;std::vector&lt;double&gt; &gt; wts(6);
00583   std::vector&lt;std::vector&lt;double&gt; &gt; gPts(6);
00584 
00585   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; 6; k++) {
00586     wts[k].resize(k+2);
00587     gPts[k].resize(k+2);
00588   }
00589 
00590   <span class="comment">//2-pt rule</span>
00591   wts[0][0] = 1.0; wts[0][1] = 1.0;
00592   gPts[0][0] = sqrt(1.0/3.0); gPts[0][1] = -sqrt(1.0/3.0); 
00593 
00594   <span class="comment">//3-pt rule</span>
00595   wts[1][0] = 0.88888889;  wts[1][1] = 0.555555556;  wts[1][2] = 0.555555556;
00596   gPts[1][0] = 0.0;  gPts[1][1] = 0.77459667;  gPts[1][2] = -0.77459667;
00597 
00598   <span class="comment">//4-pt rule</span>
00599   wts[2][0] = 0.65214515;  wts[2][1] = 0.65214515;
00600   wts[2][2] = 0.34785485; wts[2][3] = 0.34785485;  
00601   gPts[2][0] = 0.33998104;  gPts[2][1] = -0.33998104;
00602   gPts[2][2] = 0.86113631; gPts[2][3] = -0.86113631;
00603 
00604   <span class="comment">//5-pt rule</span>
00605   wts[3][0] = 0.568888889;  wts[3][1] = 0.47862867;  wts[3][2] =  0.47862867;
00606   wts[3][3] = 0.23692689; wts[3][4] = 0.23692689;
00607   gPts[3][0] = 0.0;  gPts[3][1] = 0.53846931; gPts[3][2] = -0.53846931;
00608   gPts[3][3] = 0.90617985; gPts[3][4] = -0.90617985;
00609 
00610   <span class="comment">//6-pt rule</span>
00611   wts[4][0] = 0.46791393;  wts[4][1] = 0.46791393;  wts[4][2] = 0.36076157;
00612   wts[4][3] = 0.36076157; wts[4][4] = 0.17132449; wts[4][5] = 0.17132449;
00613   gPts[4][0] = 0.23861918; gPts[4][1] = -0.23861918; gPts[4][2] = 0.66120939;
00614   gPts[4][3] = -0.66120939; gPts[4][4] = 0.93246951; gPts[4][5] = -0.93246951;
00615 
00616   <span class="comment">//7-pt rule</span>
00617   wts[5][0] = 0.41795918;  wts[5][1] = 0.38183005;  wts[5][2] = 0.38183005;
00618   wts[5][3] = 0.27970539;  wts[5][4] = 0.27970539; 
00619   wts[5][5] = 0.12948497; wts[5][6] = 0.12948497;
00620   gPts[5][0] = 0.0;  gPts[5][1] = 0.40584515;  gPts[5][2] = -0.40584515;
00621   gPts[5][3] = 0.74153119;  gPts[5][4] = -0.74153119;
00622   gPts[5][5] = 0.94910791; gPts[5][6] = -0.94910791;
00623 
00624   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00625     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00626     balOctmaxD = maxD - 1;
00627     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;();
00628         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00629         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00630     {
00631       <a class="code" href="classPoint.html">Point</a> pt;
00632       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00633       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00634       <span class="keywordtype">unsigned</span> levelhere = (da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx) - 1);
00635       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00636       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00637       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00638       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00639       <span class="keywordtype">double</span> fac = ((hxOct*hxOct*hxOct)/8.0);
00640       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00641       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00642       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00643       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(idx);
00644       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00645       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00646         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00647           <span class="keywordtype">double</span> integral = 0.0;
00648           <span class="comment">//Quadrature Rule</span>
00649           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; numGaussPts; m++) {
00650             <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; numGaussPts; n++) {
00651               <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0; p &lt; numGaussPts; p++) {
00652                 <span class="keywordtype">double</span> xPt = ( (hxOct*(1.0 +gPts[numGaussPts-2][m])*0.5) + x );
00653                 <span class="keywordtype">double</span> yPt = ( (hxOct*(1.0 + gPts[numGaussPts-2][n])*0.5) + y );
00654                 <span class="keywordtype">double</span> zPt = ( (hxOct*(1.0 + gPts[numGaussPts-2][p])*0.5) + z );
00655                 <span class="keywordtype">double</span> solVal = cos(2.0*M_PI*xPt)*cos(2.0*M_PI*yPt)*cos(2.0*M_PI*zPt); 
00656                 <span class="keywordtype">double</span> epVal = (1.0 + (lapFac*(
00657                         (cos(2.0*M_PI*xPt)*cos(2.0*M_PI*xPt)) +
00658                         (cos(2.0*M_PI*yPt)*cos(2.0*M_PI*yPt)) +
00659                         (cos(2.0*M_PI*zPt)*cos(2.0*M_PI*zPt)) 
00660                         )));
00661                 <span class="keywordtype">double</span> rhsVal = (solVal + (12.0*(M_PI*M_PI)*solVal*epVal)
00662                     - (8.0*(M_PI*M_PI)*lapFac*solVal*(
00663                         (sin(2.0*M_PI*xPt)*sin(2.0*M_PI*xPt)) +
00664                         (sin(2.0*M_PI*yPt)*sin(2.0*M_PI*yPt)) +
00665                         (sin(2.0*M_PI*zPt)*sin(2.0*M_PI*zPt)) 
00666                         )));
00667                 <span class="keywordtype">double</span> ShFnVal = ( <a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][0] + 
00668                     (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][1]*gPts[numGaussPts-2][m]) +
00669                     (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][2]*gPts[numGaussPts-2][n]) +
00670                     (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][3]*gPts[numGaussPts-2][p]) +
00671                     (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][4]*gPts[numGaussPts-2][m]*
00672                      gPts[numGaussPts-2][n]) +
00673                     (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][5]*gPts[numGaussPts-2][n]*
00674                      gPts[numGaussPts-2][p]) +
00675                     (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][6]*gPts[numGaussPts-2][p]*
00676                      gPts[numGaussPts-2][m]) +
00677                     (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][7]*gPts[numGaussPts-2][m]*
00678                      gPts[numGaussPts-2][n]*gPts[numGaussPts-2][p]) );
00679                 integral += (wts[numGaussPts-2][m]*wts[numGaussPts-2][n]
00680                     *wts[numGaussPts-2][p]*rhsVal*ShFnVal);
00681               }
00682             }
00683           }
00684           inarray[indices[j]] += (fac*integral);
00685         }<span class="comment">//end for j</span>
00686     }<span class="comment">//end for i</span>
00687   }<span class="comment">//end if active</span>
00688 
00689   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00690 
00691   PetscFunctionReturn(0);
00692 }
00693 
00694 
00695 
<a name="l00699"></a><a class="code" href="omgRhs_8C.html#a15">00699</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a15">SetSolution5</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da , Vec tmp) {
00700   PetscFunctionBegin;            
00701   PetscScalar *inarray;
00702   VecZeroEntries(tmp);
00703   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(tmp, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
00704 
00705   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00706   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD;
00707 
00708   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00709     maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00710     balOctmaxD = maxD - 1;
00711     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00712     {
00713       <a class="code" href="classPoint.html">Point</a> pt;
00714       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00715       <span class="keywordtype">unsigned</span> levelhere = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()) - 1;
00716       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00717       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00718       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00719       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00720 
00721       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00722       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00723       <span class="keywordtype">double</span> coord[8][3] = {
00724         {0.0,0.0,0.0},
00725         {1.0,0.0,0.0},
00726         {0.0,1.0,0.0},
00727         {1.0,1.0,0.0},
00728         {0.0,0.0,1.0},
00729         {1.0,0.0,1.0},
00730         {0.0,1.0,1.0},
00731         {1.0,1.0,1.0}
00732       };
00733       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hn = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00734 
00735       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; 8; i++)
00736       {
00737         <span class="keywordflow">if</span> (!(hn &amp; (1 &lt;&lt; i))){
00738           <span class="keywordtype">double</span> xhere, yhere, zhere;
00739           xhere = x + (coord[i][0]*hxOct);
00740           yhere = y + (coord[i][1]*hxOct);
00741           zhere = z + (coord[i][2]*hxOct); 
00742           <span class="keywordtype">double</span> solVal = cos(2.0*M_PI*xhere)*cos(2.0*M_PI*yhere)*cos(2.0*M_PI*zhere); 
00743           inarray[indices[i]] = solVal;
00744         }
00745       }
00746     }
00747   }
00748 
00749   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(tmp, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1); 
00750 
00751   PetscFunctionReturn(0);
00752 }
00753 
00754 <span class="comment">/*</span>
00755 <span class="comment">   Measure L-2 error for the variable coefficient scalar</span>
00756 <span class="comment">   elliptic homogeneous neumann problem  with RHS given by RHS5</span>
00757 <span class="comment">   */</span>
<a name="l00758"></a><a class="code" href="omgRhs_8C.html#a16">00758</a> <span class="keywordtype">double</span> <a class="code" href="omgRhs_8C.html#a16">ComputeError5</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da, Vec in)
00759 {
00760 
00761   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00762     <span class="keywordtype">double</span> wts[3] = { (8.0/9.0), (5.0/9.0), (5.0/9.0) };
00763     <span class="keywordtype">double</span> gPts[3] = { 0.0, sqrt((3.0/5.0)), -sqrt((3.0/5.0)) };
00764     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00765     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctmaxD = (maxD - 1);
00766     <span class="keywordtype">double</span> error = 0.0;
00767     PetscScalar *inarray;
00768     da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
00769     da-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;PetscScalar&gt;(inarray, 1);
00770     da-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;PetscScalar&gt;(inarray);
00771     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00772         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00773         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;())  
00774     {
00775       <a class="code" href="classPoint.html">Point</a> pt;
00776       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00777       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00778       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> levelhere = (da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx) - 1);
00779       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (balOctmaxD - levelhere))/(double)(1u &lt;&lt; balOctmaxD));
00780       <span class="keywordtype">double</span> x = (double)(pt.<a class="code" href="classPoint.html#z52_1">xint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00781       <span class="keywordtype">double</span> y = (double)(pt.<a class="code" href="classPoint.html#z52_3">yint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00782       <span class="keywordtype">double</span> z = (double)(pt.<a class="code" href="classPoint.html#z52_5">zint</a>())/((double)(1u &lt;&lt; (maxD-1)));
00783       <span class="keywordtype">double</span> fac = ((hxOct*hxOct*hxOct)/8.0);
00784       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00785       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00786       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00787       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(idx);
00788       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00789       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00790         <span class="keywordtype">double</span> integral = 0.0;
00791       <span class="comment">//Quadrature Rule</span>
00792       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00793         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00794           <span class="keywordflow">for</span>(<span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00795             <span class="keywordtype">double</span> xPt = ( (hxOct*(1.0 +gPts[m])*0.5) + x );
00796             <span class="keywordtype">double</span> yPt = ( (hxOct*(1.0 + gPts[n])*0.5) + y );
00797             <span class="keywordtype">double</span> zPt = ( (hxOct*(1.0 + gPts[p])*0.5) + z );
00798             <span class="keywordtype">double</span> fnVal = cos(2.0*M_PI*xPt)*cos(2.0*M_PI*yPt)*cos(2.0*M_PI*zPt); 
00799             <span class="keywordtype">double</span> uhval= 0.0; 
00800             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00801               uhval += (inarray[indices[j]]*<a class="code" href="checkError_8C.html#a5">ShapeFnStencil</a>[childNum][elemType][j][m][n][p]);
00802             }
00803             integral += (wts[m]*wts[n]*wts[p]*(fnVal - uhval)*(fnVal - uhval));
00804           }<span class="comment">// end for p</span>
00805         } <span class="comment">// end for n</span>
00806       }<span class="comment">//end for m</span>
00807       error += integral*fac;
00808     }<span class="comment">//end for i</span>
00809     da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);
00810     <span class="keywordtype">double</span> totalError = 0.0;
00811     par::Mpi_Reduce&lt;double&gt;(&amp;error, &amp;totalError, 1, MPI_SUM, 0, da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>());
00812     <span class="keywordflow">return</span>(sqrt(totalError));
00813   } <span class="keywordflow">else</span> {
00814     <span class="keywordflow">return</span>(0.0);
00815   }<span class="comment">//end if-else active</span>
00816 }<span class="comment">//end fn.</span>
00817 
<a name="l00818"></a><a class="code" href="omgRhs_8C.html#a17">00818</a> <span class="keywordtype">double</span> <a class="code" href="omgRhs_8C.html#a17">TestError5</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da) {
00819   Vec tmp;
00820   da-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>(tmp, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
00821   <a class="code" href="omgRhs_8C.html#a15">SetSolution5</a>(da, tmp);
00822   <span class="keywordtype">double</span> error = <a class="code" href="omgRhs_8C.html#a16">ComputeError5</a>(da, tmp);
00823   VecDestroy(tmp);
00824   <span class="keywordflow">return</span> error;
00825 }
00826 
00827 <span class="comment">//Force is a sum of delta functions.</span>
00828 <span class="comment">//The location and the magnitude of the delta</span>
00829 <span class="comment">//functions is given in the file "deltaSources_&lt;rank&gt;_&lt;npes&gt;.txt"</span>
<a name="l00830"></a><a class="code" href="omgRhs_8C.html#a18">00830</a> PetscErrorCode <a class="code" href="omgRhs_8C.html#a18">ComputeRHS9</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Vec in) {
00831   PetscFunctionBegin;            
00832 
00833   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00834 
00835   MPI_Comm commAll = da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>();
00836 
00837   <span class="keywordtype">int</span> rankAll = da-&gt;<a class="code" href="classot_1_1DA.html#z31_24">getRankAll</a>();
00838   <span class="keywordtype">int</span> npesAll = da-&gt;<a class="code" href="classot_1_1DA.html#z31_20">getNpesAll</a>();
00839 
00840   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = da-&gt;<a class="code" href="classot_1_1DA.html#z31_4">getDimension</a>();
00841   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00842   <span class="keywordtype">int</span> npesActive = da-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>();
00843 
00844   <span class="keywordflow">if</span>( npesActive &lt; npesAll ) {
00845     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpArr[3];
00846     tmpArr[0] = dim;
00847     tmpArr[1] = maxDepth;
00848     tmpArr[2] = npesActive;
00849 
00850     par::Mpi_Bcast&lt;unsigned int&gt;(tmpArr, 3, 0, commAll);
00851 
00852     dim = tmpArr[0];
00853     maxDepth = tmpArr[1];
00854     npesActive = static_cast&lt;int&gt;(tmpArr[2]);
00855   }
00856 
00857   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> balOctMaxD = (maxDepth - 1);
00858 
00859   <span class="keywordtype">char</span> fname[250];
00860   sprintf(fname,<span class="stringliteral">"deltaSources_%d_%d.txt"</span>, rankAll, npesAll);
00861 
00862   FILE* inFile = fopen(fname,<span class="stringliteral">"r"</span>);
00863   <span class="keywordflow">if</span>(!inFile) {
00864     std::cout&lt;&lt;<span class="stringliteral">"Unable to open "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" for reading."</span>&lt;&lt;std::endl;
00865   }
00866 
00867   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numLocalDelta; 
00868   fscanf(inFile,<span class="stringliteral">"%u"</span>,&amp;numLocalDelta);
00869 
00870   std::vector&lt;ot::NodeAndValues&lt;double, 4&gt; &gt; tnAndVal(numLocalDelta);
00871 
00872   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numLocalDelta; i++) {
00873     <span class="keywordtype">double</span> x, y, z, v;
00874     fscanf(inFile,<span class="stringliteral">"%lf"</span>,&amp;x);
00875     fscanf(inFile,<span class="stringliteral">"%lf"</span>,&amp;y);
00876     fscanf(inFile,<span class="stringliteral">"%lf"</span>,&amp;z);
00877     fscanf(inFile,<span class="stringliteral">"%lf"</span>,&amp;v);
00878 
00879     assert(x &gt;= 0.0);
00880     assert(y &gt;= 0.0);
00881     assert(z &gt;= 0.0);
00882     assert(x &lt;= 1.0);<span class="comment">//Can be equal to 1.0 for domain boundaries</span>
00883     assert(y &lt;= 1.0);<span class="comment">//Can be equal to 1.0 for domain boundaries</span>
00884     assert(z &lt;= 1.0);<span class="comment">//Can be equal to 1.0 for domain boundaries</span>
00885 
00886     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xint = static_cast&lt;unsigned int&gt;(x*static_cast&lt;double&gt;(1u &lt;&lt; balOctMaxD));
00887     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yint = static_cast&lt;unsigned int&gt;(y*static_cast&lt;double&gt;(1u &lt;&lt; balOctMaxD));
00888     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zint = static_cast&lt;unsigned int&gt;(z*static_cast&lt;double&gt;(1u &lt;&lt; balOctMaxD));
00889 
00890     tnAndVal[i].node = <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(xint, yint, zint, maxDepth, dim, maxDepth);
00891 
00892     tnAndVal[i].values[0] = x;
00893     tnAndVal[i].values[1] = y;
00894     tnAndVal[i].values[2] = z;
00895     tnAndVal[i].values[3] = v;
00896   }<span class="comment">//end for i</span>
00897 
00898   fclose(inFile);
00899 
00900   std::vector&lt;ot::TreeNode&gt; minBlocks = da-&gt;<a class="code" href="classot_1_1DA.html#a3">getMinAllBlocks</a>();
00901 
00902   <span class="keywordflow">if</span>(npesActive &lt; npesAll) {
00903     <span class="keywordtype">bool</span>* activeStates = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npesAll];
00904 
00905     activeStates[0] = <span class="keyword">true</span>;
00906     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; npesActive; i++) {
00907       activeStates[i] = <span class="keyword">false</span>;
00908     }
00909     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = npesActive; i &lt; npesAll; i++) {
00910       activeStates[i] = <span class="keyword">true</span>;
00911     }
00912 
00913     MPI_Comm tmpComm;
00914 
00915     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(activeStates, &amp;tmpComm, commAll);
00916 
00917     <span class="keywordflow">if</span>(rankAll == 0) {
00918       par::Mpi_Bcast&lt;ot::TreeNode&gt;(&amp;(*(minBlocks.begin())) , npesActive, 0, tmpComm);
00919     }
00920     <span class="keywordflow">if</span>(rankAll &gt;= npesActive) {
00921       minBlocks.resize(npesActive);
00922       par::Mpi_Bcast&lt;ot::TreeNode&gt;(&amp;(*(minBlocks.begin())) , npesActive, 0, tmpComm);
00923     }
00924 
00925     <span class="keyword">delete</span> [] activeStates;
00926   }
00927 
00928   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* part = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[tnAndVal.size()];
00929 
00930   <span class="keywordtype">int</span> *sendCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[npesAll];
00931   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npesAll; i++) {
00932     sendCnt[i] = 0;
00933   }
00934 
00935   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; tnAndVal.size(); i++) {
00936     seq::maxLowerBound&lt;ot::TreeNode&gt;(minBlocks, tnAndVal[i].node, part[i], NULL, NULL);
00937     sendCnt[part[i]]++; 
00938   }
00939 
00940   <span class="keywordtype">int</span> *recvCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[npesAll];
00941 
00942   par::Mpi_Alltoall&lt;int&gt;( sendCnt, recvCnt, 1, commAll);
00943 
00944   <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npesAll];
00945   <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npesAll];
00946 
00947   sendOffsets[0] = 0;
00948   recvOffsets[0] = 0;
00949   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 1; i &lt; npesAll; i++) {
00950     sendOffsets[i] = sendOffsets[i - 1] + sendCnt[i - 1];
00951     recvOffsets[i] = recvOffsets[i - 1] + recvCnt[i - 1];
00952   }
00953 
00954   <span class="comment">//We can simply communicate the doubles instead, but then we will need to</span>
00955   <span class="comment">//recreate octants from doubles to do further processing.</span>
00956   std::vector&lt;ot::NodeAndValues&lt;double, 4&gt; &gt; sendList(sendOffsets[npesAll] + sendCnt[npesAll]);
00957   std::vector&lt;ot::NodeAndValues&lt;double, 4&gt; &gt; recvList(recvOffsets[npesAll] + recvCnt[npesAll]);
00958 
00959   <span class="keywordtype">int</span>* tmpSendCnt = <span class="keyword">new</span> <span class="keywordtype">int</span>[npesAll];
00960   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npesAll; i++) {
00961     tmpSendCnt[i] = 0;
00962   }
00963 
00964   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; tnAndVal.size(); i++) {
00965     sendList[sendOffsets[part[i]] + tmpSendCnt[part[i]]] = tnAndVal[i];
00966     tmpSendCnt[part[i]]++;
00967   }
00968   <span class="keyword">delete</span> [] tmpSendCnt;
00969   tnAndVal.clear();
00970 
00971   par::Mpi_Alltoallv_sparse&lt;ot::NodeAndValues&lt;double, 4&gt; &gt;( &amp;(*(sendList.begin())), sendCnt,
00972       sendOffsets, &amp;(*(recvList.begin())), recvCnt, recvOffsets, commAll);
00973 
00974   sendList.clear();
00975 
00976   <span class="keyword">delete</span> [] part;
00977   <span class="keyword">delete</span> [] sendCnt;
00978   <span class="keyword">delete</span> [] recvCnt;
00979   <span class="keyword">delete</span> [] sendOffsets;
00980   <span class="keyword">delete</span> [] recvOffsets;
00981 
00982   <a class="code" href="Sort_8h.html#a7">sort</a>(recvList.begin(), recvList.end());
00983 
00984   <span class="comment">//Now the points are sorted and aligned with the DA partition</span>
00985 
00986   <span class="comment">//In PETSc's debug mode they use an Allreduce where all processors (active</span>
00987   <span class="comment">//and inactive) participate. Hence, VecZeroEntries must be called by active</span>
00988   <span class="comment">//and inactive processors.</span>
00989   VecZeroEntries(in);
00990 
00991   <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>())) {
00992     assert(recvList.empty());
00993   } <span class="keywordflow">else</span> {
00994     PetscScalar *inarray;
00995     da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
00996 
00997     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ptsCtr = 0;
00998 
00999     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
01000         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
01001         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;())  
01002     {
01003       <a class="code" href="classPoint.html">Point</a> pt;
01004       pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
01005       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
01006       <span class="keywordtype">unsigned</span> levelhere = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx);
01007       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> xint = pt.<a class="code" href="classPoint.html#z52_1">xint</a>();
01008       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> yint = pt.<a class="code" href="classPoint.html#z52_3">yint</a>();
01009       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> zint = pt.<a class="code" href="classPoint.html#z52_5">zint</a>();
01010       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> currOct(xint, yint, zint, levelhere, dim, maxDepth);
01011       <span class="keywordflow">while</span>( (ptsCtr &lt; recvList.size()) &amp;&amp; 
01012           (recvList[ptsCtr].node &lt; currOct) ) {
01013         ptsCtr++;
01014       }
01015       <span class="keywordtype">double</span> hxOct = (double)((double)(1u &lt;&lt; (maxDepth - levelhere))/(double)(1u &lt;&lt; balOctMaxD));
01016       <span class="keywordtype">double</span> x = static_cast&lt;double&gt;(xint)/((double)(1u &lt;&lt; balOctMaxD));
01017       <span class="keywordtype">double</span> y = static_cast&lt;double&gt;(yint)/((double)(1u &lt;&lt; balOctMaxD));
01018       <span class="keywordtype">double</span> z = static_cast&lt;double&gt;(zint)/((double)(1u &lt;&lt; balOctMaxD));
01019       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
01020       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
01021       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
01022       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(idx);
01023       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
01024       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
01025         <span class="keywordflow">while</span>( (ptsCtr &lt; recvList.size()) &amp;&amp; 
01026             ( currOct.<a class="code" href="classot_1_1TreeNode.html#a11">isAncestor</a>(recvList[ptsCtr].node) || 
01027               ( currOct == (recvList[ptsCtr].node) ) ) ) {
01028           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01029             <span class="keywordtype">double</span> xLoc = (((2.0/hxOct)*(recvList[ptsCtr].values[0] - x)) - 1.0);
01030             <span class="keywordtype">double</span> yLoc = (((2.0/hxOct)*(recvList[ptsCtr].values[1] - y)) - 1.0);
01031             <span class="keywordtype">double</span> zLoc = (((2.0/hxOct)*(recvList[ptsCtr].values[2] - z)) - 1.0);
01032             <span class="keywordtype">double</span> ShFnVal = ( <a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][0] + 
01033                 (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][1]*xLoc) +
01034                 (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][2]*yLoc) +
01035                 (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][3]*zLoc) +
01036                 (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][4]*xLoc*yLoc) +
01037                 (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][5]*yLoc*zLoc) +
01038                 (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][6]*zLoc*xLoc) +
01039                 (<a class="code" href="checkError_8C.html#a6">ShapeFnCoeffs</a>[childNum][elemType][j][7]*xLoc*yLoc*zLoc) );
01040             inarray[indices[j]] += ((recvList[ptsCtr].values[3])*ShFnVal);
01041           }<span class="comment">//end for j</span>
01042           ptsCtr++;
01043         }
01044     }<span class="comment">//end for i</span>
01045 
01046     da-&gt;<a class="code" href="classot_1_1DA.html#z33_6">WriteToGhostsBegin</a>&lt;PetscScalar&gt;(inarray, 1);
01047     da-&gt;<a class="code" href="classot_1_1DA.html#z33_7">WriteToGhostsEnd</a>&lt;PetscScalar&gt;(inarray, 1);
01048 
01049     da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in, inarray, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
01050 
01051   }<span class="comment">//end if active</span>
01052 
01053   PetscFunctionReturn(0);
01054 
01055 }<span class="comment">//end fn.</span>
01056 
01057 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:25 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
