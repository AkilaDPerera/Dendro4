<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /export/home/ilashuk3/Dendro/src/oct/OctFunctions.C File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.4.7 -->
<div class="tabs">
  <ul>
    <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
    <li><a href="namespaces.html"><span>Namespaces</span></a></li>
    <li><a href="classes.html"><span>Classes</span></a></li>
    <li id="current"><a href="files.html"><span>Files</span></a></li>
    <li><a href="dirs.html"><span>Directories</span></a></li>
    <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
  </ul></div>
<div class="tabs">
  <ul>
    <li><a href="files.html"><span>File&nbsp;List</span></a></li>
    <li><a href="globals.html"><span>File&nbsp;Members</span></a></li>
  </ul></div>
<div class="nav">
<a class="el" href="dir_95d5eb57f2839000f42cfeba4072b840.html">src</a>&nbsp;&raquo&nbsp;<a class="el" href="dir_afec14882e36554143ee6c192cfdf590.html">oct</a></div>
<h1>OctFunctions.C File Reference</h1>A collection of simple functions for manipulating octrees. Examples: Regular Refinements, Linearizing an octree, I/O, Nearest Common Ancestor, adding positive boundaries, marking hanging nodes. <a href="#_details">More...</a>
<p>
<code>#include &quot;<a class="el" href="TreeNode_8h-source.html">TreeNode.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="parUtils_8h-source.html">parUtils.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="seqUtils_8h-source.html">seqUtils.h</a>&quot;</code><br>
<code>#include &lt;cstring&gt;</code><br>

<p>
<a href="OctFunctions_8C-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Namespaces</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">namespace &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html">ot</a></td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#2e6e7a740c9c0ac5c20f7c8e4e8129ac">ot::addBoundaryNodesType1</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;bdy, unsigned int dim, unsigned int maxDepth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">generates psuedonodes for the positive boundary and inserts them into bdy  <a href="#2e6e7a740c9c0ac5c20f7c8e4e8129ac"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#5af02fb473c1240efbacafc7ac8e0174">ot::addBoundaryNodesType2</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;bdy, unsigned int dim, unsigned int maxDepth)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#9e1096ca22075e1397c19efd7f921d08">ot::areComparable</a> (TreeNode first, TreeNode second)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">checks if the dim and maxdepths are the same.  <a href="#9e1096ca22075e1397c19efd7f921d08"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#552416b13b66220a80a0a3f8eb7729a4">ot::bPartComparator</a> (TreeNode a, TreeNode b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">criteria for picking blocks inside blockPart  <a href="#552416b13b66220a80a0a3f8eb7729a4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#e78d7002117391fad8154f95cd7a9a5e">ot::createRegularOctree</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;out, unsigned int lev, unsigned int dim, unsigned int maxDepth, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a regular grid octree.  <a href="#e78d7002117391fad8154f95cd7a9a5e"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#d6634be4526a71a542ca8f58c13ceab6">ot::discardExtraBoundaryOctants</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, unsigned int dim, unsigned int maxDepth)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#68045a8d59f16c79baacb48bc5699803">ot::flagNodesType1</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies hanging nodes. Uses two all2allv communications. No overlap of comm and comp.  <a href="#68045a8d59f16c79baacb48bc5699803"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#f65cd39416e5f3e563c5a0dfd4a9ad72">ot::flagNodesType2</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies hanging nodes. It just uses 1 communication by sending apriori results. Overlaps comm and comp.  <a href="#f65cd39416e5f3e563c5a0dfd4a9ad72"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#3e214972d987182e70d44e2e792f8d12">ot::flagNodesType3</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;in, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Identifies hanging nodes. 2 step communication, overlapping comm and comp.  <a href="#3e214972d987182e70d44e2e792f8d12"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">TreeNode&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#e006f2fcf1be1c11e537b6bf565272a5">ot::getNCA</a> (TreeNode first, TreeNode second)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#3913300db05fa4cc1adf514679baef1b">ot::getNodeWeight</a> (const TreeNode *t)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">char&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#e6b4751ea9464a2c29b85e06689dda83">ot::int2char</a> (int d)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#8577b7288bf196eab1408c1975e6f7c7">ot::int2str</a> (int n, char *s)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">bool&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#ce647445d8d21d319bae860c220915a6">ot::lessThanUsingWts</a> (TreeNode const &amp;a, TreeNode const &amp;b)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">A comparator that uses the weights of the octants instead of the Morton ordering.  <a href="#ce647445d8d21d319bae860c220915a6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#448cc36afa59363948a041f395786b0a">ot::lineariseList</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;list, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the input linear. Removes duplicates and ancestors.  <a href="#448cc36afa59363948a041f395786b0a"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#3d27518d2830a7994b30b847a4147230">ot::lineariseList</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;list, bool skipLast=false)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Makes the input linear. Removes duplicates and ancestors.  <a href="#3d27518d2830a7994b30b847a4147230"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#248318d5a77d09fb02eb223c3d6d3096">ot::markBoundaryNodesAtAllLevels</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;finestOctree, unsigned int nlevels, std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; *coarserOctrees, unsigned int maxDepth)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#06b132c42bd1ae7c13141b6ed87b2cc2">ot::markHangingNodesAtAllLevels</a> (std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;finestOctree, unsigned int nlevels, std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; *coarserOctrees, MPI_Comm *activeComms, unsigned int dim, unsigned int maxDepth)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#6e68ba77e434b7dd152ab94d9d3a5f46">ot::mergeOctrees</a> (std::vector&lt; TreeNode &gt; &amp;inOct1, std::vector&lt; TreeNode &gt; &amp;inOct2, std::vector&lt; TreeNode &gt; &amp;outOct, MPI_Comm comm)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Merges the 2 input octrees and linearizes the result.  <a href="#6e68ba77e434b7dd152ab94d9d3a5f46"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#15d0a00169ad431ae37f6402f6b3c3e4">ot::readDataPtsFromFile</a> (char *filename, std::vector&lt; double &gt; &amp;pts, std::vector&lt; double &gt; &amp;ptVals)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a list of points and corresponding values from a file.  <a href="#15d0a00169ad431ae37f6402f6b3c3e4"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#ac62a6e651ba5133b4cd702ded046feb">ot::readNodesFromFile</a> (char *filename, std::vector&lt; TreeNode &gt; &amp;nodes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a list of octants from a file.  <a href="#ac62a6e651ba5133b4cd702ded046feb"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#36ce702d88a1c5147aff0412de56276c">ot::readPtsFromFile</a> (char *filename, std::vector&lt; double &gt; &amp;pts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a list of points from a file.  <a href="#36ce702d88a1c5147aff0412de56276c"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#60831f7b1d9148c803f227a728c6cf4c">ot::refineAndPartitionOctree</a> (const std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;inp, std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;out, MPI_Comm comm)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#c60c886da9835d2803cedb7768189470">ot::refineOctree</a> (const std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;inp, std::vector&lt; <a class="el" href="classot_1_1TreeNode.html">ot::TreeNode</a> &gt; &amp;out)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#a8615d11ba09e2073d031df6bd0ef9c1">ot::writeDataPtsToFile</a> (char *filename, std::vector&lt; double &gt; &amp;pts, std::vector&lt; double &gt; &amp;data)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a list of points and corresponding values from a file.  <a href="#a8615d11ba09e2073d031df6bd0ef9c1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#5ee76cc3e35a1333e4ac1d6041c04ef3">ot::writeNodesToFile</a> (char *filename, const std::vector&lt; TreeNode &gt; &amp;nodes)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a list of octants to a file.  <a href="#5ee76cc3e35a1333e4ac1d6041c04ef3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceot.html#f6d8ac86d7a52fdac886473d840369a5">ot::writePtsToFile</a> (char *filename, std::vector&lt; double &gt; &amp;pts)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a list of points to a file.  <a href="#f6d8ac86d7a52fdac886473d840369a5"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A collection of simple functions for manipulating octrees. Examples: Regular Refinements, Linearizing an octree, I/O, Nearest Common Ancestor, adding positive boundaries, marking hanging nodes. 
<p>
<dl compact><dt><b>Author:</b></dt><dd>Rahul S. Sampath, <a href="mailto:rahul.sampath@gmail.com">rahul.sampath@gmail.com</a> <p>
Hari Sundar, <a href="mailto:hsundar@gmail.com">hsundar@gmail.com</a> </dd></dl>

<p>
Definition in file <a class="el" href="OctFunctions_8C-source.html">OctFunctions.C</a>.<hr size="1"><address style="align: right;"><small>Generated on Fri Mar 19 16:26:45 2010 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.4.7 </small></address>
</body>
</html>
