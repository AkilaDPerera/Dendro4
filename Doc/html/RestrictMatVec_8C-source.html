<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/omg/RestrictMatVec.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000018.html">omg</a></div>
<h1>RestrictMatVec.C</h1><a href="RestrictMatVec_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00008 <span class="preprocessor">#include "petsc.h"</span>
00009 <span class="preprocessor">#include "petscmat.h"</span>
00010 <span class="preprocessor">#include "<a class="code" href="omg_8h.html">omg.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00012 
00013 <span class="preprocessor">#ifndef iC</span>
<a name="l00014"></a><a class="code" href="RestrictMatVec_8C.html#a0">00014</a> <span class="preprocessor"></span><span class="preprocessor">#define iC(fun) {CHKERRQ(fun);}</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00016 <span class="preprocessor"></span>
00017 <span class="preprocessor">#ifdef __DEBUG__</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_MG__</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_MG__</span>
00020 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00022 <span class="preprocessor"></span>
00023 <span class="keyword">namespace </span>ot {
00024 
00025   <span class="keyword">extern</span> <span class="keywordtype">double</span> **** RmatType2Stencil;
00026   <span class="keyword">extern</span> <span class="keywordtype">double</span> ***** RmatType1Stencil;
00027   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>**** VtxMap1; 
00028   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>***** VtxMap2; 
00029   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>***** VtxMap3; 
00030   <span class="keyword">extern</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>****** VtxMap4; 
00031 
<a name="l00032"></a><a class="code" href="namespaceot.html#a116">00032</a>   PetscErrorCode  <a class="code" href="namespaceot.html#a116">addRestrictMatVec</a>(Mat R, Vec v1, Vec v2, Vec v3)      
00033   {
00034     PetscScalar one = 1.0;
00035     PetscFunctionBegin;
00036     <span class="keywordflow">if</span>((v2!=v3) &amp;&amp; (v1!=v3)) {
00037       <span class="comment">//Note This will fail only if v2==v3 or v1 ==v3!(i.e they are identical copies pointing to the same memory location)</span>
00038       <a class="code" href="omg_8C.html#a0">iC</a>(MatMult(R, v1, v3));<span class="comment">//v3 = R*v1</span>
00039       <a class="code" href="omg_8C.html#a0">iC</a>(VecAXPY(v3,one,v2));<span class="comment">//v3 = v3+ v2=v2 + R*v1</span>
00040     }<span class="keywordflow">else</span> {
00041       <span class="comment">//This is less efficient but failproof.</span>
00042       <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a> *data;
00043       MatShellGetContext( R, (<span class="keywordtype">void</span> **)&amp;data);
00044       Vec tmp = data-&gt;addRtmp;
00045       <span class="keywordflow">if</span>(tmp == NULL) {
00046         VecDuplicate(v3,&amp;tmp);
00047         data-&gt;addRtmp = tmp;
00048       }
00049       <a class="code" href="omg_8C.html#a0">iC</a>(MatMult(R, v1, tmp));<span class="comment">//tmp=R*v1;</span>
00050       <a class="code" href="omg_8C.html#a0">iC</a>(VecWAXPY(v3,one,v2,tmp));<span class="comment">//v3 = (1*v2)+tmp=v2 + R*v1</span>
00051     }
00052     PetscFunctionReturn(0);
00053   }
00054 
<a name="l00055"></a><a class="code" href="namespaceot.html#a117">00055</a>   PetscErrorCode   <a class="code" href="namespaceot.html#a117">restrictMatVecType2</a>(Mat R, Vec f, Vec c) {
00056     <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a> *data;
00057     PetscFunctionBegin;
00058     <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext( R, (<span class="keywordtype">void</span> **)&amp;data));
00059     MPI_Comm comm = data-&gt;comm;
00060     Vec tmp = data-&gt;tmp;                
00061     PetscInt tmpSz;
00062     PetscInt fSz;
00063     <a class="code" href="omg_8C.html#a0">iC</a>(VecGetLocalSize(tmp,&amp;tmpSz));
00064     <a class="code" href="omg_8C.html#a0">iC</a>(VecGetLocalSize(f,&amp;fSz));
00065     <a class="code" href="namespacepar.html#a19">scatterValues</a>(f, tmp, fSz, tmpSz, data-&gt;sendSzR,
00066         data-&gt;sendOffR, data-&gt;recvSzR, data-&gt;recvOffR, comm);
00067     <a class="code" href="namespaceot.html#a119">restrictMatVecType1</a>(R, tmp, c);
00068     PetscFunctionReturn(0);
00069   }
00070 
<a name="l00071"></a><a class="code" href="RestrictMatVec_8C.html#a1">00071</a> <span class="preprocessor">#define ITLB_SET_VALUE_NO_SUPPRESSED_DOFS {\</span>
00072 <span class="preprocessor">  carr[cidx+l] += (Rval*farr[fidx+l]);\</span>
00073 <span class="preprocessor">}</span>
00074 <span class="preprocessor"></span>
<a name="l00075"></a><a class="code" href="RestrictMatVec_8C.html#a2">00075</a> <span class="preprocessor">#define ITLB_SET_VALUE_SUPPRESSED_DOFS {\</span>
00076 <span class="preprocessor">  if(!( (suppressedDOFf &amp;&amp; suppressedDOFf[fidx+l]) ||\</span>
00077 <span class="preprocessor">        (suppressedDOFc &amp;&amp; suppressedDOFc[cidx+l]) )) {\</span>
00078 <span class="preprocessor">    carr[cidx+l] += (Rval*farr[fidx+l]);\</span>
00079 <span class="preprocessor">  }\</span>
00080 <span class="preprocessor">}</span>
00081 <span class="preprocessor"></span>
<a name="l00082"></a><a class="code" href="RestrictMatVec_8C.html#a3">00082</a> <span class="preprocessor">#define INTERGRID_TRANSFER_LOOP_BLOCK(ITLB_SET_VALUE) {\</span>
00083 <span class="preprocessor">  </span><span class="comment">/*The fine loop is always Writable, but the coarse loop*/</span>\
00084   <span class="comment">/*could be Independent or W_Dependent. Hence the fine counter must*/</span>\
00085   <span class="comment">/*be incremented properly to align with the coarse.*/</span>\
00086   Point Cpt = dac-&gt;getCurrentOffset();\
00087   while(daf-&gt;getCurrentOffset() != Cpt) {\
00088     if(daf-&gt;isLUTcompressed()) {\
00089       daf-&gt;updateQuotientCounter();\
00090     }\
00091     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00092   } \
00093   unsigned char chnMask = dac-&gt;getHangingNodeIndex(dac-&gt;curr());\
00094   unsigned char cNumCoarse = dac-&gt;getChildNumber();\
00095   unsigned int cIndices[8];\
00096   dac-&gt;getNodeIndices(cIndices);\
00097   unsigned char ctype = 0;\
00098   GET_ETYPE_BLOCK(ctype,chnMask,cNumCoarse)\
00099   if(daf-&gt;getLevel(daf-&gt;curr()) == dac-&gt;getLevel(dac-&gt;curr())) {\
00100     <span class="comment">/*The coarse and fine elements are the same,*/</span>\
00101     <span class="comment">/*so cNumCoarse = cNumFine. This is type-2*/</span>\
00102     double** type2RmatPtr = RmatType2Stencil[cNumCoarse][ctype];\
00103     unsigned char fhnMask = daf-&gt;getHangingNodeIndex(daf-&gt;curr());\
00104     unsigned int fIndices[8];\
00105     daf-&gt;getNodeIndices(fIndices);\
00106     for(unsigned char fCtr = 0; fCtr &lt; 8; fCtr++) {\
00107       if(!(fhnMask &amp; (1 &lt;&lt; fCtr))) {\
00108         ot::FineTouchedStatus* fineTouchedStatusPtr = (&amp;(fineTouchedFlagsArr[fIndices[fCtr]]));\
00109         unsigned int fidx = fIndices[fCtr]*dof;\
00110         for(unsigned char cCtr = 0; cCtr &lt; 8; cCtr++) {\
00111           <span class="comment">/*Read fineTouchedFlagsArr Directly*/</span>\
00112           if( (fineTouchedStatusPtr-&gt;flags[fCtr]) &amp; (1 &lt;&lt; cCtr) ) {\
00113             unsigned int cidx = cIndices[cCtr]*dof;\
00114             double Rval = type2RmatPtr[cCtr][fCtr];\
00115             for(unsigned int l = 0; l &lt; dof; l++) {\
00116               ITLB_SET_VALUE\
00117             }\
00118           }\
00119         }\
00120       }\
00121     }\
00122     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00123   }else {\
00124     for(unsigned char cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
00125       <span class="comment">/*The coarse and fine elements are NOT the same. This is type-1.*/</span>\
00126       <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
00127       <span class="comment">/*These are the underlying fine elements.*/</span>\
00128       double** type1RmatPtr = RmatType1Stencil[cNumCoarse][cNumFine][ctype];\
00129       unsigned char fhnMask = daf-&gt;getHangingNodeIndex(daf-&gt;curr());\
00130       unsigned int fIndices[8];\
00131       daf-&gt;getNodeIndices(fIndices);\
00132       for(unsigned int fCtr = 0; fCtr &lt; 8; fCtr++) {\
00133         if(!(fhnMask &amp; (1 &lt;&lt; fCtr))) {\
00134           ot::FineTouchedStatus* fineTouchedStatusPtr = (&amp;(fineTouchedFlagsArr[fIndices[fCtr]]));\
00135           unsigned int fidx = fIndices[fCtr]*dof;\
00136           for(unsigned int cCtr = 0; cCtr &lt; 8; cCtr++) {\
00137             <span class="comment">/*Read fineTouchedFlagsArr Directly*/</span>\
00138             if( (fineTouchedStatusPtr-&gt;flags[fCtr]) &amp; (1 &lt;&lt; cCtr) ) {\
00139               unsigned int cidx = cIndices[cCtr]*dof;\
00140               double Rval = type1RmatPtr[cCtr][fCtr];\
00141               for(unsigned int l = 0; l &lt; dof; l++) {\
00142                 ITLB_SET_VALUE\
00143               }\
00144             }\
00145           }\
00146         }\
00147       }\
00148       daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00149     }\
00150   }\
00151 }
00152 
<a name="l00153"></a><a class="code" href="RestrictMatVec_8C.html#a4">00153</a> <span class="preprocessor">#define INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY {\</span>
00154 <span class="preprocessor">  </span><span class="comment">/*The fine loop is always Writable, but the coarse loop*/</span>\
00155   <span class="comment">/*could be Independent or W_Dependent. Hence the fine counter must*/</span>\
00156   <span class="comment">/*be incremented properly to align with the coarse.*/</span>\
00157   Point Cpt = dac-&gt;getCurrentOffset();\
00158   while(daf-&gt;getCurrentOffset() != Cpt) {\
00159     if(daf-&gt;isLUTcompressed()) {\
00160       daf-&gt;updateQuotientCounter();\
00161     }\
00162     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00163   }\
00164   unsigned char chnMask = dac-&gt;getHangingNodeIndex(dac-&gt;curr());\
00165   unsigned char cNumCoarse = dac-&gt;getChildNumber();\
00166   unsigned int cIndices[8];\
00167   dac-&gt;getNodeIndices(cIndices);\
00168   unsigned char ctype = 0;\
00169   GET_ETYPE_BLOCK(ctype,chnMask,cNumCoarse)\
00170   if(daf-&gt;getLevel(daf-&gt;curr()) == dac-&gt;getLevel(dac-&gt;curr())) {\
00171     <span class="comment">/*The coarse and fine elements are the same,*/</span>\
00172     <span class="comment">/*so cNumCoarse = cNumFine. This is type-2*/</span>\
00173     unsigned char fhnMask = daf-&gt;getHangingNodeIndex(daf-&gt;curr());\
00174     unsigned int fIndices[8];\
00175     daf-&gt;getNodeIndices(fIndices);\
00176     for(unsigned char fCtr = 0; fCtr &lt; 8; fCtr++) {\
00177       if(!(fhnMask &amp; (1 &lt;&lt; fCtr))) {\
00178         unsigned char thisElemLev = daf-&gt;getLevel(daf-&gt;curr());\
00179         unsigned char refElemLev = daf-&gt;getLevel(fIndices[fCtr]);\
00180         ot::FineTouchedDummyStatus* fineTouchedDummyStatusPtr = \
00181         (&amp;(fineTouchedDummyFlagsArr[fIndices[fCtr]]));\
00182         if(thisElemLev == refElemLev) {\
00183           <span class="comment">/*Set the dummy flag for this fine element and fine node pair*/</span>\
00184           <span class="comment">/*Since, I deal with this one byte at a time. It is consistent*/</span>\
00185           <span class="comment">/* across all computers. Endian issues do not enter. Hence, I*/</span>\
00186           <span class="comment">/* choose to manipulate chars instead of shorts. Besides, the*/</span>\
00187           <span class="comment">/* size of short is not guaranteed to be 2 bytes on all*/</span>\
00188           <span class="comment">/* machines.*/</span>\
00189           <span class="comment">/* A char is always 1 byte.*/</span>\
00190           <span class="comment">/*1 bit: Entry set or not (flags[2*fCtr][0]) */</span>\
00191           <span class="comment">/*1 bit: scalingCtr (flags[2*fCtr][1]) */</span>\
00192           <span class="comment">/*2 bits: stencilType (flags[2*fCtr][3,2]) */</span>\
00193           <span class="comment">/*3 bits: cNumFine (flags[2*fCtr][6,5,4]) */</span>\
00194           <span class="comment">/*3 bits: cNumCoarse (flags[2*fCtr+1][2,1,0]) */</span>\
00195           <span class="comment">/*5 bits: ctype (flags[2*fCtr+1][7,6,5,4,3]) */</span>\
00196           fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] = 1;\
00197           fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] = cNumCoarse;\
00198           fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] |= (ctype&lt;&lt;3);\
00199         }else {\
00200           unsigned char scalingCtr = 0;\
00201           if(thisElemLev &lt; refElemLev) {\
00202             scalingCtr = 1;\
00203           }\
00204           fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] = 1;\
00205           fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] |= (scalingCtr&lt;&lt;1);\
00206           fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] |= (2&lt;&lt;2);\
00207           fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] = cNumCoarse;\
00208           fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] |= (ctype&lt;&lt;3);\
00209         }\
00210       }\
00211     }\
00212     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00213   }else {\
00214     for(unsigned char cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
00215       <span class="comment">/*The coarse and fine elements are NOT the same. This is type-1.*/</span>\
00216       <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
00217       <span class="comment">/*These are the underlying fine elements.*/</span>\
00218       unsigned char fhnMask = daf-&gt;getHangingNodeIndex(daf-&gt;curr());\
00219       unsigned int fIndices[8];\
00220       daf-&gt;getNodeIndices(fIndices);\
00221       for(unsigned int fCtr = 0; fCtr &lt; 8; fCtr++) {\
00222         if(!(fhnMask &amp; (1 &lt;&lt; fCtr))) {\
00223           unsigned char thisElemLev = daf-&gt;getLevel(daf-&gt;curr());\
00224           unsigned char refElemLev = daf-&gt;getLevel(fIndices[fCtr]);\
00225           ot::FineTouchedDummyStatus* fineTouchedDummyStatusPtr = \
00226           (&amp;(fineTouchedDummyFlagsArr[fIndices[fCtr]]));\
00227           if(thisElemLev == refElemLev) {\
00228             fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] = 1;\
00229             fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] |= (1 &lt;&lt; 2);\
00230             fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] |= (cNumFine&lt;&lt;4);\
00231             fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] = cNumCoarse;\
00232             fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] |= (ctype&lt;&lt;3);\
00233           }else {\
00234             unsigned char scalingCtr = 0;\
00235             if(thisElemLev &lt; refElemLev) {\
00236               scalingCtr = 1;\
00237             }\
00238             fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] = 1;\
00239             fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] |= (scalingCtr&lt;&lt;1);\
00240             fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] |= (3&lt;&lt;2);\
00241             fineTouchedDummyStatusPtr-&gt;flags[fCtr&lt;&lt;1] |= (cNumFine&lt;&lt;4);\
00242             fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] = cNumCoarse;\
00243             fineTouchedDummyStatusPtr-&gt;flags[(fCtr&lt;&lt;1)+1] |= (ctype&lt;&lt;3);\
00244           }\
00245         }\
00246       }\
00247       daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00248     }\
00249   }\
00250 }
00251 
<a name="l00252"></a><a class="code" href="RestrictMatVec_8C.html#a5">00252</a> <span class="preprocessor">#define ITLB_DUMMY_FCTR_BLOCK1 {\</span>
00253 <span class="preprocessor">  if(fineTouchedDummyStatusPtr-&gt;flags[dummyFctr&lt;&lt;1]) {\</span>
00254 <span class="preprocessor">    </span><span class="comment">/*12_10 = (00001100)_2*/</span>\
00255     unsigned char dummyStencilType = \
00256     ((12 &amp; (fineTouchedDummyStatusPtr-&gt;flags[dummyFctr&lt;&lt;1]))&gt;&gt;2);\
00257     <span class="comment">/*7_10 = (00000111)_2*/</span>\
00258     unsigned char dummyCnumCoarse = \
00259     (7 &amp; (fineTouchedDummyStatusPtr-&gt;flags[(dummyFctr&lt;&lt;1)+1]));\
00260     <span class="comment">/*248_10 = (11111000)_2*/</span>\
00261     unsigned char dummyCtype = \
00262     ((248 &amp; (fineTouchedDummyStatusPtr-&gt;flags[(dummyFctr&lt;&lt;1)+1]))&gt;&gt;3);\
00263     switch(dummyStencilType) {\
00264       case 0: {\
00265                 dummyMapPtrs[dummyFctr] = \
00266                 VtxMap1[dummyFctr][dummyCnumCoarse][dummyCtype];\
00267                 break;\
00268               }\
00269       case 1: {\
00270                 <span class="comment">/*112_10 = (01110000)_2*/</span>\
00271                 unsigned char dummyCnumFine = \
00272                 ((112 &amp; (fineTouchedDummyStatusPtr-&gt;flags[dummyFctr&lt;&lt;1]))&gt;&gt;4);\
00273                 dummyMapPtrs[dummyFctr] = \
00274                 VtxMap2[dummyFctr][dummyCnumFine][dummyCnumCoarse][dummyCtype];\
00275                 break;\
00276               }\
00277       case 2: {\
00278                 <span class="comment">/*2_10 = (00000010)_2*/</span>\
00279                 unsigned char dummyScalingCtr = \
00280                 ((2 &amp; (fineTouchedDummyStatusPtr-&gt;flags[dummyFctr&lt;&lt;1]))&gt;&gt;1);\
00281                 dummyMapPtrs[dummyFctr] = \
00282                 VtxMap3[dummyFctr-1][dummyScalingCtr][dummyCnumCoarse][dummyCtype];\
00283                 break;\
00284               }\
00285       case 3: {\
00286                 unsigned char dummyScalingCtr = \
00287                 ((2 &amp; (fineTouchedDummyStatusPtr-&gt;flags[dummyFctr&lt;&lt;1]))&gt;&gt;1);\
00288                 unsigned char dummyCnumFine = \
00289                 ((112 &amp; (fineTouchedDummyStatusPtr-&gt;flags[dummyFctr&lt;&lt;1]))&gt;&gt;4);\
00290                 dummyMapPtrs[dummyFctr] = \
00291                 VtxMap4[dummyFctr-1][dummyScalingCtr][dummyCnumFine][dummyCnumCoarse][dummyCtype];\
00292                 break;\
00293               }\
00294       default: {\
00295                  assert(false);\
00296                }\
00297     }\
00298   }\
00299 }
00300 
<a name="l00301"></a><a class="code" href="RestrictMatVec_8C.html#a6">00301</a> <span class="preprocessor">#define ITLB_DUMMY_FCTR_BLOCK2 {\</span>
00302 <span class="preprocessor">  if(dummyMapPtrs[dummyFctr]) {\</span>
00303 <span class="preprocessor">    for(unsigned char dummyCctr = 0; dummyCctr &lt; 8; dummyCctr++) {\</span>
00304 <span class="preprocessor">      if(coarseVtxId == dummyMapPtrs[dummyFctr][dummyCctr]) {\</span>
00305 <span class="preprocessor">        skipThisEntry = true;\</span>
00306 <span class="preprocessor">        break;\</span>
00307 <span class="preprocessor">      }\</span>
00308 <span class="preprocessor">    }\</span>
00309 <span class="preprocessor">    if(skipThisEntry) {\</span>
00310 <span class="preprocessor">      break;\</span>
00311 <span class="preprocessor">    }\</span>
00312 <span class="preprocessor">  }\</span>
00313 <span class="preprocessor">}</span>
00314 <span class="preprocessor"></span>
<a name="l00315"></a><a class="code" href="RestrictMatVec_8C.html#a7">00315</a> <span class="preprocessor">#define ITLB_DUMMY_FINAL_SET_VALUE(nodeNum,idx) {\</span>
00316 <span class="preprocessor">  if(!(fhnMask &amp; (1 &lt;&lt; nodeNum))) {\</span>
00317 <span class="preprocessor">    ot::FineTouchedDummyStatus* fineTouchedDummyStatusPtr = (&amp;(fineTouchedDummyFlagsArr[idx]));\</span>
00318 <span class="preprocessor">    typedef unsigned short* ushPtr;\</span>
00319 <span class="preprocessor">    ushPtr dummyMapPtrs[8];\</span>
00320 <span class="preprocessor">    for(unsigned char dummyFctr = 0; dummyFctr &lt; 8; dummyFctr++) {\</span>
00321 <span class="preprocessor">      dummyMapPtrs[dummyFctr] = NULL;\</span>
00322 <span class="preprocessor">      ITLB_DUMMY_FCTR_BLOCK1\</span>
00323 <span class="preprocessor">    }\</span>
00324 <span class="preprocessor">    ot::FineTouchedStatus* fineTouchedStatusPtr = (&amp;(fineTouchedFlagsArr[idx]));\</span>
00325 <span class="preprocessor">    for(unsigned char fCtr = 0; fCtr &lt; 8; fCtr++) {\</span>
00326 <span class="preprocessor">      fineTouchedStatusPtr-&gt;flags[fCtr] = 0;\</span>
00327 <span class="preprocessor">      </span><span class="comment">/*Handle negative boundaries*/</span>\
00328       if(dummyMapPtrs[fCtr]) {\
00329         for(unsigned char cCtr = 0; cCtr &lt; 8; cCtr++) {\
00330           <span class="comment">/*Can't guarantee that each of the 8 elements*/</span>\
00331           <span class="comment">/*surrounding this fine node has a different cNum*/</span>\
00332           <span class="comment">/*But, they will have a different fCtr*/</span>\
00333           unsigned short coarseVtxId = dummyMapPtrs[fCtr][cCtr];\
00334           bool skipThisEntry = false;\
00335           for(unsigned char dummyFctr = 0; dummyFctr &lt; fCtr; dummyFctr++) {\
00336             ITLB_DUMMY_FCTR_BLOCK2\
00337           }\
00338           if(!skipThisEntry) {\
00339             fineTouchedStatusPtr-&gt;flags[fCtr] |= (1 &lt;&lt; cCtr);\
00340           }\
00341         }\
00342       }\
00343     }\
00344   }\
00345 }
00346 
<a name="l00347"></a><a class="code" href="RestrictMatVec_8C.html#a8">00347</a> <span class="preprocessor">#define INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY_FINAL_W {\</span>
00348 <span class="preprocessor">  </span><span class="comment">/*To avoid redundant writes, only the element whose anchor is */</span>\
00349   <span class="comment">/*the regular fine grid node writes for all the 8 elements */</span>\
00350   <span class="comment">/*surrounding this node. Note, that some of these elements */</span>\
00351   <span class="comment">/* may be owned by other processors. So all processors take */</span>\
00352   <span class="comment">/* care of all the 8 elements surrounding the node they own.*/</span>\
00353   <span class="comment">/* The only other problem is with the positive boundary nodes. */</span>\
00354   <span class="comment">/* The element whose anchor is this positive boundary node is only */</span>\
00355   <span class="comment">/* a pseudo-element and will never be visited while looping through the */</span>\
00356   <span class="comment">/* elements. To make things worse, we can have situtations where a */</span>\
00357   <span class="comment">/* positive boundary node is owned by one processor and all the */</span>\
00358   <span class="comment">/* true  elements that share this node are on different processors. */</span>\
00359   <span class="comment">/* Thus a writable loop will never suffice to take care of this */</span>\
00360   <span class="comment">/* scenario. Hence, this WRITABLE loop will handle all nodes except */</span>\
00361   <span class="comment">/* positive boundaries and a separate ALL loop will handle positive */</span>\
00362   <span class="comment">/* boundary nodes alone. NOTE, that unlike the other loops in the */</span>\
00363   <span class="comment">/* restriction/prolongation, these two loops are not simultaneous */</span>\
00364   <span class="comment">/* loops through both the fine and coarse grids. Looping through the */</span>\
00365   <span class="comment">/* fine mesh will suffice.*/</span>\
00366   unsigned char fhnMask = daf-&gt;getHangingNodeIndex(daf-&gt;curr());\
00367   ITLB_DUMMY_FINAL_SET_VALUE(0,daf-&gt;curr())\
00368 }
00369 
<a name="l00370"></a><a class="code" href="RestrictMatVec_8C.html#a9">00370</a> <span class="preprocessor">#define INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY_FINAL_A {\</span>
00371 <span class="preprocessor">  unsigned char fBndFlag;\</span>
00372 <span class="preprocessor">  bool fIsBnd = daf-&gt;isBoundaryOctant(&amp;fBndFlag);\</span>
00373 <span class="preprocessor">  fIsBnd = (fBndFlag &gt; ot::TreeNode::NEG_POS_DEMARCATION);\</span>
00374 <span class="preprocessor">  if(fIsBnd) {\</span>
00375 <span class="preprocessor">    unsigned char fhnMask = daf-&gt;getHangingNodeIndex(daf-&gt;curr());\</span>
00376 <span class="preprocessor">    unsigned int fIndices[8];\</span>
00377 <span class="preprocessor">    daf-&gt;getNodeIndices(fIndices);\</span>
00378 <span class="preprocessor">    if(fBndFlag &amp; ot::TreeNode::X_POS_BDY) {\</span>
00379 <span class="preprocessor">      ITLB_DUMMY_FINAL_SET_VALUE(1,fIndices[1])\</span>
00380 <span class="preprocessor">    }\</span>
00381 <span class="preprocessor">    if(fBndFlag &amp; ot::TreeNode::Y_POS_BDY) {\</span>
00382 <span class="preprocessor">      ITLB_DUMMY_FINAL_SET_VALUE(2,fIndices[2])\</span>
00383 <span class="preprocessor">    }\</span>
00384 <span class="preprocessor">    if(fBndFlag &amp; ot::TreeNode::Z_POS_BDY) {\</span>
00385 <span class="preprocessor">      ITLB_DUMMY_FINAL_SET_VALUE(4,fIndices[4])\</span>
00386 <span class="preprocessor">    }\</span>
00387 <span class="preprocessor">    if( (fBndFlag &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY))\</span>
00388 <span class="preprocessor">        == (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY) ) {\</span>
00389 <span class="preprocessor">      ITLB_DUMMY_FINAL_SET_VALUE(3,fIndices[3])\</span>
00390 <span class="preprocessor">    }\</span>
00391 <span class="preprocessor">    if( (fBndFlag &amp; (ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY))\</span>
00392 <span class="preprocessor">        == (ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY) ) {\</span>
00393 <span class="preprocessor">      ITLB_DUMMY_FINAL_SET_VALUE(6,fIndices[6])\</span>
00394 <span class="preprocessor">    }\</span>
00395 <span class="preprocessor">    if( (fBndFlag &amp; (ot::TreeNode::Z_POS_BDY + ot::TreeNode::X_POS_BDY))\</span>
00396 <span class="preprocessor">        == (ot::TreeNode::Z_POS_BDY + ot::TreeNode::X_POS_BDY) ) {\</span>
00397 <span class="preprocessor">      ITLB_DUMMY_FINAL_SET_VALUE(5,fIndices[5])\</span>
00398 <span class="preprocessor">    }\</span>
00399 <span class="preprocessor">    if( (fBndFlag &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY))\</span>
00400 <span class="preprocessor">        == (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY) ) {\</span>
00401 <span class="preprocessor">      ITLB_DUMMY_FINAL_SET_VALUE(7,fIndices[7])\</span>
00402 <span class="preprocessor">    }\</span>
00403 <span class="preprocessor">  }else {\</span>
00404 <span class="preprocessor">    if(daf-&gt;isLUTcompressed()) {\</span>
00405 <span class="preprocessor">      daf-&gt;updateQuotientCounter();\</span>
00406 <span class="preprocessor">    }\</span>
00407 <span class="preprocessor">  }\</span>
00408 <span class="preprocessor">}</span>
00409 <span class="preprocessor"></span>
<a name="l00410"></a><a class="code" href="namespaceot.html#a118">00410</a> PetscErrorCode <a class="code" href="namespaceot.html#a118">dummyRestrictMatVecType1</a>(<a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a> *data) {
00411 
00412   <a class="code" href="omg_8h.html#a30">PROF_MG_RESTRICT_DUMMY_BEGIN</a>
00413 
00414     <a class="code" href="classot_1_1DA.html">ot::DA</a> * dac = data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o3">dac</a>;
00415   <a class="code" href="classot_1_1DA.html">ot::DA</a> * daf = data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o4">daf</a>;
00416 
00417   <a class="code" href="classot_1_1FineTouchedDummyStatus.html">ot::FineTouchedDummyStatus</a>* fineTouchedDummyFlagsArr;
00418   std::vector&lt;ot::FineTouchedDummyStatus &gt; fineTouchedDummyFlags;
00419 
00420   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>&lt;<a class="code" href="classot_1_1FineTouchedDummyStatus.html">ot::FineTouchedDummyStatus</a> &gt;(fineTouchedDummyFlags, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);
00421   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<a class="code" href="classot_1_1FineTouchedDummyStatus.html">ot::FineTouchedDummyStatus</a> &gt;(fineTouchedDummyFlags,
00422       fineTouchedDummyFlagsArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);<span class="comment">//writable </span>
00423 
00424   <span class="keywordflow">if</span>(dac-&gt;iAmActive()) {
00425     <span class="keywordflow">for</span>(dac-&gt;init&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00426         dac-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(); dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {
00427       INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY;      
00428     }<span class="comment">//end dependent loop</span>
00429   }
00430 
00431   <span class="keywordflow">if</span>(daf-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00432     daf-&gt;<a class="code" href="classot_1_1DA.html#z33_6">WriteToGhostsBegin</a>&lt;<a class="code" href="classot_1_1FineTouchedDummyStatus.html">ot::FineTouchedDummyStatus</a>&gt;(fineTouchedDummyFlagsArr, 1);
00433   }
00434 
00435   <span class="keywordflow">if</span>(dac-&gt;iAmActive()) {
00436     <span class="comment">//Note: If Coarse is Independent, then the corresponding Fine is also independent.</span>
00437     <span class="comment">//Hence, overlapping comm with comp is possible.            </span>
00438     <span class="keywordflow">for</span>(dac-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00439         dac-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {
00440       INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY;      
00441     }<span class="comment">//end Independent loop (overlapping with write to coarse ghosts) </span>
00442   }
00443 
00444   <span class="keywordflow">if</span>(daf-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00445     daf-&gt;<a class="code" href="classot_1_1DA.html#z33_7">WriteToGhostsEnd</a>&lt;<a class="code" href="classot_1_1FineTouchedDummyStatus.html">ot::FineTouchedDummyStatus</a> &gt;(fineTouchedDummyFlagsArr, 1);
00446   }
00447 
00448   <span class="comment">//Take care of the discrepancies across processors.</span>
00449   <span class="comment">//It is not sufficient to loop over the dependent elements alone to set the</span>
00450   <span class="comment">//status. i.e. setting status for the independent elements can not be</span>
00451   <span class="comment">//combined with computing dummystatus. This is because by definition, a</span>
00452   <span class="comment">//dependent element is one which has atleast 1 writable and 1 ghost node. But</span>
00453   <span class="comment">//we could have cases where the owner of the node is not a dependent element,</span>
00454   <span class="comment">//but this node is shared with ghost elements.</span>
00455 
00456   <a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a>* fineTouchedFlagsArr;
00457   std::vector&lt;ot::FineTouchedStatus &gt;* fineTouchedFlags = data-&gt;<a class="code" href="structot_1_1TransferOpData.html#o6">fineTouchedFlags</a>;
00458 
00459   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a> &gt;(*fineTouchedFlags, fineTouchedFlagsArr,
00460       <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);<span class="comment">//writable </span>
00461 
00462   <span class="keywordflow">if</span>(daf-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00463     <span class="keywordflow">for</span>(daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;(); daf-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; daf-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;(); daf-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;()) {
00464       INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY_FINAL_W;      
00465     }<span class="comment">//end  W loop</span>
00466     <span class="keywordflow">for</span>(daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); daf-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; daf-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;(); daf-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;()) {
00467       INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY_FINAL_A;      
00468     }<span class="comment">//end  A loop</span>
00469   }
00470 
00471   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a> &gt;(*fineTouchedFlags, fineTouchedFlagsArr, 
00472       <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);<span class="comment">//writable </span>
00473 
00474   <span class="comment">//THIS IS A HACK FOR EFFICIENCY PURPOSES. Although, the buffer was modified</span>
00475   <span class="comment">//there is no need to write the changes back to the vector. This is because</span>
00476   <span class="comment">//the dummy vector is only temporary.   </span>
00477   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<a class="code" href="classot_1_1FineTouchedDummyStatus.html">ot::FineTouchedDummyStatus</a> &gt;(fineTouchedDummyFlags, fineTouchedDummyFlagsArr, 
00478       <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);<span class="comment">//READ-ONLY</span>
00479 
00480   fineTouchedDummyFlags.clear();
00481 
00482   <a class="code" href="omg_8h.html#a31">PROF_MG_RESTRICT_DUMMY_END</a>
00483 }<span class="comment">//restrict-3</span>
00484 
<a name="l00485"></a><a class="code" href="namespaceot.html#a119">00485</a> PetscErrorCode <a class="code" href="namespaceot.html#a119">restrictMatVecType1</a>(Mat R, Vec f, Vec c) {
00486 
00487   <a class="code" href="omg_8h.html#a28">PROF_MG_RESTRICT_BEGIN</a>
00488 
00489     <a class="code" href="structot_1_1TransferOpData.html">TransferOpData</a> *data;
00490   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext( R, (<span class="keywordtype">void</span> **)&amp;data));
00491 
00492   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dof = data-&gt;dof;
00493 
00494   <span class="comment">//Overlap 75% of the independent computation with the first communication and</span>
00495   <span class="comment">//25% with the second communication. In the first communication, we exchange</span>
00496   <span class="comment">// fine grid ghosts. In the second, we exchange coarse grid ghosts (1/4 of</span>
00497   <span class="comment">//fine grid, assuming uniform refinement). So, the</span>
00498   <span class="comment">//first comm. is more expensive.</span>
00499   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fop = 75;
00500 
00501   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* suppressedDOFc = data-&gt;suppressedDOFc;
00502   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* suppressedDOFf = data-&gt;suppressedDOFf;
00503 
00504   <a class="code" href="classot_1_1DA.html">ot::DA</a> * dac = data-&gt;dac;
00505   <a class="code" href="classot_1_1DA.html">ot::DA</a> * daf = data-&gt;daf;
00506 
00507   PetscInt cSz;
00508   <a class="code" href="omg_8C.html#a0">iC</a>(VecGetLocalSize(c,&amp;cSz));
00509 
00510   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fopCnt = (fop*cSz)/(100*dof);
00511 
00512   <span class="comment">//unsigned int fopCnt = data-&gt;minIndependentSize;</span>
00513 
00514   std::vector&lt;ot::FineTouchedStatus &gt;* fineTouchedFlags = data-&gt;fineTouchedFlags;
00515   <a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a>* fineTouchedFlagsArr;
00516 
00517   PetscScalar *farr = NULL;
00518   PetscScalar *carr = NULL;
00519 
00520   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(f,farr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,dof);<span class="comment">//Read-only</span>
00521   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a> &gt;(*fineTouchedFlags, 
00522       fineTouchedFlagsArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);<span class="comment">//read-only </span>
00523 
00524   <span class="keywordflow">if</span>(daf-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00525     daf-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;PetscScalar&gt;(farr, dof);
00526     daf-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a>&gt;(fineTouchedFlagsArr, 1);
00527   }
00528 
00529   VecZeroEntries(c);
00530   dac-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(c,carr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,dof);<span class="comment">//Writable</span>
00531 
00532   <span class="keywordflow">if</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00533     <span class="comment">//Note: If Coarse is Independent, then the corresponding Fine is also independent.</span>
00534     <span class="comment">//Hence, overlapping comm with comp is possible.            </span>
00535     <span class="comment">//Order of the test condition is important. We want to store the info before checking loopCtr.               </span>
00536     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> loopCtr = 0;
00537     <span class="keywordflow">if</span>(suppressedDOFc || suppressedDOFf) {
00538       <span class="keywordflow">for</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00539           ( (daf-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>() == daf-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>()) &amp;&amp; 
00540             (dac-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) &amp;&amp; (loopCtr &lt; fopCnt) );
00541           dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), loopCtr++) {
00542         <a class="code" href="ProlongMatVec_8C.html#a3">INTERGRID_TRANSFER_LOOP_BLOCK</a>(<a class="code" href="ProlongMatVec_8C.html#a2">ITLB_SET_VALUE_SUPPRESSED_DOFS</a>);  
00543       }<span class="comment">//end Independent loop (overlapping with read from fine ghosts)</span>
00544     } <span class="keywordflow">else</span> {
00545       <span class="keywordflow">for</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00546           ( (daf-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>() == daf-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>()) &amp;&amp; 
00547             (dac-&gt;<a class="code" href="classot_1_1DA.html#z36_1">currWithInfo</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) &amp;&amp; (loopCtr &lt; fopCnt) );
00548           dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), loopCtr++) {
00549         <a class="code" href="ProlongMatVec_8C.html#a3">INTERGRID_TRANSFER_LOOP_BLOCK</a>(<a class="code" href="ProlongMatVec_8C.html#a1">ITLB_SET_VALUE_NO_SUPPRESSED_DOFS</a>);       
00550       }<span class="comment">//end Independent loop (overlapping with read from fine ghosts)</span>
00551     }
00552   }
00553 
00554   <span class="keywordflow">if</span>(daf-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00555     daf-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;PetscScalar&gt;(farr);
00556     daf-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a>&gt;(fineTouchedFlagsArr);
00557   }
00558 
00559   <span class="keywordflow">if</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00560     <span class="keywordflow">if</span>(suppressedDOFc || suppressedDOFf) {
00561       <span class="keywordflow">for</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00562           dac-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(); dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {
00563         <a class="code" href="ProlongMatVec_8C.html#a3">INTERGRID_TRANSFER_LOOP_BLOCK</a>(<a class="code" href="ProlongMatVec_8C.html#a2">ITLB_SET_VALUE_SUPPRESSED_DOFS</a>);  
00564       }<span class="comment">//end dependent loop</span>
00565     } <span class="keywordflow">else</span> {
00566       <span class="keywordflow">for</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00567           dac-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(); dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {
00568         <a class="code" href="ProlongMatVec_8C.html#a3">INTERGRID_TRANSFER_LOOP_BLOCK</a>(<a class="code" href="ProlongMatVec_8C.html#a1">ITLB_SET_VALUE_NO_SUPPRESSED_DOFS</a>);       
00569       }<span class="comment">//end dependent loop</span>
00570     }
00571   }
00572 
00573   <span class="keywordflow">if</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00574     dac-&gt;<a class="code" href="classot_1_1DA.html#z33_6">WriteToGhostsBegin</a>&lt;PetscScalar&gt;(carr,  dof);
00575   }
00576 
00577   <span class="keywordflow">if</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00578     <span class="comment">//Continue Independent loop from where we left off.</span>
00579     <span class="keywordflow">if</span>(suppressedDOFc || suppressedDOFf) {
00580       <span class="keywordflow">for</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::FROM_STORED&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::FROM_STORED&gt;();
00581           dac-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {
00582         <a class="code" href="ProlongMatVec_8C.html#a3">INTERGRID_TRANSFER_LOOP_BLOCK</a>(<a class="code" href="ProlongMatVec_8C.html#a2">ITLB_SET_VALUE_SUPPRESSED_DOFS</a>);  
00583       }<span class="comment">//end Independent loop (overlapping with write to coarse ghosts) </span>
00584     } <span class="keywordflow">else</span> {
00585       <span class="keywordflow">for</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::FROM_STORED&gt;(), daf-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::FROM_STORED&gt;();
00586           dac-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; dac-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); dac-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {
00587         <a class="code" href="ProlongMatVec_8C.html#a3">INTERGRID_TRANSFER_LOOP_BLOCK</a>(<a class="code" href="ProlongMatVec_8C.html#a1">ITLB_SET_VALUE_NO_SUPPRESSED_DOFS</a>);       
00588       }<span class="comment">//end Independent loop (overlapping with write to coarse ghosts) </span>
00589     }
00590   }
00591 
00592   <span class="keywordflow">if</span>(dac-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00593     dac-&gt;<a class="code" href="classot_1_1DA.html#z33_7">WriteToGhostsEnd</a>&lt;PetscScalar&gt;(carr, dof);
00594   }
00595 
00596   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(f,farr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,dof);<span class="comment">//Read-only</span>
00597   dac-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(c,carr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,dof);<span class="comment">//Writable  </span>
00598   daf-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<a class="code" href="classot_1_1FineTouchedStatus.html">ot::FineTouchedStatus</a> &gt;(*fineTouchedFlags, 
00599       fineTouchedFlagsArr, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, 1);<span class="comment">//read-only </span>
00600 
00601 <span class="preprocessor">#ifdef PETSC_USE_LOG</span>
00602 <span class="preprocessor"></span>  PetscLogFlops(128*dof*(daf-&gt;<a class="code" href="classot_1_1DA.html#z31_5">getElementSize</a>()));
00603 <span class="preprocessor">#endif</span>
00604 <span class="preprocessor"></span>
00605   <a class="code" href="omg_8h.html#a29">PROF_MG_RESTRICT_END</a>
00606 }<span class="comment">//restrict-3</span>
00607 
00608 <span class="preprocessor">#undef ITLB_SET_VALUE_NO_SUPPRESSED_DOFS</span>
00609 <span class="preprocessor"></span><span class="preprocessor">#undef ITLB_SET_VALUE_SUPPRESSED_DOFS</span>
00610 <span class="preprocessor"></span><span class="preprocessor">#undef INTERGRID_TRANSFER_LOOP_BLOCK</span>
00611 <span class="preprocessor"></span><span class="preprocessor">#undef INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY</span>
00612 <span class="preprocessor"></span><span class="preprocessor">#undef ITLB_DUMMY_FCTR_BLOCK1 </span>
00613 <span class="preprocessor"></span><span class="preprocessor">#undef ITLB_DUMMY_FCTR_BLOCK2 </span>
00614 <span class="preprocessor"></span><span class="preprocessor">#undef ITLB_DUMMY_FINAL_SET_VALUE </span>
00615 <span class="preprocessor"></span><span class="preprocessor">#undef INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY_FINAL_W</span>
00616 <span class="preprocessor"></span><span class="preprocessor">#undef INTERGRID_TRANSFER_LOOP_BLOCK_DUMMY_FINAL_A</span>
00617 <span class="preprocessor"></span>
00618 }<span class="comment">//end namespace</span>
00619 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:33 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
