<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/include/fem/feMatrix.txx Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000001.html">include</a>&nbsp;/&nbsp;<a class="el" href="dir_000003.html">fem</a></div>
<h1>feMatrix.txx</h1><a href="feMatrix_8txx.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00003 feMatrix&lt;T&gt;::feMatrix() {
00004   <a class="code" href="classot_1_1fem_1_1feMat.html#p1">m_daType</a> = PETSC;
00005   <a class="code" href="classot_1_1fem_1_1feMat.html#p0">m_DA</a>          = NULL;
00006   <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>       = NULL;
00007   <a class="code" href="classot_1_1fem_1_1feMatrix.html#p0">m_stencil</a>     = NULL;
00008   <a class="code" href="classot_1_1fem_1_1feMatrix.html#p4">m_uiDof</a>       = 1;
00009   <a class="code" href="classot_1_1fem_1_1feMatrix.html#p3">m_ucpLut</a>      = NULL;
00010 
00011   <span class="comment">// initialize the stencils ...</span>
00012   <a class="code" href="classot_1_1fem_1_1feMatrix.html#a11">initStencils</a>();
00013 }
00014 
00015 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00016 feMatrix&lt;T&gt;::feMatrix(daType da) {
00017 <span class="preprocessor">#ifdef __DEBUG__</span>
00018 <span class="preprocessor"></span>  assert ( ( da == PETSC ) || ( da == OCT ) );
00019 <span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span>  <a class="code" href="classot_1_1fem_1_1feMat.html#p1">m_daType</a> = da;
00021   <a class="code" href="classot_1_1fem_1_1feMat.html#p0">m_DA</a>          = NULL;
00022   <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>       = NULL;
00023   <a class="code" href="classot_1_1fem_1_1feMatrix.html#p0">m_stencil</a>     = NULL;
00024   <a class="code" href="classot_1_1fem_1_1feMatrix.html#p3">m_ucpLut</a>      = NULL;
00025 
00026   <span class="comment">// initialize the stencils ...</span>
00027   <a class="code" href="classot_1_1fem_1_1feMatrix.html#a11">initStencils</a>();
00028   <span class="keywordflow">if</span> (da == OCT)
00029     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a10">initOctLut</a>();
00030 }
00031 
00032 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00033 <span class="keywordtype">void</span> feMatrix&lt;T&gt;::initOctLut() {
00034   <span class="comment">//Note: It is not symmetric.</span>
00035   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmp[8][8]={
00036     {0,1,2,3,4,5,6,7},
00037     {1,3,0,2,5,7,4,6},
00038     {2,0,3,1,6,4,7,5},
00039     {3,2,1,0,7,6,5,4},
00040     {4,5,0,1,6,7,2,3},
00041     {5,7,1,3,4,6,0,2},
00042     {6,4,2,0,7,5,3,1},
00043     {7,6,3,2,5,4,1,0}
00044   };
00045 
00046   <span class="comment">//Is Stored in  ROW_MAJOR Format.  </span>
00047   <span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>* charPtr;
00048   <a class="code" href="classot_1_1fem_1_1feMatrix.html#p3">m_ucpLut</a> = <span class="keyword">new</span> charPtr[8];
00049   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;8;i++) {
00050     <a class="code" href="classot_1_1fem_1_1feMatrix.html#p3">m_ucpLut</a>[i] = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>[8]; 
00051     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0;j&lt;8;j++) {
00052       <a class="code" href="classot_1_1fem_1_1feMatrix.html#p3">m_ucpLut</a>[i][j] = tmp[i][j];
00053     }
00054   }
00055 }
00056 
00057 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00058 feMatrix&lt;T&gt;::~feMatrix() {
00059 }
00060 
00061 
00062 <span class="preprocessor">#undef __FUNCT__</span>
00063 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "feMatrix_MatGetDiagonal"</span>
00064 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00065 <span class="keywordtype">bool</span> feMatrix&lt;T&gt;::MatGetDiagonal(Vec _diag, <span class="keywordtype">double</span> scale){
00066   PetscFunctionBegin;
00067 <span class="preprocessor">#ifdef __DEBUG__</span>
00068 <span class="preprocessor"></span>  assert ( ( m_daType == PETSC ) || ( m_daType == OCT ) );
00069 <span class="preprocessor">#endif</span>
00070 <span class="preprocessor"></span>
00071   <span class="keywordtype">int</span> ierr;
00072 
00073   <span class="comment">// PetscScalar zero=0.0;</span>
00074 
00075   <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feMat.html#p1">m_daType</a> == PETSC) {
00076 
00077     PetscInt x,y,z,m,n,p;
00078     PetscInt mx,my,mz;
00079     <span class="keywordtype">int</span> xne,yne,zne;
00080 
00081     PetscScalar ***diag;
00082     Vec diagLocal;
00083 
00084     <span class="comment">/* Get all corners*/</span>
00085     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feMat.html#p0">m_DA</a> == NULL)
00086       std::cerr &lt;&lt; <span class="stringliteral">"Da is null"</span> &lt;&lt; std::endl;
00087     ierr = DAGetCorners(m_DA, &amp;x, &amp;y, &amp;z, &amp;m, &amp;n, &amp;p); CHKERRQ(ierr); 
00088     <span class="comment">/* Get Info*/</span>
00089     ierr = DAGetInfo(m_DA,0, &amp;mx, &amp;my, &amp;mz, 0,0,0,0,0,0,0); CHKERRQ(ierr); 
00090 
00091     <span class="keywordflow">if</span> (x+m == mx) {
00092       xne=m-1;
00093     } <span class="keywordflow">else</span> {
00094       xne=m;
00095     }
00096     <span class="keywordflow">if</span> (y+n == my) {
00097       yne=n-1;
00098     } <span class="keywordflow">else</span> {
00099       yne=n;
00100     }
00101     <span class="keywordflow">if</span> (z+p == mz) {
00102       zne=p-1;
00103     } <span class="keywordflow">else</span> {
00104       zne=p;
00105     }
00106 
00107     ierr = DAGetLocalVector(m_DA, &amp;diagLocal); CHKERRQ(ierr);
00108     ierr = VecZeroEntries(diagLocal);
00109 
00110     <span class="comment">// ierr = DAGlobalToLocalBegin(m_DA, _diag, INSERT_VALUES, diagLocal); CHKERRQ(ierr);</span>
00111     <span class="comment">// ierr = DAGlobalToLocalEnd(m_DA, _diag, INSERT_VALUES, diagLocal); CHKERRQ(ierr);</span>
00112 
00113    
00114     ierr = DAVecGetArray(m_DA, diagLocal, &amp;diag);
00115 
00116     <span class="comment">// Any derived class initializations ...</span>
00117     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a16">preMatVec</a>();
00118 
00119     <span class="comment">// loop through all elements ...</span>
00120     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=z; k&lt;z+zne; k++){
00121       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=y; j&lt;y+yne; j++){
00122         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=x; i&lt;x+xne; i++){
00123          <a class="code" href="classot_1_1fem_1_1feMatrix.html#a3">ElementalMatGetDiagonal</a>(i, j, k, diag, scale);
00124         } <span class="comment">// end i</span>
00125       } <span class="comment">// end j</span>
00126     } <span class="comment">// end k</span>
00127 
00128     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a15">postMatVec</a>();
00129 
00130     ierr = DAVecRestoreArray(m_DA, diagLocal, &amp;diag);   CHKERRQ(ierr);  
00131 
00132    
00133     ierr = DALocalToGlobalBegin(m_DA, diagLocal, _diag); CHKERRQ(ierr);  
00134     ierr = DALocalToGlobalEnd(m_DA, diagLocal, _diag); CHKERRQ(ierr);  
00135     
00136     ierr = DARestoreLocalVector(m_DA, &amp;diagLocal); CHKERRQ(ierr);  
00137 
00138     
00139   } <span class="keywordflow">else</span> {
00140     <span class="comment">// loop for octree DA.</span>
00141     PetscScalar *diag=NULL;
00142 
00143     <span class="comment">// get Buffers ...</span>
00144     <span class="comment">//Nodal,Non-Ghosted,Read,1 dof, Get in array and get ghosts during computation</span>
00145     <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(_diag, diag, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, m_uiDof);
00146     
00147     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a16">preMatVec</a>();
00148 
00149     <span class="comment">// loop through all elements ...</span>
00150     <span class="keywordflow">for</span> ( <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;(); <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;() ) {
00151       <a class="code" href="classot_1_1fem_1_1feMatrix.html#a3">ElementalMatGetDiagonal</a>( <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>(), diag, scale); 
00152     }<span class="comment">//end </span>
00153 
00154     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a15">postMatVec</a>();
00155 
00156     <span class="comment">// Restore Vectors ..</span>
00157     <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(_diag, diag, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, m_uiDof);
00158   }
00159 
00160   PetscFunctionReturn(0);
00161 }
00162 
00163 
00164 
00178 <span class="preprocessor">#undef __FUNCT__</span>
00179 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "feMatrix_MatVec"</span>
00180 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00181 <span class="keywordtype">bool</span> feMatrix&lt;T&gt;::MatVec(Vec _in, Vec _out, <span class="keywordtype">double</span> scale){
00182   PetscFunctionBegin;
00183 
00184 <span class="preprocessor">#ifdef __DEBUG__</span>
00185 <span class="preprocessor"></span>  assert ( ( m_daType == PETSC ) || ( m_daType == OCT ) );
00186 <span class="preprocessor">#endif</span>
00187 <span class="preprocessor"></span>
00188   <span class="keywordtype">int</span> ierr;
00189   <span class="comment">// PetscScalar zero=0.0;</span>
00190 
00191   <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feMat.html#p1">m_daType</a> == PETSC) {
00192 
00193     PetscInt x,y,z,m,n,p;
00194     PetscInt mx,my,mz;
00195     <span class="keywordtype">int</span> xne,yne,zne;
00196 
00197     PetscScalar ***in, ***out;
00198     Vec inlocal, outlocal;
00199 
00200     <span class="comment">/* Get all corners*/</span>
00201     <span class="keywordflow">if</span> (<a class="code" href="classot_1_1fem_1_1feMat.html#p0">m_DA</a> == NULL)
00202       std::cerr &lt;&lt; <span class="stringliteral">"Da is null"</span> &lt;&lt; std::endl;
00203     ierr = DAGetCorners(m_DA, &amp;x, &amp;y, &amp;z, &amp;m, &amp;n, &amp;p); CHKERRQ(ierr); 
00204     <span class="comment">/* Get Info*/</span>
00205     ierr = DAGetInfo(m_DA,0, &amp;mx, &amp;my, &amp;mz, 0,0,0,0,0,0,0); CHKERRQ(ierr); 
00206 
00207     <span class="keywordflow">if</span> (x+m == mx) {
00208       xne=m-1;
00209     } <span class="keywordflow">else</span> {
00210       xne=m;
00211     }
00212     <span class="keywordflow">if</span> (y+n == my) {
00213       yne=n-1;
00214     } <span class="keywordflow">else</span> {
00215       yne=n;
00216     }
00217     <span class="keywordflow">if</span> (z+p == mz) {
00218       zne=p-1;
00219     } <span class="keywordflow">else</span> {
00220       zne=p;
00221     }
00222 
00223     <span class="comment">// std::cout &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; "," &lt;&lt; z &lt;&lt; " + " &lt;&lt; xne &lt;&lt;","&lt;&lt;yne&lt;&lt;","&lt;&lt;zne&lt;&lt;std::endl;</span>
00224 
00225     <span class="comment">// Get the local vector so that the ghost nodes can be accessed</span>
00226     ierr = DAGetLocalVector(m_DA, &amp;inlocal); CHKERRQ(ierr);
00227     ierr = DAGetLocalVector(m_DA, &amp;outlocal); CHKERRQ(ierr);
00228     <span class="comment">// ierr = VecDuplicate(inlocal, &amp;outlocal); CHKERRQ(ierr);</span>
00229 
00230     ierr = DAGlobalToLocalBegin(m_DA, _in, INSERT_VALUES, inlocal); CHKERRQ(ierr);
00231     ierr = DAGlobalToLocalEnd(m_DA, _in, INSERT_VALUES, inlocal); CHKERRQ(ierr);
00232     <span class="comment">// ierr = DAGlobalToLocalBegin(m_DA, _out, INSERT_VALUES, outlocal); CHKERRQ(ierr);</span>
00233     <span class="comment">// ierr = DAGlobalToLocalEnd(m_DA, _out, INSERT_VALUES, outlocal); CHKERRQ(ierr);</span>
00234 
00235     ierr = VecZeroEntries(outlocal);
00236 
00237     ierr = DAVecGetArray(m_DA, inlocal, &amp;in);
00238     ierr = DAVecGetArray(m_DA, outlocal, &amp;out);
00239 
00240     <span class="comment">// Any derived class initializations ...</span>
00241     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a16">preMatVec</a>();
00242 
00243     <span class="comment">// loop through all elements ...</span>
00244     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k=z; k&lt;z+zne; k++){
00245       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=y; j&lt;y+yne; j++){
00246         <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=x; i&lt;x+xne; i++){
00247           <span class="comment">// std::cout &lt;&lt; i &lt;&lt;"," &lt;&lt; j &lt;&lt; "," &lt;&lt; k &lt;&lt; std::endl;</span>
00248           <a class="code" href="classot_1_1fem_1_1feMatrix.html#a5">ElementalMatVec</a>(i, j, k, in, out, scale);
00249         } <span class="comment">// end i</span>
00250       } <span class="comment">// end j</span>
00251     } <span class="comment">// end k</span>
00252 
00253     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a15">postMatVec</a>();
00254 
00255     ierr = DAVecRestoreArray(m_DA, inlocal, &amp;in); CHKERRQ(ierr);  
00256     ierr = DAVecRestoreArray(m_DA, outlocal, &amp;out);     CHKERRQ(ierr);  
00257 
00258     ierr = DALocalToGlobalBegin(m_DA, outlocal, _out); CHKERRQ(ierr);  
00259     ierr = DALocalToGlobalEnd(m_DA, outlocal, _out); CHKERRQ(ierr);  
00260     
00261     ierr = DARestoreLocalVector(m_DA, &amp;inlocal); CHKERRQ(ierr);  
00262     ierr = DARestoreLocalVector(m_DA, &amp;outlocal); CHKERRQ(ierr);  
00263     <span class="comment">// ierr = VecDestroy(outlocal); CHKERRQ(ierr);  </span>
00264 
00265   } <span class="keywordflow">else</span> {
00266     <span class="comment">// loop for octree DA.</span>
00267     
00268 
00269     PetscScalar *out=NULL;
00270     PetscScalar *in=NULL; 
00271 
00272     <span class="comment">// get Buffers ...</span>
00273     <span class="comment">//Nodal,Non-Ghosted,Read,1 dof, Get in array and get ghosts during computation</span>
00274     <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(_in,   in, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,  m_uiDof);
00275     <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(_out, out, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, m_uiDof);
00276     
00277     <span class="comment">// start comm for in ...</span>
00278     <span class="comment">//m_octDA-&gt;updateGhostsBegin&lt;PetscScalar&gt;(in, false, m_uiDof);</span>
00279     <span class="comment">// m_octDA-&gt;ReadFromGhostsBegin&lt;PetscScalar&gt;(in, false, m_uiDof);</span>
00280     <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z33_2">ReadFromGhostsBegin</a>&lt;PetscScalar&gt;(in, m_uiDof);
00281     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a16">preMatVec</a>();
00282 
00283     <span class="comment">// Independent loop, loop through the nodes this processor owns..</span>
00284     <span class="keywordflow">for</span> ( <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(), <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;(); <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::INDEPENDENT&gt;() ) {
00285       <a class="code" href="classot_1_1fem_1_1feMatrix.html#a5">ElementalMatVec</a>( <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>(), in, out, scale); 
00286     }<span class="comment">//end INDEPENDENT</span>
00287 
00288     <span class="comment">// Wait for communication to end.</span>
00289     <span class="comment">//m_octDA-&gt;updateGhostsEnd&lt;PetscScalar&gt;(in);</span>
00290          <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z33_3">ReadFromGhostsEnd</a>&lt;PetscScalar&gt;(in);
00291 
00292     <span class="comment">// Dependent loop ...</span>
00293     <span class="keywordflow">for</span> ( <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::DEPENDENT&gt;(), <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;(); <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::DEPENDENT&gt;(); <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::DEPENDENT&gt;() ) {
00294       <a class="code" href="classot_1_1fem_1_1feMatrix.html#a5">ElementalMatVec</a>( <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>(), in, out, scale); 
00295     }<span class="comment">//end DEPENDENT</span>
00296 
00297     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a15">postMatVec</a>();
00298 
00299     <span class="comment">// Restore Vectors ...</span>
00300     <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(_in,   in, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>,  m_uiDof);
00301     <a class="code" href="classot_1_1fem_1_1feMat.html#p5">m_octDA</a>-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(_out, out, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, m_uiDof);
00302 
00303   }
00304 
00305   PetscFunctionReturn(0);
00306 }
00307 
00308 <span class="preprocessor">#undef __FUNCT__</span>
00309 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "alignElementAndVertices"</span>
00310 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00311 PetscErrorCode feMatrix&lt;T&gt;::alignElementAndVertices(<a class="code" href="classot_1_1DA.html">ot::DA</a> * da, stdElemType &amp; sType, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices) {
00312   PetscFunctionBegin;
00313   
00314   sType = ST_0;
00315   da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00316 
00317   <span class="comment">// not required ....</span>
00318   <span class="comment">// int rank;</span>
00319   <span class="comment">// MPI_Comm_rank(da-&gt;getComm(), &amp;rank);</span>
00320 
00321   <span class="keywordflow">if</span> (da-&gt;<a class="code" href="classot_1_1DA.html#z36_11">isHanging</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>())) {
00322 
00323     <span class="keywordtype">int</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00324     <a class="code" href="classPoint.html">Point</a> pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();   
00325 
00326     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hangingMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());    
00327 
00328     <span class="comment">//Change HangingMask and indices based on childNum</span>
00329     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a12">mapVtxAndFlagsToOrientation</a>(childNum, indices, hangingMask);    
00330 
00331     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> eType = ((126 &amp; hangingMask)&gt;&gt;1);
00332 
00333     <a class="code" href="classot_1_1fem_1_1feMatrix.html#a17">reOrderIndices</a>(eType, indices);
00334   }<span class="comment">//end if hangingElem.</span>
00335   PetscFunctionReturn(0);
00336 }<span class="comment">//end function.</span>
00337 
00338 <span class="preprocessor">#undef __FUNCT__</span>
00339 <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "mapVtxAndFlagsToOrientation"</span>
00340 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00341 PetscErrorCode feMatrix&lt;T&gt;::mapVtxAndFlagsToOrientation(<span class="keywordtype">int</span> childNum, 
00342  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> &amp; mask) {
00343   PetscFunctionBegin;
00344   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp[8];
00345   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> tmpFlags = 0;
00346   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00347     tmp[i] = indices[<a class="code" href="classot_1_1fem_1_1feMatrix.html#p3">m_ucpLut</a>[childNum][i]];
00348     tmpFlags = ( tmpFlags | ( ( (1 &lt;&lt; (m_ucpLut[childNum][i])) &amp; mask ) ? (1 &lt;&lt; i) : 0 ) );
00349   }
00350   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0;i&lt;8;i++) {
00351     indices[i] = tmp[i];
00352   }
00353   mask = tmpFlags;
00354   PetscFunctionReturn(0);
00355 }<span class="comment">//end function</span>
00356 
00357 <span class="preprocessor">#undef __FUNCT__</span>
<a name="l00358"></a><a class="code" href="feMatrix_8txx.html#a9">00358</a> <span class="preprocessor"></span><span class="preprocessor">#define __FUNCT__ "reOrderIndices"</span>
00359 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
00360 PetscErrorCode feMatrix&lt;T&gt;::reOrderIndices(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> eType, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* indices) {
00361 <span class="preprocessor">#ifdef __DEBUG_1</span>
00362 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">"Entering "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
00363 <span class="preprocessor">#endif</span>
00364 <span class="preprocessor"></span>  PetscFunctionBegin;
00365   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmp;
00366   <span class="keywordflow">switch</span> (eType) {
00367   <span class="keywordflow">case</span>  ET_N: 
00368     <span class="keywordflow">break</span>;
00369   <span class="keywordflow">case</span>  ET_Y:
00370     <span class="keywordflow">break</span>;
00371   <span class="keywordflow">case</span>  ET_X:
00372     <span class="comment">//Swap 1 &amp; 2, Swap 5 &amp; 6</span>
00373     tmp = indices[1];
00374     indices[1] = indices[2];
00375     indices[2] = tmp;
00376     tmp = indices[5];
00377     indices[5] = indices[6];
00378     indices[6] = tmp;
00379     <span class="keywordflow">break</span>;
00380   <span class="keywordflow">case</span>  ET_XY:
00381     <span class="keywordflow">break</span>;
00382   <span class="keywordflow">case</span>  ET_Z:
00383     <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00384     tmp = indices[2];
00385     indices[2] = indices[4];
00386     indices[4] = tmp;
00387     tmp = indices[3];
00388     indices[3] = indices[5];
00389     indices[5] = tmp;
00390     <span class="keywordflow">break</span>;
00391   <span class="keywordflow">case</span>  ET_ZY:
00392     <span class="comment">//Swap 1 &amp; 4, Swap 3 &amp; 6</span>
00393     tmp = indices[1];
00394     indices[1] = indices[4];
00395     indices[4] = tmp;
00396     tmp = indices[3];
00397     indices[3] = indices[6];
00398     indices[6] = tmp;
00399     <span class="keywordflow">break</span>;
00400   <span class="keywordflow">case</span>  ET_ZX:
00401     <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00402     tmp = indices[2];
00403     indices[2] = indices[4];
00404     indices[4] = tmp;
00405     tmp = indices[3];
00406     indices[3] = indices[5];
00407     indices[5] = tmp;
00408     <span class="keywordflow">break</span>;
00409   <span class="keywordflow">case</span>  ET_ZXY:
00410     <span class="keywordflow">break</span>;
00411   <span class="keywordflow">case</span>  ET_XY_XY:
00412     <span class="keywordflow">break</span>;
00413   <span class="keywordflow">case</span>  ET_XY_ZXY:
00414     <span class="keywordflow">break</span>;
00415   <span class="keywordflow">case</span>  ET_YZ_ZY:
00416     <span class="comment">//Swap 1 &amp; 4, Swap 3 &amp; 6</span>
00417     tmp = indices[1];
00418     indices[1] = indices[4];
00419     indices[4] = tmp;
00420     tmp = indices[3];
00421     indices[3] = indices[6];
00422     indices[6] = tmp;
00423     <span class="keywordflow">break</span>;
00424   <span class="keywordflow">case</span>  ET_YZ_ZXY:
00425     <span class="comment">//Swap 1 &amp; 4, Swap 3 &amp; 6</span>
00426     tmp = indices[1];
00427     indices[1] = indices[4];
00428     indices[4] = tmp;
00429     tmp = indices[3];
00430     indices[3] = indices[6];
00431     indices[6] = tmp;
00432     <span class="keywordflow">break</span>;
00433   <span class="keywordflow">case</span>  ET_YZ_XY_ZXY:
00434     <span class="keywordflow">break</span>;
00435   <span class="keywordflow">case</span>  ET_ZX_ZX:
00436     <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00437     tmp = indices[2];
00438     indices[2] = indices[4];
00439     indices[4] = tmp;
00440     tmp = indices[3];
00441     indices[3] = indices[5];
00442     indices[5] = tmp;
00443     <span class="keywordflow">break</span>;
00444   <span class="keywordflow">case</span>  ET_ZX_ZXY:
00445     <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00446     tmp = indices[2];
00447     indices[2] = indices[4];
00448     indices[4] = tmp;
00449     tmp = indices[3];
00450     indices[3] = indices[5];
00451     indices[5] = tmp;
00452     <span class="keywordflow">break</span>;
00453   <span class="keywordflow">case</span>  ET_ZX_XY_ZXY:
00454     <span class="comment">//Swap 1 &amp; 2, Swap 5 &amp; 6</span>
00455     tmp = indices[1];
00456     indices[1] = indices[2];
00457     indices[2] = tmp;
00458     tmp = indices[5];
00459     indices[5] = indices[6];
00460     indices[6] = tmp;
00461     <span class="keywordflow">break</span>;
00462   <span class="keywordflow">case</span>  ET_ZX_YZ_ZXY:
00463     <span class="comment">//Swap 2 &amp; 4, Swap 3 &amp; 5</span>
00464     tmp = indices[2];
00465     indices[2] = indices[4];
00466     indices[4] = tmp;
00467     tmp = indices[3];
00468     indices[3] = indices[5];
00469     indices[5] = tmp;
00470     <span class="keywordflow">break</span>;
00471   <span class="keywordflow">case</span>  ET_ZX_YZ_XY_ZXY:
00472     <span class="keywordflow">break</span>;
00473   <span class="keywordflow">default</span>:
00474     std::cout&lt;&lt;<span class="stringliteral">"in reOrder Etype: "</span>&lt;&lt; (int) eType &lt;&lt; std::endl;
00475     assert(<span class="keyword">false</span>);
00476   }
00477 <span class="preprocessor">#ifdef __DEBUG_1</span>
00478 <span class="preprocessor"></span>  std::cout &lt;&lt; <span class="stringliteral">"Leaving "</span> &lt;&lt; __func__ &lt;&lt; std::endl;
00479 <span class="preprocessor">#endif</span>
00480 <span class="preprocessor"></span>  PetscFunctionReturn(0);
00481 }
00482 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:27 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
