<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oct/OctFunctions.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000015.html">oct</a></div>
<h1>OctFunctions.C</h1><a href="OctFunctions_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00011 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00014 
00015 <span class="preprocessor">#ifdef __DEBUG__</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_OCT__</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_OCT__</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span>
00021 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#ifndef __MEASURE_FLAG_NODES__</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#define __MEASURE_FLAG_NODES__</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span>
00027 <span class="keyword">namespace </span>ot {
00028 
<a name="l00029"></a><a class="code" href="namespaceot.html#a39">00029</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a39">refineOctree</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt; &amp; inp, std::vector&lt;ot::TreeNode&gt; &amp;out) {
00030     out.clear();
00031     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; inp.size(); i++) {
00032       <span class="keywordflow">if</span>(inp[i].getLevel() &lt; inp[i].getMaxDepth()) {
00033         inp[i].addChildren(out);
00034       } <span class="keywordflow">else</span> {
00035         out.push_back(inp[i]);
00036       }
00037     }
00038     <span class="keywordflow">return</span> 1;
00039   }<span class="comment">//end function </span>
00040 
<a name="l00041"></a><a class="code" href="namespaceot.html#a40">00041</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a40">refineAndPartitionOctree</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt; &amp; inp, std::vector&lt;ot::TreeNode&gt; &amp;out, MPI_Comm comm) {
00042     <a class="code" href="namespaceot.html#a39">refineOctree</a>(inp,out);
00043     par::partitionW&lt;ot::TreeNode&gt;(out, NULL,comm);
00044     <span class="keywordflow">return</span> 1;
00045   }<span class="comment">//end function</span>
00046 
<a name="l00047"></a><a class="code" href="namespaceot.html#a41">00047</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a41">createRegularOctree</a>(std::vector&lt;ot::TreeNode&gt;&amp; out, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lev, 
00048       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth, MPI_Comm comm) {
00049     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> root(dim,maxDepth);
00050     out.clear();
00051     <span class="keywordtype">int</span> rank;
00052     MPI_Comm_rank(comm,&amp;rank);
00053     <span class="keywordflow">if</span>(!rank) {
00054       out.push_back(root);
00055     }
00056     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; lev; i++) {
00057       std::vector&lt;ot::TreeNode&gt; tmp;
00058       <a class="code" href="namespaceot.html#a40">refineAndPartitionOctree</a>(out,tmp,comm);
00059       out = tmp;
00060       tmp.clear();
00061     }
00062     <span class="keywordflow">return</span> 1;
00063   }
00064 
00065   <span class="comment">//list must be sorted.</span>
<a name="l00066"></a><a class="code" href="namespaceot.html#a42">00066</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a43">lineariseList</a>(std::vector&lt;ot::TreeNode&gt; &amp; list,<span class="keywordtype">bool</span> skipLast) {
00067     std::vector&lt;ot::TreeNode&gt; tmp;
00068     <span class="keywordflow">if</span>(!(list.empty())) {
00069       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; (list.size()-1); i++) {
00070 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00071 <span class="preprocessor"></span>        assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(list[i], list[i+1]));
00072 <span class="preprocessor">#endif</span>
00073 <span class="preprocessor"></span>        <span class="keywordflow">if</span>(!(list[i].isAncestor(list[i+1]))) {
00074           tmp.push_back(list[i]);
00075         }
00076       }
00077       <span class="keywordflow">if</span>(!skipLast) {
00078         tmp.push_back(list[list.size()-1]);
00079       }
00080     }
00081 
00082     list = tmp;
00083     tmp.clear();
00084     <span class="keywordflow">return</span> 1;
00085   }<span class="comment">//end fn.</span>
00086 
00087   <span class="comment">//list must be sorted.</span>
<a name="l00088"></a><a class="code" href="namespaceot.html#a43">00088</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a43">lineariseList</a>(std::vector&lt;ot::TreeNode&gt; &amp; list,MPI_Comm comm) {
00089     <span class="keywordtype">int</span> rank,size;
00090     MPI_Comm_rank(comm,&amp;rank);
00091     MPI_Comm_size(comm,&amp;size);
00092 
00093     <span class="keywordflow">if</span>(size == 1) {
00094       <a class="code" href="namespaceot.html#a43">lineariseList</a>(list,<span class="keyword">false</span>);
00095       <span class="keywordflow">return</span> 1;
00096     }
00097 
00098     <span class="comment">//Remove empty processors...</span>
00099     <span class="keywordtype">int</span> new_rank, new_size; 
00100     MPI_Comm   new_comm;
00101     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(list.empty(), &amp;new_comm,comm);
00102 
00103     MPI_Comm_rank (new_comm, &amp;new_rank);
00104     MPI_Comm_size (new_comm, &amp;new_size);
00105     <span class="keywordflow">if</span>(!list.empty()) {
00106       <span class="comment">//Send the last octant to the next processor. </span>
00107       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> lastOctant = list[list.size()-1];
00108       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> lastOnPrev;
00109 
00110       MPI_Request recvRequest;
00111       MPI_Request sendRequest;
00112 
00113       <span class="keywordflow">if</span>(new_rank) {
00114         par::Mpi_Irecv&lt;ot::TreeNode&gt;( &amp;lastOnPrev, 1, new_rank-1, 1, new_comm, &amp;recvRequest);
00115       }
00116       <span class="keywordflow">if</span>(new_rank &lt; (new_size-1)) {
00117         par::Mpi_Issend&lt;ot::TreeNode&gt;( &amp;lastOctant, 1, new_rank+1, 1, new_comm,  &amp;sendRequest);
00118       }
00119 
00120       <span class="keywordflow">if</span>(new_rank) {
00121         std::vector&lt;ot::TreeNode&gt; tmp(list.size()+1);
00122         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; list.size(); i++) {
00123           tmp[i+1] = list[i];
00124         }
00125 
00126         MPI_Status statusWait;
00127         MPI_Wait(&amp;recvRequest, &amp;statusWait);
00128         tmp[0] = lastOnPrev;
00129 
00130         list = tmp;
00131         tmp.clear();
00132       }
00133 
00134       <span class="keywordflow">if</span>(new_rank == (new_size-1)) {
00135         <a class="code" href="namespaceot.html#a43">lineariseList</a>(list,<span class="keyword">false</span>);
00136       }<span class="keywordflow">else</span> {
00137         <a class="code" href="namespaceot.html#a43">lineariseList</a>(list,<span class="keyword">true</span>);
00138       }
00139 
00140       <span class="keywordflow">if</span>(new_rank &lt; (new_size-1)) {
00141         MPI_Status statusWait;
00142         MPI_Wait(&amp;sendRequest, &amp;statusWait);
00143       }      
00144     }<span class="comment">//not empty procs only</span>
00145 
00146     <span class="keywordflow">return</span> 1;
00147   }<span class="comment">//end fn.</span>
00148 
<a name="l00149"></a><a class="code" href="namespaceot.html#a44">00149</a>   <span class="keywordtype">bool</span> <a class="code" href="namespaceot.html#a44">lessThanUsingWts</a> ( <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  <span class="keyword">const</span> &amp; a,  <a class="code" href="classot_1_1TreeNode.html">TreeNode</a>  <span class="keyword">const</span> &amp; b)  {
00150     <span class="keywordflow">if</span>(a == b){
00151       <span class="keywordflow">return</span> (a.<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>() &lt; b.<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>());
00152     }<span class="keywordflow">else</span> {
00153       <span class="keywordflow">return</span> (a &lt; b);
00154     }
00155   }<span class="comment">//end function</span>
00156 
<a name="l00157"></a><a class="code" href="namespaceot.html#a45">00157</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a45">getNodeWeight</a>(<span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> * t) {
00158     <span class="keywordflow">return</span> t-&gt;<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>();
00159   }
00160 
<a name="l00161"></a><a class="code" href="namespaceot.html#a46">00161</a>   <span class="keywordtype">bool</span> <a class="code" href="namespaceot.html#a46">bPartComparator</a>(<a class="code" href="classot_1_1TreeNode.html">TreeNode</a> a, <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> b) {
00162     <span class="keywordflow">if</span> ( (a.<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>()) != (b.<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>()) ) {
00163       <span class="comment">//pick denser</span>
00164       <span class="keywordflow">return</span>( (a.<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>()) &gt; (b.<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>()) );
00165     } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (a.<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>() &gt; 1) {
00166       <span class="comment">//pick finer</span>
00167       <span class="keywordflow">return</span>( (a.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()) &gt; (b.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()) );
00168     } <span class="keywordflow">else</span> {
00169       <span class="comment">//pick coarser</span>
00170       <span class="keywordflow">return</span>( (a.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()) &lt; (b.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>()) );
00171     }
00172   }<span class="comment">//end function</span>
00173 
00174   <span class="comment">//If one of first and second is an ancestor of the other, it is returned.  </span>
<a name="l00175"></a><a class="code" href="namespaceot.html#a47">00175</a>   <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> <a class="code" href="namespaceot.html#a47">getNCA</a>(<a class="code" href="classot_1_1TreeNode.html">TreeNode</a> first, <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> second) {
00176 <span class="preprocessor">#ifdef __DEBUG_OCT__</span>
00177 <span class="preprocessor"></span>    assert(<a class="code" href="namespaceot.html#a54">areComparable</a>(first,second));
00178     assert(first != second);
00179 <span class="preprocessor">#endif</span>
00180 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fx = first.<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00181     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sx = second.<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00182     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fy = first.<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00183     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sy = second.<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00184     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> fz = first.<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00185     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz = second.<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00186     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = first.<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>(); 
00187     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = first.<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>(); 
00188     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDiff = (<span class="keywordtype">unsigned</span> int)(std::max((std::max((fx^sx),(fy^sy))),(fz^sz)));
00189     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDiffBinLen = <a class="code" href="namespacebinOp.html#a0">binOp::binLength</a>(maxDiff);
00190     <span class="comment">//Eliminate the last maxDiffBinLen bits.</span>
00191     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ncaX = ((fx&gt;&gt;maxDiffBinLen)&lt;&lt;maxDiffBinLen);
00192     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ncaY = ((fy&gt;&gt;maxDiffBinLen)&lt;&lt;maxDiffBinLen);
00193     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ncaZ = ((fz&gt;&gt;maxDiffBinLen)&lt;&lt;maxDiffBinLen);
00194     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ncaLev = (maxDepth - maxDiffBinLen);
00195     <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> nca(ncaX,ncaY,ncaZ,ncaLev,dim,maxDepth);
00196     <span class="keywordflow">return</span> nca;
00197   }<span class="comment">//end function</span>
00198 
<a name="l00199"></a><a class="code" href="namespaceot.html#a48">00199</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a48">readPtsFromFile</a>(<span class="keywordtype">char</span>* filename, std::vector&lt;double&gt;&amp; pts) {
00200     FILE* infile;
00201     infile = fopen(filename,<span class="stringliteral">"rb"</span>);
00202     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temp;
00203     fread(&amp;temp,<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>),1,infile);
00204 
00205     <span class="keywordtype">double</span>* ptsTemp = NULL;
00206 
00207     <span class="keywordflow">if</span>(temp) {
00208       ptsTemp = <span class="keyword">new</span> <span class="keywordtype">double</span>[3*temp];
00209       fread(ptsTemp, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),3*temp,infile);
00210     }
00211 
00212     fclose(infile);
00213     pts.resize(3*temp);
00214 
00215     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; (3*temp); i++) {
00216       pts[i] = ptsTemp[i];
00217     }<span class="comment">//end for</span>
00218 
00219     <span class="keywordflow">if</span>(ptsTemp) {
00220       <span class="keyword">delete</span> [] ptsTemp;
00221       ptsTemp = NULL;
00222     }
00223 
00224     <span class="keywordflow">return</span> 1;
00225   }<span class="comment">//end function</span>
00226 
<a name="l00227"></a><a class="code" href="namespaceot.html#a49">00227</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a49">readDataPtsFromFile</a>(<span class="keywordtype">char</span>* filename, std::vector&lt;double&gt;&amp; pts, std::vector&lt;double&gt;&amp; ptVals) {
00228     <span class="comment">// file format:</span>
00229     <span class="comment">// 4 bytes (unsigned int?)  number of points N</span>
00230     <span class="comment">// 3*N*8 bytes coordinates of point (double);  X1 Y1 Z1 X2 Y2 Z2 ....</span>
00231     <span class="comment">// N*8 weights attached to points (double)</span>
00232     <span class="comment">// </span>
00233     FILE* infile;
00234     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> temp;
00235 
00236     assert(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)==8);
00237     assert(<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)==4);
00238 
00239     infile = fopen(filename,<span class="stringliteral">"rb"</span>);
00240     fread(&amp;temp,<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>),1,infile);
00241 
00242     pts.resize(3*temp);
00243     ptVals.resize(temp);
00244 
00245     fread(&amp;(pts[0]), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),3*temp,infile);
00246     fread(&amp;(ptVals[0]), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),temp,infile);
00247 
00248     fclose(infile);
00249 
00250     <span class="keywordflow">return</span> 1;
00251   }<span class="comment">//end function</span>
00252 
<a name="l00253"></a><a class="code" href="namespaceot.html#a50">00253</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a50">writePtsToFile</a>(<span class="keywordtype">char</span>* filename, std::vector&lt;double&gt;&amp; pts) {
00254     FILE* outfile = fopen(filename,<span class="stringliteral">"wb"</span>);
00255     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ptsLen = pts.size();
00256     <span class="keywordtype">double</span> * ptsTemp = NULL;
00257     <span class="keywordflow">if</span>(!pts.empty()) {
00258       ptsTemp = (&amp;(*(pts.begin())));
00259     }
00260 
00261     <span class="keywordflow">if</span> (ptsLen &gt;0) {
00262       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPts = ptsLen/3;
00263       fwrite(&amp;numPts,<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>),1,outfile);
00264       fwrite(ptsTemp, <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),ptsLen,outfile);
00265     }
00266     fclose(outfile);
00267     <span class="keywordflow">return</span> 1;
00268   }<span class="comment">//end function</span>
00269 
<a name="l00270"></a><a class="code" href="namespaceot.html#a51">00270</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a51">writeDataPtsToFile</a>(<span class="keywordtype">char</span>* filename, std::vector&lt;double&gt;&amp; pts, std::vector&lt;double&gt;&amp; data) {
00271     FILE* outfile = fopen(filename,<span class="stringliteral">"wb"</span>);
00272     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ptsLen = pts.size();
00273     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numPts=ptsLen/3;
00274 
00275     assert(<span class="keyword">sizeof</span>(<span class="keywordtype">double</span>)==8);
00276     assert(<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)==4);
00277 
00278     fwrite(&amp;numPts,<span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>),1,outfile);
00279     fwrite(&amp;(pts[0]), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),ptsLen,outfile);
00280     fwrite(&amp;(data[0]), <span class="keyword">sizeof</span>(<span class="keywordtype">double</span>),numPts,outfile);
00281     fclose(outfile);
00282     <span class="keywordflow">return</span> 1;
00283   }<span class="comment">//end function</span>
00284 
00285 
00286 
<a name="l00287"></a><a class="code" href="namespaceot.html#a52">00287</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a52">readNodesFromFile</a> (<span class="keywordtype">char</span>* filename, std::vector&lt;TreeNode &gt; &amp; nodes) {
00288     FILE* infile = fopen(filename,<span class="stringliteral">"r"</span>);
00289     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNode;
00290     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, maxDepth;
00291     fscanf(infile,<span class="stringliteral">"%u"</span>,&amp;dim);
00292     fscanf(infile,<span class="stringliteral">"%u"</span>,&amp;maxDepth); 
00293     fscanf(infile,<span class="stringliteral">"%u"</span>,&amp;numNode);
00294     nodes.resize(numNode) ;   
00295 
00296     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =0; i&lt; nodes.size(); i++) {
00297       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x,y,z,d;
00298       fscanf(infile,<span class="stringliteral">"%u"</span>,&amp;x);
00299       fscanf(infile,<span class="stringliteral">"%u"</span>,&amp;y);
00300       fscanf(infile,<span class="stringliteral">"%u"</span>,&amp;z);
00301       fscanf(infile,<span class="stringliteral">"%u"</span>,&amp;d); 
00302       nodes[i] = <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> (x,y,z,d, dim, maxDepth);
00303     }
00304     fclose(infile);
00305     <span class="keywordflow">return</span> 1;
00306   }<span class="comment">//end function</span>
00307 
<a name="l00308"></a><a class="code" href="namespaceot.html#a53">00308</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a53">writeNodesToFile</a> (<span class="keywordtype">char</span>* filename, <span class="keyword">const</span> std::vector&lt;TreeNode&gt; &amp; nodes) {
00309     FILE* outfile = fopen(filename,<span class="stringliteral">"w"</span>);
00310     <span class="keywordflow">if</span> (!nodes.empty()) {
00311       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = nodes[0].<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00312       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = nodes[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
00313       fprintf(outfile,<span class="stringliteral">"%u %u\n"</span>,dim,maxDepth); 
00314       fprintf(outfile,<span class="stringliteral">"%u\n"</span>,static_cast&lt;unsigned int&gt;(nodes.size()));
00315       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =0; i&lt; nodes.size(); i++) {
00316         assert(nodes[i].getDim() == dim);
00317         assert(nodes[i].getMaxDepth() == maxDepth);
00318         fprintf(outfile,<span class="stringliteral">"%u %u %u %u\n"</span>,nodes[i].getX(),nodes[i].getY(),nodes[i].getZ(),nodes[i].getLevel());
00319       }
00320     }
00321     fclose(outfile);
00322     <span class="keywordflow">return</span> 1;
00323   }<span class="comment">//end function</span>
00324 
<a name="l00325"></a><a class="code" href="namespaceot.html#a54">00325</a>   <span class="keywordtype">bool</span> <a class="code" href="namespaceot.html#a54">areComparable</a> (<a class="code" href="classot_1_1TreeNode.html">TreeNode</a> first, <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> second) {
00326     <span class="keywordflow">return</span>( ( (first.<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>()) == (second.<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>()) ) &amp;&amp; ( (first.<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>()) == (second.<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>()) ) );
00327   }
00328 
<a name="l00329"></a><a class="code" href="namespaceot.html#a55">00329</a>   <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a55">int2str</a>(<span class="keywordtype">int</span> n,<span class="keywordtype">char</span>*s) {
00330     <span class="keywordtype">int</span> tmpd[20];
00331     <span class="keywordtype">int</span> i=0;
00332     <span class="keywordtype">int</span> j;   
00333     <span class="keywordflow">if</span> (n==0) {
00334       strcpy(s,<span class="stringliteral">"0\0"</span>);
00335     } <span class="keywordflow">else</span> {
00336       <span class="keywordflow">while</span> (n&gt;0) {
00337         tmpd[i]= (n%10);
00338         n= (int)(n/10);
00339         i++;
00340       }
00341       <span class="keywordflow">for</span> (j=i-1;j&gt;=0;j--) {
00342         s[i-j-1]=<a class="code" href="namespaceot.html#a56">int2char</a>(tmpd[j]);
00343       }
00344       s[i]=<span class="charliteral">'\0'</span>;
00345     }
00346     <span class="keywordflow">return</span> 1;
00347   }<span class="comment">//end function</span>
00348 
<a name="l00349"></a><a class="code" href="namespaceot.html#a56">00349</a>   <span class="keywordtype">char</span> <a class="code" href="namespaceot.html#a56">int2char</a>(<span class="keywordtype">int</span> d) {
00350     <span class="keywordflow">switch</span> (d) {
00351       <span class="keywordflow">case</span> 0: <span class="keywordflow">return</span> <span class="charliteral">'0'</span>;
00352       <span class="keywordflow">case</span> 1: <span class="keywordflow">return</span> <span class="charliteral">'1'</span>;
00353       <span class="keywordflow">case</span> 2: <span class="keywordflow">return</span> <span class="charliteral">'2'</span>;
00354       <span class="keywordflow">case</span> 3: <span class="keywordflow">return</span> <span class="charliteral">'3'</span>;
00355       <span class="keywordflow">case</span> 4: <span class="keywordflow">return</span> <span class="charliteral">'4'</span>;
00356       <span class="keywordflow">case</span> 5: <span class="keywordflow">return</span> <span class="charliteral">'5'</span>;
00357       <span class="keywordflow">case</span> 6: <span class="keywordflow">return</span> <span class="charliteral">'6'</span>;
00358       <span class="keywordflow">case</span> 7: <span class="keywordflow">return</span> <span class="charliteral">'7'</span>;
00359       <span class="keywordflow">case</span> 8: <span class="keywordflow">return</span> <span class="charliteral">'8'</span>;
00360       <span class="keywordflow">case</span> 9: <span class="keywordflow">return</span> <span class="charliteral">'9'</span>;
00361       <span class="keywordflow">default</span>: <span class="keywordflow">return</span> <span class="charliteral">'\0'</span>;
00362     }
00363   }<span class="comment">//end function</span>
00364 
00365   <span class="comment">// This will add boundary nodes and will also embed the octree one level higher</span>
00366   <span class="comment">// to enable the addition of the boundary nodes.</span>
<a name="l00367"></a><a class="code" href="namespaceot.html#a57">00367</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a57">addBoundaryNodesType2</a>(std::vector&lt;ot::TreeNode&gt; &amp;in, 
00368       std::vector&lt;ot::TreeNode&gt;&amp; bdy, 
00369       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00370 
00371     <a class="code" href="octUtils_8h.html#a94">PROF_ADD_BDY_BEGIN</a>
00372       assert(bdy.empty());
00373 
00374     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
00375       <span class="comment">// get basic info ...</span>
00376       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00377       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00378       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00379       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00380 
00381       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bdyFlags;
00382       <span class="comment">// check if this is a boundary octant or not ...</span>
00383       <span class="keywordflow">if</span> ( in[i].isBoundaryOctant(ot::TreeNode::POSITIVE, &amp;bdyFlags) ) {
00384         <span class="comment">// bdy flags tells us which octants to add ...</span>
00385 
00386         <span class="comment">//NOTE: == is important since a&amp;(b+c) will be true if</span>
00387         <span class="comment">//a=b, a=c and a=b+c</span>
00388 
00389         <span class="comment">// +x and more ... add additional octant in +x dir</span>
00390         <span class="keywordflow">if</span> ( bdyFlags &amp; ot::TreeNode::X_POS_BDY ) {
00391           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>( (1u &lt;&lt; maxDepth), y, z, (d+1), dim, maxDepth+1));
00392         }
00393 
00394         <span class="comment">// +y and more ... add additional octant in +y dir</span>
00395         <span class="keywordflow">if</span> ( bdyFlags &amp; ot::TreeNode::Y_POS_BDY ) {
00396           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, (1u &lt;&lt; maxDepth), z,
00397                 (d+1), dim, maxDepth+1));
00398         }
00399 
00400         <span class="comment">// +z and more ... add additional octant in +z dir</span>
00401         <span class="keywordflow">if</span> ( bdyFlags &amp; ot::TreeNode::Z_POS_BDY ) {
00402           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, (1u &lt;&lt; maxDepth),
00403                 (d+1), dim, maxDepth+1));
00404         }
00405 
00406         <span class="comment">//+x+y and more</span>
00407         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY)) == 
00408             (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY) ) { 
00409           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((1u &lt;&lt; maxDepth),(1u &lt;&lt; maxDepth), z,
00410                 (d+1), dim, maxDepth+1));
00411         }
00412 
00413         <span class="comment">//+x+z and more</span>
00414         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Z_POS_BDY)) ==
00415             (ot::TreeNode::X_POS_BDY + ot::TreeNode::Z_POS_BDY) ) {
00416           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((1u &lt;&lt; maxDepth), y, (1u &lt;&lt; maxDepth),
00417                 (d+1), dim, maxDepth+1));
00418         }
00419 
00420         <span class="comment">//+y+z and more</span>
00421         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY)) == 
00422             (ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY) ) {
00423           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, (1u &lt;&lt; maxDepth), (1u &lt;&lt; maxDepth),
00424                 (d+1), dim, maxDepth+1));
00425         }
00426 
00427         <span class="comment">// if global corner ...</span>
00428         <span class="comment">//+x +y and +z only</span>
00429         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY +
00430                 ot::TreeNode::Z_POS_BDY)) == (ot::TreeNode::X_POS_BDY +
00431                 ot::TreeNode::Y_POS_BDY +  ot::TreeNode::Z_POS_BDY) ) {
00432           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((1u &lt;&lt; maxDepth), (1u &lt;&lt; maxDepth), (1u &lt;&lt; maxDepth),
00433                 (d+1), dim, maxDepth+1));
00434         }
00435       }<span class="comment">//end if boundary</span>
00436 
00437       <span class="comment">// Embed the actual octant in one level higher ...</span>
00438       in[i] = <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, z, d+1, dim, maxDepth+1);
00439 
00440     }<span class="comment">//end for i</span>
00441 
00442     <span class="comment">// A Parallel Sort for the bdy nodes follows.  </span>
00443     <span class="comment">//Then in and bdy will be merged.</span>
00444 
00445     <a class="code" href="octUtils_8h.html#a95">PROF_ADD_BDY_END</a>
00446   }<span class="comment">//end function</span>
00447 
<a name="l00448"></a><a class="code" href="namespaceot.html#a58">00448</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a58">markBoundaryNodesAtAllLevels</a>(std::vector&lt;ot::TreeNode&gt;&amp; finestOctree, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels,
00449       std::vector&lt;ot::TreeNode&gt;* coarserOctrees, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00450     <span class="comment">//coarser octrees</span>
00451     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> lev = 0; lev &lt; (nlevels - 1); lev++) {
00452       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; coarserOctrees[lev].size(); i++) {
00453         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = coarserOctrees[lev][i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00454         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = coarserOctrees[lev][i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00455         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = coarserOctrees[lev][i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00456         <span class="keywordflow">if</span>( (myX == (1u &lt;&lt; (maxDepth - 1))) ||
00457             (myY == (1u &lt;&lt; (maxDepth - 1))) ||
00458             (myZ == (1u &lt;&lt; (maxDepth - 1))) ) {
00459           coarserOctrees[lev][i].<a class="code" href="classot_1_1TreeNode.html#z19_15">orFlag</a>(ot::TreeNode::BOUNDARY);
00460         }
00461       }<span class="comment">//end for i</span>
00462     }<span class="comment">//end for lev</span>
00463 
00464     <span class="comment">//finest octree</span>
00465     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; finestOctree.size(); i++) {
00466       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = finestOctree[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00467       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = finestOctree[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00468       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = finestOctree[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00469       <span class="keywordflow">if</span>( (myX == (1u &lt;&lt; (maxDepth - 1))) ||
00470           (myY == (1u &lt;&lt; (maxDepth - 1))) ||
00471           (myZ == (1u &lt;&lt; (maxDepth - 1))) ) {
00472         finestOctree[i].<a class="code" href="classot_1_1TreeNode.html#z19_15">orFlag</a>(ot::TreeNode::BOUNDARY);
00473       }
00474     }<span class="comment">//end for i</span>
00475 
00476   }<span class="comment">//end function</span>
00477 
<a name="l00478"></a><a class="code" href="namespaceot.html#a59">00478</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a59">discardExtraBoundaryOctants</a>(std::vector&lt;ot::TreeNode&gt;&amp; in,
00479       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00480 
00481     std::vector&lt;ot::TreeNode&gt; tmpOctree;
00482     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
00483       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00484       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00485       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00486       <span class="keywordflow">if</span>( (myX &lt;= (1u &lt;&lt; (maxDepth - 1))) &amp;&amp;
00487           (myY &lt;= (1u &lt;&lt; (maxDepth - 1))) &amp;&amp;
00488           (myZ &lt;= (1u &lt;&lt; (maxDepth - 1))) ) {
00489         tmpOctree.push_back(in[i]);
00490       }
00491     }<span class="comment">//end for i</span>
00492 
00493     <span class="keywordflow">if</span>(tmpOctree.size() &lt; in.size()) {
00494       in = tmpOctree;
00495     }
00496   }<span class="comment">//end function</span>
00497 
00498   <span class="comment">//A simple implementation for now. This just calls flagNodesType3 for all</span>
00499   <span class="comment">//levels. A smarter implementation would use the fact that regular coarse</span>
00500   <span class="comment">//grid nodes remain regular on all finer octrees </span>
<a name="l00501"></a><a class="code" href="namespaceot.html#a60">00501</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a60">markHangingNodesAtAllLevels</a>(std::vector&lt;ot::TreeNode&gt;&amp; finestOctree, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nlevels, 
00502       std::vector&lt;ot::TreeNode&gt;* coarserOctrees, MPI_Comm* activeComms,
00503       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00504 
00505     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> lev = 0; lev &lt; (nlevels - 1); lev++) {
00506       <span class="keywordflow">if</span>( !(coarserOctrees[lev].empty()) ) {
00507         <a class="code" href="namespaceot.html#a64">ot::flagNodesType3</a>(coarserOctrees[lev], activeComms[lev + 1]);
00508       }
00509     }<span class="comment">//end for lev</span>
00510 
00511     <span class="keywordflow">if</span>( !(finestOctree.empty()) ) {
00512       <a class="code" href="namespaceot.html#a64">ot::flagNodesType3</a>(finestOctree, activeComms[0]);
00513     }
00514 
00515   }<span class="comment">//end function</span>
00516 
00517   <span class="comment">// This will add boundary nodes and will also embed the octree one level higher</span>
00518   <span class="comment">// to enable the addition of the boundary nodes. The positive boundary nodes</span>
00519   <span class="comment">// are also marked as BOUNDARY.</span>
<a name="l00520"></a><a class="code" href="namespaceot.html#a61">00520</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a61">addBoundaryNodesType1</a>(std::vector&lt;ot::TreeNode&gt; &amp;in, 
00521       std::vector&lt;ot::TreeNode&gt;&amp; bdy, 
00522       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00523     <a class="code" href="octUtils_8h.html#a94">PROF_ADD_BDY_BEGIN</a>
00524 
00525       assert(bdy.empty());
00526 
00527     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
00528       <span class="comment">// get basic info ...</span>
00529       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d   = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00530       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00531       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00532       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = in[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00533 
00534       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> bdyFlags;
00535       <span class="comment">// check if this is a boundary octant or not ...</span>
00536       <span class="keywordflow">if</span> ( in[i].isBoundaryOctant(ot::TreeNode::POSITIVE, &amp;bdyFlags) ) {
00537         <span class="comment">// bdy flags tells us which octants to add ...</span>
00538 
00539         <span class="comment">//NOTE: == is important since a&amp;(b+c) will be true if</span>
00540         <span class="comment">//a=b, a=c and a=b+c</span>
00541 
00542         <span class="comment">// +x and more ... add additional octant in +x dir</span>
00543         <span class="keywordflow">if</span> ( bdyFlags &amp; ot::TreeNode::X_POS_BDY ) {
00544           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>( (1u &lt;&lt; maxDepth), y, z, (d+1) |
00545                 ot::TreeNode::BOUNDARY, dim, maxDepth+1));
00546         }
00547 
00548         <span class="comment">// +y and more ... add additional octant in +y dir</span>
00549         <span class="keywordflow">if</span> ( bdyFlags &amp; ot::TreeNode::Y_POS_BDY ) {
00550           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, (1u &lt;&lt; maxDepth), z,
00551                 (d+1) | ot::TreeNode::BOUNDARY, dim, maxDepth+1));
00552         }
00553 
00554         <span class="comment">// +z and more ... add additional octant in +z dir</span>
00555         <span class="keywordflow">if</span> ( bdyFlags &amp; ot::TreeNode::Z_POS_BDY ) {
00556           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, (1u &lt;&lt; maxDepth),
00557                 (d+1) | ot::TreeNode::BOUNDARY, dim, maxDepth+1));
00558         }
00559 
00560         <span class="comment">//+x+y and more</span>
00561         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY)) == 
00562             (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY) ) { 
00563           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((1u &lt;&lt; maxDepth),(1u &lt;&lt; maxDepth), z,
00564                 (d+1) | ot::TreeNode::BOUNDARY, dim, maxDepth+1));
00565         }
00566 
00567         <span class="comment">//+x+z and more</span>
00568         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Z_POS_BDY)) ==
00569             (ot::TreeNode::X_POS_BDY + ot::TreeNode::Z_POS_BDY) ) {
00570           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((1u &lt;&lt; maxDepth), y, (1u &lt;&lt; maxDepth),
00571                 (d+1) | ot::TreeNode::BOUNDARY, dim, maxDepth+1));
00572         }
00573 
00574         <span class="comment">//+y+z and more</span>
00575         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY)) == 
00576             (ot::TreeNode::Y_POS_BDY + ot::TreeNode::Z_POS_BDY) ) {
00577           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, (1u &lt;&lt; maxDepth),(1u &lt;&lt; maxDepth),
00578                 (d+1) | ot::TreeNode::BOUNDARY, dim, maxDepth+1));
00579         }
00580 
00581         <span class="comment">// if global corner ...</span>
00582         <span class="comment">//+x +y and +z only</span>
00583         <span class="keywordflow">if</span> ( (bdyFlags &amp; (ot::TreeNode::X_POS_BDY + ot::TreeNode::Y_POS_BDY +
00584                 ot::TreeNode::Z_POS_BDY)) == (ot::TreeNode::X_POS_BDY +
00585                 ot::TreeNode::Y_POS_BDY +  ot::TreeNode::Z_POS_BDY) ) {
00586           bdy.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((1u &lt;&lt; maxDepth), (1u &lt;&lt; maxDepth), (1u &lt;&lt; maxDepth),
00587                 (d+1) | ot::TreeNode::BOUNDARY, dim, maxDepth+1));
00588         }
00589       }<span class="comment">//end if boundary</span>
00590 
00591       <span class="comment">// Embed the actual octant in one level higher ...</span>
00592       in[i] = <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(x, y, z, d+1, dim, maxDepth+1);
00593 
00594     }<span class="comment">//end for i</span>
00595 
00596     <span class="comment">// A Parallel Sort for the bdy nodes follows in the constructor.  </span>
00597     <span class="comment">//Then in and bdy will be merged.</span>
00598 
00599     <a class="code" href="octUtils_8h.html#a95">PROF_ADD_BDY_END</a>
00600   }<span class="comment">//end function</span>
00601 
<a name="l00602"></a><a class="code" href="namespaceot.html#a62">00602</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a62">flagNodesType1</a>(std::vector&lt;ot::TreeNode&gt; &amp; in, MPI_Comm comm) {
00603 
00604 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00605 <span class="preprocessor"></span>    MPI_Barrier(comm);
00606 <span class="preprocessor">#endif</span>
00607 <span class="preprocessor"></span>
00608     <a class="code" href="octUtils_8h.html#a92">PROF_MARK_HANGING_BEGIN</a>
00609 
00610       <a class="code" href="octUtils_8h.html#a70">PROF_FLN_STAGE1_BEGIN</a>
00611 
00612       <span class="keywordtype">int</span> npes;
00613     <span class="keywordtype">int</span> rank;
00614 
00615     MPI_Comm_rank(comm, &amp;rank);
00616     MPI_Comm_size(comm, &amp;npes);
00617 
00618     std::vector&lt;unsigned int &gt; keysCount(in.size());
00619     std::vector&lt;ot::TreeNode &gt; keys;
00620 
00621     assert(!in.empty());
00622     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
00623     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim  = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00624     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* inPtr = (&amp;(*(in.begin())));
00625 
00626     <span class="comment">//1. Generate Keys</span>
00627     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
00628       keysCount[i] = 0;
00629       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myLev = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00630       <span class="keywordflow">if</span> (myLev == 1) {
00631         <span class="keywordflow">continue</span>;
00632       }
00633       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> childNum = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_3">getChildNumber</a>();   
00634       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mySz = (1u &lt;&lt; (maxD - myLev));
00635       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00636       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00637       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();    
00638 
00639       <span class="keywordflow">switch</span> (childNum) {
00640         <span class="keywordflow">case</span> 0:
00641           {
00642             <span class="keywordflow">break</span>;
00643           }
00644         <span class="keywordflow">case</span> 7:
00645           {
00646             <span class="keywordflow">break</span>;
00647           }
00648         <span class="keywordflow">case</span> 1:
00649           {
00650             <span class="comment">//-y,-z,-yz</span>
00651             <span class="keywordflow">if</span> (myY) {
00652               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ,myLev,dim,maxD);
00653               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00654               keysCount[i]++;
00655             }
00656             <span class="keywordflow">if</span> (myZ) {
00657               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY,myZ-mySz,myLev,dim,maxD);
00658               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00659               keysCount[i]++;
00660             }
00661             <span class="keywordflow">if</span> (myY &amp;&amp; myZ) {
00662               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ-mySz,myLev,dim,maxD);         
00663               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00664               keysCount[i]++;
00665             }
00666             <span class="keywordflow">break</span>;
00667           }
00668         <span class="keywordflow">case</span> 2:
00669           {
00670             <span class="comment">//-x,-z,-xz</span>
00671             <span class="keywordflow">if</span> (myX) {
00672               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ,myLev,dim,maxD);
00673               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00674               keysCount[i]++;
00675             }
00676             <span class="keywordflow">if</span> (myZ) {
00677               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY,myZ-mySz,myLev,dim,maxD);
00678               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00679               keysCount[i]++;
00680             }
00681             <span class="keywordflow">if</span> (myX &amp;&amp; myZ) {
00682               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ-mySz,myLev,dim,maxD);
00683               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00684               keysCount[i]++;
00685             }
00686             <span class="keywordflow">break</span>;
00687           }
00688         <span class="keywordflow">case</span> 3:
00689           {
00690             <span class="comment">//-z</span>
00691             <span class="keywordflow">if</span> (myZ) {
00692               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY,myZ-mySz,myLev,dim,maxD);
00693               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00694               keysCount[i]++;
00695             }
00696             <span class="keywordflow">break</span>;
00697           }
00698         <span class="keywordflow">case</span> 4:
00699           {
00700             <span class="comment">//-x,-y,-xy</span>
00701             <span class="keywordflow">if</span> (myX) {
00702               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ,myLev,dim,maxD);
00703               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00704               keysCount[i]++;
00705             }
00706             <span class="keywordflow">if</span> (myY) {
00707               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ,myLev,dim,maxD);
00708               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00709               keysCount[i]++;
00710             }
00711             <span class="keywordflow">if</span> (myX &amp;&amp; myY) {
00712               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY-mySz,myZ,myLev,dim,maxD);
00713               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00714               keysCount[i]++;
00715             }
00716             <span class="keywordflow">break</span>;
00717           }
00718         <span class="keywordflow">case</span> 5:
00719           {
00720             <span class="comment">//-y</span>
00721             <span class="keywordflow">if</span> (myY) {
00722               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ,myLev,dim,maxD);
00723               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
00724               keysCount[i]++;
00725             }
00726             <span class="keywordflow">break</span>;
00727           }
00728         <span class="keywordflow">case</span> 6:
00729           {
00730             <span class="comment">//-x</span>
00731             <span class="keywordflow">if</span> (myX) {
00732               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ,myLev,dim,maxD);
00733               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());    
00734               keysCount[i]++;
00735             }
00736             <span class="keywordflow">break</span>;      
00737           }
00738         <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);
00739       }<span class="comment">//end switch</span>
00740     }<span class="comment">//end for i        </span>
00741 
00742     <a class="code" href="octUtils_8h.html#a81">PROF_FLN_STAGE1_END</a>
00743       <a class="code" href="octUtils_8h.html#a71">PROF_FLN_STAGE2_BEGIN</a>
00744 
00745       <span class="comment">// allocate memory for the mins array</span>
00746       std::vector&lt;ot::TreeNode&gt; mins(npes);
00747 
00748     par::Mpi_Allgather&lt;ot::TreeNode&gt;(inPtr, &amp;(*(mins.begin())), 1, comm);
00749 
00750     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *part = NULL;
00751     <span class="keywordflow">if</span>(!keys.empty()) {
00752       part = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keys.size()];    
00753     }
00754 
00755     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; keys.size(); i++) {
00756       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00757       <span class="comment">//maxLB returns the last index in a sorted array</span>
00758       <span class="comment">//such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
00759       <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(mins, keys[i], idx, NULL, NULL);
00760       <span class="keywordflow">if</span> (!found ) {
00761         part[i] = rank;
00762       } <span class="keywordflow">else</span> {
00763         part[i] = idx;
00764       }
00765     }<span class="comment">//end for i</span>
00766     mins.clear();
00767 
00768     <a class="code" href="octUtils_8h.html#a82">PROF_FLN_STAGE2_END</a>
00769       <a class="code" href="octUtils_8h.html#a72">PROF_FLN_STAGE3_BEGIN</a>
00770 
00771       <span class="keywordtype">int</span> *numKeysSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00772     <span class="keywordtype">int</span> *numKeysRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00773     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00774       numKeysSend[i] = 0;
00775     }
00776 
00777     <span class="comment">// calculate the number of keys to send ...</span>
00778     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; keys.size(); i++) {
00779       assert(part[i] &lt; npes);
00780       numKeysSend[part[i]]++;
00781     }
00782 
00783     <span class="comment">// Now do an All2All to get inumKeysRecv</span>
00784     par::Mpi_Alltoall&lt;int&gt;(numKeysSend, numKeysRecv, 1, comm);
00785 
00786     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalKeys=0; <span class="comment">// total number of local keys ...</span>
00787     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00788       totalKeys += numKeysRecv[i];
00789     }
00790 
00791 <span class="preprocessor">#ifdef __MEASURE_FLAG_NODES__</span>
00792 <span class="preprocessor"></span>    MPI_Barrier(comm);
00793     <span class="keywordtype">int</span> numProcsSend = 0;
00794     <span class="keywordtype">int</span> numProcsRecv = 0;
00795     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00796       <span class="keywordflow">if</span>(numKeysSend[i]) {
00797         numProcsSend++;
00798       }
00799       <span class="keywordflow">if</span>(numKeysRecv[i]) {
00800         numProcsRecv++;
00801       }
00802     }<span class="comment">//end for i</span>
00803     <span class="keywordtype">int</span>* allNumProcsSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00804     <span class="keywordtype">int</span>* allNumProcsRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
00805     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allKeysSz = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
00806     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecv = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes]; 
00807     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localKeysSize = keys.size(); 
00808     par::Mpi_Gather&lt;int&gt;(&amp;numProcsSend, allNumProcsSend, 1, 0, comm);
00809     par::Mpi_Gather&lt;int&gt;(&amp;numProcsRecv, allNumProcsRecv, 1, 0, comm);
00810     par::Mpi_Gather&lt;unsigned int&gt;(&amp;localKeysSize, allKeysSz, 1, 0, comm);
00811     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalKeys, allTotalRecv, 1, 0, comm);
00812     <span class="keywordflow">if</span>(!rank) {
00813       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00814         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allNumProcsSend["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allNumProcsSend[i]&lt;&lt;std::endl;
00815         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allNumProcsRecv["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allNumProcsRecv[i]&lt;&lt;std::endl;
00816         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allKeysSz["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allKeysSz[i]&lt;&lt;std::endl;
00817         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allTotalRecv["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allTotalRecv[i]&lt;&lt;std::endl;
00818       }<span class="comment">//end for i</span>
00819     }
00820 
00821     <span class="keyword">delete</span> [] allNumProcsSend;
00822     <span class="keyword">delete</span> [] allNumProcsRecv;
00823     <span class="keyword">delete</span> [] allKeysSz;
00824     <span class="keyword">delete</span> [] allTotalRecv;
00825     MPI_Barrier(comm);
00826 <span class="preprocessor">#endif</span>
00827 <span class="preprocessor"></span>
00828     <span class="comment">// create the send and recv buffers ...</span>
00829     std::vector&lt;ot::TreeNode&gt; sendK (keys.size());
00830     std::vector&lt;ot::TreeNode&gt; recvK (totalKeys);
00831     <span class="comment">// the mapping ..</span>
00832     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> * comm_map = NULL;
00833     <span class="keywordflow">if</span>(!keys.empty()) {
00834       comm_map = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> [keys.size()];
00835     }
00836 
00837     <span class="comment">// Now create sendK</span>
00838     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; sendOffsets[0] = 0;
00839     <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; recvOffsets[0] = 0;
00840     <span class="keywordtype">int</span> *numKeysTmp = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; numKeysTmp[0] = 0; 
00841 
00842     <span class="comment">// compute offsets ...</span>
00843     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; npes; i++) {
00844       sendOffsets[i] = sendOffsets[i-1] + numKeysSend[i-1];
00845       recvOffsets[i] = recvOffsets[i-1] + numKeysRecv[i-1];
00846       numKeysTmp[i] = 0; 
00847     }
00848 
00849     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; keys.size(); i++) {
00850       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmp[part[i]];
00851       numKeysTmp[part[i]]++;
00852       <span class="comment">// set entry ...</span>
00853       assert((sendOffsets[part[i]] + ni) &lt; keys.size());
00854       sendK[sendOffsets[part[i]] + ni] = keys[i];
00855       <span class="comment">// save mapping .. will need it later ...</span>
00856       comm_map[i] = sendOffsets[part[i]] + ni;
00857     }
00858     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keysSz = keys.size();
00859     keys.clear();
00860 
00861     <span class="keywordflow">if</span>(part) {
00862       <span class="keyword">delete</span> [] part;
00863       part = NULL;
00864     }
00865 
00866     <span class="keyword">delete</span> [] numKeysTmp;
00867     numKeysTmp = NULL;
00868 
00869     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendKptr = NULL;
00870     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvKptr = NULL;
00871     <span class="keywordflow">if</span>(!sendK.empty()) {
00872       sendKptr = &amp;(*(sendK.begin()));
00873     }
00874     <span class="keywordflow">if</span>(!recvK.empty()) {
00875       recvKptr = &amp;(*(recvK.begin()));
00876     }
00877 
00878     par::Mpi_Alltoallv_sparse&lt;ot::TreeNode&gt;(sendKptr, numKeysSend, sendOffsets,
00879         recvKptr, numKeysRecv, recvOffsets, comm);
00880 
00881     sendK.clear();
00882 
00883     <a class="code" href="octUtils_8h.html#a83">PROF_FLN_STAGE3_END</a>
00884       <a class="code" href="octUtils_8h.html#a73">PROF_FLN_STAGE4_BEGIN</a>
00885 
00886       std::vector&lt;char&gt;  resSend (totalKeys);
00887     std::vector&lt;char&gt;  resRecv (keysSz);
00888 
00889     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; totalKeys; i++) {
00890       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00891       resSend[i] = static_cast&lt;char&gt;(
00892           seq::BinarySearch&lt;ot::TreeNode&gt;(inPtr,
00893             in.size(),  recvK[i], &amp;idx)) ;   
00894     }<span class="comment">//end for i</span>
00895     recvK.clear();
00896 
00897     <a class="code" href="octUtils_8h.html#a84">PROF_FLN_STAGE4_END</a>
00898       <a class="code" href="octUtils_8h.html#a74">PROF_FLN_STAGE5_BEGIN</a>
00899 
00900       <span class="keywordtype">char</span>* resSendPtr = NULL;
00901     <span class="keywordtype">char</span>* resRecvPtr = NULL;
00902     <span class="keywordflow">if</span>(!resSend.empty()) {
00903       resSendPtr = &amp;(*(resSend.begin()));
00904     }
00905     <span class="keywordflow">if</span>(!resRecv.empty()) {
00906       resRecvPtr = &amp;(*(resRecv.begin()));
00907     }
00908 
00909     par::Mpi_Alltoallv_sparse&lt;char&gt;( resSendPtr, numKeysRecv, recvOffsets, 
00910         resRecvPtr, numKeysSend, sendOffsets, comm);
00911 
00912     resSend.clear();
00913 
00914     <span class="keyword">delete</span> [] sendOffsets;
00915     sendOffsets = NULL;
00916 
00917     <span class="keyword">delete</span> [] recvOffsets;
00918     recvOffsets = NULL;
00919 
00920     <span class="keyword">delete</span> [] numKeysSend;
00921     numKeysSend = NULL;
00922 
00923     <span class="keyword">delete</span> [] numKeysRecv;
00924     numKeysRecv = NULL;
00925 
00926     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> st = 0;
00927     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
00928       <span class="keywordtype">bool</span> isHanging = <span class="keyword">false</span>;
00929       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; keysCount[i]; k++) {
00930         assert(comm_map[st + k] &lt; resRecv.size());
00931         <span class="keywordflow">if</span> (resRecv[comm_map[st + k]]) {
00932           isHanging = <span class="keyword">true</span>;
00933           <span class="keywordflow">break</span>;
00934         }
00935       }<span class="comment">//end for k</span>
00936       <span class="keywordflow">if</span> (!isHanging) {
00937         in[i].<a class="code" href="classot_1_1TreeNode.html#z19_15">orFlag</a>(ot::TreeNode::NODE);
00938       }
00939       st += keysCount[i];
00940     }<span class="comment">//end for i</span>
00941     assert(st == keysSz);
00942     <span class="comment">// Clean up ...</span>
00943     <span class="keywordflow">if</span>(comm_map) {
00944       <span class="keyword">delete</span> [] comm_map; 
00945       comm_map = NULL;
00946     }
00947 
00948     resRecv.clear();
00949 
00950     <a class="code" href="octUtils_8h.html#a85">PROF_FLN_STAGE5_END</a>
00951 
00952       <a class="code" href="octUtils_8h.html#a93">PROF_MARK_HANGING_END</a>
00953   }<span class="comment">//end function</span>
00954 
00955 
<a name="l00956"></a><a class="code" href="namespaceot.html#a63">00956</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a63">flagNodesType2</a>(std::vector&lt;ot::TreeNode&gt; &amp; in, MPI_Comm comm) {
00957 
00958 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
00959 <span class="preprocessor"></span>    MPI_Barrier(comm);
00960 <span class="preprocessor">#endif</span>
00961 <span class="preprocessor"></span>
00962     <a class="code" href="octUtils_8h.html#a92">PROF_MARK_HANGING_BEGIN</a>
00963 
00964       <a class="code" href="octUtils_8h.html#a70">PROF_FLN_STAGE1_BEGIN</a>
00965 
00966       <span class="keywordtype">int</span> npes;
00967     <span class="keywordtype">int</span> rank;
00968 
00969     MPI_Comm_rank(comm, &amp;rank);
00970     MPI_Comm_size(comm, &amp;npes);
00971 
00972     std::vector&lt;ot::TreeNode &gt; keys;
00973 
00974     assert(!in.empty());
00975     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
00976     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim  = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
00977 
00978     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* inPtr = (&amp;(*in.begin()));
00979 
00980     <span class="comment">//1. Generate Keys</span>
00981     <span class="comment">//Only true octants need to generate keys. Pseudo-octants don't generate keys.</span>
00982     <span class="comment">//This is because the positive boundary nodes can only be edge-hanging, they</span>
00983     <span class="comment">//can't be face hanging. And the edge hanging node will be identified by the</span>
00984     <span class="comment">//key generated by the true element instead</span>
00985     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
00986       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myLev = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00987       <span class="keywordflow">if</span> (myLev == maxD) {
00988         <span class="keywordflow">continue</span>;
00989       }
00990       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mySz = (1u &lt;&lt; (maxD - myLev));
00991       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00992       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00993       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();    
00994 
00995       <span class="keywordflow">if</span>( (myX + mySz) &lt;= (1u &lt;&lt; (maxD-1)) ) {
00996         <span class="comment">//Add C6 of my +x neighbour (Face Hanging)</span>
00997         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp6x((myX + mySz), (myY + (mySz&gt;&gt;1)), (myZ + (mySz&gt;&gt;1)), (myLev + 1), dim, maxD);
00998         keys.push_back(tmp6x);
00999 
01000         <span class="comment">//Add C4 of my +x neighbour (Edge Hanging)</span>
01001         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp4x((myX + mySz), myY, (myZ + (mySz&gt;&gt;1)), (myLev + 1), dim, maxD);
01002         keys.push_back(tmp4x);
01003 
01004         <span class="comment">//Add C2 of my +x neighbour (Edge Hanging)</span>
01005         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp2x((myX + mySz), (myY + (mySz&gt;&gt;1)), myZ, (myLev + 1), dim, maxD);
01006         keys.push_back(tmp2x);
01007 
01008         <span class="keywordflow">if</span>( (myY + mySz) &lt;= (1u &lt;&lt; (maxD-1)) ) {
01009           <span class="comment">//Add C4 of my +xy neighbour (Edge Hanging)</span>
01010           <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp4xy((myX + mySz), (myY + mySz), (myZ + (mySz&gt;&gt;1)), (myLev + 1), dim, maxD);
01011           keys.push_back(tmp4xy);
01012         }
01013 
01014         <span class="keywordflow">if</span>( (myZ + mySz) &lt;= (1u &lt;&lt; (maxD-1)) ) {
01015           <span class="comment">//Add C2 of my +xz neighbour (Edge Hanging)</span>
01016           <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp2xz((myX + mySz), (myY + (mySz&gt;&gt;1)), (myZ + mySz), (myLev + 1), dim, maxD);
01017           keys.push_back(tmp2xz);
01018         }
01019       } 
01020 
01021       <span class="keywordflow">if</span>( (myY + mySz) &lt;= (1u &lt;&lt; (maxD-1)) ) {
01022         <span class="comment">//Add C5 of my +y neighbour (Face Hanging)</span>
01023         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp5y((myX + (mySz&gt;&gt;1)), (myY + mySz), (myZ + (mySz&gt;&gt;1)), (myLev + 1), dim, maxD);
01024         keys.push_back(tmp5y);
01025 
01026         <span class="comment">//Add C1 of my +y neighbour (Edge Hanging)</span>
01027         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp1y((myX + (mySz&gt;&gt;1)), (myY + mySz), myZ, (myLev + 1), dim, maxD);
01028         keys.push_back(tmp1y);
01029 
01030         <span class="comment">//Add C4 of my +y neighbour (Edge Hanging)</span>
01031         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp4y(myX, (myY + mySz), (myZ + (mySz&gt;&gt;1)), (myLev + 1), dim, maxD);
01032         keys.push_back(tmp4y);
01033 
01034         <span class="keywordflow">if</span>( (myZ + mySz) &lt;= (1u &lt;&lt; (maxD-1)) ) {
01035           <span class="comment">//Add C1 of my +yz neighbour (Edge Hanging)</span>
01036           <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp1yz((myX + (mySz&gt;&gt;1)), (myY + mySz), (myZ + mySz), (myLev + 1), dim, maxD);
01037           keys.push_back(tmp1yz);
01038         }
01039       } 
01040 
01041       <span class="keywordflow">if</span>( (myZ + mySz) &lt;= (1u &lt;&lt; (maxD-1)) ) {
01042         <span class="comment">//Add C3 of my +z neighbour (Face Hanging)</span>
01043         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp3z((myX + (mySz&gt;&gt;1)), (myY + (mySz&gt;&gt;1)), (myZ + mySz), (myLev + 1), dim, maxD);
01044         keys.push_back(tmp3z);
01045 
01046         <span class="comment">//Add C1 of my +z neighbour (Edge Hanging)</span>
01047         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp1z((myX + (mySz&gt;&gt;1)), myY, (myZ + mySz), (myLev + 1), dim, maxD);
01048         keys.push_back(tmp1z);
01049 
01050         <span class="comment">//Add C2 of my +z neighbour (Edge Hanging)</span>
01051         <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp2z(myX, (myY + (mySz&gt;&gt;1)), (myZ + mySz), (myLev + 1), dim, maxD);
01052         keys.push_back(tmp2z);
01053       }
01054     }<span class="comment">//end for i        </span>
01055 
01056 <span class="preprocessor">#ifdef __MEASURE_FLAG_NODES__</span>
01057 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> forwardKeysCount = 0;
01058     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
01059       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myLev = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01060       <span class="keywordflow">if</span> (myLev == 1) {
01061         <span class="keywordflow">continue</span>;
01062       }
01063       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> childNum = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_3">getChildNumber</a>();   
01064       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mySz = (1u &lt;&lt; (maxD - myLev));
01065       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
01066       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
01067       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();    
01068 
01069       <span class="keywordflow">switch</span> (childNum) {
01070         <span class="keywordflow">case</span> 0:
01071           {
01072             <span class="keywordflow">break</span>;
01073           }
01074         <span class="keywordflow">case</span> 7:
01075           {
01076             <span class="keywordflow">break</span>;
01077           }
01078         <span class="keywordflow">case</span> 1:
01079           {
01080             <span class="comment">//-y,-z,-yz</span>
01081             <span class="keywordflow">if</span> (myY) {
01082               forwardKeysCount++;
01083             }
01084             <span class="keywordflow">if</span> (myZ) {
01085               forwardKeysCount++;
01086             }
01087             <span class="keywordflow">if</span> (myY &amp;&amp; myZ) {
01088               forwardKeysCount++;
01089             }
01090             <span class="keywordflow">break</span>;
01091           }
01092         <span class="keywordflow">case</span> 2:
01093           {
01094             <span class="comment">//-x,-z,-xz</span>
01095             <span class="keywordflow">if</span> (myX) {
01096               forwardKeysCount++;
01097             }
01098             <span class="keywordflow">if</span> (myZ) {
01099               forwardKeysCount++;
01100             }
01101             <span class="keywordflow">if</span> (myX &amp;&amp; myZ) {
01102               forwardKeysCount++;
01103             }
01104             <span class="keywordflow">break</span>;
01105           }
01106         <span class="keywordflow">case</span> 3:
01107           {
01108             <span class="comment">//-z</span>
01109             <span class="keywordflow">if</span> (myZ) {
01110               forwardKeysCount++;
01111             }
01112             <span class="keywordflow">break</span>;
01113           }
01114         <span class="keywordflow">case</span> 4:
01115           {
01116             <span class="comment">//-x,-y,-xy</span>
01117             <span class="keywordflow">if</span> (myX) {
01118               forwardKeysCount++;
01119             }
01120             <span class="keywordflow">if</span> (myY) {
01121               forwardKeysCount++;
01122             }
01123             <span class="keywordflow">if</span> (myX &amp;&amp; myY) {
01124               forwardKeysCount++;
01125             }
01126             <span class="keywordflow">break</span>;
01127           }
01128         <span class="keywordflow">case</span> 5:
01129           {
01130             <span class="comment">//-y</span>
01131             <span class="keywordflow">if</span> (myY) {
01132               forwardKeysCount++;
01133             }
01134             <span class="keywordflow">break</span>;
01135           }
01136         <span class="keywordflow">case</span> 6:
01137           {
01138             <span class="comment">//-x</span>
01139             <span class="keywordflow">if</span> (myX) {
01140               forwardKeysCount++;
01141             }
01142             <span class="keywordflow">break</span>;      
01143           }
01144         <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);
01145       }<span class="comment">//end switch</span>
01146     }<span class="comment">//end for i        </span>
01147 <span class="preprocessor">#endif</span>
01148 <span class="preprocessor"></span>
01149     <a class="code" href="octUtils_8h.html#a81">PROF_FLN_STAGE1_END</a>
01150       <a class="code" href="octUtils_8h.html#a71">PROF_FLN_STAGE2_BEGIN</a>
01151 
01152 <span class="preprocessor">#ifdef __MEASURE_FLAG_NODES__</span>
01153 <span class="preprocessor"></span>      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keysSzBefore = keys.size();
01154 <span class="preprocessor">#endif</span>
01155 <span class="preprocessor"></span>
01156     <span class="comment">//Make keys sorted and unique locally. There could still be duplicates</span>
01157     <span class="comment">//globally and keys need not be globally sorted</span>
01158     seq::makeVectorUnique&lt;ot::TreeNode&gt;(keys, <span class="keyword">false</span>);
01159 
01160 <span class="preprocessor">#ifdef __MEASURE_FLAG_NODES__</span>
01161 <span class="preprocessor"></span>    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keysSzAfter = keys.size();
01162     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allKeysSzBefore = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
01163     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allKeysSzAfter = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
01164     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allForwardKeysCount = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
01165     par::Mpi_Gather&lt;unsigned int&gt;(&amp;keysSzBefore, allKeysSzBefore, 1, 0, comm);
01166     par::Mpi_Gather&lt;unsigned int&gt;(&amp;keysSzAfter, allKeysSzAfter, 1, 0, comm);
01167     par::Mpi_Gather&lt;unsigned int&gt;(&amp;forwardKeysCount, allForwardKeysCount, 1, 0, comm);
01168     <span class="keywordflow">if</span>(!rank) {
01169       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01170         std::cout&lt;&lt;<span class="stringliteral">"rank = "</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"keys Before = "</span>&lt;&lt;allKeysSzBefore[i]
01171           &lt;&lt;<span class="stringliteral">" After = "</span>&lt;&lt;allKeysSzAfter[i]
01172           &lt;&lt;<span class="stringliteral">" Forward = "</span>&lt;&lt;allForwardKeysCount[i]
01173           &lt;&lt;std::endl; 
01174       }<span class="comment">//end for i</span>
01175     }
01176     <span class="keyword">delete</span> [] allKeysSzBefore;
01177     <span class="keyword">delete</span> [] allKeysSzAfter;
01178     <span class="keyword">delete</span> [] allForwardKeysCount;
01179     MPI_Barrier(comm);
01180 <span class="preprocessor">#endif</span>
01181 <span class="preprocessor"></span>
01182     <a class="code" href="octUtils_8h.html#a82">PROF_FLN_STAGE2_END</a>
01183       <a class="code" href="octUtils_8h.html#a72">PROF_FLN_STAGE3_BEGIN</a>
01184 
01185       <span class="comment">// allocate memory for the mins array</span>
01186       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* mins = <span class="keyword">new</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>[npes];
01187 
01188     par::Mpi_Allgather&lt;ot::TreeNode&gt;(inPtr, mins, 1, comm);
01189     <span class="comment">//Mins will be sorted and unique</span>
01190 
01191     MPI_Request* requests = <span class="keyword">new</span> MPI_Request[npes&lt;&lt;1];
01192     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* keysPtr = NULL;
01193     <span class="keywordflow">if</span>(!(keys.empty())) {
01194       keysPtr = (&amp;(*keys.begin()));
01195     }
01196 
01197     <span class="keywordtype">int</span>* sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01198     <span class="keywordtype">int</span>* sendCounts = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01199     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01200       sendOffsets[i] = 0;
01201       sendCounts[i] = 0;
01202     }
01203 
01204     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; (npes - 1); i++) {
01205       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = sendOffsets[i]; j &lt; keys.size(); j++) {
01206         <span class="keywordflow">if</span>(keysPtr[j] &gt;= mins[i+1]) {
01207           <span class="keywordflow">break</span>;
01208         } <span class="keywordflow">else</span> {
01209           sendCounts[i]++;
01210         }
01211       }
01212       sendOffsets[i + 1] = (sendOffsets[i] + sendCounts[i]);
01213     }<span class="comment">//end for i</span>
01214 
01215     sendCounts[npes - 1] = (keys.size() - sendOffsets[npes - 1]);
01216 
01217     <span class="keyword">delete</span> [] mins;
01218 
01219     <span class="keywordtype">int</span>* recvCounts = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01220     <a class="code" href="namespacepar.html#a14">par::Mpi_Alltoall</a>(sendCounts, recvCounts, 1, comm); 
01221 
01222     std::vector&lt;ot::TreeNode&gt;* recvNodes = <span class="keyword">new</span> std::vector&lt;ot::TreeNode&gt;[npes];
01223     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01224       recvNodes[i].resize(recvCounts[i]);
01225     }<span class="comment">//end for i</span>
01226 
01227     <span class="comment">//Post Recvs</span>
01228     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01229       <span class="keywordflow">if</span>(recvCounts[i]) {
01230         par::Mpi_Irecv&lt;ot::TreeNode&gt;( (&amp;(*((recvNodes[i]).begin()))) , recvCounts[i],
01231             i, 1, comm, (requests + (i&lt;&lt;1)) );
01232       }
01233     }<span class="comment">//end for i</span>
01234 
01235     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01236       <span class="keywordflow">if</span>(recvCounts[i]) {
01237         par::Mpi_Irecv&lt;ot::TreeNode&gt;( (&amp;(*((recvNodes[i]).begin()))) , recvCounts[i],
01238             i, 1, comm, (requests + (i&lt;&lt;1)) );
01239       }
01240     }<span class="comment">//end for i</span>
01241 
01242     <span class="comment">//Post Sends</span>
01243     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01244       <span class="keywordflow">if</span>(sendCounts[i]) {
01245         par::Mpi_Issend&lt;ot::TreeNode&gt;( (keysPtr + sendOffsets[i]), sendCounts[i], 
01246             i, 1, comm, (requests + ((i&lt;&lt;1) + 1)) );
01247       }
01248     }<span class="comment">//end for i</span>
01249 
01250     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01251       <span class="keywordflow">if</span>(sendCounts[i]) {
01252         par::Mpi_Issend&lt;ot::TreeNode&gt;( (keysPtr + sendOffsets[i]), sendCounts[i], 
01253             i, 1, comm, (requests + ((i&lt;&lt;1) + 1)) );
01254       }
01255     }<span class="comment">//end for i</span>
01256 
01257     <a class="code" href="octUtils_8h.html#a83">PROF_FLN_STAGE3_END</a>
01258       <a class="code" href="octUtils_8h.html#a73">PROF_FLN_STAGE4_BEGIN</a>
01259 
01260       <span class="keywordtype">bool</span>* isHanging = <span class="keyword">new</span> <span class="keywordtype">bool</span>[in.size()];
01261     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
01262       isHanging[i] = <span class="keyword">false</span>; 
01263     }<span class="comment">//end for i</span>
01264 
01265     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = sendOffsets[rank]; i &lt; (sendOffsets[rank] + sendCounts[rank]); i++) {
01266       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> retIdx;
01267       <span class="keywordtype">bool</span> found =  <a class="code" href="namespaceseq.html#a2">seq::BinarySearch</a>(inPtr, in.size(), keysPtr[i], &amp;retIdx);
01268       <span class="keywordflow">if</span>(found) {
01269         <span class="comment">//hanging</span>
01270         isHanging[retIdx] = <span class="keyword">true</span>;
01271       }
01272     }<span class="comment">//end for i</span>
01273 
01274     <span class="keyword">delete</span> [] sendOffsets;
01275 
01276     <a class="code" href="octUtils_8h.html#a84">PROF_FLN_STAGE4_END</a>
01277       <a class="code" href="octUtils_8h.html#a74">PROF_FLN_STAGE5_BEGIN</a>
01278 
01279       <span class="comment">//Wait for the recvs to complete</span>
01280       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01281         <span class="keywordflow">if</span>(recvCounts[i]) {
01282           MPI_Status status;
01283           MPI_Wait( (requests + (i&lt;&lt;1)), &amp;status);
01284         }
01285       }<span class="comment">//end for i</span>
01286 
01287     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01288       <span class="keywordflow">if</span>(recvCounts[i]) {
01289         MPI_Status status;
01290         MPI_Wait( (requests + (i&lt;&lt;1)), &amp;status);
01291       }
01292     }<span class="comment">//end for i</span>
01293 
01294     <a class="code" href="octUtils_8h.html#a85">PROF_FLN_STAGE5_END</a>
01295       <a class="code" href="octUtils_8h.html#a75">PROF_FLN_STAGE6_BEGIN</a>
01296 
01297       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01298         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; recvCounts[i]; j++) {
01299           <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> retIdx;
01300           <span class="keywordtype">bool</span> found =  <a class="code" href="namespaceseq.html#a2">seq::BinarySearch</a>(inPtr, in.size(), recvNodes[i][j], &amp;retIdx);
01301           <span class="keywordflow">if</span>(found) {
01302             <span class="comment">//hanging</span>
01303             isHanging[retIdx] = <span class="keyword">true</span>;
01304           }
01305         }<span class="comment">//end for j</span>
01306       }<span class="comment">//end for i</span>
01307 
01308     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01309       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; recvCounts[i]; j++) {
01310         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> retIdx;
01311         <span class="keywordtype">bool</span> found =  <a class="code" href="namespaceseq.html#a2">seq::BinarySearch</a>(inPtr, in.size(), recvNodes[i][j], &amp;retIdx);
01312         <span class="keywordflow">if</span>(found) {
01313           <span class="comment">//hanging</span>
01314           isHanging[retIdx] = <span class="keyword">true</span>;
01315         }
01316       }<span class="comment">//end for j</span>
01317     }<span class="comment">//end for i</span>
01318 
01319     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
01320       <span class="keywordflow">if</span>(!isHanging[i]) {
01321         inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_15">orFlag</a>(ot::TreeNode::NODE);
01322       } 
01323     }<span class="comment">//end for i</span>
01324 
01325     <span class="keyword">delete</span> [] isHanging;
01326     <span class="keyword">delete</span> [] recvNodes;
01327     <span class="keyword">delete</span> [] recvCounts;
01328 
01329     <a class="code" href="octUtils_8h.html#a86">PROF_FLN_STAGE6_END</a>
01330       <a class="code" href="octUtils_8h.html#a76">PROF_FLN_STAGE7_BEGIN</a>
01331 
01332       <span class="comment">//Wait for the sends to complete</span>
01333       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01334         <span class="keywordflow">if</span>(sendCounts[i]) {
01335           MPI_Status status;
01336           MPI_Wait( (requests + ((i&lt;&lt;1) + 1)), &amp;status);
01337         }
01338       }<span class="comment">//end for i</span>
01339 
01340     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01341       <span class="keywordflow">if</span>(sendCounts[i]) {
01342         MPI_Status status;
01343         MPI_Wait( (requests + ((i&lt;&lt;1) + 1)), &amp;status);
01344       }
01345     }<span class="comment">//end for i</span>
01346 
01347     keys.clear();
01348     <span class="keyword">delete</span> [] sendCounts;
01349     <span class="keyword">delete</span> [] requests;
01350 
01351     <a class="code" href="octUtils_8h.html#a87">PROF_FLN_STAGE7_END</a>
01352 
01353       <a class="code" href="octUtils_8h.html#a93">PROF_MARK_HANGING_END</a>
01354 
01355   }<span class="comment">//end function</span>
01356 
<a name="l01357"></a><a class="code" href="namespaceot.html#a64">01357</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a64">flagNodesType3</a>(std::vector&lt;ot::TreeNode&gt; &amp; in, MPI_Comm comm) {
01358 
01359 <span class="preprocessor">#ifdef __PROF_WITH_BARRIER__</span>
01360 <span class="preprocessor"></span>    MPI_Barrier(comm);
01361 <span class="preprocessor">#endif</span>
01362 <span class="preprocessor"></span>
01363     <a class="code" href="octUtils_8h.html#a92">PROF_MARK_HANGING_BEGIN</a>
01364 
01365       <a class="code" href="octUtils_8h.html#a70">PROF_FLN_STAGE1_BEGIN</a>
01366 
01367       <span class="keywordtype">int</span> npes;
01368     <span class="keywordtype">int</span> rank;
01369 
01370     MPI_Comm_rank(comm, &amp;rank);
01371     MPI_Comm_size(comm, &amp;npes);
01372 
01373     std::vector&lt;ot::TreeNode &gt; keys;
01374 
01375     assert(!in.empty());
01376     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
01377     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim  = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>();
01378     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* inPtr = (&amp;(*(in.begin())));
01379 
01380     <span class="comment">//1. Generate Keys</span>
01381     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
01382       <span class="comment">//keysCount[i] = 0;</span>
01383       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myLev = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
01384       <span class="keywordflow">if</span> (myLev == 1) {
01385         <span class="keywordflow">continue</span>;
01386       }
01387       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currKeySz = static_cast&lt;unsigned int&gt;(keys.size());
01388       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> childNum = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_3">getChildNumber</a>();   
01389       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mySz = (1u &lt;&lt; (maxD - myLev));
01390       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
01391       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
01392       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = inPtr[i].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();    
01393 
01394       <span class="keywordflow">switch</span> (childNum) {
01395         <span class="keywordflow">case</span> 0:
01396           {
01397             <span class="keywordflow">break</span>;
01398           }
01399         <span class="keywordflow">case</span> 7:
01400           {
01401             <span class="keywordflow">break</span>;
01402           }
01403         <span class="keywordflow">case</span> 1:
01404           {
01405             <span class="comment">//-y,-z,-yz</span>
01406             <span class="keywordflow">if</span> (myY) {
01407               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ,myLev,dim,maxD);
01408               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01409             }
01410             <span class="keywordflow">if</span> (myZ) {
01411               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY,myZ-mySz,myLev,dim,maxD);
01412               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01413             }
01414             <span class="keywordflow">if</span> (myY &amp;&amp; myZ) {
01415               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ-mySz,myLev,dim,maxD);         
01416               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01417             }
01418             <span class="keywordflow">break</span>;
01419           }
01420         <span class="keywordflow">case</span> 2:
01421           {
01422             <span class="comment">//-x,-z,-xz</span>
01423             <span class="keywordflow">if</span> (myX) {
01424               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ,myLev,dim,maxD);
01425               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01426             }
01427             <span class="keywordflow">if</span> (myZ) {
01428               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY,myZ-mySz,myLev,dim,maxD);
01429               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01430             }
01431             <span class="keywordflow">if</span> (myX &amp;&amp; myZ) {
01432               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ-mySz,myLev,dim,maxD);
01433               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01434             }
01435             <span class="keywordflow">break</span>;
01436           }
01437         <span class="keywordflow">case</span> 3:
01438           {
01439             <span class="comment">//-z</span>
01440             <span class="keywordflow">if</span> (myZ) {
01441               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY,myZ-mySz,myLev,dim,maxD);
01442               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01443             }
01444             <span class="keywordflow">break</span>;
01445           }
01446         <span class="keywordflow">case</span> 4:
01447           {
01448             <span class="comment">//-x,-y,-xy</span>
01449             <span class="keywordflow">if</span> (myX) {
01450               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ,myLev,dim,maxD);
01451               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01452             }
01453             <span class="keywordflow">if</span> (myY) {
01454               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ,myLev,dim,maxD);
01455               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01456             }
01457             <span class="keywordflow">if</span> (myX &amp;&amp; myY) {
01458               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY-mySz,myZ,myLev,dim,maxD);
01459               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01460             }
01461             <span class="keywordflow">break</span>;
01462           }
01463         <span class="keywordflow">case</span> 5:
01464           {
01465             <span class="comment">//-y</span>
01466             <span class="keywordflow">if</span> (myY) {
01467               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX,myY-mySz,myZ,myLev,dim,maxD);
01468               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());
01469             }
01470             <span class="keywordflow">break</span>;
01471           }
01472         <span class="keywordflow">case</span> 6:
01473           {
01474             <span class="comment">//-x</span>
01475             <span class="keywordflow">if</span> (myX) {
01476               <a class="code" href="classot_1_1TreeNode.html">TreeNode</a> tmp(myX-mySz,myY,myZ,myLev,dim,maxD);
01477               keys.push_back(tmp.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>());    
01478             }
01479             <span class="keywordflow">break</span>;      
01480           }
01481         <span class="keywordflow">default</span>: assert(<span class="keyword">false</span>);
01482       }<span class="comment">//end switch</span>
01483       <span class="keywordflow">for</span>(<span class="keywordtype">int</span>  j = currKeySz; j &lt; keys.size(); j++) {
01484         keys[j].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(i);
01485       }<span class="comment">//end for j </span>
01486     }<span class="comment">//end for i        </span>
01487 
01488     <a class="code" href="octUtils_8h.html#a81">PROF_FLN_STAGE1_END</a>
01489 
01490 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01491 <span class="preprocessor"></span>      MPI_Barrier(comm);
01492     <span class="keywordflow">if</span>(!rank) {
01493       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 1 passed."</span>&lt;&lt;std::endl;
01494     }
01495     MPI_Barrier(comm);
01496 <span class="preprocessor">#endif</span>
01497 <span class="preprocessor"></span>
01498     <a class="code" href="octUtils_8h.html#a71">PROF_FLN_STAGE2_BEGIN</a>
01499 
01500       <span class="comment">// allocate memory for the mins array</span>
01501       std::vector&lt;ot::TreeNode&gt; mins(npes);
01502 
01503     par::Mpi_Allgather&lt;ot::TreeNode&gt;(inPtr, (&amp;(*(mins.begin()))), 1, comm);
01504 
01505     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> *part = NULL;
01506     <span class="keywordflow">if</span>(!keys.empty()) {
01507       part = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keys.size()];    
01508     }
01509 
01510     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; keys.size(); i++) {
01511       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01512       <span class="comment">//maxLB returns the last index in a sorted array</span>
01513       <span class="comment">//such that a[ind] &lt;= key and  a[index +1] &gt; key</span>
01514       <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;TreeNode &gt;(mins, keys[i], idx, NULL, NULL);
01515       <span class="keywordflow">if</span> (!found ) {
01516         part[i] = rank;
01517       } <span class="keywordflow">else</span> {
01518         part[i] = idx;
01519       }
01520     }<span class="comment">//end for i</span>
01521     mins.clear();
01522 
01523     <a class="code" href="octUtils_8h.html#a82">PROF_FLN_STAGE2_END</a> 
01524 
01525 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01526 <span class="preprocessor"></span>      MPI_Barrier(comm);
01527     <span class="keywordflow">if</span>(!rank) {
01528       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 2 passed."</span>&lt;&lt;std::endl;
01529     }
01530     MPI_Barrier(comm);
01531 <span class="preprocessor">#endif</span>
01532 <span class="preprocessor"></span>
01533     <a class="code" href="octUtils_8h.html#a72">PROF_FLN_STAGE3_BEGIN</a>
01534 
01535       <span class="keywordtype">int</span> *numKeysSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01536     <span class="keywordtype">int</span> *numKeysRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01537     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01538       numKeysSend[i] = 0;
01539     }
01540 
01541     <span class="comment">// calculate the number of keys to send ...</span>
01542     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; keys.size(); i++) {
01543       assert(part[i] &lt; npes);
01544       numKeysSend[part[i]]++;
01545     }
01546 
01547     <span class="comment">// Now do an All2All to get inumKeysRecv</span>
01548     par::Mpi_Alltoall&lt;int&gt;(numKeysSend, numKeysRecv, 1, comm);
01549 
01550     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> totalKeys=0; <span class="comment">// total number of local keys ...</span>
01551     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01552       totalKeys += numKeysRecv[i];
01553     }
01554 
01555 <span class="preprocessor">#ifdef __MEASURE_FLAG_NODES__</span>
01556 <span class="preprocessor"></span>    MPI_Barrier(comm);
01557     <span class="keywordtype">int</span> numProcsSend = 0;
01558     <span class="keywordtype">int</span> numProcsRecv = 0;
01559     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01560       <span class="keywordflow">if</span>(numKeysSend[i]) {
01561         numProcsSend++;
01562       }
01563       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01564         numProcsRecv++;
01565       }
01566     }<span class="comment">//end for i</span>
01567     <span class="keywordtype">int</span>* allNumProcsSend = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01568     <span class="keywordtype">int</span>* allNumProcsRecv = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes];
01569     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allKeysSz = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes];
01570     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* allTotalRecv = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[npes]; 
01571     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> localKeysSize = keys.size(); 
01572     par::Mpi_Gather&lt;int&gt;(&amp;numProcsSend, allNumProcsSend, 1, 0, comm);
01573     par::Mpi_Gather&lt;int&gt;(&amp;numProcsRecv, allNumProcsRecv, 1, 0, comm);
01574     par::Mpi_Gather&lt;unsigned int&gt;(&amp;localKeysSize, allKeysSz, 1, 0, comm);
01575     par::Mpi_Gather&lt;unsigned int&gt;(&amp;totalKeys, allTotalRecv, 1, 0, comm);
01576     <span class="keywordflow">if</span>(!rank) {
01577       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
01578         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allNumProcsSend["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allNumProcsSend[i]&lt;&lt;std::endl;
01579         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allNumProcsRecv["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allNumProcsRecv[i]&lt;&lt;std::endl;
01580         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allKeysSz["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allKeysSz[i]&lt;&lt;std::endl;
01581         std::cout&lt;&lt;<span class="stringliteral">"In Flag Nodes:  allTotalRecv["</span>&lt;&lt;i&lt;&lt;<span class="stringliteral">"] = "</span>&lt;&lt;allTotalRecv[i]&lt;&lt;std::endl;
01582       }<span class="comment">//end for i</span>
01583     }
01584 
01585     <span class="keyword">delete</span> [] allNumProcsSend;
01586     <span class="keyword">delete</span> [] allNumProcsRecv;
01587     <span class="keyword">delete</span> [] allKeysSz;
01588     <span class="keyword">delete</span> [] allTotalRecv;
01589     MPI_Barrier(comm);
01590 <span class="preprocessor">#endif</span>
01591 <span class="preprocessor"></span>
01592     <span class="comment">// create the send and recv buffers ...</span>
01593     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* sendK = NULL;
01594     <span class="keywordflow">if</span>(!(keys.empty())) {
01595       sendK = <span class="keyword">new</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>[keys.size()];
01596     }
01597 
01598     <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>* recvK = NULL;
01599     <span class="keywordflow">if</span>(totalKeys) {
01600       recvK = <span class="keyword">new</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>[totalKeys];
01601     }
01602 
01603     <span class="comment">// the mapping ..</span>
01604     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>* comm_map = NULL;
01605     <span class="keywordflow">if</span>(!keys.empty()) {
01606       comm_map = <span class="keyword">new</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>[keys.size()];
01607     }
01608 
01609     <span class="comment">// Now create sendK</span>
01610     <span class="keywordtype">int</span> *sendOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; sendOffsets[0] = 0;
01611     <span class="keywordtype">int</span> *recvOffsets = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; recvOffsets[0] = 0;
01612     <span class="keywordtype">int</span> *numKeysTmp = <span class="keyword">new</span> <span class="keywordtype">int</span>[npes]; numKeysTmp[0] = 0; 
01613 
01614     <span class="comment">// compute offsets ...</span>
01615     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; npes; i++) {
01616       sendOffsets[i] = sendOffsets[i-1] + numKeysSend[i-1];
01617       recvOffsets[i] = recvOffsets[i-1] + numKeysRecv[i-1];
01618       numKeysTmp[i] = 0; 
01619     }
01620 
01621     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; keys.size(); i++) {
01622       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ni = numKeysTmp[part[i]];
01623       numKeysTmp[part[i]]++;
01624       <span class="comment">// set entry ...</span>
01625       assert((sendOffsets[part[i]] + ni) &lt; keys.size());
01626       sendK[sendOffsets[part[i]] + ni] = keys[i];
01627       <span class="comment">// save mapping .. will need it later ...</span>
01628       comm_map[sendOffsets[part[i]] + ni] = keys[i].<a class="code" href="classot_1_1TreeNode.html#z19_11">getWeight</a>();
01629     }
01630     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> keysSz = keys.size();
01631     keys.clear();
01632 
01633     <span class="keywordflow">if</span>(part) {
01634       <span class="keyword">delete</span> [] part;
01635       part = NULL;
01636     }
01637 
01638     <span class="keyword">delete</span> [] numKeysTmp;
01639     numKeysTmp = NULL;
01640 
01641     MPI_Request* requests1 = <span class="keyword">new</span> MPI_Request[npes&lt;&lt;1];
01642 
01643     <span class="comment">//Post Recvs</span>
01644     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01645       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01646         par::Mpi_Irecv&lt;ot::TreeNode&gt;( (recvK + recvOffsets[i]) , numKeysRecv[i],
01647             i, 1, comm, (requests1 + (i&lt;&lt;1)) );
01648       }
01649     }<span class="comment">//end for i</span>
01650 
01651     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01652       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01653         par::Mpi_Irecv&lt;ot::TreeNode&gt;( (recvK + recvOffsets[i]) , numKeysRecv[i],
01654             i, 1, comm, (requests1 + (i&lt;&lt;1)) );
01655       }
01656     }<span class="comment">//end for i</span>
01657 
01658     <span class="comment">//Post Sends</span>
01659     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01660       <span class="keywordflow">if</span>(numKeysSend[i]) {
01661         par::Mpi_Issend&lt;ot::TreeNode&gt;( (sendK + sendOffsets[i]), numKeysSend[i], 
01662             i, 1, comm, (requests1 + ((i&lt;&lt;1) + 1)) );
01663       }
01664     }<span class="comment">//end for i</span>
01665 
01666     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01667       <span class="keywordflow">if</span>(numKeysSend[i]) {
01668         par::Mpi_Issend&lt;ot::TreeNode&gt;( (sendK + sendOffsets[i]), numKeysSend[i], 
01669             i, 1, comm, (requests1 + ((i&lt;&lt;1) + 1)) );
01670       }
01671     }<span class="comment">//end for i</span>
01672 
01673     <a class="code" href="octUtils_8h.html#a83">PROF_FLN_STAGE3_END</a>
01674 
01675 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01676 <span class="preprocessor"></span>      MPI_Barrier(comm);
01677     <span class="keywordflow">if</span>(!rank) {
01678       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 3 passed."</span>&lt;&lt;std::endl;
01679     }
01680     MPI_Barrier(comm);
01681 <span class="preprocessor">#endif</span>
01682 <span class="preprocessor"></span>
01683     <a class="code" href="octUtils_8h.html#a73">PROF_FLN_STAGE4_BEGIN</a>
01684 
01685       <span class="keywordtype">bool</span>* resSend = NULL;
01686     <span class="keywordflow">if</span>(totalKeys) {
01687       resSend = <span class="keyword">new</span> <span class="keywordtype">bool</span>[totalKeys];
01688     }
01689 
01690     <span class="keywordtype">bool</span>* resRecv = NULL;
01691     <span class="keywordflow">if</span>(keysSz) {
01692       resRecv = <span class="keyword">new</span> <span class="keywordtype">bool</span>[keysSz];
01693     }
01694 
01695     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = sendOffsets[rank];
01696         i &lt; (sendOffsets[rank] + numKeysSend[rank]); i++) {
01697       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01698       resSend[recvOffsets[rank] + (i - sendOffsets[rank])] =
01699         seq::BinarySearch&lt;ot::TreeNode&gt;(inPtr, in.size(), sendK[i], &amp;idx);   
01700     }<span class="comment">//end for i</span>
01701 
01702     <a class="code" href="octUtils_8h.html#a84">PROF_FLN_STAGE4_END</a> 
01703 
01704 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01705 <span class="preprocessor"></span>      MPI_Barrier(comm);
01706     <span class="keywordflow">if</span>(!rank) {
01707       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 4 passed."</span>&lt;&lt;std::endl;
01708     }
01709     MPI_Barrier(comm);
01710 <span class="preprocessor">#endif</span>
01711 <span class="preprocessor"></span>
01712     <a class="code" href="octUtils_8h.html#a74">PROF_FLN_STAGE5_BEGIN</a>
01713 
01714       <span class="comment">//Wait for the recvs to complete</span>
01715       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01716         <span class="keywordflow">if</span>(numKeysRecv[i]) {
01717           MPI_Status status;
01718           MPI_Wait( (requests1 + (i&lt;&lt;1)), &amp;status);
01719         }
01720       }<span class="comment">//end for i</span>
01721 
01722     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01723       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01724         MPI_Status status;
01725         MPI_Wait( (requests1 + (i&lt;&lt;1)), &amp;status);
01726       }
01727     }<span class="comment">//end for i</span>
01728 
01729     <a class="code" href="octUtils_8h.html#a85">PROF_FLN_STAGE5_END</a> 
01730 
01731 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01732 <span class="preprocessor"></span>      MPI_Barrier(comm);
01733     <span class="keywordflow">if</span>(!rank) {
01734       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 5 passed."</span>&lt;&lt;std::endl;
01735     }
01736     MPI_Barrier(comm);
01737 <span class="preprocessor">#endif</span>
01738 <span class="preprocessor"></span>
01739     <a class="code" href="octUtils_8h.html#a75">PROF_FLN_STAGE6_BEGIN</a>
01740 
01741       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; recvOffsets[rank]; i++) {
01742         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01743         resSend[i] = seq::BinarySearch&lt;ot::TreeNode&gt;(inPtr, in.size(), recvK[i], &amp;idx);   
01744       }<span class="comment">//end for i</span>
01745 
01746     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = (recvOffsets[rank] + numKeysRecv[rank]); i &lt; totalKeys; i++) {
01747       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
01748       resSend[i] = seq::BinarySearch&lt;ot::TreeNode&gt;(inPtr, in.size(), recvK[i], &amp;idx);   
01749     }<span class="comment">//end for i</span>
01750 
01751     <a class="code" href="octUtils_8h.html#a86">PROF_FLN_STAGE6_END</a>
01752 
01753 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01754 <span class="preprocessor"></span>      MPI_Barrier(comm);
01755     <span class="keywordflow">if</span>(!rank) {
01756       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 6 passed."</span>&lt;&lt;std::endl;
01757     }
01758     MPI_Barrier(comm);
01759 <span class="preprocessor">#endif</span>
01760 <span class="preprocessor"></span>
01761     <a class="code" href="octUtils_8h.html#a76">PROF_FLN_STAGE7_BEGIN</a>
01762 
01763       MPI_Request* requests2 = <span class="keyword">new</span> MPI_Request[npes&lt;&lt;1];
01764 
01765     <span class="comment">//Post Recvs</span>
01766     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01767       <span class="keywordflow">if</span>(numKeysSend[i]) {
01768         par::Mpi_Irecv&lt;bool&gt;( (resRecv + sendOffsets[i]) , numKeysSend[i],
01769             i, 1, comm, (requests2 + (i&lt;&lt;1)) );
01770       }
01771     }<span class="comment">//end for i</span>
01772 
01773     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01774       <span class="keywordflow">if</span>(numKeysSend[i]) {
01775         par::Mpi_Irecv&lt;bool&gt;( (resRecv + sendOffsets[i]) , numKeysSend[i],
01776             i, 1, comm, (requests2 + (i&lt;&lt;1)) );
01777       }
01778     }<span class="comment">//end for i</span>
01779 
01780     <span class="comment">//Post Sends</span>
01781     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01782       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01783         par::Mpi_Issend&lt;bool&gt;( (resSend + recvOffsets[i]), numKeysRecv[i], 
01784             i, 1, comm, (requests2 + ((i&lt;&lt;1) + 1)) );
01785       }
01786     }<span class="comment">//end for i</span>
01787 
01788     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01789       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01790         par::Mpi_Issend&lt;bool&gt;( (resSend + recvOffsets[i]), numKeysRecv[i], 
01791             i, 1, comm, (requests2 + ((i&lt;&lt;1) + 1)) );
01792       }
01793     }<span class="comment">//end for i</span>
01794 
01795     <a class="code" href="octUtils_8h.html#a87">PROF_FLN_STAGE7_END</a>
01796 
01797 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01798 <span class="preprocessor"></span>      MPI_Barrier(comm);
01799     <span class="keywordflow">if</span>(!rank) {
01800       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 7 passed."</span>&lt;&lt;std::endl;
01801     }
01802     MPI_Barrier(comm);
01803 <span class="preprocessor">#endif</span>
01804 <span class="preprocessor"></span>
01805     <a class="code" href="octUtils_8h.html#a77">PROF_FLN_STAGE8_BEGIN</a>
01806       <span class="keywordtype">bool</span>* isHanging = <span class="keyword">new</span> <span class="keywordtype">bool</span>[in.size()];
01807     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
01808       isHanging[i] = <span class="keyword">false</span>;
01809     }<span class="comment">//end for i</span>
01810 
01811     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = recvOffsets[rank]; i &lt; (recvOffsets[rank] + numKeysRecv[rank]); i++) {
01812       <span class="keywordflow">if</span>(resSend[i]) {
01813         isHanging[comm_map[sendOffsets[rank] + i - recvOffsets[rank]]] = <span class="keyword">true</span>;
01814       }
01815     }<span class="comment">//end for i</span>
01816 
01817     <a class="code" href="octUtils_8h.html#a88">PROF_FLN_STAGE8_END</a>
01818 
01819 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01820 <span class="preprocessor"></span>      MPI_Barrier(comm);
01821     <span class="keywordflow">if</span>(!rank) {
01822       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 8 passed."</span>&lt;&lt;std::endl;
01823     }
01824     MPI_Barrier(comm);
01825 <span class="preprocessor">#endif</span>
01826 <span class="preprocessor"></span>
01827     <a class="code" href="octUtils_8h.html#a78">PROF_FLN_STAGE9_BEGIN</a>
01828 
01829       <span class="comment">//wait for recvs</span>
01830       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01831         <span class="keywordflow">if</span>(numKeysSend[i]) {
01832           MPI_Status status;
01833           MPI_Wait( (requests2 + (i&lt;&lt;1)), &amp;status);
01834         }
01835       }<span class="comment">//end for i</span>
01836 
01837     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01838       <span class="keywordflow">if</span>(numKeysSend[i]) {
01839         MPI_Status status;
01840         MPI_Wait( (requests2 + (i&lt;&lt;1)), &amp;status);
01841       }
01842     }<span class="comment">//end for i</span>
01843 
01844     <a class="code" href="octUtils_8h.html#a89">PROF_FLN_STAGE9_END</a>
01845 
01846 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01847 <span class="preprocessor"></span>      MPI_Barrier(comm);
01848     <span class="keywordflow">if</span>(!rank) {
01849       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 9 passed."</span>&lt;&lt;std::endl;
01850     }
01851     MPI_Barrier(comm);
01852 <span class="preprocessor">#endif</span>
01853 <span class="preprocessor"></span>
01854     <a class="code" href="octUtils_8h.html#a79">PROF_FLN_STAGE10_BEGIN</a>
01855 
01856       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; sendOffsets[rank]; i++) {
01857         <span class="keywordflow">if</span>(resRecv[i]) {
01858           isHanging[comm_map[i]] = <span class="keyword">true</span>;
01859         }
01860       }<span class="comment">//end for i</span>
01861 
01862     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (sendOffsets[rank] + numKeysSend[rank]); i &lt; keysSz; i++) {
01863       <span class="keywordflow">if</span>(resRecv[i]) {
01864         isHanging[comm_map[i]] = <span class="keyword">true</span>;
01865       }
01866     }<span class="comment">//end for i</span>
01867 
01868     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; in.size(); i++) {
01869       <span class="keywordflow">if</span> (!isHanging[i]) {
01870         in[i].<a class="code" href="classot_1_1TreeNode.html#z19_15">orFlag</a>(ot::TreeNode::NODE);
01871       }
01872     }<span class="comment">//end for i</span>
01873 
01874     <a class="code" href="octUtils_8h.html#a90">PROF_FLN_STAGE10_END</a>
01875 
01876 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01877 <span class="preprocessor"></span>      MPI_Barrier(comm);
01878     <span class="keywordflow">if</span>(!rank) {
01879       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 10 passed."</span>&lt;&lt;std::endl;
01880     }
01881     MPI_Barrier(comm);
01882 <span class="preprocessor">#endif</span>
01883 <span class="preprocessor"></span>
01884     <a class="code" href="octUtils_8h.html#a80">PROF_FLN_STAGE11_BEGIN</a>
01885 
01886       <span class="comment">//Wait for the sends to complete</span>
01887       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01888         <span class="keywordflow">if</span>(numKeysSend[i]) {
01889           MPI_Status status;
01890           MPI_Wait( (requests1 + ((i&lt;&lt;1) + 1)), &amp;status);
01891         }
01892       }<span class="comment">//end for i</span>
01893 
01894     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01895       <span class="keywordflow">if</span>(numKeysSend[i]) {
01896         MPI_Status status;
01897         MPI_Wait( (requests1 + ((i&lt;&lt;1) + 1)), &amp;status);
01898       }
01899     }<span class="comment">//end for i</span>
01900 
01901     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; rank; i++) {
01902       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01903         MPI_Status status;
01904         MPI_Wait( (requests2 + ((i&lt;&lt;1) + 1)), &amp;status);
01905       }
01906     }<span class="comment">//end for i</span>
01907 
01908     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (rank + 1); i &lt; npes; i++) {
01909       <span class="keywordflow">if</span>(numKeysRecv[i]) {
01910         MPI_Status status;
01911         MPI_Wait( (requests2 + ((i&lt;&lt;1) + 1)), &amp;status);
01912       }
01913     }<span class="comment">//end for i</span>
01914 
01915     <span class="comment">// Clean up ...</span>
01916     <span class="keywordflow">if</span>(comm_map) {
01917       <span class="keyword">delete</span> [] comm_map; 
01918     }
01919 
01920     <span class="keywordflow">if</span>(resRecv) {
01921       <span class="keyword">delete</span> [] resRecv;
01922     }
01923 
01924     <span class="keywordflow">if</span>(resSend) {
01925       <span class="keyword">delete</span> []resSend;
01926     }
01927 
01928     <span class="keywordflow">if</span>(sendK) {
01929       <span class="keyword">delete</span> [] sendK;
01930     }
01931 
01932     <span class="keywordflow">if</span>(recvK) {
01933       <span class="keyword">delete</span> [] recvK;
01934     }
01935 
01936     <span class="keyword">delete</span> [] sendOffsets;
01937     <span class="keyword">delete</span> [] recvOffsets;
01938     <span class="keyword">delete</span> [] numKeysSend;
01939     <span class="keyword">delete</span> [] numKeysRecv;
01940     <span class="keyword">delete</span> [] requests1;
01941     <span class="keyword">delete</span> [] requests2;
01942 
01943     <a class="code" href="octUtils_8h.html#a91">PROF_FLN_STAGE11_END</a>
01944 
01945 <span class="preprocessor">#ifdef __DEBUG_DA_PUBLIC__</span>
01946 <span class="preprocessor"></span>      MPI_Barrier(comm);
01947     <span class="keywordflow">if</span>(!rank) {
01948       std::cout&lt;&lt;<span class="stringliteral">"FLN Stage 11 passed."</span>&lt;&lt;std::endl;
01949     }
01950     MPI_Barrier(comm);
01951 <span class="preprocessor">#endif</span>
01952 <span class="preprocessor"></span>
01953     <a class="code" href="octUtils_8h.html#a93">PROF_MARK_HANGING_END</a>
01954   }<span class="comment">//end function</span>
01955 
01956 
01957 }<span class="comment">//end namespace</span>
01958 
01959 
01960 
01961 
01962 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:31 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
