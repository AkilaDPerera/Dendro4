<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/examples/handleType2Stencils.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">examples</a></div>
<h1>handleType2Stencils.C</h1><a href="handleType2Stencils_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00002 <span class="preprocessor">#include "mpi.h"</span>
00003 <span class="preprocessor">#include &lt;cstdio&gt;</span>
00004 <span class="preprocessor">#include &lt;iostream&gt;</span>
00005 <span class="preprocessor">#include &lt;cassert&gt;</span>
00006 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00007 <span class="preprocessor">#include "<a class="code" href="handleStencils_8h.html">handleStencils.h</a>"</span>
00008 
<a name="l00009"></a><a class="code" href="handleType2Stencils_8C.html#a0">00009</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a0">createShapeFnCoeffs</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00010 
00011 <span class="preprocessor">#ifdef __USE_MG_INIT_TYPE3__</span>
00012 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a1">createShapeFnCoeffs_Type3</a>(Mmat);
00013 <span class="preprocessor">#else</span>
00014 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_MG_INIT_TYPE2__</span>
00015 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a2">createShapeFnCoeffs_Type2</a>(Mmat);
00016 <span class="preprocessor">#else</span>
00017 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a3">createShapeFnCoeffs_Type1</a>(Mmat);
00018 <span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00020 <span class="preprocessor"></span>
00021   <span class="keywordflow">return</span> 1;
00022 }
00023 
<a name="l00024"></a><a class="code" href="handleType2Stencils_8C.html#a1">00024</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a1">createShapeFnCoeffs_Type3</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00025   FILE* infile;
00026   <span class="keywordtype">int</span> rank;
00027   MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank); 
00028   <span class="keywordtype">char</span> fname[250];
00029   sprintf(fname,<span class="stringliteral">"ShapeFnCoeffs_%d.inp"</span>, rank);
00030   infile = fopen(fname,<span class="stringliteral">"r"</span>);
00031   <span class="keywordflow">if</span>(!infile) {
00032     std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00033     assert(<span class="keyword">false</span>);
00034   }
00035 
00036   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00037   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00038   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00039 
00040   Mmat = <span class="keyword">new</span> double3Ptr[8];
00041   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00042     Mmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00043     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00044       Mmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
00045       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00046         Mmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00047         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00048           fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Mmat[cNum][eType][i][j]));
00049         }
00050       }
00051     }
00052   }
00053 
00054   fclose(infile);
00055   <span class="keywordflow">return</span> 1;
00056 }
00057 
<a name="l00058"></a><a class="code" href="handleType2Stencils_8C.html#a2">00058</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a2">createShapeFnCoeffs_Type2</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00059   FILE* infile;
00060   MPI_Comm comm = MPI_COMM_WORLD;
00061 
00062   <span class="keywordtype">int</span> rank, npes;
00063   MPI_Comm_rank(comm, &amp;rank);
00064   MPI_Comm_size(comm, &amp;npes);
00065 
00066   <span class="keyword">const</span> <span class="keywordtype">int</span> THOUSAND = 1000;
00067   <span class="keywordtype">int</span> numGroups = (npes/THOUSAND);
00068   <span class="keywordflow">if</span>( (numGroups*THOUSAND) &lt; npes) {
00069     numGroups++;
00070   }
00071 
00072   MPI_Comm newComm;
00073 
00074   <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npes];
00075   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numGroups; i++) {
00076     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; (j &lt; (i*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00077       isEmptyList[j] = <span class="keyword">true</span>;
00078     }
00079     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = (i*THOUSAND); (j &lt; ((i+1)*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00080       isEmptyList[j] = <span class="keyword">false</span>;
00081     }
00082     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = ((i + 1)*THOUSAND); j &lt; npes; j++) {
00083       isEmptyList[j] = <span class="keyword">true</span>;
00084     }
00085     MPI_Comm tmpComm;
00086     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(isEmptyList, &amp;tmpComm, comm);
00087     <span class="keywordflow">if</span>(!(isEmptyList[rank])) {
00088       newComm = tmpComm;
00089     }
00090   }<span class="comment">//end for i</span>
00091   <span class="keyword">delete</span> [] isEmptyList;
00092 
00093 
00094   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00095     <span class="keywordtype">char</span> fname[250];
00096     sprintf(fname,<span class="stringliteral">"ShapeFnCoeffs_%d.inp"</span>, (rank/THOUSAND));
00097     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00098     <span class="keywordflow">if</span>(!infile) {
00099       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00100       assert(<span class="keyword">false</span>);
00101     }
00102   }
00103 
00104   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00105   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00106   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00107 
00108   Mmat = <span class="keyword">new</span> double3Ptr[8];
00109   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00110     Mmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00111     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00112       Mmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
00113       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00114         Mmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00115         <span class="keywordflow">if</span>((rank % THOUSAND) == 0){
00116           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00117             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Mmat[cNum][eType][i][j]));
00118           }
00119         }
00120       }
00121     }
00122   }
00123 
00124   <span class="keywordflow">if</span>((rank % THOUSAND) == 0){
00125     fclose(infile);
00126   }
00127 
00128   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[9216];
00129 
00130   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00131     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00132     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00133       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00134         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00135           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00136             tmpMat[ctr] = Mmat[cNum][eType][i][j];
00137             ctr++;
00138           }
00139         }
00140       }
00141     }
00142   }
00143 
00144   par::Mpi_Bcast&lt;double&gt;(tmpMat,9216, 0, newComm);
00145 
00146   <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
00147     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00148     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00149       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00150         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00151           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00152             Mmat[cNum][eType][i][j] = tmpMat[ctr];
00153             ctr++;
00154           }
00155         }
00156       }
00157     }
00158   }
00159 
00160   <span class="keyword">delete</span> [] tmpMat;
00161 
00162   <span class="keywordflow">return</span> 1;
00163 }<span class="comment">//end of function</span>
00164 
<a name="l00165"></a><a class="code" href="handleType2Stencils_8C.html#a3">00165</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a3">createShapeFnCoeffs_Type1</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00166   FILE* infile;
00167   <span class="keywordtype">int</span> rank;
00168   MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
00169   <span class="keywordflow">if</span>(!rank) {
00170     <span class="keywordtype">char</span> fname[250];
00171     sprintf(fname,<span class="stringliteral">"ShapeFnCoeffs.inp"</span>);
00172     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00173     <span class="keywordflow">if</span>(!infile) {
00174       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00175       assert(<span class="keyword">false</span>);
00176     }
00177   }
00178 
00179   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00180   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00181   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00182 
00183   Mmat = <span class="keyword">new</span> double3Ptr[8];
00184   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00185     Mmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00186     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00187       Mmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
00188       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00189         Mmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00190         <span class="keywordflow">if</span>(!rank){
00191           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00192             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Mmat[cNum][eType][i][j]));
00193           }
00194         }
00195       }
00196     }
00197   }
00198 
00199   <span class="keywordflow">if</span>(!rank){
00200     fclose(infile);
00201   }
00202 
00203   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[9216];
00204 
00205   <span class="keywordflow">if</span>(!rank) {
00206     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00207     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00208       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00209         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00210           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00211             tmpMat[ctr] = Mmat[cNum][eType][i][j];
00212             ctr++;
00213           }
00214         }
00215       }
00216     }
00217   }
00218 
00219   par::Mpi_Bcast&lt;double&gt;(tmpMat,9216, 0, MPI_COMM_WORLD);
00220 
00221   <span class="keywordflow">if</span>(rank) {
00222     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00223     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00224       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00225         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00226           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00227             Mmat[cNum][eType][i][j] = tmpMat[ctr];
00228             ctr++;
00229           }
00230         }
00231       }
00232     }
00233   }
00234 
00235   <span class="keyword">delete</span> [] tmpMat;
00236 
00237   <span class="keywordflow">return</span> 1;
00238 }<span class="comment">//end of function</span>
00239 
<a name="l00240"></a><a class="code" href="handleType2Stencils_8C.html#a4">00240</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a4">createShFnMat</a>(<span class="keywordtype">double</span>******&amp; shFnMat) {
00241 
00242 <span class="preprocessor">#ifdef __USE_MG_INIT_TYPE3__</span>
00243 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a5">createShFnMat_Type3</a>(shFnMat);
00244 <span class="preprocessor">#else</span>
00245 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_MG_INIT_TYPE2__</span>
00246 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a6">createShFnMat_Type2</a>(shFnMat);
00247 <span class="preprocessor">#else</span>
00248 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a7">createShFnMat_Type1</a>(shFnMat);
00249 <span class="preprocessor">#endif</span>
00250 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00251 <span class="preprocessor"></span>
00252   <span class="keywordflow">return</span> 1;
00253 }
00254 
<a name="l00255"></a><a class="code" href="handleType2Stencils_8C.html#a5">00255</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a5">createShFnMat_Type3</a>(<span class="keywordtype">double</span>******&amp; shFnMat) {
00256   FILE* infile;
00257   <span class="keywordtype">int</span> rank;
00258   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
00259 
00260   <span class="keywordtype">char</span> fname[250];
00261   sprintf(fname,<span class="stringliteral">"ShFnStencils_%d.inp"</span>, rank);
00262   infile = fopen(fname,<span class="stringliteral">"r"</span>);
00263   <span class="keywordflow">if</span>(!infile) {
00264     std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00265     assert(<span class="keyword">false</span>);
00266   }
00267 
00268   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00269   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00270   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00271   <span class="keyword">typedef</span> double3Ptr* double4Ptr;
00272   <span class="keyword">typedef</span> double4Ptr* double5Ptr;
00273 
00274   shFnMat = <span class="keyword">new</span> double5Ptr[8];
00275   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00276     shFnMat[cNum] = <span class="keyword">new</span> double4Ptr[18];
00277     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00278       shFnMat[cNum][eType] = <span class="keyword">new</span> double3Ptr[8];
00279       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00280         shFnMat[cNum][eType][j] = <span class="keyword">new</span> double2Ptr[3];
00281         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00282           shFnMat[cNum][eType][j][m] = <span class="keyword">new</span> doublePtr[3];
00283           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00284             shFnMat[cNum][eType][j][m][n] = <span class="keyword">new</span> <span class="keywordtype">double</span>[3];
00285             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00286               fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(shFnMat[cNum][eType][j][m][n][p]));
00287             }<span class="comment">//end p</span>
00288           }<span class="comment">//end n</span>
00289         }<span class="comment">//end m</span>
00290       }<span class="comment">//end j</span>
00291     }<span class="comment">//end etype</span>
00292   }<span class="comment">//end cNum</span>
00293 
00294   fclose(infile);
00295 
00296   <span class="keywordflow">return</span> 1;
00297 }
00298 
<a name="l00299"></a><a class="code" href="handleType2Stencils_8C.html#a6">00299</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a6">createShFnMat_Type2</a>(<span class="keywordtype">double</span>******&amp; shFnMat) {
00300   FILE* infile;
00301   MPI_Comm comm = MPI_COMM_WORLD;
00302 
00303   <span class="keywordtype">int</span> rank, npes;
00304   MPI_Comm_rank(comm, &amp;rank);
00305   MPI_Comm_size(comm, &amp;npes);
00306 
00307   <span class="keyword">const</span> <span class="keywordtype">int</span> THOUSAND = 1000;
00308   <span class="keywordtype">int</span> numGroups = (npes/THOUSAND);
00309   <span class="keywordflow">if</span>( (numGroups*THOUSAND) &lt; npes) {
00310     numGroups++;
00311   }
00312 
00313   MPI_Comm newComm;
00314 
00315   <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npes];
00316   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numGroups; i++) {
00317     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; (j &lt; (i*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00318       isEmptyList[j] = <span class="keyword">true</span>;
00319     }
00320     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = (i*THOUSAND); (j &lt; ((i+1)*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00321       isEmptyList[j] = <span class="keyword">false</span>;
00322     }
00323     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = ((i + 1)*THOUSAND); j &lt; npes; j++) {
00324       isEmptyList[j] = <span class="keyword">true</span>;
00325     }
00326     MPI_Comm tmpComm;
00327     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(isEmptyList, &amp;tmpComm, comm);
00328     <span class="keywordflow">if</span>(!(isEmptyList[rank])) {
00329       newComm = tmpComm;
00330     }
00331   }<span class="comment">//end for i</span>
00332   <span class="keyword">delete</span> [] isEmptyList;
00333 
00334 
00335   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00336     <span class="keywordtype">char</span> fname[250];
00337     sprintf(fname,<span class="stringliteral">"ShFnStencils_%d.inp"</span>, (rank/THOUSAND));
00338     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00339     <span class="keywordflow">if</span>(!infile) {
00340       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00341       assert(<span class="keyword">false</span>);
00342     }
00343   }
00344 
00345   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00346   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00347   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00348   <span class="keyword">typedef</span> double3Ptr* double4Ptr;
00349   <span class="keyword">typedef</span> double4Ptr* double5Ptr;
00350 
00351   shFnMat = <span class="keyword">new</span> double5Ptr[8];
00352   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00353     shFnMat[cNum] = <span class="keyword">new</span> double4Ptr[18];
00354     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00355       shFnMat[cNum][eType] = <span class="keyword">new</span> double3Ptr[8];
00356       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00357         shFnMat[cNum][eType][j] = <span class="keyword">new</span> double2Ptr[3];
00358         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00359           shFnMat[cNum][eType][j][m] = <span class="keyword">new</span> doublePtr[3];
00360           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00361             shFnMat[cNum][eType][j][m][n] = <span class="keyword">new</span> <span class="keywordtype">double</span>[3];
00362             <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00363               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00364                 fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(shFnMat[cNum][eType][j][m][n][p]));
00365               }<span class="comment">//end p</span>
00366             }
00367           }<span class="comment">//end n</span>
00368         }<span class="comment">//end m</span>
00369       }<span class="comment">//end j</span>
00370     }<span class="comment">//end etype</span>
00371   }<span class="comment">//end cNum</span>
00372 
00373   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00374     fclose(infile);
00375   }
00376 
00377   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[31104];
00378 
00379   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00380     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00381     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00382       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00383         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00384           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00385             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00386               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00387                 tmpMat[ctr] = shFnMat[cNum][eType][j][m][n][p];
00388                 ctr++;
00389               }
00390             }
00391           }
00392         }
00393       }
00394     }
00395   }
00396 
00397   par::Mpi_Bcast&lt;double&gt;(tmpMat,31104, 0, newComm);
00398 
00399   <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
00400     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00401     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00402       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00403         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00404           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00405             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00406               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00407                 shFnMat[cNum][eType][j][m][n][p] = tmpMat[ctr];
00408                 ctr++;
00409               }
00410             }
00411           }
00412         }
00413       }
00414     }
00415   }
00416 
00417   <span class="keyword">delete</span> [] tmpMat;
00418 
00419   <span class="keywordflow">return</span> 1;
00420 }<span class="comment">//end fn.</span>
00421 
<a name="l00422"></a><a class="code" href="handleType2Stencils_8C.html#a7">00422</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a7">createShFnMat_Type1</a>(<span class="keywordtype">double</span>******&amp; shFnMat) {
00423   FILE* infile;
00424   <span class="keywordtype">int</span> rank;
00425   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
00426 
00427   <span class="keywordflow">if</span>(!rank) {
00428     <span class="keywordtype">char</span> fname[250];
00429     sprintf(fname,<span class="stringliteral">"ShFnStencils.inp"</span>);
00430     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00431     <span class="keywordflow">if</span>(!infile) {
00432       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00433       assert(<span class="keyword">false</span>);
00434     }
00435   }
00436 
00437   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00438   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00439   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00440   <span class="keyword">typedef</span> double3Ptr* double4Ptr;
00441   <span class="keyword">typedef</span> double4Ptr* double5Ptr;
00442 
00443   shFnMat = <span class="keyword">new</span> double5Ptr[8];
00444   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00445     shFnMat[cNum] = <span class="keyword">new</span> double4Ptr[18];
00446     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00447       shFnMat[cNum][eType] = <span class="keyword">new</span> double3Ptr[8];
00448       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00449         shFnMat[cNum][eType][j] = <span class="keyword">new</span> double2Ptr[3];
00450         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00451           shFnMat[cNum][eType][j][m] = <span class="keyword">new</span> doublePtr[3];
00452           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00453             shFnMat[cNum][eType][j][m][n] = <span class="keyword">new</span> <span class="keywordtype">double</span>[3];
00454             <span class="keywordflow">if</span>(!rank) {
00455               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00456                 fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(shFnMat[cNum][eType][j][m][n][p]));
00457               }<span class="comment">//end p</span>
00458             }
00459           }<span class="comment">//end n</span>
00460         }<span class="comment">//end m</span>
00461       }<span class="comment">//end j</span>
00462     }<span class="comment">//end etype</span>
00463   }<span class="comment">//end cNum</span>
00464 
00465   <span class="keywordflow">if</span>(!rank) {
00466     fclose(infile);
00467   }
00468 
00469   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[31104];
00470 
00471   <span class="keywordflow">if</span>(!rank) {
00472     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00473     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00474       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00475         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00476           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00477             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00478               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00479                 tmpMat[ctr] = shFnMat[cNum][eType][j][m][n][p];
00480                 ctr++;
00481               }
00482             }
00483           }
00484         }
00485       }
00486     }
00487   }
00488 
00489   par::Mpi_Bcast&lt;double&gt;(tmpMat,31104, 0, MPI_COMM_WORLD);
00490 
00491   <span class="keywordflow">if</span>(rank) {
00492     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00493     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00494       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00495         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00496           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
00497             <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
00498               <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> p = 0; p &lt; 3; p++) {
00499                 shFnMat[cNum][eType][j][m][n][p] = tmpMat[ctr];
00500                 ctr++;
00501               }
00502             }
00503           }
00504         }
00505       }
00506     }
00507   }
00508 
00509   <span class="keyword">delete</span> [] tmpMat;
00510 
00511   <span class="keywordflow">return</span> 1;
00512 }<span class="comment">//end fn.</span>
00513 
<a name="l00514"></a><a class="code" href="handleType2Stencils_8C.html#a8">00514</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a8">createGDmatType2</a>(<span class="keywordtype">double</span> ****&amp; GDmat) {
00515 
00516 <span class="preprocessor">#ifdef __USE_MG_INIT_TYPE3__</span>
00517 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a9">createGDmatType2_Type3</a>(GDmat);
00518 <span class="preprocessor">#else</span>
00519 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_MG_INIT_TYPE2__</span>
00520 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a10">createGDmatType2_Type2</a>(GDmat);
00521 <span class="preprocessor">#else</span>
00522 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a11">createGDmatType2_Type1</a>(GDmat);
00523 <span class="preprocessor">#endif</span>
00524 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00525 <span class="preprocessor"></span>
00526   <span class="keywordflow">return</span> 1;
00527 }
00528 
<a name="l00529"></a><a class="code" href="handleType2Stencils_8C.html#a9">00529</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a9">createGDmatType2_Type3</a>(<span class="keywordtype">double</span> ****&amp; GDmat) {
00530   FILE* infile;
00531   <span class="keywordtype">int</span> rank;
00532   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
00533 
00534   <span class="keywordtype">char</span> fname[250];
00535   sprintf(fname,<span class="stringliteral">"GDType2Stencils_%d.inp"</span>, rank);
00536   infile = fopen(fname,<span class="stringliteral">"r"</span>);
00537   <span class="keywordflow">if</span>(!infile) {
00538     std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00539     assert(<span class="keyword">false</span>);
00540   }
00541 
00542   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00543   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00544   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00545 
00546   GDmat = <span class="keyword">new</span> double3Ptr[8];
00547   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00548     GDmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00549     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00550       GDmat[cNum][eType] = <span class="keyword">new</span> doublePtr[24];
00551       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
00552         GDmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[24];
00553         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 24; j++) {
00554           fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(GDmat[cNum][eType][i][j]));
00555         }
00556       }
00557     }
00558   }
00559 
00560   fclose(infile);
00561 
00562   <span class="keywordflow">return</span> 1;
00563 }
00564 
<a name="l00565"></a><a class="code" href="handleType2Stencils_8C.html#a10">00565</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a10">createGDmatType2_Type2</a>(<span class="keywordtype">double</span> ****&amp; GDmat) {
00566   FILE* infile;
00567   MPI_Comm comm = MPI_COMM_WORLD;
00568 
00569   <span class="keywordtype">int</span> rank, npes;
00570   MPI_Comm_rank(comm, &amp;rank);
00571   MPI_Comm_size(comm, &amp;npes);
00572 
00573   <span class="keyword">const</span> <span class="keywordtype">int</span> THOUSAND = 1000;
00574   <span class="keywordtype">int</span> numGroups = (npes/THOUSAND);
00575   <span class="keywordflow">if</span>( (numGroups*THOUSAND) &lt; npes) {
00576     numGroups++;
00577   }
00578 
00579   MPI_Comm newComm;
00580 
00581   <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npes];
00582   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numGroups; i++) {
00583     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; (j &lt; (i*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00584       isEmptyList[j] = <span class="keyword">true</span>;
00585     }
00586     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = (i*THOUSAND); (j &lt; ((i+1)*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00587       isEmptyList[j] = <span class="keyword">false</span>;
00588     }
00589     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = ((i + 1)*THOUSAND); j &lt; npes; j++) {
00590       isEmptyList[j] = <span class="keyword">true</span>;
00591     }
00592     MPI_Comm tmpComm;
00593     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(isEmptyList, &amp;tmpComm, comm);
00594     <span class="keywordflow">if</span>(!(isEmptyList[rank])) {
00595       newComm = tmpComm;
00596     }
00597   }<span class="comment">//end for i</span>
00598   <span class="keyword">delete</span> [] isEmptyList;
00599 
00600 
00601   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00602     <span class="keywordtype">char</span> fname[250];
00603     sprintf(fname,<span class="stringliteral">"GDType2Stencils_%d.inp"</span>, (rank/THOUSAND));
00604     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00605     <span class="keywordflow">if</span>(!infile) {
00606       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00607       assert(<span class="keyword">false</span>);
00608     }
00609   }
00610 
00611   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00612   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00613   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00614 
00615   GDmat = <span class="keyword">new</span> double3Ptr[8];
00616   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00617     GDmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00618     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00619       GDmat[cNum][eType] = <span class="keyword">new</span> doublePtr[24];
00620       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
00621         GDmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[24];
00622         <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00623           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 24; j++) {
00624             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(GDmat[cNum][eType][i][j]));
00625           }
00626         }
00627       }
00628     }
00629   }
00630 
00631   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00632     fclose(infile);
00633   }
00634 
00635   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[82944];
00636 
00637   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00638     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00639     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00640       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00641         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
00642           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 24; j++) {
00643             tmpMat[ctr] = GDmat[cNum][eType][i][j];
00644             ctr++;
00645           }
00646         }
00647       }
00648     }
00649   }
00650 
00651   par::Mpi_Bcast&lt;double&gt;(tmpMat,82944, 0, newComm);
00652 
00653   <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
00654     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00655     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00656       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00657         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
00658           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 24; j++) {
00659             GDmat[cNum][eType][i][j] = tmpMat[ctr];
00660             ctr++;
00661           }
00662         }
00663       }
00664     }
00665   }
00666 
00667   <span class="keyword">delete</span> [] tmpMat;
00668 
00669   <span class="keywordflow">return</span> 1;
00670 }<span class="comment">//end fn.</span>
00671 
00672 
00673 <span class="comment">/*Type 2 Matrices: Coarse and Fine are the same.*/</span>
<a name="l00674"></a><a class="code" href="handleType2Stencils_8C.html#a11">00674</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a11">createGDmatType2_Type1</a>(<span class="keywordtype">double</span> ****&amp; GDmat) {
00675   FILE* infile;
00676   <span class="keywordtype">int</span> rank;
00677   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
00678 
00679   <span class="keywordflow">if</span>(!rank) {
00680     <span class="keywordtype">char</span> fname[250];
00681     sprintf(fname,<span class="stringliteral">"GDType2Stencils.inp"</span>);
00682     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00683     <span class="keywordflow">if</span>(!infile) {
00684       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00685       assert(<span class="keyword">false</span>);
00686     }
00687   }
00688 
00689   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00690   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00691   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00692 
00693   GDmat = <span class="keyword">new</span> double3Ptr[8];
00694   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00695     GDmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00696     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00697       GDmat[cNum][eType] = <span class="keyword">new</span> doublePtr[24];
00698       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
00699         GDmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[24];
00700         <span class="keywordflow">if</span>(!rank) {
00701           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 24; j++) {
00702             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(GDmat[cNum][eType][i][j]));
00703           }
00704         }
00705       }
00706     }
00707   }
00708 
00709   <span class="keywordflow">if</span>(!rank) {
00710     fclose(infile);
00711   }
00712 
00713   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[82944];
00714 
00715   <span class="keywordflow">if</span>(!rank) {
00716     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00717     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00718       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00719         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
00720           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 24; j++) {
00721             tmpMat[ctr] = GDmat[cNum][eType][i][j];
00722             ctr++;
00723           }
00724         }
00725       }
00726     }
00727   }
00728 
00729   par::Mpi_Bcast&lt;double&gt;(tmpMat,82944, 0, MPI_COMM_WORLD);
00730 
00731   <span class="keywordflow">if</span>(rank) {
00732     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00733     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00734       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00735         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
00736           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 24; j++) {
00737             GDmat[cNum][eType][i][j] = tmpMat[ctr];
00738             ctr++;
00739           }
00740         }
00741       }
00742     }
00743   }
00744 
00745   <span class="keyword">delete</span> [] tmpMat;
00746 
00747   <span class="keywordflow">return</span> 1;
00748 }<span class="comment">//end fn.</span>
00749 
<a name="l00750"></a><a class="code" href="handleType2Stencils_8C.html#a12">00750</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a12">createMmatType2</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00751 
00752 <span class="preprocessor">#ifdef __USE_MG_INIT_TYPE3__</span>
00753 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a13">createMmatType2_Type3</a>(Mmat);
00754 <span class="preprocessor">#else</span>
00755 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_MG_INIT_TYPE2__</span>
00756 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a14">createMmatType2_Type2</a>(Mmat);
00757 <span class="preprocessor">#else</span>
00758 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a15">createMmatType2_Type1</a>(Mmat);
00759 <span class="preprocessor">#endif</span>
00760 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00761 <span class="preprocessor"></span>
00762   <span class="keywordflow">return</span> 1;
00763 }
00764 
<a name="l00765"></a><a class="code" href="handleType2Stencils_8C.html#a13">00765</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a13">createMmatType2_Type3</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00766   FILE* infile;
00767   <span class="keywordtype">int</span> rank;
00768   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
00769 
00770   <span class="keywordtype">char</span> fname[250];
00771   sprintf(fname,<span class="stringliteral">"MassType2Stencils_%d.inp"</span>, rank);
00772   infile = fopen(fname,<span class="stringliteral">"r"</span>);
00773   <span class="keywordflow">if</span>(!infile) {
00774     std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00775     assert(<span class="keyword">false</span>);
00776   }
00777 
00778   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00779   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00780   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00781 
00782   Mmat = <span class="keyword">new</span> double3Ptr[8];
00783   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00784     Mmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00785     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00786       Mmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
00787       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00788         Mmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00789         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00790           fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Mmat[cNum][eType][i][j]));
00791         }
00792       }
00793     }
00794   }
00795 
00796   fclose(infile);
00797 
00798   <span class="keywordflow">return</span> 1;
00799 }
00800 
<a name="l00801"></a><a class="code" href="handleType2Stencils_8C.html#a14">00801</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a14">createMmatType2_Type2</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00802   FILE* infile;
00803   MPI_Comm comm = MPI_COMM_WORLD;
00804 
00805   <span class="keywordtype">int</span> rank, npes;
00806   MPI_Comm_rank(comm, &amp;rank);
00807   MPI_Comm_size(comm, &amp;npes);
00808 
00809   <span class="keyword">const</span> <span class="keywordtype">int</span> THOUSAND = 1000;
00810   <span class="keywordtype">int</span> numGroups = (npes/THOUSAND);
00811   <span class="keywordflow">if</span>( (numGroups*THOUSAND) &lt; npes) {
00812     numGroups++;
00813   }
00814 
00815   MPI_Comm newComm;
00816 
00817   <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npes];
00818   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numGroups; i++) {
00819     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; (j &lt; (i*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00820       isEmptyList[j] = <span class="keyword">true</span>;
00821     }
00822     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = (i*THOUSAND); (j &lt; ((i+1)*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
00823       isEmptyList[j] = <span class="keyword">false</span>;
00824     }
00825     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = ((i + 1)*THOUSAND); j &lt; npes; j++) {
00826       isEmptyList[j] = <span class="keyword">true</span>;
00827     }
00828     MPI_Comm tmpComm;
00829     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(isEmptyList, &amp;tmpComm, comm);
00830     <span class="keywordflow">if</span>(!(isEmptyList[rank])) {
00831       newComm = tmpComm;
00832     }
00833   }<span class="comment">//end for i</span>
00834   <span class="keyword">delete</span> [] isEmptyList;
00835 
00836 
00837   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00838     <span class="keywordtype">char</span> fname[250];
00839     sprintf(fname,<span class="stringliteral">"MassType2Stencils_%d.inp"</span>, (rank/THOUSAND));
00840     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00841     <span class="keywordflow">if</span>(!infile) {
00842       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00843       assert(<span class="keyword">false</span>);
00844     }
00845   }
00846 
00847   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00848   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00849   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00850 
00851   Mmat = <span class="keyword">new</span> double3Ptr[8];
00852   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00853     Mmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00854     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00855       Mmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
00856       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00857         Mmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00858         <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00859           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00860             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Mmat[cNum][eType][i][j]));
00861           }
00862         }
00863       }
00864     }
00865   }
00866 
00867   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00868     fclose(infile);
00869   }
00870 
00871   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[9216];
00872 
00873   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
00874     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00875     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00876       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00877         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00878           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00879             tmpMat[ctr] = Mmat[cNum][eType][i][j];
00880             ctr++;
00881           }
00882         }
00883       }
00884     }
00885   }
00886 
00887   par::Mpi_Bcast&lt;double&gt;(tmpMat,9216, 0, newComm);
00888 
00889   <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
00890     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00891     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00892       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00893         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00894           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00895             Mmat[cNum][eType][i][j] = tmpMat[ctr];
00896             ctr++;
00897           }
00898         }
00899       }
00900     }
00901   }
00902 
00903   <span class="keyword">delete</span> [] tmpMat;
00904 
00905   <span class="keywordflow">return</span> 1;
00906 }<span class="comment">//end of function</span>
00907 
00908 
<a name="l00909"></a><a class="code" href="handleType2Stencils_8C.html#a15">00909</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a15">createMmatType2_Type1</a>(<span class="keywordtype">double</span> ****&amp; Mmat) {
00910   FILE* infile;
00911   <span class="keywordtype">int</span> rank;
00912   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
00913 
00914   <span class="keywordflow">if</span>(!rank) {
00915     <span class="keywordtype">char</span> fname[250];
00916     sprintf(fname,<span class="stringliteral">"MassType2Stencils.inp"</span>);
00917     infile = fopen(fname,<span class="stringliteral">"r"</span>);
00918     <span class="keywordflow">if</span>(!infile) {
00919       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
00920       assert(<span class="keyword">false</span>);
00921     }
00922   }
00923 
00924   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
00925   <span class="keyword">typedef</span> doublePtr* double2Ptr;
00926   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
00927 
00928   Mmat = <span class="keyword">new</span> double3Ptr[8];
00929   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00930     Mmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
00931     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00932       Mmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
00933       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00934         Mmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
00935         <span class="keywordflow">if</span>(!rank) {
00936           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00937             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Mmat[cNum][eType][i][j]));
00938           }
00939         }
00940       }
00941     }
00942   }
00943 
00944   <span class="keywordflow">if</span>(!rank) {
00945     fclose(infile);
00946   }
00947 
00948   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[9216];
00949 
00950   <span class="keywordflow">if</span>(!rank) {
00951     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00952     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00953       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00954         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00955           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00956             tmpMat[ctr] = Mmat[cNum][eType][i][j];
00957             ctr++;
00958           }
00959         }
00960       }
00961     }
00962   }
00963 
00964   par::Mpi_Bcast&lt;double&gt;(tmpMat,9216, 0, MPI_COMM_WORLD);
00965 
00966   <span class="keywordflow">if</span>(rank) {
00967     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
00968     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
00969       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
00970         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
00971           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
00972             Mmat[cNum][eType][i][j] = tmpMat[ctr];
00973             ctr++;
00974           }
00975         }
00976       }
00977     }
00978   }
00979 
00980   <span class="keyword">delete</span> [] tmpMat;
00981 
00982   <span class="keywordflow">return</span> 1;
00983 }<span class="comment">//end of function</span>
00984 
<a name="l00985"></a><a class="code" href="handleType2Stencils_8C.html#a16">00985</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a16">createLmatType2</a>(<span class="keywordtype">double</span> ****&amp; Lmat) {
00986 
00987 <span class="preprocessor">#ifdef __USE_MG_INIT_TYPE3__</span>
00988 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a17">createLmatType2_Type3</a>(Lmat);
00989 <span class="preprocessor">#else</span>
00990 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_MG_INIT_TYPE2__</span>
00991 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a18">createLmatType2_Type2</a>(Lmat);
00992 <span class="preprocessor">#else</span>
00993 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a19">createLmatType2_Type1</a>(Lmat);
00994 <span class="preprocessor">#endif</span>
00995 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00996 <span class="preprocessor"></span>
00997   <span class="keywordflow">return</span> 1;
00998 }
00999 
<a name="l01000"></a><a class="code" href="handleType2Stencils_8C.html#a17">01000</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a17">createLmatType2_Type3</a>(<span class="keywordtype">double</span> ****&amp; Lmat) {
01001   FILE* infile;
01002   <span class="keywordtype">int</span> rank;
01003   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
01004 
01005   <span class="keywordtype">char</span> fname[250];
01006   sprintf(fname,<span class="stringliteral">"LapType2Stencils_%d.inp"</span>, rank);
01007   infile = fopen(fname,<span class="stringliteral">"r"</span>);
01008   <span class="keywordflow">if</span>(!infile) {
01009     std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
01010     assert(<span class="keyword">false</span>);
01011   }
01012 
01013   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
01014   <span class="keyword">typedef</span> doublePtr* double2Ptr;
01015   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
01016 
01017   Lmat = <span class="keyword">new</span> double3Ptr[8];
01018   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01019     Lmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
01020     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01021       Lmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
01022       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01023         Lmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
01024         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01025           fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Lmat[cNum][eType][i][j]));
01026         }
01027       }
01028     }
01029   }
01030 
01031   fclose(infile);
01032 
01033   <span class="keywordflow">return</span> 1;
01034 }
01035 
<a name="l01036"></a><a class="code" href="handleType2Stencils_8C.html#a18">01036</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a18">createLmatType2_Type2</a>(<span class="keywordtype">double</span> ****&amp; Lmat) {
01037   FILE* infile;
01038   MPI_Comm comm = MPI_COMM_WORLD;
01039 
01040   <span class="keywordtype">int</span> rank, npes;
01041   MPI_Comm_rank(comm, &amp;rank);
01042   MPI_Comm_size(comm, &amp;npes);
01043 
01044   <span class="keyword">const</span> <span class="keywordtype">int</span> THOUSAND = 1000;
01045   <span class="keywordtype">int</span> numGroups = (npes/THOUSAND);
01046   <span class="keywordflow">if</span>( (numGroups*THOUSAND) &lt; npes) {
01047     numGroups++;
01048   }
01049 
01050   MPI_Comm newComm;
01051 
01052   <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npes];
01053   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numGroups; i++) {
01054     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; (j &lt; (i*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
01055       isEmptyList[j] = <span class="keyword">true</span>;
01056     }
01057     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = (i*THOUSAND); (j &lt; ((i+1)*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
01058       isEmptyList[j] = <span class="keyword">false</span>;
01059     }
01060     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = ((i + 1)*THOUSAND); j &lt; npes; j++) {
01061       isEmptyList[j] = <span class="keyword">true</span>;
01062     }
01063     MPI_Comm tmpComm;
01064     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(isEmptyList, &amp;tmpComm, comm);
01065     <span class="keywordflow">if</span>(!(isEmptyList[rank])) {
01066       newComm = tmpComm;
01067     }
01068   }<span class="comment">//end for i</span>
01069   <span class="keyword">delete</span> [] isEmptyList;
01070 
01071 
01072   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01073     <span class="keywordtype">char</span> fname[250];
01074     sprintf(fname,<span class="stringliteral">"LapType2Stencils_%d.inp"</span>, (rank/THOUSAND));
01075     infile = fopen(fname,<span class="stringliteral">"r"</span>);
01076     <span class="keywordflow">if</span>(!infile) {
01077       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
01078       assert(<span class="keyword">false</span>);
01079     }
01080   }
01081 
01082   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
01083   <span class="keyword">typedef</span> doublePtr* double2Ptr;
01084   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
01085 
01086   Lmat = <span class="keyword">new</span> double3Ptr[8];
01087   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01088     Lmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
01089     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01090       Lmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
01091       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01092         Lmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
01093         <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01094           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01095             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Lmat[cNum][eType][i][j]));
01096           }
01097         }
01098       }
01099     }
01100   }
01101 
01102   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01103     fclose(infile);
01104   }
01105 
01106   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[9216];
01107 
01108   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01109     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01110     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01111       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01112         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01113           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01114             tmpMat[ctr] = Lmat[cNum][eType][i][j];
01115             ctr++;
01116           }
01117         }
01118       }
01119     }
01120   }
01121 
01122   par::Mpi_Bcast&lt;double&gt;(tmpMat,9216, 0, newComm);
01123 
01124   <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
01125     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01126     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01127       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01128         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01129           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01130             Lmat[cNum][eType][i][j] = tmpMat[ctr];
01131             ctr++;
01132           }
01133         }
01134       }
01135     }
01136   }
01137 
01138   <span class="keyword">delete</span> [] tmpMat;
01139 
01140   <span class="keywordflow">return</span> 1;
01141 }<span class="comment">//end of function</span>
01142 
<a name="l01143"></a><a class="code" href="handleType2Stencils_8C.html#a19">01143</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a19">createLmatType2_Type1</a>(<span class="keywordtype">double</span> ****&amp; Lmat) {
01144   FILE* infile;
01145   <span class="keywordtype">int</span> rank;
01146   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
01147 
01148   <span class="keywordflow">if</span>(!rank) {
01149     <span class="keywordtype">char</span> fname[250];
01150     sprintf(fname,<span class="stringliteral">"LapType2Stencils.inp"</span>);
01151     infile = fopen(fname,<span class="stringliteral">"r"</span>);
01152     <span class="keywordflow">if</span>(!infile) {
01153       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
01154       assert(<span class="keyword">false</span>);
01155     }
01156   }
01157 
01158   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
01159   <span class="keyword">typedef</span> doublePtr* double2Ptr;
01160   <span class="keyword">typedef</span> double2Ptr* double3Ptr;
01161 
01162   Lmat = <span class="keyword">new</span> double3Ptr[8];
01163   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01164     Lmat[cNum] = <span class="keyword">new</span> double2Ptr[18];
01165     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01166       Lmat[cNum][eType] = <span class="keyword">new</span> doublePtr[8];
01167       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01168         Lmat[cNum][eType][i] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
01169         <span class="keywordflow">if</span>(!rank) {
01170           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01171             fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Lmat[cNum][eType][i][j]));
01172           }
01173         }
01174       }
01175     }
01176   }
01177 
01178   <span class="keywordflow">if</span>(!rank) {
01179     fclose(infile);
01180   }
01181 
01182   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[9216];
01183 
01184   <span class="keywordflow">if</span>(!rank) {
01185     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01186     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01187       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01188         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01189           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01190             tmpMat[ctr] = Lmat[cNum][eType][i][j];
01191             ctr++;
01192           }
01193         }
01194       }
01195     }
01196   }
01197 
01198   par::Mpi_Bcast&lt;double&gt;(tmpMat,9216, 0, MPI_COMM_WORLD);
01199 
01200   <span class="keywordflow">if</span>(rank) {
01201     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01202     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01203       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01204         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01205           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01206             Lmat[cNum][eType][i][j] = tmpMat[ctr];
01207             ctr++;
01208           }
01209         }
01210       }
01211     }
01212   }
01213 
01214   <span class="keyword">delete</span> [] tmpMat;
01215 
01216   <span class="keywordflow">return</span> 1;
01217 }<span class="comment">//end of function</span>
01218 
<a name="l01219"></a><a class="code" href="handleType2Stencils_8C.html#a20">01219</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a20">createRHSType2</a>(<span class="keywordtype">double</span> ***&amp; Lmat ) {
01220 
01221 <span class="preprocessor">#ifdef __USE_MG_INIT_TYPE3__</span>
01222 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a21">createRHSType2_Type3</a>(Lmat);
01223 <span class="preprocessor">#else</span>
01224 <span class="preprocessor"></span><span class="preprocessor">#ifdef __USE_MG_INIT_TYPE2__</span>
01225 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a22">createRHSType2_Type2</a>(Lmat);
01226 <span class="preprocessor">#else</span>
01227 <span class="preprocessor"></span>  <a class="code" href="handleType2Stencils_8C.html#a23">createRHSType2_Type1</a>(Lmat);
01228 <span class="preprocessor">#endif</span>
01229 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
01230 <span class="preprocessor"></span>
01231   <span class="keywordflow">return</span> 1;
01232 }
01233 
<a name="l01234"></a><a class="code" href="handleType2Stencils_8C.html#a21">01234</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a21">createRHSType2_Type3</a> (<span class="keywordtype">double</span> ***&amp; Lmat ) {
01235   FILE* infile;
01236   FILE* debugfile;
01237 
01238   <span class="keywordtype">int</span> rank;
01239   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
01240 
01241   <span class="keywordtype">char</span> fname[250];
01242   sprintf(fname,<span class="stringliteral">"RHSType2Stencils_%d.inp"</span>, rank);
01243   infile = fopen(fname,<span class="stringliteral">"r"</span>);
01244   <span class="keywordflow">if</span>(!infile) {
01245     std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
01246     assert(<span class="keyword">false</span>);
01247   }
01248 
01249   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
01250   <span class="keyword">typedef</span> doublePtr* double2Ptr;
01251 
01252   Lmat = <span class="keyword">new</span> double2Ptr[8];
01253   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01254     Lmat[cNum] = <span class="keyword">new</span> doublePtr[18];
01255     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01256       Lmat[cNum][eType] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
01257       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01258         fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Lmat[cNum][eType][i]));
01259       }
01260     }
01261   }
01262 
01263   fclose(infile);
01264 
01265   <span class="keywordflow">return</span> 1;
01266 }
01267 
<a name="l01268"></a><a class="code" href="handleType2Stencils_8C.html#a22">01268</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a22">createRHSType2_Type2</a>(<span class="keywordtype">double</span> ***&amp; Lmat ) {
01269   FILE* infile;
01270   FILE* debugfile;
01271   MPI_Comm comm = MPI_COMM_WORLD;
01272 
01273   <span class="keywordtype">int</span> rank, npes;
01274   MPI_Comm_rank(comm, &amp;rank);
01275   MPI_Comm_size(comm, &amp;npes);
01276 
01277   <span class="keyword">const</span> <span class="keywordtype">int</span> THOUSAND = 1000;
01278   <span class="keywordtype">int</span> numGroups = (npes/THOUSAND);
01279   <span class="keywordflow">if</span>( (numGroups*THOUSAND) &lt; npes) {
01280     numGroups++;
01281   }
01282 
01283   MPI_Comm newComm;
01284 
01285   <span class="keywordtype">bool</span>* isEmptyList = <span class="keyword">new</span> <span class="keywordtype">bool</span>[npes];
01286   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numGroups; i++) {
01287     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; (j &lt; (i*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
01288       isEmptyList[j] = <span class="keyword">true</span>;
01289     }
01290     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = (i*THOUSAND); (j &lt; ((i+1)*THOUSAND)) &amp;&amp; (j &lt; npes); j++) {
01291       isEmptyList[j] = <span class="keyword">false</span>;
01292     }
01293     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = ((i + 1)*THOUSAND); j &lt; npes; j++) {
01294       isEmptyList[j] = <span class="keyword">true</span>;
01295     }
01296     MPI_Comm tmpComm;
01297     <a class="code" href="namespacepar.html#a2">par::splitComm2way</a>(isEmptyList, &amp;tmpComm, comm);
01298     <span class="keywordflow">if</span>(!(isEmptyList[rank])) {
01299       newComm = tmpComm;
01300     }
01301   }<span class="comment">//end for i</span>
01302   <span class="keyword">delete</span> [] isEmptyList;
01303 
01304 
01305   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01306     <span class="keywordtype">char</span> fname[250];
01307     sprintf(fname,<span class="stringliteral">"RHSType2Stencils_%d.inp"</span>, (rank/THOUSAND));
01308     infile = fopen(fname,<span class="stringliteral">"r"</span>);
01309     <span class="keywordflow">if</span>(!infile) {
01310       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
01311       assert(<span class="keyword">false</span>);
01312     }
01313   }
01314 
01315   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
01316   <span class="keyword">typedef</span> doublePtr* double2Ptr;
01317 
01318   Lmat = <span class="keyword">new</span> double2Ptr[8];
01319   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01320     Lmat[cNum] = <span class="keyword">new</span> doublePtr[18];
01321     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01322       Lmat[cNum][eType] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
01323       <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01324         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01325           fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Lmat[cNum][eType][i]));
01326         }
01327       }
01328     }
01329   }
01330 
01331   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01332     fclose(infile);
01333   }
01334 
01335   <span class="keyword">const</span> <span class="keywordtype">int</span> data_size = 8*18*8;
01336   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[data_size];
01337 
01338   <span class="keywordflow">if</span>((rank % THOUSAND) == 0) {
01339     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01340     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01341       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01342         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01343           tmpMat[ctr] = Lmat[cNum][eType][i];
01344           ctr++;
01345         }
01346       }
01347     }
01348   }
01349 
01350   par::Mpi_Bcast&lt;double&gt;(tmpMat,data_size, 0, newComm);
01351 
01352   <span class="keywordflow">if</span>((rank % THOUSAND) != 0) {
01353     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01354     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01355       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01356         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01357           Lmat[cNum][eType][i] = tmpMat[ctr];
01358           ctr++;
01359         }
01360       }
01361     }
01362   }
01363 
01364   <span class="keyword">delete</span> [] tmpMat;
01365 
01366   <span class="keywordflow">return</span> 1;
01367 }
01368 
<a name="l01369"></a><a class="code" href="handleType2Stencils_8C.html#a23">01369</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a23">createRHSType2_Type1</a> (<span class="keywordtype">double</span> ***&amp; Lmat ) {
01370   FILE* infile;
01371   FILE* debugfile;
01372 
01373   <span class="keywordtype">int</span> rank;
01374   MPI_Comm_rank(MPI_COMM_WORLD, &amp;rank);
01375 
01376   <span class="keywordflow">if</span>(!rank) {
01377     <span class="keywordtype">char</span> fname[250];
01378     sprintf(fname,<span class="stringliteral">"RHSType2Stencils.inp"</span>);
01379     infile = fopen(fname,<span class="stringliteral">"r"</span>);
01380     <span class="keywordflow">if</span>(!infile) {
01381       std::cout&lt;&lt;<span class="stringliteral">"The file "</span>&lt;&lt;fname&lt;&lt;<span class="stringliteral">" is not good for reading."</span>&lt;&lt;std::endl;
01382       assert(<span class="keyword">false</span>);
01383     }
01384   }
01385 
01386   <span class="keyword">typedef</span> <span class="keywordtype">double</span>* doublePtr;
01387   <span class="keyword">typedef</span> doublePtr* double2Ptr;
01388 
01389   Lmat = <span class="keyword">new</span> double2Ptr[8];
01390   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01391     Lmat[cNum] = <span class="keyword">new</span> doublePtr[18];
01392     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01393       Lmat[cNum][eType] = <span class="keyword">new</span> <span class="keywordtype">double</span>[8];
01394       <span class="keywordflow">if</span>(!rank) {
01395         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01396           fscanf(infile,<span class="stringliteral">"%lf"</span>,&amp;(Lmat[cNum][eType][i]));
01397         }
01398       }
01399     }
01400   }
01401 
01402   <span class="keywordflow">if</span>(!rank) {
01403     fclose(infile);
01404   }
01405 
01406   <span class="keyword">const</span> <span class="keywordtype">int</span> data_size = 8*18*8;
01407   <span class="keywordtype">double</span> * tmpMat = <span class="keyword">new</span> <span class="keywordtype">double</span>[data_size];
01408 
01409   <span class="keywordflow">if</span>(!rank) {
01410     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01411     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01412       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01413         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01414           tmpMat[ctr] = Lmat[cNum][eType][i];
01415           ctr++;
01416         }
01417       }
01418     }
01419   }
01420 
01421   par::Mpi_Bcast&lt;double&gt;(tmpMat,data_size, 0, MPI_COMM_WORLD);
01422 
01423   <span class="keywordflow">if</span>(rank) {
01424     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ctr = 0;
01425     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01426       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01427         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01428           Lmat[cNum][eType][i] = tmpMat[ctr];
01429           ctr++;
01430         }
01431       }
01432     }
01433   }
01434 
01435   <span class="keyword">delete</span> [] tmpMat;
01436 
01437   <span class="keywordflow">return</span> 1;
01438 }
01439 
<a name="l01440"></a><a class="code" href="handleType2Stencils_8C.html#a24">01440</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a24">destroyRHSType2</a> (<span class="keywordtype">double</span> ***&amp; Lmat )
01441 {  
01442   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01443     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01444       <span class="keyword">delete</span> [] (Lmat[cNum][eType]);
01445       Lmat[cNum][eType] = NULL;
01446     }
01447 
01448     <span class="keyword">delete</span> [] (Lmat[cNum]);
01449     Lmat[cNum] = NULL;
01450   }
01451 
01452   <span class="keyword">delete</span> [] Lmat;  
01453   Lmat = NULL;
01454 
01455   <span class="keywordflow">return</span> 1;
01456 }
01457 
<a name="l01458"></a><a class="code" href="handleType2Stencils_8C.html#a25">01458</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a25">destroyShapeFnCoeffs</a>(<span class="keywordtype">double</span> ****&amp; Mmat ) {
01459   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01460     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01461       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01462         <span class="keyword">delete</span> [] (Mmat[cNum][eType][i]);
01463         Mmat[cNum][eType][i] = NULL;
01464       }
01465       <span class="keyword">delete</span> [] (Mmat[cNum][eType]);
01466       Mmat[cNum][eType] = NULL;
01467     }
01468     <span class="keyword">delete</span> [] (Mmat[cNum]);
01469     Mmat[cNum] = NULL;
01470   }
01471 
01472   <span class="keyword">delete</span> [] Mmat;
01473   Mmat = NULL;
01474 
01475   <span class="keywordflow">return</span> 1;
01476 }<span class="comment">//end of function</span>
01477 
<a name="l01478"></a><a class="code" href="handleType2Stencils_8C.html#a26">01478</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a26">destroyLmatType2</a>(<span class="keywordtype">double</span> ****&amp; Lmat ) {
01479   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01480     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01481       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01482         <span class="keyword">delete</span> [] (Lmat[cNum][eType][i]);
01483         Lmat[cNum][eType][i] = NULL;
01484       }
01485       <span class="keyword">delete</span> [] (Lmat[cNum][eType]);
01486       Lmat[cNum][eType] = NULL;
01487     }
01488     <span class="keyword">delete</span> [] (Lmat[cNum]);
01489     Lmat[cNum] = NULL;
01490   }
01491 
01492   <span class="keyword">delete</span> [] Lmat;
01493   Lmat = NULL;
01494 
01495   <span class="keywordflow">return</span> 1;
01496 }<span class="comment">//end of function</span>
01497 
<a name="l01498"></a><a class="code" href="handleType2Stencils_8C.html#a27">01498</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a27">destroyMmatType2</a>(<span class="keywordtype">double</span> ****&amp; Mmat ) {
01499   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01500     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01501       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 8; i++) {
01502         <span class="keyword">delete</span> [] (Mmat[cNum][eType][i]);
01503         Mmat[cNum][eType][i] = NULL;
01504       }
01505       <span class="keyword">delete</span> [] (Mmat[cNum][eType]);
01506       Mmat[cNum][eType] = NULL;
01507     }
01508     <span class="keyword">delete</span> [] (Mmat[cNum]);
01509     Mmat[cNum] = NULL;
01510   }
01511 
01512   <span class="keyword">delete</span> [] Mmat;
01513   Mmat = NULL;
01514 
01515   <span class="keywordflow">return</span> 1;
01516 }<span class="comment">//end of function</span>
01517 
<a name="l01518"></a><a class="code" href="handleType2Stencils_8C.html#a28">01518</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a28">destroyGDmatType2</a>(<span class="keywordtype">double</span> ****&amp; GDmat) {
01519   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01520     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01521       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; 24; i++) {
01522         <span class="keyword">delete</span> [] (GDmat[cNum][eType][i]);
01523         GDmat[cNum][eType][i] = NULL;
01524       }
01525       <span class="keyword">delete</span> [] (GDmat[cNum][eType]);
01526       GDmat[cNum][eType] = NULL;
01527     }
01528     <span class="keyword">delete</span> [] (GDmat[cNum]);
01529     GDmat[cNum] = NULL;
01530   }
01531 
01532   <span class="keyword">delete</span> [] GDmat;
01533   GDmat = NULL;
01534 
01535   <span class="keywordflow">return</span> 1;
01536 }<span class="comment">//end fn.</span>
01537 
<a name="l01538"></a><a class="code" href="handleType2Stencils_8C.html#a29">01538</a> <span class="keywordtype">int</span> <a class="code" href="handleType2Stencils_8C.html#a29">destroyShFnMat</a>(<span class="keywordtype">double</span>******&amp; shFnMat) {
01539   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cNum = 0; cNum &lt; 8; cNum++) {
01540     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> eType = 0; eType &lt; 18; eType++) {
01541       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) {
01542         <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; 3; m++) {
01543           <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; 3; n++) {
01544             <span class="keyword">delete</span> [] (shFnMat[cNum][eType][j][m][n]);
01545             shFnMat[cNum][eType][j][m][n] = NULL;
01546           }
01547           <span class="keyword">delete</span> [] (shFnMat[cNum][eType][j][m]);
01548           shFnMat[cNum][eType][j][m] = NULL;
01549         }
01550         <span class="keyword">delete</span> [] (shFnMat[cNum][eType][j]);
01551         shFnMat[cNum][eType][j] = NULL;
01552       }
01553       <span class="keyword">delete</span> [] (shFnMat[cNum][eType]);
01554       shFnMat[cNum][eType] = NULL;
01555     }
01556     <span class="keyword">delete</span> [] (shFnMat[cNum]);
01557     shFnMat[cNum] = NULL;
01558   }
01559 
01560   <span class="keyword">delete</span> [] shFnMat;
01561   shFnMat = NULL;
01562 
01563   <span class="keywordflow">return</span> 1;
01564 }<span class="comment">//end fn.</span>
01565 
01566 
01567 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:23 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
