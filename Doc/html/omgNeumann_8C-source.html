<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/examples/omgNeumann.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">examples</a></div>
<h1>omgNeumann.C</h1><a href="omgNeumann_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00005 <span class="preprocessor">#include &lt;mpi.h&gt;</span>
00006 <span class="preprocessor">#include &lt;cstdio&gt;</span>
00007 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00008 <span class="preprocessor">#include "<a class="code" href="omg_8h.html">omg.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="Point_8h.html">Point.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="octUtils_8h.html">octUtils.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00013 <span class="preprocessor">#include "<a class="code" href="handleStencils_8h.html">handleStencils.h</a>"</span>
00014 <span class="preprocessor">#include &lt;cstdlib&gt;</span>
00015 <span class="preprocessor">#include "<a class="code" href="sys_8h.html">sys.h</a>"</span>
00016 <span class="preprocessor">#include &lt;sstream&gt;</span>
00017 <span class="preprocessor">#include "<a class="code" href="omgNeumann_8h.html">omgNeumann.h</a>"</span>
00018 <span class="preprocessor">#include "<a class="code" href="dendro_8h.html">dendro.h</a>"</span>
00019 
00020 <span class="preprocessor">#ifdef PETSC_USE_LOG</span>
00021 <span class="preprocessor"></span><span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2MultEvent;
00022 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2DiagEvent;
00023 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2FinestMultEvent;
00024 <span class="keyword">extern</span> <span class="keywordtype">int</span> Jac2FinestDiagEvent;
00025 <span class="preprocessor">#endif</span>
00026 <span class="preprocessor"></span>
<a name="l00027"></a><a class="code" href="omgNeumann_8C.html#a8">00027</a> <span class="keyword">static</span> <span class="keywordtype">double</span>**** LaplacianType2Stencil; 
<a name="l00028"></a><a class="code" href="omgNeumann_8C.html#a9">00028</a> <span class="keyword">static</span> <span class="keywordtype">double</span>**** MassType2Stencil; 
<a name="l00029"></a><a class="code" href="omgNeumann_8C.html#a10">00029</a> <span class="keyword">static</span> <span class="keywordtype">double</span>*** RHSType2Stencil; 
<a name="l00030"></a><a class="code" href="omgNeumann_8C.html#a11">00030</a> <span class="keyword">static</span> std::vector&lt;double&gt; force_values; <span class="comment">// value of RHS at centers of "ALL" octants on this process;  global since ComputeRHS needs it</span>
00031 
00032 <span class="keyword">struct </span><a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> {
<a name="l00033"></a><a class="code" href="structJac2MFreeData.html#o3">00033</a>   std::vector&lt;double&gt;* matProp;
<a name="l00034"></a><a class="code" href="structJac2MFreeData.html#o1">00034</a>   <span class="keywordtype">bool</span> isFinestLevel;
<a name="l00035"></a><a class="code" href="structJac2MFreeData.html#o2">00035</a>   Mat Jmat_private;
<a name="l00036"></a><a class="code" href="structJac2MFreeData.html#o0">00036</a>   Vec inTmp;
<a name="l00037"></a><a class="code" href="structJac2MFreeData.html#o5">00037</a>   Vec outTmp;
00038 };
00039 
<a name="l00040"></a><a class="code" href="omgNeumann_8C.html#a0">00040</a> <span class="preprocessor">#define CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK {\</span>
00041 <span class="preprocessor">  if( damg_i-&gt;da_aux == NULL ) {\</span>
00042 <span class="preprocessor">    daf = da;\</span>
00043 <span class="preprocessor">    fMatPropVec = matPropVecPtr;\</span>
00044 <span class="preprocessor">    changedPartition  = false;\</span>
00045 <span class="preprocessor">  }else {\</span>
00046 <span class="preprocessor">    daf = damg_i-&gt;da_aux;\</span>
00047 <span class="preprocessor">    </span><span class="comment">/*Need to Scatter Values*/</span>\
00048     fMatPropVec = new std::vector&lt;double&gt;;\
00049     changedPartition  = true;\
00050     <span class="comment">/*elemental - non-ghosted*/</span>\
00051     std::vector&lt;double&gt; tmpVec1;\
00052     da-&gt;createVector&lt;double&gt;(tmpVec1,true,false,2);\
00053     double *vec1Arr = NULL;\
00054     <span class="comment">/*Elemental,non-Ghosted,Write,2 Dof.*/</span>\
00055     da-&gt;vecGetBuffer&lt;double&gt;(tmpVec1,vec1Arr,true,false,false,2);\
00056     matPropArr = NULL;\
00057     <span class="comment">/*Elemental,Ghosted,Read-only,2 Dof.*/</span>\
00058     da-&gt;vecGetBuffer&lt;double&gt;((*matPropVecPtr), matPropArr, true, true, true, 2);\
00059     if(da-&gt;iAmActive()) {\
00060       for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;(); da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;(); da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\
00061         unsigned int idx = da-&gt;curr();\
00062         vec1Arr[2*idx] = matPropArr[2*idx];\
00063         vec1Arr[2*idx+1] = matPropArr[2*idx+1];\
00064       }\
00065     }\
00066     da-&gt;vecRestoreBuffer&lt;double&gt;((*matPropVecPtr), matPropArr, true, true, true, 2);\
00067     da-&gt;vecRestoreBuffer&lt;double&gt;(tmpVec1,vec1Arr,true,false,false,2);\
00068     par::scatterValues&lt;double&gt;(tmpVec1, (*fMatPropVec), (2*(daf-&gt;getElementSize())), da-&gt;getComm());\
00069     tmpVec1.clear();\
00070   }\
00071 }
00072 
<a name="l00073"></a><a class="code" href="omgNeumann_8C.html#a1">00073</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_FINE_TO_COARSE_ELEM_BLOCK {\</span>
00074 <span class="preprocessor">  </span><span class="comment">/*The fine loop is always Writable, but the coarse loop*/</span>\
00075   <span class="comment">/*could be Independent or W_Dependent. Hence the fine counter must*/</span>\
00076   <span class="comment">/*be incremented properly to align with the coarse.*/</span>\
00077   unsigned int idxC= da-&gt;curr();\
00078   Point Cpt = da-&gt;getCurrentOffset();\
00079   assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00080   while(daf-&gt;getCurrentOffset() != Cpt) {\
00081     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00082     assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00083   }\
00084   if(daf-&gt;getLevel(daf-&gt;curr()) == da-&gt;getLevel(idxC)) {\
00085     <span class="comment">/*The coarse and fine elements are the same,*/</span>\
00086     assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00087     unsigned int idxF = daf-&gt;curr();\
00088     matPropArr[2*idxC] = fMatArr[2*idxF];\
00089     matPropArr[2*idxC+1] = fMatArr[2*idxF+1];\
00090     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00091   }else {\
00092     double cLapVal = 0.0;\
00093     double cMassVal = 0.0;\
00094     for(unsigned char cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
00095       <span class="comment">/*The coarse and fine elements are NOT the same. */</span>\
00096       <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
00097       <span class="comment">/*These are the underlying fine elements.*/</span>\
00098       assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00099       unsigned int idxF = daf-&gt;curr();\
00100       cLapVal += fMatArr[2*idxF];\
00101       cMassVal += fMatArr[2*idxF+1];\
00102       daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00103     }\
00104     matPropArr[2*idxC] = (cLapVal/8.0);\
00105     matPropArr[2*idxC+1] = (cMassVal/8.0);\
00106   }\
00107   if(matPropArr[2*idxC] &gt; maxCoeff) {\
00108     maxCoeff = matPropArr[2*idxC];\
00109   }\
00110   if(matPropArr[2*idxC] &lt; minCoeff) {\
00111     minCoeff = matPropArr[2*idxC];\
00112   }\
00113 }
00114 
<a name="l00115"></a><a class="code" href="omgNeumann_8C.html#a2">00115</a> <span class="preprocessor">#define FINE_TO_COARSE_BLOCK {\</span>
00116 <span class="preprocessor">  damg_i = damg[i];\</span>
00117 <span class="preprocessor">  damg_i-&gt;user = ctx;\</span>
00118 <span class="preprocessor">  da = damg_i-&gt;da;\</span>
00119 <span class="preprocessor">  assert(da-&gt;iAmActive() == daf-&gt;iAmActive());\</span>
00120 <span class="preprocessor">  da-&gt;createVector&lt;double&gt;((*matPropVecPtr), true, true, 2);\</span>
00121 <span class="preprocessor">  for(unsigned int j = 0; j &lt; matPropVecPtr-&gt;size(); j++) {\</span>
00122 <span class="preprocessor">    (*matPropVecPtr)[j] = 0.0;\</span>
00123 <span class="preprocessor">  }\</span>
00124 <span class="preprocessor">  comm = da-&gt;getCommActive();\</span>
00125 <span class="preprocessor">  MPI_Comm_rank(comm,&amp;rank);\</span>
00126 <span class="preprocessor">  </span><span class="comment">/*Elemental,Ghosted,Write,2 Dof.*/</span>\
00127   matPropArr = NULL;\
00128   da-&gt;vecGetBuffer&lt;double&gt;((*matPropVecPtr), matPropArr,\
00129       true, true, false, 2);\
00130   double *fMatArr = NULL;\
00131   if(changedPartition) {\
00132     <span class="comment">/*Elemental, non-Ghosted, Read-only, 2 Dof.*/</span>\
00133     daf-&gt;vecGetBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00134         true, false, true, 2);\
00135   }else {\
00136     <span class="comment">/*Elemental, Ghosted, Read-only, 2 Dof.*/</span>\
00137     daf-&gt;vecGetBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00138         true, true, true, 2);\
00139   }\
00140   if(da-&gt;iAmActive()) {\
00141     double maxCoeff = 0.0;\
00142     double minCoeff = 1.0e+8;\
00143     double globalMaxCoeff;\
00144     double globalMinCoeff;\
00145     <span class="comment">/*Loop through the coarse and fine simultaneously*/</span>\
00146     <span class="comment">/*Note: If Coarse is Independent, then the*/</span>\
00147     <span class="comment">/*corresponding Fine is also independent.*/</span>\
00148     <span class="comment">/*Hence, overlapping comm with comp is possible.*/</span>\
00149     <span class="comment">/*First, we loop though the dependent elements.*/</span>\
00150     <span class="comment">/*Then we begin the communication and simulatenously*/</span>\
00151     <span class="comment">/*loop over the independent elements.*/</span>\
00152     for(da-&gt;init&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(),\
00153         daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00154         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();\
00155         da-&gt;next&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {\
00156       ASSIGN_MAT_PROP_FINE_TO_COARSE_ELEM_BLOCK \
00157     } <span class="comment">/*end dependent loop*/</span>\
00158     da-&gt;ReadFromGhostElemsBegin&lt;double&gt;(matPropArr,2);\
00159     for(da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;(),\
00160         daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00161         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00162         da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {\
00163       ASSIGN_MAT_PROP_FINE_TO_COARSE_ELEM_BLOCK \
00164     } <span class="comment">/*end Independent loop */</span>\
00165     da-&gt;ReadFromGhostElemsEnd&lt;double&gt;(matPropArr);\
00166     par::Mpi_Reduce&lt;double&gt;(&amp;maxCoeff, &amp;globalMaxCoeff, 1, MPI_MAX, 0, comm);\
00167     par::Mpi_Reduce&lt;double&gt;(&amp;minCoeff, &amp;globalMinCoeff, 1, MPI_MIN, 0, comm);\
00168     if(!rank) {\
00169       std::cout&lt;&lt;"Level: "&lt;&lt;i&lt;&lt;" Max Lap. Coeff: "\
00170       &lt;&lt;globalMaxCoeff&lt;&lt;" Min Lap. Coeff: "\
00171       &lt;&lt;globalMinCoeff&lt;&lt;std::endl;\
00172     }\
00173     MPI_Barrier(comm);\
00174   } <span class="comment">/*end check if active*/</span>\
00175   da-&gt;vecRestoreBuffer&lt;double&gt;((*matPropVecPtr),\
00176       matPropArr, true, true, false, 2);\
00177   if(changedPartition) {\
00178     <span class="comment">/*Elemental, non-Ghosted, Read-only, 2 Dof.*/</span>\
00179     daf-&gt;vecRestoreBuffer&lt;double&gt;((*fMatPropVec),\
00180         fMatArr, true, false, true, 2);\
00181   }else {\
00182     <span class="comment">/*Elemental, Ghosted, Read-only, 2 Dof.*/</span>\
00183     daf-&gt;vecRestoreBuffer&lt;double&gt;((*fMatPropVec),\
00184         fMatArr, true, true, true, 2);\
00185   }\
00186 }
00187 
<a name="l00188"></a><a class="code" href="omgNeumann_8C.html#a12">00188</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8C.html#a12">SetPDECoefFromPts</a>(
00189     <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg,
00190     <span class="keyword">const</span> std::vector&lt;double&gt;&amp; centers,
00191     <span class="keywordtype">void</span> (*CalcCoef)(<span class="keyword">const</span> std::vector&lt;double&gt; &amp; pts, std::vector&lt;double&gt; &amp; values)
00192     )
00193 {
00194   <span class="keywordtype">int</span> nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of mg levels</span>
00195   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg_i = damg[nlevels-1];
00196 
00197   <span class="comment">//Set Mat Props Finest to Coarsest...</span>
00198   <span class="keywordtype">void</span> * ctx;
00199 
00200   <span class="comment">// Set for the finest level first</span>
00201   ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;
00202 
00203   std::vector&lt;double&gt; * matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00204 
00205   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00206   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">true</span>;
00207   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00208   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00209   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00210 
00211   <span class="keywordtype">double</span> *matPropArr = NULL;
00212   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da;
00213   <span class="keywordtype">int</span> rank;
00214   MPI_Comm comm;
00215 
00216   damg_i-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a> = ctx;
00217   da = damg_i-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00218   comm = da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
00219   MPI_Comm_rank(comm,&amp;rank);
00220   <span class="comment">/*Elem,Ghosted, 2-dof vector.*/</span>
00221   <span class="comment">/*Note: I am creating a ghosted vector only*/</span>
00222   <span class="comment">/*because the mat-vec will need it.*/</span>
00223   <span class="comment">/*So this way, I can avoid mallocs inside the mat-vec.*/</span>
00224   da-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>&lt;<span class="keywordtype">double</span>&gt;((*matPropVecPtr), <span class="keyword">true</span>, <span class="keyword">true</span>, 2);
00225   <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; matPropVecPtr-&gt;size(); i++) {
00226     (*matPropVecPtr)[i] = 0.0;
00227   }
00228   <span class="comment">/*Elemental,Ghosted,Write,2 Dof.*/</span>
00229   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<span class="keywordtype">double</span>&gt;((*matPropVecPtr), matPropArr,
00230       <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, 2);
00231   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00232     <span class="keywordtype">double</span> maxCoeff = 0.0;
00233     <span class="keywordtype">double</span> minCoeff = 1.0e+80;
00234     <span class="keywordtype">double</span> globalMaxCoeff;
00235     <span class="keywordtype">double</span> globalMinCoeff;
00236 
00237     <span class="comment">// call user-provided routine to calculate the coefficients</span>
00238     <span class="comment">// we can use here *matPropVectPtr since this vector is both elemental and ghosted</span>
00239     CalcCoef(centers, *matPropVecPtr);
00240 
00241     <span class="comment">// calculate min and max "alpha" for debugging</span>
00242     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;();
00243         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00244         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;()) {
00245       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00246 
00247       <span class="keywordflow">if</span>(matPropArr[2*idx] &gt; maxCoeff) 
00248         maxCoeff = matPropArr[2*idx];
00249 
00250       <span class="keywordflow">if</span>(matPropArr[2*idx] &lt; minCoeff) 
00251         minCoeff = matPropArr[2*idx];
00252     }
00253 
00254     par::Mpi_Reduce&lt;double&gt;(&amp;maxCoeff, &amp;globalMaxCoeff, 1, MPI_MAX, 0, comm);
00255     par::Mpi_Reduce&lt;double&gt;(&amp;minCoeff, &amp;globalMinCoeff, 1, MPI_MIN, 0, comm);
00256     <span class="keywordflow">if</span>(!rank) {
00257       std::cout&lt;&lt;<span class="stringliteral">"Level: "</span>&lt;&lt;(nlevels-(damg_i-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>))&lt;&lt;
00258         <span class="stringliteral">" Max Lap. Coeff: "</span>&lt;&lt;globalMaxCoeff&lt;&lt;
00259         <span class="stringliteral">" Min Lap. Coeff: "</span>&lt;&lt;globalMinCoeff&lt;&lt;std::endl;
00260     }
00261   } <span class="comment">/*end if active*/</span>
00262   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<span class="keywordtype">double</span>&gt;((*matPropVecPtr), matPropArr,
00263       <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, 2);
00264 
00265   <span class="comment">//The coarser levels...</span>
00266   <a class="code" href="classot_1_1DA.html">ot::DA</a>* daf;
00267   std::vector&lt;double&gt;* fMatPropVec = NULL;
00268   <span class="keywordtype">bool</span> changedPartition;
00269 
00270   <span class="keywordflow">if</span>(nlevels &gt; 1) {
00271     <a class="code" href="matProp_8C.html#a7">CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK</a> 
00272   }
00273 
00274   <span class="comment">//Coarser levels</span>
00275   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (nlevels-2); i &gt;= 0; i--) {
00276       ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;
00277 
00278     matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00279 
00280     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00281     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">false</span>;
00282     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00283     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00284     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00285 
00286     <a class="code" href="matProp_8C.html#a9">FINE_TO_COARSE_BLOCK</a>
00287 
00288       <span class="keywordflow">if</span>(changedPartition) {
00289         fMatPropVec-&gt;clear();
00290         <span class="keyword">delete</span> fMatPropVec;
00291       }
00292 
00293     <span class="keywordflow">if</span>(i) {     
00294       <a class="code" href="matProp_8C.html#a7">CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK</a> 
00295     }
00296   }<span class="comment">//end for i</span>
00297 }<span class="comment">//end fn.</span>
00298 
00299 
<a name="l00300"></a><a class="code" href="omgNeumann_8C.html#a13">00300</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8C.html#a13">DestroyUserContexts</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg) {
00301   
00302   <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
00303 
00304   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
00305     <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>* ctx = (static_cast&lt;Jac2MFreeData*&gt;(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00306     ctx-&gt;<a class="code" href="structJac2MFreeData.html#o4">matProp</a>-&gt;clear();
00307     <span class="keyword">delete</span> ctx-&gt;<a class="code" href="structJac2MFreeData.html#o4">matProp</a>;
00308     <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>) {
00309       MatDestroy(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>);
00310       ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a> = NULL;
00311     }
00312     <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>) {
00313       VecDestroy(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>);
00314       ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a> = NULL;
00315     }
00316     <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>) {
00317       VecDestroy(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>);
00318       ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a> = NULL;
00319     }
00320     <span class="keyword">delete</span> ctx;
00321   }
00322 }<span class="comment">//end fn.</span>
00323 
<a name="l00324"></a><a class="code" href="omgNeumann_8C.html#a14">00324</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a14">Jacobian2ShellMatMult</a>(Mat J, Vec in, Vec out) {
00325   PetscFunctionBegin;
00326 
00327   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00328 
00329   MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg));
00330 
00331   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>* ctx = static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user);
00332 
00333   <span class="keywordflow">if</span>(damg-&gt;da-&gt;iAmActive()) {      
00334     PetscScalar* inArray;
00335     PetscScalar* outArray;
00336 
00337     VecGetArray(in, &amp;inArray);
00338     VecGetArray(out, &amp;outArray);
00339 
00340     VecPlaceArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>, inArray);
00341     VecPlaceArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>, outArray);
00342 
00343     MatMult(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>, ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>);
00344 
00345     VecResetArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>);
00346     VecResetArray(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>);
00347 
00348     VecRestoreArray(in, &amp;inArray);
00349     VecRestoreArray(out, &amp;outArray);
00350   }
00351 
00352   PetscFunctionReturn(0);
00353 }
00354 
00355 
00356 
<a name="l00357"></a><a class="code" href="omgNeumann_8C.html#a15">00357</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8C.html#a15">getActiveStateAndActiveCommForKSP_Shell_Jac2or3</a>(Mat mat,
00358     <span class="keywordtype">bool</span> &amp; activeState, MPI_Comm &amp; activeComm) {
00359   PetscTruth isshell;
00360   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00361   assert(isshell);
00362   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00363   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;damg));
00364   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00365   activeState = da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>();
00366   activeComm = da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>();
00367 }
00368 
00369 
<a name="l00370"></a><a class="code" href="omgNeumann_8C.html#a16">00370</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8h.html#a1">getPrivateMatricesForKSP_Shell_Jac2</a>(Mat mat,
00371     Mat *AmatPrivate, Mat *PmatPrivate, MatStructure* pFlag) {
00372   PetscTruth isshell;
00373   PetscTypeCompare((PetscObject)mat, MATSHELL, &amp;isshell);
00374   assert(isshell);
00375   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00376   MatShellGetContext(mat, (<span class="keywordtype">void</span>**)(&amp;damg));
00377   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user));
00378   *AmatPrivate = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00379   *PmatPrivate = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00380   *pFlag = DIFFERENT_NONZERO_PATTERN;
00381 }
00382 
00383 
00384 
00385 
00386 
<a name="l00387"></a><a class="code" href="omgNeumann_8C.html#a17">00387</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a17">Jacobian2MatDestroy</a>(Mat J) {
00388   PetscFunctionBegin;
00389   <span class="comment">//Nothing to be done here. No new pointers were created during creation. </span>
00390   <span class="comment">//The pointer were created in setUSerContext. So they will be destroyed in</span>
00391   <span class="comment">//DestroyUserContexts.</span>
00392   PetscFunctionReturn(0);
00393 }
00394 
00395 
<a name="l00396"></a><a class="code" href="omgNeumann_8C.html#a3">00396</a> <span class="preprocessor">#define JAC_TYPE2_ELEM_DIAG_BLOCK {\</span>
00397 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00398 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00399 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00400 <span class="preprocessor">  double matP1 = matPropArr[2*idx];\</span>
00401 <span class="preprocessor">  double matP2 = matPropArr[2*idx+1];\</span>
00402 <span class="preprocessor">  double fac1 = matP1*h/2.0;\</span>
00403 <span class="preprocessor">  double fac2 = matP2*h*h*h/8.0;\</span>
00404 <span class="preprocessor">  unsigned int indices[8];\</span>
00405 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00406 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00407 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00408 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00409 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00410 <span class="preprocessor">  for(int k = 0; k &lt; 8; k++) {\</span>
00411 <span class="preprocessor">    diagArr[indices[k]] +=  ((fac1*(LaplacianType2Stencil[childNum][elemType][k][k])) +\</span>
00412 <span class="preprocessor">        (fac2*(MassType2Stencil[childNum][elemType][k][k])));\</span>
00413 <span class="preprocessor">  } </span><span class="comment">/*end k*/</span>\
00414 }
00415 
<a name="l00416"></a><a class="code" href="omgNeumann_8C.html#a4">00416</a> <span class="preprocessor">#define JAC_TYPE2_DIAG_BLOCK {\</span>
00417 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00418 <span class="preprocessor">  iC(VecZeroEntries(diag));\</span>
00419 <span class="preprocessor">  double *matPropArr;\</span>
00420 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghost,Read-only,1 dof*/</span>\
00421   da-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00422   PetscScalar *diagArr;\
00423   <span class="comment">/*Nodal,Non-Ghosted,Write,1 dof*/</span>\
00424   da-&gt;vecGetBuffer(diag,diagArr,false,false,false,1);\
00425   unsigned int maxD;\
00426   double hFac;\
00427   if(da-&gt;iAmActive()) {\
00428     maxD = (da-&gt;getMaxDepth());\
00429     hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\
00430     <span class="comment">/*Loop through All Elements including ghosted*/</span>\
00431     for(da-&gt;init&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::ALL&gt;(); da-&gt;next&lt;ot::DA_FLAGS::ALL&gt;()) {\
00432       JAC_TYPE2_ELEM_DIAG_BLOCK\
00433     } <span class="comment">/*end i*/</span>\
00434   } <span class="comment">/*end if active*/</span>\
00435   da-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00436   da-&gt;vecRestoreBuffer(diag,diagArr,false,false,false,1);\
00437   PetscLogFlops(44*(da-&gt;getGhostedElementSize()));\
00438 }
00439 
00440 
00441 
<a name="l00442"></a><a class="code" href="omgNeumann_8C.html#a18">00442</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a18">Jacobian2MatGetDiagonal</a>(Mat J, Vec diag) {
00443   PetscFunctionBegin;
00444 
00445   PetscLogEventBegin(Jac2DiagEvent,diag,0,0,0);
00446 
00447   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00448   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00449 
00450   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user));
00451 
00452   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00453     PetscLogEventBegin(Jac2FinestDiagEvent,diag,0,0,0);
00454   }
00455 
00456   <a class="code" href="omgJac_8C.html#a1">JAC_TYPE2_DIAG_BLOCK</a> 
00457 
00458     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00459       PetscLogEventEnd(Jac2FinestDiagEvent,diag,0,0,0);
00460     }
00461 
00462   PetscLogEventEnd(Jac2DiagEvent,diag,0,0,0);
00463 
00464   PetscFunctionReturn(0);
00465 }
00466 
00467 
<a name="l00468"></a><a class="code" href="omgNeumann_8C.html#a5">00468</a> <span class="preprocessor">#define JAC_TYPE2_ELEM_MULT_BLOCK {\</span>
00469 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00470 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00471 <span class="preprocessor">  double h = hFac*(1u &lt;&lt; (maxD - lev));\</span>
00472 <span class="preprocessor">  double matP1 = matPropArr[2*idx];\</span>
00473 <span class="preprocessor">  double matP2 = matPropArr[2*idx+1];\</span>
00474 <span class="preprocessor">  double fac1 = matP1*h/2.0;\</span>
00475 <span class="preprocessor">  double fac2 = matP2*h*h*h/8.0;\</span>
00476 <span class="preprocessor">  unsigned int indices[8];\</span>
00477 <span class="preprocessor">  da-&gt;getNodeIndices(indices);\</span>
00478 <span class="preprocessor">  unsigned char childNum = da-&gt;getChildNumber();\</span>
00479 <span class="preprocessor">  unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\</span>
00480 <span class="preprocessor">  unsigned char elemType = 0;\</span>
00481 <span class="preprocessor">  GET_ETYPE_BLOCK(elemType,hnMask,childNum)\</span>
00482 <span class="preprocessor">  for(int k = 0;k &lt; 8;k++) {\</span>
00483 <span class="preprocessor">    for(int j=0;j&lt;8;j++) {\</span>
00484 <span class="preprocessor">      outArr[indices[k]] +=  (((fac1*(LaplacianType2Stencil[childNum][elemType][k][j])) +\</span>
00485 <span class="preprocessor">            (fac2*(MassType2Stencil[childNum][elemType][k][j])))*inArr[indices[j]]);\</span>
00486 <span class="preprocessor">    }</span><span class="comment">/*end for j*/</span>\
00487   }<span class="comment">/*end for k*/</span>\
00488 }
00489 
00490 
<a name="l00491"></a><a class="code" href="omgNeumann_8C.html#a6">00491</a> <span class="preprocessor">#define JAC_TYPE2_MULT_BLOCK {\</span>
00492 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00493 <span class="preprocessor">  iC(VecZeroEntries(out));\</span>
00494 <span class="preprocessor">  unsigned int maxD;\</span>
00495 <span class="preprocessor">  double hFac;\</span>
00496 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00497 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
00498 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
00499 <span class="preprocessor">  }\</span>
00500 <span class="preprocessor">  double *matPropArr = NULL;\</span>
00501 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghost,Read-only,2 dof*/</span>\
00502   da-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00503   PetscScalar *outArr=NULL;\
00504   PetscScalar *inArr=NULL;\
00505   <span class="comment">/*Nodal,Non-Ghosted,Read,1 dof*/</span>\
00506   da-&gt;vecGetBuffer(in,inArr,false,false,true,1);\
00507   da-&gt;ReadFromGhostsBegin&lt;PetscScalar&gt;(inArr,1);\
00508   <span class="comment">/*Nodal,Non-Ghosted,Write,1 dof*/</span>\
00509   da-&gt;vecGetBuffer(out,outArr,false,false,false,1);\
00510   <span class="comment">/*Loop through All Independent Elements*/</span>\
00511   if(da-&gt;iAmActive()) {\
00512     for(da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;(); da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;() ) {\
00513       JAC_TYPE2_ELEM_MULT_BLOCK\
00514     } <span class="comment">/*end independent*/</span>\
00515   } <span class="comment">/*end if active*/</span>\
00516   da-&gt;ReadFromGhostsEnd&lt;PetscScalar&gt;(inArr);\
00517   <span class="comment">/*Loop through All Dependent Elements,*/</span>\
00518   <span class="comment">/*i.e. Elements which have atleast one*/</span>\
00519   <span class="comment">/*vertex owned by this processor and at least one*/</span>\
00520   <span class="comment">/*vertex not owned by this processor.*/</span>\
00521   if(da-&gt;iAmActive()) {\
00522     for(da-&gt;init&lt;ot::DA_FLAGS::DEPENDENT&gt;(); da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::DEPENDENT&gt;();  da-&gt;next&lt;ot::DA_FLAGS::DEPENDENT&gt;() ) {\
00523       JAC_TYPE2_ELEM_MULT_BLOCK\
00524     } <span class="comment">/*end loop for dependent elems*/</span>\
00525   } <span class="comment">/*end if active*/</span>\
00526   da-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00527   da-&gt;vecRestoreBuffer(in,inArr,false,false,true,1);\
00528   da-&gt;vecRestoreBuffer(out,outArr,false,false,false,1);\
00529   PetscLogFlops(332*(da-&gt;getGhostedElementSize()));\
00530 }
00531 
00532 
<a name="l00533"></a><a class="code" href="omgNeumann_8C.html#a19">00533</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a19">Jacobian2MatMult</a>(Mat J, Vec in, Vec out)
00534 {
00535   PetscFunctionBegin;
00536 
00537   PetscLogEventBegin(Jac2MultEvent,in,out,0,0);
00538 
00539   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg;
00540   <a class="code" href="omg_8C.html#a0">iC</a>(MatShellGetContext(J, (<span class="keywordtype">void</span>**)(&amp;damg)));
00541 
00542   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;user));
00543 
00544   <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00545     PetscLogEventBegin(Jac2FinestMultEvent,in,out,0,0);
00546   }
00547 
00548   <a class="code" href="omgJac_8C.html#a3">JAC_TYPE2_MULT_BLOCK</a> 
00549 
00550     <span class="keywordflow">if</span>(data-&gt;<a class="code" href="structJac2MFreeData.html#o1">isFinestLevel</a>) {
00551       PetscLogEventEnd(Jac2FinestMultEvent,in,out,0,0);
00552     }
00553 
00554   PetscLogEventEnd(Jac2MultEvent,in,out,0,0);
00555 
00556   PetscFunctionReturn(0);
00557 }
00558 
00559 
<a name="l00560"></a><a class="code" href="omgNeumann_8C.html#a7">00560</a> <span class="preprocessor">#define BUILD_FULL_JAC_TYPE2_BLOCK(B) {\</span>
00561 <span class="preprocessor">  ot::DA* da = damg-&gt;da;\</span>
00562 <span class="preprocessor">  MatZeroEntries(B);\</span>
00563 <span class="preprocessor">  std::vector&lt;ot::MatRecord&gt; records;\</span>
00564 <span class="preprocessor">  unsigned int maxD;\</span>
00565 <span class="preprocessor">  double hFac;\</span>
00566 <span class="preprocessor">  if(da-&gt;iAmActive()) {\</span>
00567 <span class="preprocessor">    maxD = da-&gt;getMaxDepth();\</span>
00568 <span class="preprocessor">    hFac = 1.0/((double)(1u &lt;&lt; (maxD-1)));\</span>
00569 <span class="preprocessor">  }\</span>
00570 <span class="preprocessor">  double *matPropArr = NULL;\</span>
00571 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghost,Read-only,2 dof*/</span>\
00572   <span class="comment">/*Note: All the flags are used for describing*/</span>\
00573   <span class="comment">/*the type of input vector, not*/</span>\
00574   <span class="comment">/*the type of the buffer.*/</span>\
00575   da-&gt;vecGetBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00576   if(da-&gt;iAmActive()) {\
00577     for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;(); da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();  da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\
00578       unsigned int idx = da-&gt;curr();\
00579       unsigned int lev = da-&gt;getLevel(idx);\
00580       double h = hFac*(1u &lt;&lt; (maxD - lev));\
00581       double matP1 = matPropArr[2*idx];\
00582       double matP2 = matPropArr[2*idx+1];\
00583       double fac1 = matP1*h/2.0;\
00584       double fac2 = matP2*h*h*h/8.0;\
00585       unsigned int indices[8];\
00586       da-&gt;getNodeIndices(indices);\
00587       unsigned char childNum = da-&gt;getChildNumber();\
00588       unsigned char hnMask = da-&gt;getHangingNodeIndex(idx);\
00589       unsigned char elemType = 0;\
00590       GET_ETYPE_BLOCK(elemType,hnMask,childNum)\
00591       for(int k = 0;k &lt; 8;k++) {\
00592         for(int j=0;j&lt;8;j++) {\
00593           ot::MatRecord currRec;\
00594           currRec.rowIdx = indices[k];\
00595           currRec.colIdx = indices[j];\
00596           currRec.rowDim = 0;\
00597           currRec.colDim = 0;\
00598           currRec.val = ((fac1*(LaplacianType2Stencil[childNum][elemType][k][j])) +\
00599               (fac2*(MassType2Stencil[childNum][elemType][k][j])));\
00600           records.push_back(currRec);\
00601         } <span class="comment">/*end for j*/</span>\
00602       } <span class="comment">/*end for k*/</span>\
00603       if(records.size() &gt; 1000) {\
00604         <span class="comment">/*records will be cleared inside the function*/</span>\
00605         da-&gt;setValuesInMatrix(B, records, 1, ADD_VALUES);\
00606       }\
00607     } <span class="comment">/*end writable*/</span>\
00608   } <span class="comment">/*end if active*/</span>\
00609   da-&gt;setValuesInMatrix(B, records, 1, ADD_VALUES);\
00610   MatAssemblyBegin(B, MAT_FINAL_ASSEMBLY);\
00611   da-&gt;vecRestoreBuffer&lt;double&gt;(*(data-&gt;matProp),matPropArr,true,true,true,2);\
00612   MatAssemblyEnd(B, MAT_FINAL_ASSEMBLY);\
00613 }
00614 
00615 
<a name="l00616"></a><a class="code" href="omgNeumann_8C.html#a20">00616</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a20">ComputeJacobian2</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat J, Mat B) {
00617   <span class="comment">//For matShells nothing to be done here.</span>
00618   PetscFunctionBegin;
00619 
00620   PetscTruth isshell;
00621   PetscTypeCompare((PetscObject)B, MATSHELL, &amp;isshell);
00622 
00623   <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00624 
00625   assert(B == J);
00626 
00627   <span class="keywordflow">if</span>(isshell) {
00628     <span class="keywordflow">if</span>( data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a> == NULL ) {
00629       PetscFunctionReturn(0);
00630     } <span class="keywordflow">else</span> {
00631       J = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00632       B = data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>;
00633     }
00634   }
00635 
00636   <span class="comment">//Assuming that B and J are the same.</span>
00637 
00638   <a class="code" href="omgJac_8C.html#a5">BUILD_FULL_JAC_TYPE2_BLOCK</a>(B) 
00639 
00640     PetscFunctionReturn(0);
00641 }
00642 
<a name="l00643"></a><a class="code" href="omgNeumann_8C.html#a21">00643</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a21">CreateJacobian2</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg, Mat *jac) {
00644   PetscFunctionBegin;
00645   <span class="keywordtype">int</span> totalLevels;
00646   PetscTruth flg;
00647   PetscInt buildFullCoarseMat;
00648   PetscInt buildFullMatAll;
00649   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullMatAll"</span>,&amp;buildFullMatAll,&amp;flg);
00650   PetscOptionsGetInt(PETSC_NULL,<span class="stringliteral">"-buildFullCoarseMat"</span>,&amp;buildFullCoarseMat,&amp;flg);
00651   <span class="keywordflow">if</span>(buildFullMatAll) {
00652     buildFullCoarseMat = 1;
00653   }
00654   totalLevels = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o17">totalLevels</a>;
00655   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00656   <span class="keywordtype">int</span> myRank;
00657   MPI_Comm_rank(da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>(),&amp;myRank);
00658   <span class="comment">//The size this processor owns ( without ghosts).</span>
00659   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>  m,n;
00660   m=n=da-&gt;<a class="code" href="classot_1_1DA.html#z31_18">getNodeSize</a>();
00661   <span class="keywordflow">if</span>(totalLevels == damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>) {
00662     <span class="comment">//This is the coarsest.</span>
00663     <span class="keywordflow">if</span>( (!myRank) &amp;&amp; buildFullCoarseMat ) {
00664       std::cout&lt;&lt;<span class="stringliteral">"Building Full Coarse Mat."</span>&lt;&lt;std::endl;
00665     }
00666     <span class="keywordtype">char</span> matType[30];
00667     <span class="keywordflow">if</span>(buildFullCoarseMat) {
00668       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00669         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00670       }
00671       PetscTruth typeFound;
00672       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00673       <span class="keywordflow">if</span>(!typeFound) {
00674         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00675         assert(<span class="keyword">false</span>);
00676       } 
00677     }
00678     <span class="keywordtype">bool</span> requirePrivateMats = (da-&gt;<a class="code" href="classot_1_1DA.html#z31_19">getNpesActive</a>() != da-&gt;<a class="code" href="classot_1_1DA.html#z31_20">getNpesAll</a>());    
00679     <span class="keywordflow">if</span>(requirePrivateMats ) {
00680       <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a> *data = (static_cast&lt;Jac2MFreeData*&gt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
00681       <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00682         <span class="keywordflow">if</span>(buildFullCoarseMat) {
00683           da-&gt;<a class="code" href="classot_1_1DA.html#z35_4">createActiveMatrix</a>(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, matType, 1);
00684         } <span class="keywordflow">else</span> {
00685           MatCreateShell(da-&gt;<a class="code" href="classot_1_1DA.html#z31_2">getCommActive</a>(), m, n, PETSC_DETERMINE,
00686               PETSC_DETERMINE, damg, &amp;(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>));
00687           MatShellSetOperation(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, MATOP_MULT,
00688               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a28">Jacobian2MatMult</a>);
00689           MatShellSetOperation(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, MATOP_GET_DIAGONAL,
00690               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a27">Jacobian2MatGetDiagonal</a>);
00691           MatShellSetOperation(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, MATOP_DESTROY,
00692               (void (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00693         }
00694         MatGetVecs(data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>, &amp;(data-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>), &amp;(data-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>));
00695       } <span class="keywordflow">else</span> {
00696         data-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a> = NULL;
00697         data-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a> = NULL;
00698         data-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a> = NULL;
00699       }
00700       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00701       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00702       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span>(*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a13">Jacobian2ShellMatMult</a>);
00703     } <span class="keywordflow">else</span> {
00704       <span class="keywordflow">if</span>(buildFullCoarseMat) {
00705         da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 1);
00706       } <span class="keywordflow">else</span> {
00707         MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00708         MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a28">Jacobian2MatMult</a>);
00709         MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a27">Jacobian2MatGetDiagonal</a>);
00710         MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00711       }
00712     }
00713     <span class="keywordflow">if</span>((!myRank) &amp;&amp; buildFullCoarseMat) {
00714       std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Coarse Mat."</span>&lt;&lt;std::endl;
00715     }
00716   } <span class="keywordflow">else</span> {
00717     <span class="comment">//This is some finer level.</span>
00718     <span class="keywordflow">if</span>(buildFullMatAll) {
00719       <span class="keywordflow">if</span>(!myRank) {
00720         std::cout&lt;&lt;<span class="stringliteral">"Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00721       }
00722       <span class="keywordflow">if</span>(!(da-&gt;<a class="code" href="classot_1_1DA.html#z35_0">computedLocalToGlobal</a>())) {
00723         da-&gt;<a class="code" href="classot_1_1DA.html#z35_3">computeLocalToGlobalMappings</a>();
00724       }
00725       <span class="keywordtype">char</span> matType[30];
00726       PetscTruth typeFound;
00727       PetscOptionsGetString(PETSC_NULL,<span class="stringliteral">"-fullJacMatType"</span>,matType,30,&amp;typeFound);
00728       <span class="keywordflow">if</span>(!typeFound) {
00729         std::cout&lt;&lt;<span class="stringliteral">"I need a MatType for the full Jacobian matrix!"</span>&lt;&lt;std::endl;
00730         assert(<span class="keyword">false</span>);
00731       } 
00732       da-&gt;<a class="code" href="classot_1_1DA.html#z35_6">createMatrix</a>(*jac, matType, 1);
00733       <span class="keywordflow">if</span>(!myRank) {
00734         std::cout&lt;&lt;<span class="stringliteral">"Finished Building Full Mat for level: "</span>&lt;&lt;(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>)&lt;&lt;std::endl;
00735       }
00736     } <span class="keywordflow">else</span> {
00737       MatCreateShell(damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o2">comm</a>, m ,n, PETSC_DETERMINE, PETSC_DETERMINE, damg, jac);
00738       MatShellSetOperation(*jac ,MATOP_MULT, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a28">Jacobian2MatMult</a>);
00739       MatShellSetOperation(*jac ,MATOP_GET_DIAGONAL, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a27">Jacobian2MatGetDiagonal</a>);
00740       MatShellSetOperation(*jac ,MATOP_DESTROY, (<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span>)) <a class="code" href="omgJac_8C.html#a26">Jacobian2MatDestroy</a>);
00741     }
00742   }
00743 
00744   PetscFunctionReturn(0);
00745 }<span class="comment">//end fn.</span>
00746 
00747 <span class="comment">/*</span>
00748 <span class="comment"> * This function computes the right-hand side for FEM system. The load (force) is sampled at the center of each octant. These sample values are read from the global variable force_values */</span>
<a name="l00749"></a><a class="code" href="omgNeumann_8C.html#a22">00749</a> PetscErrorCode <a class="code" href="omgNeumann_8C.html#a22">ComputeRHS_omgNeumann</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg,Vec in) {
00750   PetscFunctionBegin;            
00751   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da = damg-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o3">da</a>;
00752   PetscScalar *inarray;
00753   VecZeroEntries(in);
00754   da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00755 
00756   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00757     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;();
00758         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00759         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00760     {
00761       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00762       <span class="keywordtype">unsigned</span> levelhere = (da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx) - 1);
00763       
00764       <span class="keywordtype">double</span> hxOct = ldexp(1.0,-levelhere);
00765       assert(hxOct==1.0/(1u&lt;&lt;levelhere));
00766       <span class="keywordtype">double</span> fac = ((hxOct*hxOct*hxOct)/8.0);
00767       
00768       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00769       da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00770       
00771       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> childNum = da-&gt;<a class="code" href="classot_1_1DA.html#z36_3">getChildNumber</a>();
00772       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(idx);
00773       <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> elemType = 0;
00774       <a class="code" href="odaUtils_8h.html#a12">GET_ETYPE_BLOCK</a>(elemType,hnMask,childNum)
00775       
00776       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; 8; j++) 
00777         inarray[indices[j]] += <a class="code" href="omgNeumann_8C.html#a11">force_values</a>[idx]*<a class="code" href="omgNeumann_8C.html#a10">RHSType2Stencil</a>[childNum][elemType][j]*fac;
00778     
00779     }<span class="comment">//end looping over octants</span>
00780     
00781   }<span class="comment">//end if active</span>
00782 
00783   da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>(in,inarray,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00784   PetscFunctionReturn(0);
00785 }
00786 
00787 
<a name="l00788"></a><a class="code" href="omgNeumann_8C.html#a23">00788</a> <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8C.html#a23">CalculateCenters</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da, std::vector&lt;double&gt; &amp; centers)
00789 {
00790   <span class="comment">// this only resizes "centers"</span>
00791   <span class="comment">// also, since vector is both elemental and ghosted, we don't need the "getbuffer" function for access</span>
00792   da-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>&lt;<span class="keywordtype">double</span>&gt;(centers, <span class="keyword">true</span><span class="comment">/*elemental*/</span>, <span class="keyword">true</span><span class="comment">/*ghosted*/</span>, 3<span class="comment">/*values per octant*/</span>);
00793 
00794   <span class="comment">// initialize all entries to zero (loop over elements might not touch some entries)</span>
00795   <span class="comment">// maybe this can be skipped. but then some function will have to calculate garbage from garbage</span>
00796   centers.assign(centers.size(),0.0);
00797   
00798   <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00799     <span class="keywordtype">unsigned</span> maxD = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00800     
00801     <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;();
00802         da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00803         da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;())  
00804     {
00805       <a class="code" href="classPoint.html">Point</a> pt = da-&gt;<a class="code" href="classot_1_1DA.html#z31_3">getCurrentOffset</a>();
00806       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>();
00807       
00808       <span class="keywordtype">double</span> x = ldexp( static_cast&lt;double&gt;(pt.<a class="code" href="classPoint.html#z52_1">xint</a>()) , 1-maxD );
00809       <span class="keywordtype">double</span> y = ldexp( static_cast&lt;double&gt;(pt.<a class="code" href="classPoint.html#z52_3">yint</a>()) , 1-maxD );
00810       <span class="keywordtype">double</span> z = ldexp( static_cast&lt;double&gt;(pt.<a class="code" href="classPoint.html#z52_5">zint</a>()) , 1-maxD );
00811       <span class="keywordtype">unsigned</span> levelhere = (da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(idx) - 1);
00812       <span class="keywordtype">double</span> halfSide = ldexp(0.5, -levelhere);
00813       
00814       centers[3*idx]=x+halfSide;
00815       centers[3*idx+1]=y+halfSide;
00816       centers[3*idx+2]=z+halfSide;
00817     }<span class="comment">//end looping over octants</span>
00818     
00819   }<span class="comment">//end if active</span>
00820 }
00821 
<a name="l00832"></a><a class="code" href="omgNeumann_8h.html#a0">00832</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8h.html#a0">solve_neumann</a>(
00833     <span class="comment">/* input parameters: */</span>
00834      std::vector&lt;double&gt;&amp; pts,
00835      <span class="keywordtype">void</span> (*CalcCoef)(<span class="keyword">const</span> std::vector&lt;double&gt; &amp; pts, std::vector&lt;double&gt; &amp; values),
00836      <span class="keywordtype">void</span> (*CalcRHS)(<span class="keyword">const</span> std::vector&lt;double&gt; &amp; pts, std::vector&lt;double&gt; &amp; values),
00837      <span class="keywordtype">int</span> numMultigridLevels,
00838      <span class="comment">/* output parameters */</span>
00839      Vec&amp; sol,
00840      <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> * &amp; damg
00841     )
00842 {
00843   <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00844   
00845   <span class="keyword">const</span> <span class="keywordtype">int</span> dim = 3;
00846   <span class="keywordtype">double</span> gSize[3]={1.0, 1.0, 1.0};
00847   <span class="keyword">const</span> <span class="keywordtype">double</span> mgLoadFac = 1.5;
00848   <span class="keyword">const</span> <span class="keywordtype">bool</span> compressLut = <span class="keyword">false</span>;
00849   <span class="keyword">const</span> <span class="keywordtype">bool</span> incCorner = <span class="keyword">true</span>; 
00850   <span class="keyword">const</span> <span class="keywordtype">int</span> maxNumPts=1;  <span class="comment">// we want at most 1 point per octant</span>
00851   <span class="keyword">const</span> <span class="keywordtype">int</span> maxDepth = 30;
00852   <span class="keyword">const</span> <span class="keywordtype">int</span> dof=1;
00853 
00854   <span class="keywordtype">int</span> size, rank;
00855   MPI_Comm_size(MPI_COMM_WORLD,&amp;size);
00856   MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
00857 
00858   
00859   <span class="comment">// enforce that all points are inside [0,1)^3</span>
00860   <span class="keywordflow">for</span>(size_t i=0;i&lt;pts.size();i++) 
00861     <span class="keywordflow">if</span> (pts[i]&lt;0)
00862       pts[i]=0;
00863     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (pts[i]&gt;=1)
00864       pts[i]=1-ldexp(0.5,-maxDepth);
00865 
00866   <span class="comment">// now convert points to octree </span>
00867   <span class="comment">// "pts" is cleared inside this function</span>
00868   vector&lt;ot::TreeNode&gt; linOct;
00869   <a class="code" href="namespaceot.html#a35">ot::points2Octree</a>(pts, gSize, linOct, dim, maxDepth, maxNumPts, MPI_COMM_WORLD);
00870 
00871   <span class="comment">//now balance the octree; "linOct" is cleared inside this function</span>
00872   vector&lt;ot::TreeNode&gt; balOct;
00873   <a class="code" href="namespaceot.html#a10">ot::balanceOctree</a> (linOct, balOct, dim, maxDepth, <span class="keyword">true</span>, MPI_COMM_WORLD, NULL, NULL);
00874   
00875   <span class="comment">/*</span>
00876 <span class="comment">  for(int i = 0; i &lt; 1; i++) {</span>
00877 <span class="comment">    std::vector&lt;ot::TreeNode&gt; tmpOct = balOct;</span>
00878 <span class="comment">    balOct.clear();</span>
00879 <span class="comment">    ot::refineOctree(tmpOct, balOct); </span>
00880 <span class="comment">  }</span>
00881 <span class="comment">  */</span>
00882 
00883   <span class="comment">// createRegularOctree(balOct,5,3,maxDepth,MPI_COMM_WORLD);</span>
00884 
00885   <span class="comment">// print how many finest-level octants we have</span>
00886   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> locBalSize = balOct.size();
00887   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> totBalSize;
00888   par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;locBalSize, &amp;totBalSize, 1, MPI_SUM, 0, MPI_COMM_WORLD);
00889   <span class="keywordflow">if</span>(!rank) {
00890     cout &lt;&lt; <span class="stringliteral">"# of octants on finest level: "</span>&lt;&lt; totBalSize &lt;&lt; endl; 
00891   }
00892   
00893   <span class="comment">// create multigrid solver object, coarser octrees, finite element meshes and the interpolation</span>
00894   <span class="comment">// balOct is cleared inside this function</span>
00895   <span class="comment">// numMultigridLevels might be modified inside this function</span>
00896   <a class="code" href="namespaceot.html#a103">ot::DAMGCreateAndSetDA</a>(MPI_COMM_WORLD,numMultigridLevels, NULL, &amp;damg, balOct,
00897       dof, mgLoadFac, compressLut, incCorner);
00898  
00899   <span class="comment">// set some options to make "CreateJacobian2" and "ComputeJacobian2" work. These routines are related to matrix-vector multiplication on all levels.</span>
00900   PetscOptionsSetValue(<span class="stringliteral">"-jacType"</span>,<span class="stringliteral">"2"</span>);
00901   
00902   <span class="comment">// load stencils, i.e. integrals of: products of gradients of shape functions, product of shape functions and shape functions themselves</span>
00903   <a class="code" href="handleType2Stencils_8C.html#a16">createLmatType2</a>(<a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>);
00904   <a class="code" href="handleType2Stencils_8C.html#a12">createMmatType2</a>(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>);
00905   <a class="code" href="handleType2Stencils_8C.html#a20">createRHSType2</a>(<a class="code" href="omgNeumann_8C.html#a10">RHSType2Stencil</a>);
00906 
00907   <span class="comment">// here will be stored centers of "ALL" octants on this process;</span>
00908   vector&lt;double&gt; centers;   
00909   
00910   <span class="comment">// calculate centers for "ALL" octants (both pre-ghost and writable)</span>
00911   <a class="code" href="omgNeumann_8C.html#a23">CalculateCenters</a>(damg[numMultigridLevels-1]-&gt;da, centers);
00912   
00913   <span class="comment">// call user-provided function to sample the right-hand-side</span>
00914   <a class="code" href="omgNeumann_8C.html#a11">force_values</a>.resize(centers.size()/3);
00915   CalcRHS(centers, <a class="code" href="omgNeumann_8C.html#a11">force_values</a>);
00916   
00917   <span class="comment">// calculate PDE coef. for all levels. This calls user-provided function CalcCoef</span>
00918   <a class="code" href="omgNeumann_8C.html#a12">SetPDECoefFromPts</a>(damg, centers,CalcCoef); 
00919   
00920   <span class="comment">// set up functions which do matvecs and compute right hand side</span>
00921   <a class="code" href="namespaceot.html#a96">ot::DAMGSetKSP</a>(damg, <a class="code" href="omgJac_8C.html#a25">CreateJacobian2</a>,<a class="code" href="omgJac_8C.html#a29">ComputeJacobian2</a>,<a class="code" href="omgNeumann_8C.html#a22">ComputeRHS_omgNeumann</a>);
00922   
00923   <span class="comment">// solve (using zero initial guess -- this is the default)</span>
00924   <a class="code" href="namespaceot.html#a100">ot::DAMGSolve</a>(damg);
00925 
00926   <span class="comment">// get the solution</span>
00927   sol = <a class="code" href="omg_8h.html#a36">DAMGGetx</a>(damg);
00928   
00929   <span class="comment">// destroy objects </span>
00930   <a class="code" href="handleType2Stencils_8C.html#a26">destroyLmatType2</a>(<a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>);
00931   <a class="code" href="handleType2Stencils_8C.html#a27">destroyMmatType2</a>(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>);
00932   <a class="code" href="handleType2Stencils_8C.html#a24">destroyRHSType2</a>(<a class="code" href="omgNeumann_8C.html#a10">RHSType2Stencil</a>);
00933   <a class="code" href="omgNeumann_8C.html#a13">DestroyUserContexts</a>(damg);
00934 
00935   <span class="keywordflow">return</span>;
00936 }
00937 
<a name="l00949"></a><a class="code" href="omgNeumann_8h.html#a2">00949</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8h.html#a2">solve_neumann_oct</a>(
00950     <span class="comment">/* input parameters: */</span>
00951      std::vector&lt;ot::TreeNode&gt;&amp; octs,
00952      <span class="keywordtype">void</span> (*CalcCoef)(<span class="keyword">const</span> std::vector&lt;double&gt; &amp; pts, std::vector&lt;double&gt; &amp; values),
00953      <span class="keywordtype">void</span> (*CalcRHS)(<span class="keyword">const</span> std::vector&lt;double&gt; &amp; pts, std::vector&lt;double&gt; &amp; values),
00954      <span class="keywordtype">int</span> numMultigridLevels,
00955      <span class="comment">/* output parameters */</span>
00956      Vec&amp; sol,
00957      <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> * &amp; damg
00958     )
00959 {
00960   <span class="keyword">using</span> <span class="keyword">namespace </span>std;
00961   
00962   <span class="keyword">const</span> <span class="keywordtype">int</span> dim = 3;
00963   <span class="keywordtype">double</span> gSize[3]={1.0, 1.0, 1.0};
00964   <span class="keyword">const</span> <span class="keywordtype">double</span> mgLoadFac = 1.5;
00965   <span class="keyword">const</span> <span class="keywordtype">bool</span> compressLut = <span class="keyword">false</span>;
00966   <span class="keyword">const</span> <span class="keywordtype">bool</span> incCorner = <span class="keyword">true</span>; 
00967   <span class="keyword">const</span> <span class="keywordtype">int</span> maxDepth = octs[0].<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00968   <span class="keyword">const</span> <span class="keywordtype">int</span> dof=1;
00969 
00970 
00971   <span class="keywordtype">int</span> size, rank;
00972   MPI_Comm_size(MPI_COMM_WORLD,&amp;size);
00973   MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
00974   
00975   <span class="comment">// complete the octree </span>
00976   vector&lt;ot::TreeNode&gt; linOct;
00977   <a class="code" href="namespaceot.html#a33">ot::completeOctree</a>(octs, linOct, 3 <span class="comment">/*dim*/</span>,
00978       maxDepth,
00979       <span class="keyword">true</span>, <span class="comment">/* isUnique */</span>
00980       <span class="keyword">false</span>, <span class="comment">/* isSorted */</span>
00981       <span class="keyword">false</span>, <span class="comment">/* assertNoEmptyProcs */</span>
00982       MPI_COMM_WORLD);
00983   octs.clear();
00984     
00985   <span class="comment">//now balance the octree; "linOct" is cleared inside this function</span>
00986   vector&lt;ot::TreeNode&gt; balOct;
00987   <a class="code" href="namespaceot.html#a10">ot::balanceOctree</a> (linOct, balOct, dim, maxDepth, <span class="keyword">true</span>, MPI_COMM_WORLD, NULL, NULL);
00988   
00989   <span class="comment">// debug </span>
00990   <span class="comment">// balOct.clear();</span>
00991   <span class="comment">// createRegularOctree(balOct,7,3,maxDepth,MPI_COMM_WORLD);</span>
00992   
00993   <span class="comment">// debug -- print octree to file</span>
00994   <span class="comment">// writeNodesToFile ("the_tree.ot", balOct);</span>
00995   
00996   <span class="comment">// print how many finest-level octants we have</span>
00997   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> locBalSize = balOct.size();
00998   <a class="code" href="dendro_8h.html#a0">DendroIntL</a> totBalSize;
00999   par::Mpi_Reduce&lt;DendroIntL&gt;(&amp;locBalSize, &amp;totBalSize, 1, MPI_SUM, 0, MPI_COMM_WORLD);
01000   <span class="keywordflow">if</span>(!rank) {
01001     cout &lt;&lt; <span class="stringliteral">"# of octants on finest level: "</span>&lt;&lt; totBalSize &lt;&lt; endl; 
01002   }
01003   
01004   <span class="comment">// create multigrid solver object, coarser octrees, finite element meshes and the interpolation</span>
01005   <span class="comment">// balOct is cleared inside this function</span>
01006   <span class="comment">// numMultigridLevels might be modified inside this function</span>
01007   <a class="code" href="namespaceot.html#a103">ot::DAMGCreateAndSetDA</a>(MPI_COMM_WORLD,numMultigridLevels, NULL, &amp;damg, balOct,
01008       dof, mgLoadFac, compressLut, incCorner);
01009 
01010   <span class="comment">// set some options to make "CreateJacobian2" and "ComputeJacobian2" work. These routines are related to matrix-vector multiplication on all levels.</span>
01011   PetscOptionsSetValue(<span class="stringliteral">"-jacType"</span>,<span class="stringliteral">"2"</span>);
01012   
01013   <span class="comment">// load stencils, i.e. integrals of: products of gradients of shape functions, product of shape functions and shape functions themselves</span>
01014   <a class="code" href="handleType2Stencils_8C.html#a16">createLmatType2</a>(<a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>);
01015   <a class="code" href="handleType2Stencils_8C.html#a12">createMmatType2</a>(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>);
01016   <a class="code" href="handleType2Stencils_8C.html#a20">createRHSType2</a>(<a class="code" href="omgNeumann_8C.html#a10">RHSType2Stencil</a>);
01017 
01018   <span class="comment">// here will be stored centers of "ALL" octants on this process;</span>
01019   vector&lt;double&gt; centers;   
01020   
01021   <span class="comment">// calculate centers for "ALL" octants (both pre-ghost and writable)</span>
01022   <a class="code" href="omgNeumann_8C.html#a23">CalculateCenters</a>(damg[numMultigridLevels-1]-&gt;da, centers);
01023   
01024   <span class="comment">// call user-provided function to sample the right-hand-side</span>
01025   <a class="code" href="omgNeumann_8C.html#a11">force_values</a>.resize(centers.size()/3);
01026   CalcRHS(centers, <a class="code" href="omgNeumann_8C.html#a11">force_values</a>);
01027   
01028   <span class="comment">// calculate PDE coef. for all levels. This calls user-provided function CalcCoef</span>
01029   <a class="code" href="omgNeumann_8C.html#a12">SetPDECoefFromPts</a>(damg, centers,CalcCoef); 
01030   
01031   <span class="comment">// set up functions which do matvecs and compute right hand side</span>
01032   <a class="code" href="namespaceot.html#a96">ot::DAMGSetKSP</a>(damg, <a class="code" href="omgJac_8C.html#a25">CreateJacobian2</a>,<a class="code" href="omgJac_8C.html#a29">ComputeJacobian2</a>,<a class="code" href="omgNeumann_8C.html#a22">ComputeRHS_omgNeumann</a>);
01033   
01034   <span class="comment">// solve (using zero initial guess -- this is the default)</span>
01035   <a class="code" href="namespaceot.html#a100">ot::DAMGSolve</a>(damg);
01036 
01037   <span class="comment">// get the solution</span>
01038   sol = <a class="code" href="omg_8h.html#a36">DAMGGetx</a>(damg);
01039   
01040   <span class="comment">// destroy objects </span>
01041   <a class="code" href="handleType2Stencils_8C.html#a26">destroyLmatType2</a>(<a class="code" href="checkError_8C.html#a2">LaplacianType2Stencil</a>);
01042   <a class="code" href="handleType2Stencils_8C.html#a27">destroyMmatType2</a>(<a class="code" href="checkError_8C.html#a4">MassType2Stencil</a>);
01043   <a class="code" href="handleType2Stencils_8C.html#a24">destroyRHSType2</a>(<a class="code" href="omgNeumann_8C.html#a10">RHSType2Stencil</a>);
01044   <a class="code" href="omgNeumann_8C.html#a13">DestroyUserContexts</a>(damg);
01045 
01046   <span class="keywordflow">return</span>;
01047 }
01048 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:25 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
