<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/src/oda/odaUtils.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000013.html">src</a>&nbsp;/&nbsp;<a class="el" href="dir_000016.html">oda</a></div>
<h1>odaUtils.C</h1><a href="odaUtils_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00008 <span class="preprocessor">#include "<a class="code" href="odaUtils_8h.html">odaUtils.h</a>"</span>
00009 <span class="preprocessor">#include "<a class="code" href="TreeNode_8h.html">TreeNode.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span>
00011 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00012 <span class="preprocessor">#include "<a class="code" href="seqUtils_8h.html">seqUtils.h</a>"</span>
00013 
00014 <span class="preprocessor">#ifdef __DEBUG__</span>
00015 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA__</span>
00016 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA__</span>
00017 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00018 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00019 <span class="preprocessor"></span>
00020 <span class="preprocessor">#ifdef __DEBUG_DA__</span>
00021 <span class="preprocessor"></span><span class="preprocessor">#ifndef __DEBUG_DA_PUBLIC__</span>
00022 <span class="preprocessor"></span><span class="preprocessor">#define __DEBUG_DA_PUBLIC__</span>
00023 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00024 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00025 <span class="preprocessor"></span>
00026 <span class="keyword">namespace </span>ot {
00027 
<a name="l00028"></a><a class="code" href="namespaceot.html#a78">00028</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a78">writePartitionVTK</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da, <span class="keyword">const</span> <span class="keywordtype">char</span>* outFileName) {
00029     <span class="keywordtype">int</span> rank = da-&gt;<a class="code" href="classot_1_1DA.html#z31_24">getRankAll</a>();
00030     <span class="comment">//Only processor writes</span>
00031     <span class="keywordflow">if</span>(!rank) {
00032       std::vector&lt;ot::TreeNode&gt; minBlocks = da-&gt;<a class="code" href="classot_1_1DA.html#a3">getMinAllBlocks</a>();
00033       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = da-&gt;<a class="code" href="classot_1_1DA.html#z31_16">getMaxDepth</a>();
00034       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> root(3, maxDepth);
00035       std::vector&lt;ot::TreeNode&gt; allBlocks;
00036       <a class="code" href="namespaceot.html#a34">ot::completeSubtree</a>(root, minBlocks, allBlocks, 3, maxDepth, <span class="keyword">true</span>, <span class="keyword">true</span>);
00037 
00038       FILE* outfile = fopen(outFileName,<span class="stringliteral">"w"</span>);
00039 
00040       <span class="comment">//Set the weights of allBlocks to be the processor ids. </span>
00041       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; allBlocks.size(); i++) {
00042         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pId;
00043         <span class="keywordtype">bool</span> found = seq::maxLowerBound&lt;ot::TreeNode&gt;(minBlocks, allBlocks[i], pId, NULL, NULL);
00044         assert(found);
00045         allBlocks[i].setWeight(pId);
00046       }
00047 
00048       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> numNode = static_cast&lt;unsigned int&gt;(allBlocks.size());
00049 
00050       <span class="keywordtype">float</span> coord[8][3] = {
00051         {0.0,0.0,0.0},
00052         {1.0,0.0,0.0},
00053         {0.0,1.0,0.0},
00054         {1.0,1.0,0.0},
00055         {0.0,0.0,1.0},
00056         {1.0,0.0,1.0},
00057         {0.0,1.0,1.0},
00058         {1.0,1.0,1.0}
00059       };
00060 
00061       fprintf(outfile,<span class="stringliteral">"# vtk DataFile Version 3.0\n"</span>);
00062       fprintf(outfile,<span class="stringliteral">"Octree field file\n"</span>);
00063       fprintf(outfile,<span class="stringliteral">"ASCII\n"</span>);
00064       fprintf(outfile,<span class="stringliteral">"DATASET UNSTRUCTURED_GRID\n"</span>);
00065       fprintf(outfile,<span class="stringliteral">"POINTS %d float\n"</span>,(numNode*8));
00066 
00067       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; numNode; i++) {
00068         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x = allBlocks[i].getX();
00069         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y = allBlocks[i].getY(); 
00070         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z = allBlocks[i].getZ();
00071         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d = allBlocks[i].<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>();
00072         <span class="keywordtype">float</span> fx, fy, fz,hx;
00073         fx = ((float)x)/((float)(1u&lt;&lt;maxDepth));
00074         fy = ((float)y)/((float)(1u&lt;&lt;maxDepth));
00075         fz = ((float)z)/((float)(1u&lt;&lt;maxDepth));
00076         hx = ((float)(1u&lt;&lt;(maxDepth-d)))/((float)(1u&lt;&lt;maxDepth));
00077 
00078         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++)
00079         {
00080           <span class="keywordtype">float</span> fxn,fyn,fzn;
00081           fxn = fx + coord[j][0]*hx;
00082           fyn = fy + coord[j][1]*hx;
00083           fzn = fz + coord[j][2]*hx;
00084           fprintf(outfile,<span class="stringliteral">"%f %f %f \n"</span>,fxn,fyn,fzn);
00085         }
00086       }
00087 
00088       fprintf(outfile,<span class="stringliteral">"\nCELLS %d %d\n"</span>,numNode,numNode*9);
00089 
00090       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numNode; i++)
00091       {
00092         fprintf(outfile,<span class="stringliteral">"8 "</span>);
00093 
00094         <span class="keywordflow">for</span>(<span class="keywordtype">int</span> j = 0; j &lt; 8; j++)
00095         {
00096           <span class="keywordtype">int</span> index = (8*i)+j;
00097           fprintf(outfile,<span class="stringliteral">"%d "</span>,index);
00098         }
00099         fprintf(outfile,<span class="stringliteral">"\n"</span>);
00100       }
00101 
00102       fprintf(outfile,<span class="stringliteral">"\nCELL_TYPES %d\n"</span>,numNode);
00103 
00104       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; numNode; i++)
00105       {
00106         fprintf(outfile,<span class="stringliteral">"11 \n"</span>);
00107       }
00108 
00109       fprintf(outfile,<span class="stringliteral">"\nCELL_DATA %d\n"</span>,numNode);
00110       fprintf(outfile,<span class="stringliteral">"SCALARS scalars unsigned_int\n"</span>);
00111       fprintf(outfile,<span class="stringliteral">"LOOKUP_TABLE default\n"</span>);
00112 
00113       <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i =0; i&lt; numNode; i++) {
00114         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = allBlocks[i].getWeight();
00115         fprintf(outfile,<span class="stringliteral">"%u \n"</span>, v);
00116       }
00117 
00118       fclose(outfile);
00119 
00120     }<span class="comment">//end if p0</span>
00121   }<span class="comment">//end function</span>
00122 
<a name="l00123"></a><a class="code" href="namespaceot.html#a79">00123</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a79">getGlobalMinLevel</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da) {
00124 
00125     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinLev = ot::TreeNode::MAX_LEVEL;
00126     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMinLev;
00127 
00128     <span class="comment">//It is sufficient to loop over the elements, since boundaries were added at the same level as some element. </span>
00129     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00130       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00131           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00132           da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;())  
00133       {
00134         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currLevel = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00135         <span class="keywordflow">if</span>(currLevel &lt; myMinLev) {
00136           myMinLev = currLevel;
00137         }
00138       }      
00139     }
00140 
00141     par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;myMinLev, &amp;globalMinLev, 1, MPI_MIN, da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>() );
00142 
00143     <span class="comment">//The initial octree is not root. So the min lev in the initial octree is atleast 1. So in the embedded octree the minlev is atleast 2. </span>
00144     assert(globalMinLev &gt; 1);
00145 
00146     <span class="comment">//Return the result in the original octree configuration</span>
00147     <span class="keywordflow">return</span> (globalMinLev -1);
00148   }
00149 
<a name="l00150"></a><a class="code" href="namespaceot.html#a80">00150</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a80">getGlobalMaxLevel</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da) {
00151 
00152     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxLev = 0;
00153     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> globalMaxLev;
00154 
00155     <span class="comment">//It is sufficient to loop over the elements, since boundaries were added at the same level as some element. </span>
00156     <span class="keywordflow">if</span>( da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>() ) {
00157       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;(); 
00158           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00159           da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;())  
00160       {
00161         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> currLevel = da-&gt;<a class="code" href="classot_1_1DA.html#z36_6">getLevel</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00162         <span class="keywordflow">if</span>(currLevel &gt; myMaxLev) {
00163           myMaxLev = currLevel;
00164         }
00165       }      
00166     }
00167 
00168     par::Mpi_Allreduce&lt;unsigned int&gt;(&amp;myMaxLev, &amp;globalMaxLev, 1, MPI_MAX, da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>() );
00169 
00170     <span class="comment">//m_uiMaxDepth will be 0 on inActive processors.</span>
00171     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00172       assert(globalMaxLev &lt;= da-&gt;getMaxDepth() );
00173     }<span class="keywordflow">else</span> {
00174       assert(globalMaxLev &lt;= ot::TreeNode::MAX_LEVEL);
00175     }
00176 
00177     <span class="comment">//Return the result in the original octree configuration</span>
00178     <span class="keywordflow">return</span> (globalMaxLev -1);   
00179   }
00180 
<a name="l00181"></a><a class="code" href="namespaceot.html#a81">00181</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceot.html#a81">getSortOrder</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> x, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> y, 
00182       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> z, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sz) {
00183 
00184     <span class="comment">// first compare the x, y, and z to determine which one dominates ...</span>
00185     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _x = x^(x+sz);
00186     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _y = y^(y+sz);
00187     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> _z = z^(z+sz);
00188 
00189     <span class="comment">// compute order ...</span>
00190     <span class="keywordflow">if</span> (_x &gt; _y) {
00191       <span class="keywordflow">if</span> ( _y &gt; _z) {
00192         <span class="keywordflow">return</span> ot::DA_FLAGS::ZYX;
00193       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _x &gt; _z ) {
00194         <span class="keywordflow">return</span> ot::DA_FLAGS::YZX;
00195       } <span class="keywordflow">else</span> {
00196         <span class="keywordflow">return</span> ot::DA_FLAGS::YXZ;
00197       }
00198     } <span class="keywordflow">else</span> {
00199       <span class="keywordflow">if</span> ( _y &gt; _z) {
00200         <span class="keywordflow">return</span> ot::DA_FLAGS::ZXY;
00201       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( _x &gt; _z ) {
00202         <span class="keywordflow">return</span> ot::DA_FLAGS::ZXY;
00203       } <span class="keywordflow">else</span> {
00204         <span class="keywordflow">return</span> ot::DA_FLAGS::XYZ;
00205       }
00206     }
00207   }
00208 
<a name="l00209"></a><a class="code" href="namespaceot.html#a82">00209</a>   <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> <a class="code" href="namespaceot.html#a82">getTouchConfig</a>(<span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; curr, 
00210       <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; next, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth) {
00211     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> c = 0;
00212     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cx = curr.<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00213     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cy = curr.<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00214     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cz = curr.<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00215     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nx = next.<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00216     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ny = next.<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00217     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nz = next.<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00218     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cd = curr.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00219     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nd = next.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00220     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cs = (1u&lt;&lt;(maxDepth - cd));
00221     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ns = (1u&lt;&lt;(maxDepth - nd));
00222 
00223     <span class="comment">//_zzyyxxT  </span>
00224     <span class="keywordtype">bool</span> isTouchingX = <span class="keyword">false</span>;
00225     <span class="keywordtype">bool</span> isTouchingY = <span class="keyword">false</span>;
00226     <span class="keywordtype">bool</span> isTouchingZ = <span class="keyword">false</span>;
00227 
00228     <span class="keywordflow">if</span> (cx == nx) {
00229       isTouchingX = <span class="keyword">true</span>;
00230     }
00231 
00232     <span class="keywordflow">if</span> (cx == (nx + ns) ) {
00233       isTouchingX = <span class="keyword">true</span>;
00234       c += (1 &lt;&lt; 1);
00235     }
00236 
00237     <span class="keywordflow">if</span> ( (cx + cs) == nx ) {
00238       isTouchingX = <span class="keyword">true</span>;
00239       c += (2 &lt;&lt; 1);
00240     }
00241 
00242     <span class="keywordflow">if</span> ( (cx + cs) == (nx + ns) ) {
00243       isTouchingX = <span class="keyword">true</span>;
00244       c += (3 &lt;&lt; 1);
00245     }
00246 
00247     <span class="keywordflow">if</span> (cy == ny) {
00248       isTouchingY = <span class="keyword">true</span>;
00249     }
00250 
00251     <span class="keywordflow">if</span> (cy == (ny + ns) ) {
00252       isTouchingY = <span class="keyword">true</span>;
00253       c += (1 &lt;&lt; 3);
00254     }
00255 
00256     <span class="keywordflow">if</span> ( (cy + cs) == ny ) {
00257       isTouchingY = <span class="keyword">true</span>;
00258       c += (2 &lt;&lt; 3);
00259     }
00260 
00261     <span class="keywordflow">if</span> ( (cy + cs) == (ny + ns) ) {
00262       isTouchingY = <span class="keyword">true</span>;
00263       c += (3 &lt;&lt; 3);
00264     }
00265 
00266     <span class="keywordflow">if</span> (cz == nz) {
00267       isTouchingZ = <span class="keyword">true</span>;
00268     }
00269 
00270     <span class="keywordflow">if</span> (cz == (nz + ns) ) {
00271       isTouchingZ = <span class="keyword">true</span>;
00272       c += (1 &lt;&lt; 5);
00273     }
00274 
00275     <span class="keywordflow">if</span> ( (cz + cs) == nz ) {
00276       isTouchingZ = <span class="keyword">true</span>;
00277       c += (2&lt;&lt;5);
00278     }
00279 
00280     <span class="keywordflow">if</span> ( (cz + cs) == (nz + ns) ) {
00281       isTouchingZ = <span class="keyword">true</span>;
00282       c += (3&lt;&lt;5);
00283     }
00284 
00285     <span class="keywordflow">if</span> ( isTouchingX &amp;&amp; isTouchingY &amp;&amp; isTouchingZ ) {
00286       c += 1;
00287     } <span class="keywordflow">else</span> {
00288       c = 0;
00289     }
00290 
00291     <span class="keywordflow">return</span> c;
00292   }
00293 
<a name="l00294"></a><a class="code" href="namespaceot.html#a83">00294</a>   <span class="keywordtype">bool</span> <a class="code" href="namespaceot.html#a83">isRegularGrid</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da) {
00295     <span class="keywordtype">int</span> iHaveHanging = 0;
00296     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00297       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::WRITABLE&gt;(); 
00298           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::WRITABLE&gt;();
00299           da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::WRITABLE&gt;()) { 
00300         <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_11">isHanging</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>())) {
00301           iHaveHanging = 1;
00302           std::cout&lt;&lt;(da-&gt;<a class="code" href="classot_1_1DA.html#z31_23">getRankActive</a>())&lt;&lt;
00303             <span class="stringliteral">" found a hanging node for element with id: "</span>
00304             &lt;&lt;(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>())&lt;&lt;std::endl;
00305 
00306           <span class="keywordflow">break</span>;
00307         }
00308       }<span class="comment">//end for writable</span>
00309     }<span class="comment">//end if active</span>
00310 
00311     <span class="keywordtype">int</span> anyOneHasHanging;
00312     par::Mpi_Allreduce&lt;int&gt;(&amp;iHaveHanging, &amp;anyOneHasHanging, 1, MPI_SUM, da-&gt;<a class="code" href="classot_1_1DA.html#z31_1">getComm</a>());
00313 
00314     <span class="keywordflow">return</span> (!anyOneHasHanging);
00315   }<span class="comment">//end function</span>
00316 
<a name="l00317"></a><a class="code" href="namespaceot.html#a84">00317</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a84">assignBoundaryFlags</a>(<a class="code" href="classot_1_1DA.html">ot::DA</a>* da, 
00318       std::vector&lt;unsigned char&gt; &amp; bdyFlagVec) {
00319 
00320     da-&gt;<a class="code" href="classot_1_1DA.html#z35_8">createVector</a>(bdyFlagVec, <span class="keyword">false</span>, <span class="keyword">false</span>, 1);<span class="comment">//Nodal, Non-ghosted, single dof</span>
00321 
00322     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; bdyFlagVec.size(); i++) {
00323       bdyFlagVec[i] = 0;
00324     }<span class="comment">//initialization loop</span>
00325 
00326     <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> *bdyFlagArr = NULL;
00327     da-&gt;<a class="code" href="classot_1_1DA.html#z35_11">vecGetBuffer</a>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(bdyFlagVec,bdyFlagArr,
00328         <span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00329 
00330     <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#a5">iAmActive</a>()) {
00331       <span class="comment">//We can only loop over the elements, hence the positive boundary elements</span>
00332       <span class="comment">//will add the flags for the external positive boundary nodes.</span>
00333       <span class="keywordflow">for</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_9">init</a>&lt;ot::DA_FLAGS::ALL&gt;(); 
00334           da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>() &lt; da-&gt;<a class="code" href="classot_1_1DA.html#z36_2">end</a>&lt;ot::DA_FLAGS::ALL&gt;();
00335           da-&gt;<a class="code" href="classot_1_1DA.html#z36_13">next</a>&lt;ot::DA_FLAGS::ALL&gt;()) { 
00336         <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> currentFlags;
00337         <span class="keywordtype">bool</span> calledGetNodeIndices = <span class="keyword">false</span>;
00338         <span class="keywordflow">if</span>(da-&gt;<a class="code" href="classot_1_1DA.html#z31_27">isBoundaryOctant</a>(&amp;currentFlags)) {
00339           <span class="comment">//The status of the anchor of any real octant is determined by the</span>
00340           <span class="comment">//negative face boundaries only</span>
00341           <span class="keywordtype">int</span> xNegBdy = (currentFlags &amp; ot::TreeNode::X_NEG_BDY);
00342           <span class="keywordtype">int</span> yNegBdy = (currentFlags &amp; ot::TreeNode::Y_NEG_BDY);
00343           <span class="keywordtype">int</span> zNegBdy = (currentFlags &amp; ot::TreeNode::Z_NEG_BDY);
00344 
00345           <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> hnMask = da-&gt;<a class="code" href="classot_1_1DA.html#z36_5">getHangingNodeIndex</a>(da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>());
00346           <span class="keywordflow">if</span>(!(hnMask &amp; 1)) {
00347             <span class="comment">//Anchor is not hanging                 </span>
00348             <span class="keywordflow">if</span>(xNegBdy) {
00349               <span class="keywordflow">if</span>(yNegBdy &amp;&amp; zNegBdy){
00350                 bdyFlagArr[da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()] = ot::TreeNode::CORNER_BDY;
00351               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yNegBdy || zNegBdy) {
00352                 bdyFlagArr[da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()] = ot::TreeNode::EDGE_BDY;
00353               }<span class="keywordflow">else</span> {
00354                 bdyFlagArr[da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()] = ot::TreeNode::FACE_BDY;
00355               }
00356             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yNegBdy) {
00357               <span class="keywordflow">if</span>(zNegBdy) {
00358                 bdyFlagArr[da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()] = ot::TreeNode::EDGE_BDY;
00359               }<span class="keywordflow">else</span> {
00360                 bdyFlagArr[da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()] = ot::TreeNode::FACE_BDY;
00361               }
00362             }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zNegBdy) {
00363               bdyFlagArr[da-&gt;<a class="code" href="classot_1_1DA.html#z36_0">curr</a>()] = ot::TreeNode::FACE_BDY;
00364             }
00365           }<span class="comment">//end if anchor hanging</span>
00366 
00367           <span class="keywordflow">if</span>(currentFlags &gt; ot::TreeNode::NEG_POS_DEMARCATION) {
00368             <span class="comment">//Has at least one positive boundary</span>
00369             <span class="comment">//May have negative boundaries as well</span>
00370             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> indices[8];
00371             da-&gt;<a class="code" href="classot_1_1DA.html#z36_7">getNodeIndices</a>(indices); 
00372             calledGetNodeIndices = <span class="keyword">true</span>;
00373             <span class="keywordtype">int</span> xPosBdy = (currentFlags &amp; ot::TreeNode::X_POS_BDY);
00374             <span class="keywordtype">int</span> yPosBdy = (currentFlags &amp; ot::TreeNode::Y_POS_BDY);
00375             <span class="keywordtype">int</span> zPosBdy = (currentFlags &amp; ot::TreeNode::Z_POS_BDY);
00376 
00377             <span class="keywordflow">if</span>(!(hnMask &amp; (1 &lt;&lt; 1))) {
00378               <span class="keywordtype">bool</span> xBdy = xPosBdy;
00379               <span class="keywordtype">bool</span> yBdy = yNegBdy;
00380               <span class="keywordtype">bool</span> zBdy = zNegBdy;
00381               <span class="keywordflow">if</span>(xBdy) {
00382                 <span class="keywordflow">if</span>(yBdy &amp;&amp; zBdy){
00383                   bdyFlagArr[indices[1]] = ot::TreeNode::CORNER_BDY;
00384                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy || zBdy) {
00385                   bdyFlagArr[indices[1]] = ot::TreeNode::EDGE_BDY;
00386                 }<span class="keywordflow">else</span> {
00387                   bdyFlagArr[indices[1]] = ot::TreeNode::FACE_BDY;
00388                 }
00389               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy) {
00390                 <span class="keywordflow">if</span>(zBdy) {
00391                   bdyFlagArr[indices[1]] = ot::TreeNode::EDGE_BDY;
00392                 }<span class="keywordflow">else</span> {
00393                   bdyFlagArr[indices[1]] = ot::TreeNode::FACE_BDY;
00394                 }
00395               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zBdy) {
00396                 bdyFlagArr[indices[1]] = ot::TreeNode::FACE_BDY;
00397               }
00398             }
00399 
00400             <span class="keywordflow">if</span>(!(hnMask &amp; (1 &lt;&lt; 2))) {
00401               <span class="keywordtype">bool</span> xBdy = xNegBdy;
00402               <span class="keywordtype">bool</span> yBdy = yPosBdy;
00403               <span class="keywordtype">bool</span> zBdy = zNegBdy;
00404               <span class="keywordflow">if</span>(xBdy) {
00405                 <span class="keywordflow">if</span>(yBdy &amp;&amp; zBdy){
00406                   bdyFlagArr[indices[2]] = ot::TreeNode::CORNER_BDY;
00407                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy || zBdy) {
00408                   bdyFlagArr[indices[2]] = ot::TreeNode::EDGE_BDY;
00409                 }<span class="keywordflow">else</span> {
00410                   bdyFlagArr[indices[2]] = ot::TreeNode::FACE_BDY;
00411                 }
00412               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy) {
00413                 <span class="keywordflow">if</span>(zBdy) {
00414                   bdyFlagArr[indices[2]] = ot::TreeNode::EDGE_BDY;
00415                 }<span class="keywordflow">else</span> {
00416                   bdyFlagArr[indices[2]] = ot::TreeNode::FACE_BDY;
00417                 }
00418               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zBdy) {
00419                 bdyFlagArr[indices[2]] = ot::TreeNode::FACE_BDY;
00420               }
00421             }
00422 
00423             <span class="keywordflow">if</span>(!(hnMask &amp; (1 &lt;&lt; 3))) {
00424               <span class="keywordtype">bool</span> xBdy = xPosBdy;
00425               <span class="keywordtype">bool</span> yBdy = yPosBdy;
00426               <span class="keywordtype">bool</span> zBdy = zNegBdy;
00427               <span class="keywordflow">if</span>(xBdy) {
00428                 <span class="keywordflow">if</span>(yBdy &amp;&amp; zBdy){
00429                   bdyFlagArr[indices[3]] = ot::TreeNode::CORNER_BDY;
00430                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy || zBdy) {
00431                   bdyFlagArr[indices[3]] = ot::TreeNode::EDGE_BDY;
00432                 }<span class="keywordflow">else</span> {
00433                   bdyFlagArr[indices[3]] = ot::TreeNode::FACE_BDY;
00434                 }
00435               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy) {
00436                 <span class="keywordflow">if</span>(zBdy) {
00437                   bdyFlagArr[indices[3]] = ot::TreeNode::EDGE_BDY;
00438                 }<span class="keywordflow">else</span> {
00439                   bdyFlagArr[indices[3]] = ot::TreeNode::FACE_BDY;
00440                 }
00441               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zBdy) {
00442                 bdyFlagArr[indices[3]] = ot::TreeNode::FACE_BDY;
00443               }
00444             }
00445 
00446             <span class="keywordflow">if</span>(!(hnMask &amp; (1 &lt;&lt; 4))) {
00447               <span class="keywordtype">bool</span> xBdy = xNegBdy;
00448               <span class="keywordtype">bool</span> yBdy = yNegBdy;
00449               <span class="keywordtype">bool</span> zBdy = zPosBdy;
00450               <span class="keywordflow">if</span>(xBdy) {
00451                 <span class="keywordflow">if</span>(yBdy &amp;&amp; zBdy){
00452                   bdyFlagArr[indices[4]] = ot::TreeNode::CORNER_BDY;
00453                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy || zBdy) {
00454                   bdyFlagArr[indices[4]] = ot::TreeNode::EDGE_BDY;
00455                 }<span class="keywordflow">else</span> {
00456                   bdyFlagArr[indices[4]] = ot::TreeNode::FACE_BDY;
00457                 }
00458               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy) {
00459                 <span class="keywordflow">if</span>(zBdy) {
00460                   bdyFlagArr[indices[4]] = ot::TreeNode::EDGE_BDY;
00461                 }<span class="keywordflow">else</span> {
00462                   bdyFlagArr[indices[4]] = ot::TreeNode::FACE_BDY;
00463                 }
00464               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zBdy) {
00465                 bdyFlagArr[indices[4]] = ot::TreeNode::FACE_BDY;
00466               }
00467             }
00468 
00469             <span class="keywordflow">if</span>(!(hnMask &amp; (1 &lt;&lt; 5))) {
00470               <span class="keywordtype">bool</span> xBdy = xPosBdy;
00471               <span class="keywordtype">bool</span> yBdy = yNegBdy;
00472               <span class="keywordtype">bool</span> zBdy = zPosBdy;
00473               <span class="keywordflow">if</span>(xBdy) {
00474                 <span class="keywordflow">if</span>(yBdy &amp;&amp; zBdy){
00475                   bdyFlagArr[indices[5]] = ot::TreeNode::CORNER_BDY;
00476                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy || zBdy) {
00477                   bdyFlagArr[indices[5]] = ot::TreeNode::EDGE_BDY;
00478                 }<span class="keywordflow">else</span> {
00479                   bdyFlagArr[indices[5]] = ot::TreeNode::FACE_BDY;
00480                 }
00481               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy) {
00482                 <span class="keywordflow">if</span>(zBdy) {
00483                   bdyFlagArr[indices[5]] = ot::TreeNode::EDGE_BDY;
00484                 }<span class="keywordflow">else</span> {
00485                   bdyFlagArr[indices[5]] = ot::TreeNode::FACE_BDY;
00486                 }
00487               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zBdy) {
00488                 bdyFlagArr[indices[5]] = ot::TreeNode::FACE_BDY;
00489               }
00490             }
00491 
00492             <span class="keywordflow">if</span>(!(hnMask &amp; (1 &lt;&lt; 6))) {
00493               <span class="keywordtype">bool</span> xBdy = xNegBdy;
00494               <span class="keywordtype">bool</span> yBdy = yPosBdy;
00495               <span class="keywordtype">bool</span> zBdy = zPosBdy;
00496               <span class="keywordflow">if</span>(xBdy) {
00497                 <span class="keywordflow">if</span>(yBdy &amp;&amp; zBdy){
00498                   bdyFlagArr[indices[6]] = ot::TreeNode::CORNER_BDY;
00499                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy || zBdy) {
00500                   bdyFlagArr[indices[6]] = ot::TreeNode::EDGE_BDY;
00501                 }<span class="keywordflow">else</span> {
00502                   bdyFlagArr[indices[6]] = ot::TreeNode::FACE_BDY;
00503                 }
00504               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy) {
00505                 <span class="keywordflow">if</span>(zBdy) {
00506                   bdyFlagArr[indices[6]] = ot::TreeNode::EDGE_BDY;
00507                 }<span class="keywordflow">else</span> {
00508                   bdyFlagArr[indices[6]] = ot::TreeNode::FACE_BDY;
00509                 }
00510               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zBdy) {
00511                 bdyFlagArr[indices[6]] = ot::TreeNode::FACE_BDY;
00512               }
00513             }
00514 
00515             <span class="keywordflow">if</span>(!(hnMask &amp; (1 &lt;&lt; 7))) {
00516               <span class="keywordtype">bool</span> xBdy = xPosBdy;
00517               <span class="keywordtype">bool</span> yBdy = yPosBdy;
00518               <span class="keywordtype">bool</span> zBdy = zPosBdy;
00519               <span class="keywordflow">if</span>(xBdy) {
00520                 <span class="keywordflow">if</span>(yBdy &amp;&amp; zBdy){
00521                   bdyFlagArr[indices[7]] = ot::TreeNode::CORNER_BDY;
00522                 }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy || zBdy) {
00523                   bdyFlagArr[indices[7]] = ot::TreeNode::EDGE_BDY;
00524                 }<span class="keywordflow">else</span> {
00525                   bdyFlagArr[indices[7]] = ot::TreeNode::FACE_BDY;
00526                 }
00527               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(yBdy) {
00528                 <span class="keywordflow">if</span>(zBdy) {
00529                   bdyFlagArr[indices[7]] = ot::TreeNode::EDGE_BDY;
00530                 }<span class="keywordflow">else</span> {
00531                   bdyFlagArr[indices[7]] = ot::TreeNode::FACE_BDY;
00532                 }
00533               }<span class="keywordflow">else</span> <span class="keywordflow">if</span>(zBdy) {
00534                 bdyFlagArr[indices[7]] = ot::TreeNode::FACE_BDY;
00535               }
00536             }
00537           }<span class="comment">//end if-else has positive boundaries</span>
00538         }<span class="comment">//end if boundary</span>
00539         <span class="keywordflow">if</span>( (!calledGetNodeIndices) &amp;&amp; (da-&gt;<a class="code" href="classot_1_1DA.html#a6">isLUTcompressed</a>()) ) {
00540           da-&gt;<a class="code" href="classot_1_1DA.html#a7">updateQuotientCounter</a>();
00541         }
00542       }<span class="comment">//end for all own elements</span>
00543     }<span class="comment">//end if active</span>
00544 
00545     da-&gt;<a class="code" href="classot_1_1DA.html#z35_13">vecRestoreBuffer</a>&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>&gt;(bdyFlagVec,bdyFlagArr,<span class="keyword">false</span>,<span class="keyword">false</span>,<span class="keyword">false</span>,1);
00546   }<span class="comment">//end function</span>
00547 
<a name="l00548"></a><a class="code" href="namespaceot.html#a85">00548</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a85">includeSiblingsOfBoundary</a>(std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves, 
00549       <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; myFirstOctant, <span class="keyword">const</span> <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>&amp; myLastOctant) {
00550     <a class="code" href="odaUtils_8h.html#a6">PROF_ADD_BDY_SIBLINGS_BEGIN</a>
00551 
00552       std::vector&lt;ot::TreeNode&gt; tmpAllBoundaryLeaves;
00553 
00554     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; allBoundaryLeaves.size(); i++) {
00555       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> thisOct = allBoundaryLeaves[i];
00556       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> thisOctParent = thisOct.<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
00557       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> thisCnum = ((<span class="keywordtype">unsigned</span> int)(thisOct.<a class="code" href="classot_1_1TreeNode.html#z19_3">getChildNumber</a>()));
00558       std::vector&lt;ot::TreeNode&gt; siblingsToAdd;
00559       thisOctParent.<a class="code" href="classot_1_1TreeNode.html#a2">addChildren</a>(siblingsToAdd);
00560       <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j &lt; 8; j++) {
00561         <span class="keywordflow">if</span>( (j != thisCnum) &amp;&amp; (j != (7-thisCnum)) ) {
00562           <span class="keywordflow">if</span>( (siblingsToAdd[j] &gt;= myFirstOctant) &amp;&amp; 
00563               (siblingsToAdd[j] &lt;= myLastOctant) ) {
00564             tmpAllBoundaryLeaves.push_back(siblingsToAdd[j]);
00565           }
00566         }
00567       }   
00568     }<span class="comment">//end for i</span>
00569 
00570     seq::makeVectorUnique&lt;ot::TreeNode&gt;(tmpAllBoundaryLeaves,<span class="keyword">false</span>);
00571 
00572     std::vector&lt;ot::TreeNode&gt; tmp2Vec;
00573 
00574     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> tmpCnt = 0;
00575     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bdyCnt = 0;
00576 
00577     <span class="comment">//The two lists are independently sorted and unique, Now we do a linear</span>
00578     <span class="comment">//pass and merge them so that the result is also sorted and unique.</span>
00579 
00580     <span class="keywordflow">while</span> ( (tmpCnt &lt; tmpAllBoundaryLeaves.size()) &amp;&amp;
00581         (bdyCnt &lt; allBoundaryLeaves.size()) ) {
00582       <span class="keywordflow">if</span> ( tmpAllBoundaryLeaves[tmpCnt] &lt; allBoundaryLeaves[bdyCnt] ) {
00583         tmp2Vec.push_back(tmpAllBoundaryLeaves[tmpCnt]);
00584         tmpCnt++;
00585       }<span class="keywordflow">else</span> <span class="keywordflow">if</span>( tmpAllBoundaryLeaves[tmpCnt] &gt; allBoundaryLeaves[bdyCnt] ) {
00586         tmp2Vec.push_back(allBoundaryLeaves[bdyCnt]);
00587         bdyCnt++;
00588       }<span class="keywordflow">else</span> {
00589         tmp2Vec.push_back(allBoundaryLeaves[bdyCnt]);
00590         bdyCnt++;
00591         tmpCnt++; <span class="comment">//tmpCnt must also be incremented to preserve uniqueness.</span>
00592       }
00593     }
00594 
00595     <span class="keywordflow">while</span> (bdyCnt &lt; allBoundaryLeaves.size()) {
00596       tmp2Vec.push_back(allBoundaryLeaves[bdyCnt]);
00597       bdyCnt++;
00598     }
00599 
00600     <span class="keywordflow">while</span> (tmpCnt &lt; tmpAllBoundaryLeaves.size()) {
00601       tmp2Vec.push_back(tmpAllBoundaryLeaves[tmpCnt]);
00602       tmpCnt++;
00603     }
00604 
00605     allBoundaryLeaves = tmp2Vec;
00606 
00607     tmp2Vec.clear();
00608     tmpAllBoundaryLeaves.clear();
00609 
00610     <a class="code" href="odaUtils_8h.html#a7">PROF_ADD_BDY_SIBLINGS_END</a>
00611   }<span class="comment">//end function</span>
00612 
<a name="l00613"></a><a class="code" href="namespaceot.html#a86">00613</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a86">prepareAprioriCommMessagesInDAtype1</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; in,
00614       std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves, std::vector&lt;ot::TreeNode&gt;&amp; blocks,
00615       <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; allBlocks, <span class="keywordtype">int</span> myRank, <span class="keywordtype">int</span> npes, <span class="keywordtype">int</span>* sendCnt,
00616       std::vector&lt;std::vector&lt;unsigned int&gt; &gt;&amp; sendNodes) {
00617     <a class="code" href="odaUtils_8h.html#a10">PROF_DA_APRIORI_COMM_BEGIN</a>
00618 
00619       std::vector&lt;unsigned int&gt; bdy2elem;
00620 
00621     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bdyCnt = 0;
00622     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allCnt = 0;
00623 
00624     <span class="keywordflow">while</span> (bdyCnt &lt; allBoundaryLeaves.size()) {
00625       <span class="keywordflow">if</span> ( allBoundaryLeaves[bdyCnt] &lt; in[allCnt]) {
00626         bdyCnt++;
00627       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( allBoundaryLeaves[bdyCnt] &gt; in[allCnt]) {
00628         allCnt++;
00629       } <span class="keywordflow">else</span> {
00630         <span class="comment">//Both are equal.               </span>
00631         bdy2elem.push_back(allCnt);
00632         bdyCnt++;
00633       }
00634     }
00635 
00636     <span class="comment">//This step is necessary because some elements of allBoundaryLeaves were not</span>
00637     <span class="comment">//copied from the "in" vector, instead we generated them directly. So these</span>
00638     <span class="comment">//octants will not have correct flags set. So we find the corresponding copy</span>
00639     <span class="comment">//in the "in" vector.  </span>
00640     allBoundaryLeaves.clear();
00641     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; bdy2elem.size(); i++) {
00642       allBoundaryLeaves.push_back(in[bdy2elem[i]]);
00643     }
00644 
00645     <span class="comment">// 3. Reduce the list of global blocks to a smaller list that only has the</span>
00646     <span class="comment">// blocks which neighbour ones own blocks.</span>
00647 
00648     <span class="comment">//First mark your own blocks as being singular or not.</span>
00649     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allBdyCnt = 0;
00650     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; blocks.size(); i++) {
00651       <span class="keywordflow">while</span>( (allBdyCnt &lt; allBoundaryLeaves.size()) &amp;&amp;
00652           (allBoundaryLeaves[allBdyCnt] &lt; blocks[i]) ) {
00653         allBdyCnt++;
00654       }
00655       <span class="comment">//Note, even if a block is Singular but is</span>
00656       <span class="comment">//not a ghost candidates (i.e., it is completely internal).</span>
00657       <span class="comment">// It will be treated as being NOT singular.</span>
00658       <span class="keywordtype">bool</span> isSingular = <span class="keyword">false</span>;
00659       <span class="keywordflow">if</span>( (allBdyCnt &lt; allBoundaryLeaves.size()) &amp;&amp;
00660           (allBoundaryLeaves[allBdyCnt] == blocks[i]) ) {
00661         isSingular = <span class="keyword">true</span>;
00662       }
00663       <span class="keywordflow">if</span>(isSingular) {
00664         blocks[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(1);
00665       }<span class="keywordflow">else</span> {
00666         blocks[i].<a class="code" href="classot_1_1TreeNode.html#z19_17">setWeight</a>(0);
00667       }
00668     }
00669 
00670     std::vector&lt;ot::TreeNode&gt; myNhBlocks;
00671     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; blocks.size(); j++) {
00672       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxX;
00673       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxY;
00674       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxZ;
00675       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinX;
00676       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinY;
00677       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinZ;
00678       <span class="keywordflow">if</span>(blocks[j].getWeight()) {
00679         <span class="comment">//Since the subsequent selection is done based on the octant's parent's</span>
00680         <span class="comment">//neighbours, Singular blocks must be handled differently.</span>
00681         myMaxX = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>().<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00682         myMaxY = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>().<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
00683         myMaxZ = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>().<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
00684         myMinX = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>().<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00685         myMinY = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>().<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00686         myMinZ = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>().<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00687       }<span class="keywordflow">else</span> {
00688         myMaxX = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00689         myMaxY = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
00690         myMaxZ = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
00691         myMinX = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00692         myMinY = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00693         myMinZ = blocks[j].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00694       }
00695       <span class="keywordtype">double</span> myLenX = (double)(myMaxX-myMinX);
00696       <span class="keywordtype">double</span> myLenY = (double)(myMaxY-myMinY);
00697       <span class="keywordtype">double</span> myLenZ = (double)(myMaxZ-myMinZ);
00698       <span class="keywordtype">double</span> myXc  = ((double)(myMinX + myMaxX))/2.0;
00699       <span class="keywordtype">double</span> myYc  = ((double)(myMinY + myMaxY))/2.0;
00700       <span class="keywordtype">double</span> myZc  = ((double)(myMinZ + myMaxZ))/2.0;
00701       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; allBlocks.size(); k++) {
00702         <span class="keywordflow">if</span> ( (allBlocks[k] &gt;= blocks[0]) &amp;&amp; 
00703             (allBlocks[k] &lt;= blocks[blocks.size()-1]) ) {
00704           <span class="comment">//ignore my own blocks</span>
00705           <span class="keywordflow">continue</span>;
00706         }
00707         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMinX = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00708         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMaxX = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00709         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMinY = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00710         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMaxY = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
00711         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMinZ = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00712         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMaxZ = allBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
00713         <span class="keywordtype">double</span> hisLenX = (double)(hisMaxX-hisMinX);
00714         <span class="keywordtype">double</span> hisLenY = (double)(hisMaxY-hisMinY);
00715         <span class="keywordtype">double</span> hisLenZ = (double)(hisMaxZ-hisMinZ);
00716         <span class="keywordtype">double</span> hisXc  = ((double)(hisMinX + hisMaxX))/2.0;
00717         <span class="keywordtype">double</span> hisYc  = ((double)(hisMinY + hisMaxY))/2.0;
00718         <span class="keywordtype">double</span> hisZc  = ((double)(hisMinZ + hisMaxZ))/2.0;
00719         <span class="keywordtype">double</span> deltaX = ( (hisXc &gt; myXc) ? (hisXc - myXc) : (myXc - hisXc ) );
00720         <span class="keywordtype">double</span> deltaY = ( (hisYc &gt; myYc) ? (hisYc - myYc) : (myYc - hisYc ) );
00721         <span class="keywordtype">double</span> deltaZ = ( (hisZc &gt; myZc) ? (hisZc - myZc) : (myZc - hisZc ) );
00722 
00723         <span class="comment">//Note: This test will pass if the octants intersect (say one is an</span>
00724         <span class="comment">//ancestor of another) or they simply touch externally.</span>
00725 
00726         <span class="keywordflow">if</span> ((deltaX &lt;= ((hisLenX+myLenX)/2.0)) &amp;&amp;
00727             (deltaY &lt;= ((hisLenY+myLenY)/2.0)) &amp;&amp;
00728             (deltaZ &lt;= ((hisLenZ+myLenZ)/2.0))) {
00729           <span class="comment">//We touch</span>
00730           myNhBlocks.push_back(allBlocks[k]);
00731         }<span class="comment">//end if</span>
00732       }<span class="comment">//end for k</span>
00733     }<span class="comment">//end for j</span>
00734 
00735     <span class="comment">//This also sorts myNhBlocks</span>
00736     seq::makeVectorUnique&lt;ot::TreeNode&gt;(myNhBlocks,<span class="keyword">false</span>);
00737 
00738     sendNodes.resize(npes);
00739     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i &lt; npes; i++) {
00740       sendNodes[i].clear();
00741       sendCnt[i] = 0;
00742     } 
00743 
00744     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j=0; j&lt;allBoundaryLeaves.size(); j++) {
00745       <span class="comment">//It is important to make the selection using the parent. This tackles</span>
00746       <span class="comment">//the cases where some nodes of an octant are hanging and so even if the octant itself</span>
00747       <span class="comment">//does not touch a processor, its parent does and so the replacement for</span>
00748       <span class="comment">//the hanging node will be mapped to that processor. This also handles</span>
00749       <span class="comment">//the case where two or more siblings belong to different processors. By</span>
00750       <span class="comment">//making the test using the parent they will be sent to each other.</span>
00751       <span class="comment">//Moreover, some of the nodes of these children could be hanging and the</span>
00752       <span class="comment">//replacement could belong to a third processor. Even in this case, the</span>
00753       <span class="comment">//octants will be sent to the correct processors. </span>
00754 
00755       <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> parNode = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
00756       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxX = parNode.<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00757       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxY = parNode.<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
00758       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMaxZ = parNode.<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
00759       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinX = parNode.<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00760       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinY = parNode.<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00761       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myMinZ = parNode.<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00762       <span class="keywordtype">double</span> myLenX = (double)(myMaxX-myMinX);
00763       <span class="keywordtype">double</span> myLenY = (double)(myMaxY-myMinY);
00764       <span class="keywordtype">double</span> myLenZ = (double)(myMaxZ-myMinZ);
00765       <span class="keywordtype">double</span> myXc  = ((double)(myMinX + myMaxX))/2.0;
00766       <span class="keywordtype">double</span> myYc  = ((double)(myMinY + myMaxY))/2.0;
00767       <span class="keywordtype">double</span> myZc  = ((double)(myMinZ + myMaxZ))/2.0;
00768       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> lastP = npes;
00769       <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; myNhBlocks.size(); k++) {
00770         <span class="keywordflow">if</span> (myNhBlocks[k].getWeight() == lastP) {
00771           <span class="keywordflow">continue</span>;
00772         }
00773         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMinX = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a17">minX</a>();
00774         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMaxX = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a14">maxX</a>();
00775         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMinY = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a18">minY</a>();
00776         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMaxY = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a15">maxY</a>();
00777         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMinZ = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a19">minZ</a>();
00778         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hisMaxZ = myNhBlocks[k].<a class="code" href="classot_1_1TreeNode.html#a16">maxZ</a>();
00779         <span class="keywordtype">double</span> hisLenX = (double)(hisMaxX-hisMinX);
00780         <span class="keywordtype">double</span> hisLenY = (double)(hisMaxY-hisMinY);
00781         <span class="keywordtype">double</span> hisLenZ = (double)(hisMaxZ-hisMinZ);
00782         <span class="keywordtype">double</span> hisXc  = ((double)(hisMinX + hisMaxX))/2.0;
00783         <span class="keywordtype">double</span> hisYc  = ((double)(hisMinY + hisMaxY))/2.0;
00784         <span class="keywordtype">double</span> hisZc  = ((double)(hisMinZ + hisMaxZ))/2.0;
00785         <span class="keywordtype">double</span> deltaX = ( (hisXc &gt; myXc) ? (hisXc - myXc) : (myXc - hisXc ) );
00786         <span class="keywordtype">double</span> deltaY = ( (hisYc &gt; myYc) ? (hisYc - myYc) : (myYc - hisYc ) );
00787         <span class="keywordtype">double</span> deltaZ = ( (hisZc &gt; myZc) ? (hisZc - myZc) : (myZc - hisZc ) );
00788 
00789         <span class="comment">//Note: This test will pass if the octants intersect (say one is an</span>
00790         <span class="comment">//ancestor of another) or they simply touch externally.</span>
00791 
00792         <span class="keywordflow">if</span> ((deltaX &lt;= ((hisLenX+myLenX)/2.0)) &amp;&amp;
00793             (deltaY &lt;= ((hisLenY+myLenY)/2.0)) &amp;&amp;
00794             (deltaZ &lt;= ((hisLenZ+myLenZ)/2.0))) {
00795           <span class="comment">//We touch</span>
00796           sendNodes[myNhBlocks[k].getWeight()].push_back(bdy2elem[j]); 
00797           sendCnt[myNhBlocks[k].getWeight()]++;
00798           lastP = myNhBlocks[k].getWeight();
00799         }<span class="comment">//end if</span>
00800       }<span class="comment">//end for k</span>
00801     }<span class="comment">//end for j</span>
00802 
00803     <a class="code" href="odaUtils_8h.html#a11">PROF_DA_APRIORI_COMM_END</a>
00804   }<span class="comment">//end function</span>
00805 
<a name="l00806"></a><a class="code" href="namespaceot.html#a87">00806</a>   <span class="keywordtype">void</span> <a class="code" href="namespaceot.html#a87">prepareAprioriCommMessagesInDAtype2</a>(<span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; in,
00807       std::vector&lt;ot::TreeNode&gt;&amp; allBoundaryLeaves, std::vector&lt;ot::TreeNode&gt;&amp; blocks,
00808       <span class="keyword">const</span> std::vector&lt;ot::TreeNode&gt;&amp; minsOfBlocks, <span class="keywordtype">int</span> myRank, <span class="keywordtype">int</span> npes, <span class="keywordtype">int</span>* sendCnt,
00809       std::vector&lt;std::vector&lt;unsigned int&gt; &gt;&amp; sendNodes) {
00810     <a class="code" href="odaUtils_8h.html#a10">PROF_DA_APRIORI_COMM_BEGIN</a>
00811 
00812       std::vector&lt;unsigned int&gt; bdy2elem;
00813 
00814     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bdyCnt = 0;
00815     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> allCnt = 0;
00816     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxDepth = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_7">getMaxDepth</a>();
00817     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = in[0].<a class="code" href="classot_1_1TreeNode.html#z19_4">getDim</a>(); 
00818 
00819     <span class="keywordflow">while</span> (bdyCnt &lt; allBoundaryLeaves.size()) {
00820       <span class="keywordflow">if</span> ( allBoundaryLeaves[bdyCnt] &lt; in[allCnt]) {
00821         bdyCnt++;
00822       } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( allBoundaryLeaves[bdyCnt] &gt; in[allCnt]) {
00823         allCnt++;
00824       } <span class="keywordflow">else</span> {
00825         <span class="comment">//Both are equal.               </span>
00826         bdy2elem.push_back(allCnt);
00827         bdyCnt++;
00828       }
00829     }
00830 
00831     <span class="comment">//This step is necessary because some elements of allBoundaryLeaves were not</span>
00832     <span class="comment">//copied from the "in" vector, instead we generated them directly. So these</span>
00833     <span class="comment">//octants will not have correct flags set. So we find the corresponding copy</span>
00834     <span class="comment">//in the "in" vector.  </span>
00835     allBoundaryLeaves.clear();
00836     <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; bdy2elem.size(); i++) {
00837       allBoundaryLeaves.push_back(in[bdy2elem[i]]);
00838     }
00839 
00840     sendNodes.resize(npes);
00841     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; npes; i++) {
00842       sendNodes[i].clear();
00843       sendCnt[i] = 0;
00844     } 
00845 
00846     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; allBoundaryLeaves.size(); j++) {
00847       <span class="comment">//It is important to make the selection using the parent. This tackles</span>
00848       <span class="comment">//the cases where some nodes of an octant are hanging and so even if the octant itself</span>
00849       <span class="comment">//does not touch a processor, its parent does and so the replacement for</span>
00850       <span class="comment">//the hanging node will be mapped to that processor. This also handles</span>
00851       <span class="comment">//the case where two or more siblings belong to different processors. By</span>
00852       <span class="comment">//making the test using the parent they will be sent to each other.</span>
00853       <span class="comment">//Moreover, some of the nodes of these children could be hanging and the</span>
00854       <span class="comment">//replacement could belong to a third processor. Even in this case, the</span>
00855       <span class="comment">//octants will be sent to the correct processors. </span>
00856 
00857       <span class="comment">//1. We must not miss any pre-ghost elements that point to one of our own</span>
00858       <span class="comment">//octants, i.e. any pre-ghost element that we integrate over. This is</span>
00859       <span class="comment">//because we need to build the nlist for these octants as well.</span>
00860       <span class="comment">//2. We might get some extra ghosts they will be marked as FOREIGN and</span>
00861       <span class="comment">//will be ignored.</span>
00862       <span class="comment">//3. We must try to get as many post-ghost octants as possible to avoid</span>
00863       <span class="comment">//misses later and hence reduce subsequent communication. We should get</span>
00864       <span class="comment">//all direct post-ghost octants.</span>
00865       <span class="comment">//4. Post-ghosts are read-only and so it is sufficient to test for</span>
00866       <span class="comment">//post-ghost using its anchor</span>
00867       std::vector&lt;ot::TreeNode&gt; myVertices;
00868       std::vector&lt;ot::TreeNode&gt; parVertices;
00869       std::vector&lt;ot::TreeNode&gt; anchorMirrors;
00870 
00871       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myX = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00872       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myY = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00873       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myZ = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00874 
00875       <span class="comment">//keys to check if you are a pre-ghost</span>
00876       <span class="comment">//Positive boundaries will not be pre-ghosts</span>
00877       <span class="keywordflow">if</span>(!(allBoundaryLeaves[j].getFlag() &amp; ot::TreeNode::BOUNDARY)) {
00878         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myLev = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00879         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> mySz = (1u&lt;&lt;(maxDepth - myLev));
00880 
00881         <span class="comment">//All vertices except my anchor. Since my anchor belongs to my processor</span>
00882         myVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX + mySz), myY, myZ, maxDepth, dim, maxDepth));
00883         myVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(myX, (myY + mySz), myZ, maxDepth, dim, maxDepth));
00884         myVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX + mySz), (myY + mySz), myZ, maxDepth, dim, maxDepth));
00885         myVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(myX, myY, (myZ + mySz), maxDepth, dim, maxDepth));
00886         myVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX + mySz), myY, (myZ + mySz), maxDepth, dim, maxDepth));
00887         myVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(myX, (myY + mySz), (myZ + mySz), maxDepth, dim, maxDepth));
00888         myVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX + mySz), (myY + mySz), (myZ + mySz), maxDepth, dim, maxDepth));
00889 
00890         <a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a> parNode = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#a9">getParent</a>();
00891         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> myCnum = allBoundaryLeaves[j].<a class="code" href="classot_1_1TreeNode.html#z19_3">getChildNumber</a>();
00892         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parX = parNode.<a class="code" href="classot_1_1TreeNode.html#z19_12">getX</a>();
00893         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parY = parNode.<a class="code" href="classot_1_1TreeNode.html#z19_13">getY</a>();
00894         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parZ = parNode.<a class="code" href="classot_1_1TreeNode.html#z19_14">getZ</a>();
00895         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parLev = parNode.<a class="code" href="classot_1_1TreeNode.html#z19_6">getLevel</a>();
00896         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> parSz = (1u&lt;&lt;(maxDepth - parLev));
00897 
00898         <span class="comment">//vertices numbers myCnum and (7 - myCnum) can't be hanging and so they</span>
00899         <span class="comment">//will not be mapped to the corresponding vertices of my parent</span>
00900         <span class="keywordflow">if</span>( (myCnum != 0) &amp;&amp; (myCnum != 7) ) {
00901           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY, parZ, maxDepth, dim, maxDepth));
00902         }
00903         <span class="keywordflow">if</span>( (myCnum != 1) &amp;&amp; (myCnum != 6) ) {
00904           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((parX + parSz), parY, parZ, maxDepth, dim, maxDepth));
00905         }
00906         <span class="keywordflow">if</span>( (myCnum != 2) &amp;&amp; (myCnum != 5) ) {
00907           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, (parY + parSz), parZ, maxDepth, dim, maxDepth));
00908         }
00909         <span class="keywordflow">if</span>( (myCnum != 3) &amp;&amp; (myCnum != 4) ) {
00910           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((parX + parSz), (parY + parSz), parZ, maxDepth, dim, maxDepth));
00911         }
00912         <span class="keywordflow">if</span>( (myCnum != 4) &amp;&amp; (myCnum != 3) ) {
00913           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, parY, (parZ + parSz), maxDepth, dim, maxDepth));
00914         }
00915         <span class="keywordflow">if</span>( (myCnum != 5) &amp;&amp; (myCnum != 2) ) {
00916           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((parX + parSz), parY, (parZ + parSz), maxDepth, dim, maxDepth));
00917         }
00918         <span class="keywordflow">if</span>( (myCnum != 6) &amp;&amp; (myCnum != 1) ) {
00919           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(parX, (parY + parSz), (parZ + parSz), maxDepth, dim, maxDepth));
00920         }
00921         <span class="keywordflow">if</span>( (myCnum != 7) &amp;&amp; (myCnum != 0) ) {
00922           parVertices.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((parX + parSz), (parY + parSz),
00923                 (parZ + parSz), maxDepth, dim, maxDepth));
00924         }
00925 
00926       }<span class="comment">//end if positive boundary</span>
00927 
00928       <span class="comment">//Keys to check if you are a post-ghost</span>
00929       <span class="comment">//If the anchor is hanging we need not send it. When some processor searches</span>
00930       <span class="comment">//for this node as its primary key and does not find it, it will be</span>
00931       <span class="comment">//understood that this is hanging  </span>
00932       <span class="keywordflow">if</span>(allBoundaryLeaves[j].getFlag() &amp; ot::TreeNode::NODE) {
00933         <span class="comment">//-x</span>
00934         <span class="keywordflow">if</span>( myX ) {
00935           anchorMirrors.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX - 1), myY, myZ, 
00936                 maxDepth, dim, maxDepth));
00937         }
00938         <span class="comment">//-y</span>
00939         <span class="keywordflow">if</span>( myY ) {
00940           anchorMirrors.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(myX, (myY - 1), myZ, 
00941                 maxDepth, dim, maxDepth));
00942         }
00943         <span class="comment">//-z</span>
00944         <span class="keywordflow">if</span>( myZ ) {
00945           anchorMirrors.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(myX, myY, (myZ - 1), 
00946                 maxDepth, dim, maxDepth));
00947         }
00948         <span class="comment">//-xy</span>
00949         <span class="keywordflow">if</span>( myX &amp;&amp; myY ) {
00950           anchorMirrors.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX - 1), (myY - 1), myZ, 
00951                 maxDepth, dim, maxDepth));
00952         }
00953         <span class="comment">//-yz</span>
00954         <span class="keywordflow">if</span>( myY &amp;&amp; myZ ) {
00955           anchorMirrors.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>(myX, (myY - 1), (myZ - 1),
00956                 maxDepth, dim, maxDepth));
00957         }
00958         <span class="comment">//-zx</span>
00959         <span class="keywordflow">if</span>( myZ &amp;&amp; myX ) {
00960           anchorMirrors.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX - 1), myY, (myZ - 1),
00961                 maxDepth, dim, maxDepth));
00962         }
00963         <span class="comment">//-xyz</span>
00964         <span class="keywordflow">if</span>( myX &amp;&amp; myY &amp;&amp; myZ ) {
00965           anchorMirrors.push_back(<a class="code" href="classot_1_1TreeNode.html">ot::TreeNode</a>((myX - 1), (myY - 1), (myZ - 1),
00966                 maxDepth, dim, maxDepth));
00967         }
00968       }<span class="comment">//end if hanging anchor</span>
00969 
00970       std::vector&lt;unsigned int&gt; pIds;
00971       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; parVertices.size(); k++) {
00972         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00973         seq::maxLowerBound&lt;ot::TreeNode&gt;(minsOfBlocks, parVertices[k], idx, NULL, NULL);
00974         pIds.push_back(idx);
00975       }
00976 
00977       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; anchorMirrors.size(); k++) {
00978         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00979         seq::maxLowerBound&lt;ot::TreeNode&gt;(minsOfBlocks, anchorMirrors[k], idx, NULL, NULL);
00980         pIds.push_back(idx);
00981       }
00982 
00983       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; myVertices.size(); k++) {
00984         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx;
00985         seq::maxLowerBound&lt;ot::TreeNode&gt;(minsOfBlocks, myVertices[k], idx, NULL, NULL);
00986         pIds.push_back(idx);
00987       }<span class="comment">//end for k</span>
00988 
00989       <span class="comment">//Do not send the same octant to the same processor twice </span>
00990       seq::makeVectorUnique&lt;unsigned int&gt;(pIds, <span class="keyword">false</span>);
00991 
00992       <span class="keywordflow">for</span>(<span class="keywordtype">int</span> k = 0; k &lt; pIds.size(); k++) {
00993         <span class="comment">//Send to processor pIds[k] </span>
00994         <span class="comment">//Only send to other processors  </span>
00995         <span class="keywordflow">if</span>(pIds[k] != myRank) {
00996           sendNodes[pIds[k]].push_back(bdy2elem[j]); 
00997           sendCnt[pIds[k]]++;
00998         }
00999       }<span class="comment">//end for k</span>
01000     }<span class="comment">//end for j</span>
01001 
01002     <a class="code" href="odaUtils_8h.html#a11">PROF_DA_APRIORI_COMM_END</a>
01003   }<span class="comment">//end function</span>
01004 
01005 }<span class="comment">//end namespace</span>
01006 
01007 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:32 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
