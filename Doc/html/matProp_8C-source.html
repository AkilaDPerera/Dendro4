<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>DENDRO: /net/ac190/www-db1/grads/r/rahulss/Dendro/examples/matProp.C Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="dirs.html">Directories</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a></div>
<div class="nav">
<a class="el" href="dir_000000.html">examples</a></div>
<h1>matProp.C</h1><a href="matProp_8C.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment">00001 
00007 <span class="preprocessor">#include "<a class="code" href="omg_8h.html">omg.h</a>"</span>
00008 <span class="preprocessor">#include "<a class="code" href="oda_8h.html">oda.h</a>"</span> 
00009 <span class="preprocessor">#include "<a class="code" href="omgJac_8h.html">omgJac.h</a>"</span>
00010 <span class="preprocessor">#include "<a class="code" href="parUtils_8h.html">parUtils.h</a>"</span>
00011 
<a name="l00012"></a><a class="code" href="matProp_8C.html#a0">00012</a> <span class="preprocessor">#define SQUARE(x) ((x)*(x))</span>
00013 <span class="preprocessor"></span>
<a name="l00014"></a><a class="code" href="matProp_8C.html#a1">00014</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_FROM_PTS_ELEM_BLOCK {\</span>
00015 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00016 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00017 <span class="preprocessor">  Point pt = da-&gt;getCurrentOffset();\</span>
00018 <span class="preprocessor">  ot::TreeNode me(pt.xint(),pt.yint(),pt.zint(),lev,3,maxD);\</span>
00019 <span class="preprocessor">  matPropArr[2*idx] = lapBase; </span><span class="comment">/*Laplacian's coefficient*/</span>\
00020   matPropArr[2*idx+1] = massBase; <span class="comment">/*Mass Matrix's coefficient*/</span>\
00021   if(ptsCtr &lt; (lapJump.size())) {\
00022     ot::TreeNode lastVisitedPt;\
00023     <span class="comment">/*Assuming pts are sorted in Morton ordering*/</span>\
00024     <span class="comment">/*Assuming pts and local octants are aligned*/</span>\
00025     bool repeat = false;\
00026     do {\
00027       unsigned int ptX = static_cast&lt;unsigned int&gt;(\
00028           pts[(3*ptsCtr)]*static_cast&lt;double&gt;(1u &lt;&lt; (maxD-1)));\
00029       unsigned int ptY = static_cast&lt;unsigned int&gt;(\
00030           pts[(3*ptsCtr)+1]*static_cast&lt;double&gt;(1u &lt;&lt; (maxD-1)));\
00031       unsigned int ptZ = static_cast&lt;unsigned int&gt;(\
00032           pts[(3*ptsCtr)+2]*static_cast&lt;double&gt;(1u &lt;&lt; (maxD-1)));\
00033       ot::TreeNode currPt(ptX,ptY,ptZ,maxD,3,maxD);\
00034       repeat = false;\
00035       if( (currPt &lt; me) &amp;&amp; (ptsCtr &lt; (lapJump.size()-1)) ) {\
00036         repeat = true;\
00037         ptsCtr++;\
00038       } else {\
00039         lastVisitedPt = currPt;\
00040       }\
00041     } while(repeat);\
00042     <span class="comment">/*There could be more than 1 pt. per octant*/</span>\
00043     while( (ptsCtr &lt; lapJump.size()) &amp;&amp; (me.isAncestor(lastVisitedPt) ||\
00044           (me == lastVisitedPt))) {\
00045       matPropArr[2*idx] += lapJump[ptsCtr];\
00046       ptsCtr++;\
00047       if(ptsCtr &lt; lapJump.size()) {\
00048         unsigned int ptX = static_cast&lt;unsigned int&gt;(\
00049             pts[(3*ptsCtr)]*static_cast&lt;double&gt;(1u &lt;&lt; (maxD-1)));\
00050         unsigned int ptY = static_cast&lt;unsigned int&gt;(\
00051             pts[(3*ptsCtr)+1]*static_cast&lt;double&gt;(1u &lt;&lt; (maxD-1)));\
00052         unsigned int ptZ = static_cast&lt;unsigned int&gt;(\
00053             pts[(3*ptsCtr)+2]*static_cast&lt;double&gt;(1u &lt;&lt; (maxD-1)));\
00054         ot::TreeNode currPt(ptX,ptY,ptZ,maxD,3,maxD);\
00055         lastVisitedPt = currPt;\
00056       }\
00057     }\
00058   }\
00059   if(matPropArr[2*idx] &gt; maxCoeff) {\
00060     maxCoeff = matPropArr[2*idx];\
00061   }\
00062   if(matPropArr[2*idx] &lt; minCoeff) {\
00063     minCoeff = matPropArr[2*idx];\
00064   }\
00065 }
00066 
<a name="l00067"></a><a class="code" href="matProp_8C.html#a2">00067</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_1_CUBE_ELEM_BLOCK {\</span>
00068 <span class="preprocessor">  Point pt = da-&gt;getCurrentOffset();\</span>
00069 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00070 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00071 <span class="preprocessor">  double h = ((double)(1u &lt;&lt; (maxD - lev)))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00072 <span class="preprocessor">  double x = ((double)(pt.xint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00073 <span class="preprocessor">  double y = ((double)(pt.yint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00074 <span class="preprocessor">  double z = ((double)(pt.zint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00075 <span class="preprocessor">  matPropArr[2*idx] = 1.0; </span><span class="comment">/*Laplacian's coefficient*/</span>\
00076   matPropArr[2*idx+1] = massBase; <span class="comment">/*Mass Matrix's coefficient*/</span>\
00077   double minX1 = 0.5-h;\
00078   double minY1 = 0.0;\
00079   double minZ1 = 0.0;\
00080   double maxX1 = 0.5+h;\
00081   double maxY1 = 1.0;\
00082   double maxZ1 = 1.0;\
00083   double minX2 = x;\
00084   double minY2 = y;\
00085   double minZ2 = z;\
00086   double maxX2 = (x+h);\
00087   double maxY2 = (y+h);\
00088   double maxZ2 = (z+h);\
00089   bool oneInTwo = ( (minX1 &gt;= minX2) &amp;&amp; (minX1 &lt; maxX2) &amp;&amp;  (minY1 &gt;= minY2) &amp;&amp; (minY1 &lt; maxY2) &amp;&amp;  (minZ1 &gt;= minZ2) &amp;&amp; (minZ1 &lt; maxZ2) );\
00090   bool twoInOne = ( (minX2 &gt;= minX1) &amp;&amp; (minX2 &lt; maxX1) &amp;&amp;  (minY2 &gt;= minY1) &amp;&amp; (minY2 &lt; maxY1) &amp;&amp;  (minZ2 &gt;= minZ1) &amp;&amp; (minZ2 &lt; maxZ1) );\
00091   if( oneInTwo || twoInOne ) {\
00092     double maxOfMinsX = ( (minX2 &gt; minX1) ? minX2 : minX1 );\
00093     double maxOfMinsY = ( (minY2 &gt; minY1) ? minY2 : minY1 );\
00094     double maxOfMinsZ = ( (minZ2 &gt; minZ1) ? minZ2 : minZ1 );\
00095     double minOfMaxsX = ( (maxX2 &lt; maxX1) ? maxX2 : maxX1 );\
00096     double minOfMaxsY = ( (maxY2 &lt; maxY1) ? maxY2 : maxY1 );\
00097     double minOfMaxsZ = ( (maxZ2 &lt; maxZ1) ? maxZ2 : maxZ1 );\
00098     double intersectionVolume = ((minOfMaxsX - maxOfMinsX)*(minOfMaxsY - maxOfMinsY)*(minOfMaxsZ - maxOfMinsZ))/(h*h*h);\
00099     if(intersectionVolume &lt;= 0.0) {\
00100       std::cout&lt;&lt;"intesection Volume: "&lt;&lt;intersectionVolume&lt;&lt;" x: "&lt;&lt;x&lt;&lt;" y: "&lt;&lt;y&lt;&lt;" z: "&lt;&lt;z&lt;&lt;" h: "&lt;&lt;h&lt;&lt;" oneInTwo: "&lt;&lt;oneInTwo&lt;&lt;" twoInOne: "&lt;&lt;twoInOne&lt;&lt;std::endl;\
00101       assert(false);\
00102     }\
00103     matPropArr[2*idx] += lapFac*intersectionVolume; <span class="comment">/*Laplacian's coefficient*/</span>\
00104     matPropArr[2*idx+1]+= massFac*intersectionVolume;<span class="comment">/*Mass Matrix's coefficient*/</span>\
00105   }\
00106   if(matPropArr[2*idx] &gt; maxCoeff) {\
00107     maxCoeff = matPropArr[2*idx];\
00108   }\
00109   if(matPropArr[2*idx] &lt; minCoeff) {\
00110     minCoeff = matPropArr[2*idx];\
00111   }\
00112 }
00113 
<a name="l00114"></a><a class="code" href="matProp_8C.html#a3">00114</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_MULTIPLE_CUBES_ELEM_BLOCK {\</span>
00115 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00116 <span class="preprocessor">  matPropArr[2*idx] = 1.0; </span><span class="comment">/*Laplacian's coefficient*/</span>\
00117   matPropArr[2*idx+1] = massBase; <span class="comment">/*Mass Matrix's coefficient*/</span>\
00118   unsigned int procElementSize = da-&gt;getElementSize();\
00119   unsigned int numCubesInterval = procElementSize/numCubes;\
00120   if( (idx % numCubesInterval) == 0 ) {\
00121     matPropArr[2*idx] += lapFac; <span class="comment">/*Laplacian's coefficient*/</span>\
00122     matPropArr[2*idx+1] +=  massFac; <span class="comment">/*Mass Matrix's coefficient*/</span>\
00123   }\
00124   if(matPropArr[2*idx] &gt; maxCoeff) {\
00125     maxCoeff = matPropArr[2*idx];\
00126   }\
00127   if(matPropArr[2*idx] &lt; minCoeff) {\
00128     minCoeff = matPropArr[2*idx];\
00129   }\
00130 }
00131 
<a name="l00132"></a><a class="code" href="matProp_8C.html#a4">00132</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_CHECKER_BOARD_ELEM_BLOCK {\</span>
00133 <span class="preprocessor">  Point pt = da-&gt;getCurrentOffset();\</span>
00134 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00135 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00136 <span class="preprocessor">  double h = ((double)(1u &lt;&lt; (maxD - lev)))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00137 <span class="preprocessor">  double x = ((double)(pt.xint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00138 <span class="preprocessor">  double y = ((double)(pt.yint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00139 <span class="preprocessor">  double z = ((double)(pt.zint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00140 <span class="preprocessor">  matPropArr[2*idx+1] = massBase; </span><span class="comment">/*Mass Matrix's coefficient*/</span>\
00141   if(z &gt;= 0.0 &amp;&amp; z &lt; 0.5 ) {\
00142     if(x &gt;= 0.0 &amp;&amp; x &lt; 0.5 &amp;&amp; y &gt;= 0.0 &amp;&amp; y &lt; 0.5) {\
00143       matPropArr[2*idx] = lapFac; <span class="comment">/*Laplacian's coefficient*/</span>\
00144     } else if(x &gt;= 0.5 &amp;&amp; x &lt; 1.0 &amp;&amp; y &gt;= 0.0 &amp;&amp; y &lt; 0.5) {\
00145       matPropArr[2*idx] = 1.0; <span class="comment">/*Laplacian's coefficient*/</span>\
00146     } else if(x &gt;= 0.0 &amp;&amp; x &lt; 0.5 &amp;&amp; y &gt;= 0.5 &amp;&amp; y &lt; 1.0) {\
00147       matPropArr[2*idx] = 1.0; <span class="comment">/*Laplacian's coefficient*/</span>\
00148     } else {\
00149       matPropArr[2*idx] = lapFac; <span class="comment">/*Laplacian's coefficient*/</span>\
00150     }\
00151   } else {\
00152     if(x &gt;= 0.0 &amp;&amp; x &lt; 0.5 &amp;&amp; y &gt;= 0.0 &amp;&amp; y &lt; 0.5) {\
00153       matPropArr[2*idx] = 1.0; <span class="comment">/*Laplacian's coefficient*/</span>\
00154     } else if(x &gt;= 0.5 &amp;&amp; x &lt; 1.0 &amp;&amp; y &gt;= 0.0 &amp;&amp; y &lt; 0.5) {\
00155       matPropArr[2*idx] = lapFac; <span class="comment">/*Laplacian's coefficient*/</span>\
00156     } else if(x &gt;= 0.0 &amp;&amp; x &lt; 0.5 &amp;&amp; y &gt;= 0.5 &amp;&amp; y &lt; 1.0) {\
00157       matPropArr[2*idx] = lapFac; <span class="comment">/*Laplacian's coefficient*/</span>\
00158     } else {\
00159       matPropArr[2*idx] = 1.0; <span class="comment">/*Laplacian's coefficient*/</span>\
00160     }\
00161   }\
00162   if(matPropArr[2*idx] &gt; maxCoeff) {\
00163     maxCoeff = matPropArr[2*idx];\
00164   }\
00165   if(matPropArr[2*idx] &lt; minCoeff) {\
00166     minCoeff = matPropArr[2*idx];\
00167   }\
00168 }
00169 
<a name="l00170"></a><a class="code" href="matProp_8C.html#a5">00170</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_ANALYTIC_FN_ELEM_BLOCK {\</span>
00171 <span class="preprocessor">  Point pt = da-&gt;getCurrentOffset();\</span>
00172 <span class="preprocessor">  unsigned int idx = da-&gt;curr();\</span>
00173 <span class="preprocessor">  unsigned int lev = da-&gt;getLevel(idx);\</span>
00174 <span class="preprocessor">  double h = ((double)(1u &lt;&lt; (maxD - lev)))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00175 <span class="preprocessor">  double x = ((double)(pt.xint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00176 <span class="preprocessor">  double y = ((double)(pt.yint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00177 <span class="preprocessor">  double z = ((double)(pt.zint()))/((double)(1u &lt;&lt; (maxD-1)));\</span>
00178 <span class="preprocessor">  matPropArr[2*idx+1] = massBase; </span><span class="comment">/*Mass Matrix's coefficient*/</span>\
00179   <span class="comment">/*Laplacian's coefficient*/</span>\
00180   matPropArr[2*idx] = 1.0 +\
00181   (lapFac*(SQUARE(cos(lapFreq*M_PI*(x+(0.5*h))))+\
00182            SQUARE(cos(lapFreq*M_PI*(y+(0.5*h))))+\
00183            SQUARE(cos(lapFreq*M_PI*(z+(0.5*h))))));\
00184   if(matPropArr[2*idx] &gt; maxCoeff) {\
00185     maxCoeff = matPropArr[2*idx];\
00186   }\
00187   if(matPropArr[2*idx] &lt; minCoeff) {\
00188     minCoeff = matPropArr[2*idx];\
00189   }\
00190 }
00191 
<a name="l00192"></a><a class="code" href="matProp_8C.html#a6">00192</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_FINE_TO_COARSE_ELEM_BLOCK {\</span>
00193 <span class="preprocessor">  </span><span class="comment">/*The fine loop is always Writable, but the coarse loop*/</span>\
00194   <span class="comment">/*could be Independent or W_Dependent. Hence the fine counter must*/</span>\
00195   <span class="comment">/*be incremented properly to align with the coarse.*/</span>\
00196   unsigned int idxC= da-&gt;curr();\
00197   Point Cpt = da-&gt;getCurrentOffset();\
00198   assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00199   while(daf-&gt;getCurrentOffset() != Cpt) {\
00200     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00201     assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00202   }\
00203   if(daf-&gt;getLevel(daf-&gt;curr()) == da-&gt;getLevel(idxC)) {\
00204     <span class="comment">/*The coarse and fine elements are the same,*/</span>\
00205     assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00206     unsigned int idxF = daf-&gt;curr();\
00207     matPropArr[2*idxC] = fMatArr[2*idxF];\
00208     matPropArr[2*idxC+1] = fMatArr[2*idxF+1];\
00209     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00210   }else {\
00211     double cLapVal = 0.0;\
00212     double cMassVal = 0.0;\
00213     for(unsigned char cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
00214       <span class="comment">/*The coarse and fine elements are NOT the same. */</span>\
00215       <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
00216       <span class="comment">/*These are the underlying fine elements.*/</span>\
00217       assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00218       unsigned int idxF = daf-&gt;curr();\
00219       cLapVal += fMatArr[2*idxF];\
00220       cMassVal += fMatArr[2*idxF+1];\
00221       daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00222     }\
00223     matPropArr[2*idxC] = (cLapVal/8.0);\
00224     matPropArr[2*idxC+1] = (cMassVal/8.0);\
00225   }\
00226   if(matPropArr[2*idxC] &gt; maxCoeff) {\
00227     maxCoeff = matPropArr[2*idxC];\
00228   }\
00229   if(matPropArr[2*idxC] &lt; minCoeff) {\
00230     minCoeff = matPropArr[2*idxC];\
00231   }\
00232 }
00233 
<a name="l00234"></a><a class="code" href="matProp_8C.html#a7">00234</a> <span class="preprocessor">#define CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK {\</span>
00235 <span class="preprocessor">  if( damg_i-&gt;da_aux == NULL ) {\</span>
00236 <span class="preprocessor">    daf = da;\</span>
00237 <span class="preprocessor">    fMatPropVec = matPropVecPtr;\</span>
00238 <span class="preprocessor">    changedPartition  = false;\</span>
00239 <span class="preprocessor">  }else {\</span>
00240 <span class="preprocessor">    daf = damg_i-&gt;da_aux;\</span>
00241 <span class="preprocessor">    </span><span class="comment">/*Need to Scatter Values*/</span>\
00242     fMatPropVec = new std::vector&lt;double&gt;;\
00243     changedPartition  = true;\
00244     <span class="comment">/*elemental - non-ghosted*/</span>\
00245     std::vector&lt;double&gt; tmpVec1;\
00246     da-&gt;createVector&lt;double&gt;(tmpVec1,true,false,2);\
00247     double *vec1Arr = NULL;\
00248     <span class="comment">/*Elemental,non-Ghosted,Write,2 Dof.*/</span>\
00249     da-&gt;vecGetBuffer&lt;double&gt;(tmpVec1,vec1Arr,true,false,false,2);\
00250     matPropArr = NULL;\
00251     <span class="comment">/*Elemental,Ghosted,Read-only,2 Dof.*/</span>\
00252     da-&gt;vecGetBuffer&lt;double&gt;((*matPropVecPtr), matPropArr, true, true, true, 2);\
00253     if(da-&gt;iAmActive()) {\
00254       for(da-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00255           da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00256           da-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\
00257         unsigned int idx = da-&gt;curr();\
00258         vec1Arr[2*idx] = matPropArr[2*idx];\
00259         vec1Arr[2*idx+1] = matPropArr[2*idx+1];\
00260       }\
00261     }\
00262     da-&gt;vecRestoreBuffer&lt;double&gt;((*matPropVecPtr), matPropArr, true, true, true, 2);\
00263     da-&gt;vecRestoreBuffer&lt;double&gt;(tmpVec1,vec1Arr,true,false,false,2);\
00264     par::scatterValues&lt;double&gt;(tmpVec1, (*fMatPropVec), (2*(daf-&gt;getElementSize())), da-&gt;getComm());\
00265     tmpVec1.clear();\
00266   }\
00267 }
00268 
<a name="l00269"></a><a class="code" href="matProp_8C.html#a8">00269</a> <span class="preprocessor">#define SET_SINGLE_LEVEL_MAT_PROP_BLOCK(ELEM_MAT_PROP_BLOCK, EXTRA_INITS)  {\</span>
00270 <span class="preprocessor">  damg_i-&gt;user = ctx;\</span>
00271 <span class="preprocessor">  da = damg_i-&gt;da;\</span>
00272 <span class="preprocessor">  comm = da-&gt;getCommActive();\</span>
00273 <span class="preprocessor">  </span><span class="comment">/*Elem,Ghosted, 2-dof vector.*/</span>\
00274   <span class="comment">/*Note: I am creating a ghosted vector only*/</span>\
00275   <span class="comment">/*because the mat-vec will need it.*/</span>\
00276   <span class="comment">/*So this way, I can avoid mallocs inside the mat-vec.*/</span>\
00277   da-&gt;createVector&lt;double&gt;((*matPropVecPtr), true, true, 2);\
00278   for(unsigned int i = 0; i &lt; matPropVecPtr-&gt;size(); i++) {\
00279     (*matPropVecPtr)[i] = 0.0;\
00280   }\
00281   <span class="comment">/*Elemental,Ghosted,Write,2 Dof.*/</span>\
00282   da-&gt;vecGetBuffer&lt;double&gt;((*matPropVecPtr), matPropArr,\
00283       true, true, false, 2);\
00284   maxD =  da-&gt;getMaxDepth();\
00285   if(da-&gt;iAmActive()) {\
00286     MPI_Comm_rank(comm,&amp;rank);\
00287     double maxCoeff = 0.0;\
00288     double minCoeff = 1.0e+8;\
00289     double globalMaxCoeff;\
00290     double globalMinCoeff;\
00291     <span class="comment">/*Any independent element has all its 8*/</span>\
00292     <span class="comment">/*indices pointing to elements the same processor owns.*/</span>\
00293     <span class="comment">/*So, even if any independent element is sent to*/</span>\
00294     <span class="comment">/*another processor as a ghost (This is rare, but might*/</span>\
00295     <span class="comment">/*happen due to a-priori communication and partial*/</span>\
00296     <span class="comment">/*second ring communication), it would have to*/</span>\
00297     <span class="comment">/*be FOREIGN on that processor. So overlapping comm*/</span>\
00298     <span class="comment">/*and comp is not a problem.*/</span>\
00299     EXTRA_INITS\
00300     for(da-&gt;init&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();\
00301         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();\
00302         da-&gt;next&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {\
00303       ELEM_MAT_PROP_BLOCK\
00304     }\
00305     da-&gt;ReadFromGhostElemsBegin&lt;double&gt;(matPropArr, 2);\
00306     EXTRA_INITS\
00307     for(da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00308         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00309         da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {\
00310       ELEM_MAT_PROP_BLOCK\
00311     }\
00312     da-&gt;ReadFromGhostElemsEnd&lt;double&gt;(matPropArr);\
00313     par::Mpi_Reduce&lt;double&gt;(&amp;maxCoeff, &amp;globalMaxCoeff, 1, MPI_MAX, 0, comm);\
00314     par::Mpi_Reduce&lt;double&gt;(&amp;minCoeff, &amp;globalMinCoeff, 1, MPI_MIN, 0, comm);\
00315     if(!rank) {\
00316       std::cout&lt;&lt;"Level: "&lt;&lt;(nlevels-(damg_i-&gt;nlevels))&lt;&lt;\
00317       " Max Lap. Coeff: "&lt;&lt;globalMaxCoeff&lt;&lt;\
00318       " Min Lap. Coeff: "&lt;&lt;globalMinCoeff&lt;&lt;std::endl;\
00319     }\
00320     MPI_Barrier(comm);\
00321   } <span class="comment">/*end if active*/</span>\
00322   da-&gt;vecRestoreBuffer&lt;double&gt;((*matPropVecPtr), matPropArr,\
00323       true, true, false, 2);\
00324 }
00325 
<a name="l00326"></a><a class="code" href="matProp_8C.html#a9">00326</a> <span class="preprocessor">#define FINE_TO_COARSE_BLOCK {\</span>
00327 <span class="preprocessor">  damg_i = damg[i];\</span>
00328 <span class="preprocessor">  damg_i-&gt;user = ctx;\</span>
00329 <span class="preprocessor">  da = damg_i-&gt;da;\</span>
00330 <span class="preprocessor">  assert(da-&gt;iAmActive() == daf-&gt;iAmActive());\</span>
00331 <span class="preprocessor">  da-&gt;createVector&lt;double&gt;((*matPropVecPtr), true, true, 2);\</span>
00332 <span class="preprocessor">  for(unsigned int j = 0; j &lt; matPropVecPtr-&gt;size(); j++) {\</span>
00333 <span class="preprocessor">    (*matPropVecPtr)[j] = 0.0;\</span>
00334 <span class="preprocessor">  }\</span>
00335 <span class="preprocessor">  comm = da-&gt;getCommActive();\</span>
00336 <span class="preprocessor">  </span><span class="comment">/*Elemental,Ghosted,Write,2 Dof.*/</span>\
00337   matPropArr = NULL;\
00338   da-&gt;vecGetBuffer&lt;double&gt;((*matPropVecPtr), matPropArr,\
00339       true, true, false, 2);\
00340   double *fMatArr = NULL;\
00341   if(changedPartition) {\
00342     <span class="comment">/*Elemental, non-Ghosted, Read-only, 2 Dof.*/</span>\
00343     daf-&gt;vecGetBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00344         true, false, true, 2);\
00345   }else {\
00346     <span class="comment">/*Elemental, Ghosted, Read-only, 2 Dof.*/</span>\
00347     daf-&gt;vecGetBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00348         true, true, true, 2);\
00349   }\
00350   if(da-&gt;iAmActive()) {\
00351     MPI_Comm_rank(comm,&amp;rank);\
00352     double maxCoeff = 0.0;\
00353     double minCoeff = 1.0e+8;\
00354     double globalMaxCoeff;\
00355     double globalMinCoeff;\
00356     <span class="comment">/*Loop through the coarse and fine simultaneously*/</span>\
00357     <span class="comment">/*Note: If Coarse is Independent, then the*/</span>\
00358     <span class="comment">/*corresponding Fine is also independent.*/</span>\
00359     <span class="comment">/*Hence, overlapping comm with comp is possible.*/</span>\
00360     <span class="comment">/*First, we loop though the dependent elements.*/</span>\
00361     <span class="comment">/*Then we begin the communication and simulatenously*/</span>\
00362     <span class="comment">/*loop over the independent elements.*/</span>\
00363     for(da-&gt;init&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(),\
00364         daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00365         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();\
00366         da-&gt;next&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {\
00367       ASSIGN_MAT_PROP_FINE_TO_COARSE_ELEM_BLOCK \
00368     } <span class="comment">/*end dependent loop*/</span>\
00369     da-&gt;ReadFromGhostElemsBegin&lt;double&gt;(matPropArr,2);\
00370     for(da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;(),\
00371         daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00372         da-&gt;curr() &lt; da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00373         da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {\
00374       ASSIGN_MAT_PROP_FINE_TO_COARSE_ELEM_BLOCK \
00375     } <span class="comment">/*end Independent loop */</span>\
00376     da-&gt;ReadFromGhostElemsEnd&lt;double&gt;(matPropArr);\
00377     par::Mpi_Reduce&lt;double&gt;(&amp;maxCoeff, &amp;globalMaxCoeff, 1, MPI_MAX, 0, comm);\
00378     par::Mpi_Reduce&lt;double&gt;(&amp;minCoeff, &amp;globalMinCoeff, 1, MPI_MIN, 0, comm);\
00379     if(!rank) {\
00380       std::cout&lt;&lt;"Level: "&lt;&lt;i&lt;&lt;" Max Lap. Coeff: "\
00381       &lt;&lt;globalMaxCoeff&lt;&lt;" Min Lap. Coeff: "\
00382       &lt;&lt;globalMinCoeff&lt;&lt;std::endl;\
00383     }\
00384     MPI_Barrier(comm);\
00385   } <span class="comment">/*end check if active*/</span>\
00386   da-&gt;vecRestoreBuffer&lt;double&gt;((*matPropVecPtr),\
00387       matPropArr, true, true, false, 2);\
00388   if(changedPartition) {\
00389     <span class="comment">/*Elemental, non-Ghosted, Read-only, 2 Dof.*/</span>\
00390     daf-&gt;vecRestoreBuffer&lt;double&gt;((*fMatPropVec),\
00391         fMatArr, true, false, true, 2);\
00392   }else {\
00393     <span class="comment">/*Elemental, Ghosted, Read-only, 2 Dof.*/</span>\
00394     daf-&gt;vecRestoreBuffer&lt;double&gt;((*fMatPropVec),\
00395         fMatArr, true, true, true, 2);\
00396   }\
00397 }
00398 
<a name="l00399"></a><a class="code" href="omgJac_8h.html#a0">00399</a> <span class="keywordtype">void</span> <a class="code" href="omgJac_8h.html#a0">SetUserContexts</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg) {
00400 
00401   PetscInt       jacType = 1;
00402   PetscOptionsGetInt(0, <span class="stringliteral">"-jacType"</span>, &amp;jacType, 0);
00403 
00404   <span class="keywordflow">if</span>(jacType == 1) { <span class="keywordflow">return</span>; }
00405 
00406   PetscTruth setMatPropsAtCoarsest;
00407   PetscOptionsHasName(0,<span class="stringliteral">"-setMatPropsAtCoarsest"</span>,&amp;setMatPropsAtCoarsest);
00408 
00409   <span class="keywordflow">if</span>(setMatPropsAtCoarsest) {
00410     assert(jacType == 2);
00411     <a class="code" href="omgJac_8h.html#a1">SetUserContextsCoarsestToFinest</a>(damg);
00412     <span class="keywordflow">return</span>;
00413   }
00414 
00415   <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
00416 
00417   <span class="comment">//Set Mat Props Finest to Coarsest...</span>
00418   <span class="keywordtype">void</span> * ctx;
00419 
00420   <span class="comment">// Set for the finest level first</span>
00421   <span class="keywordflow">if</span>(jacType == 2) {
00422     ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;
00423   }<span class="keywordflow">else</span> {
00424     ctx = <span class="keyword">new</span> <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a>;
00425   }
00426 
00427   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg_i = damg[nlevels-1];
00428   <span class="keywordtype">int</span> rank;
00429   MPI_Comm comm;
00430 
00431   std::vector&lt;double&gt; * matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00432 
00433   <span class="keywordflow">if</span>(jacType == 2) {
00434     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00435     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">true</span>;
00436     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00437     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00438     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00439   }<span class="keywordflow">else</span> {
00440     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00441     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">true</span>;
00442     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isCoarsestLevel = <span class="keyword">false</span>;
00443     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;daf = NULL;
00444     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matPropFine = NULL;
00445     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;changedPartition = <span class="keyword">false</span>;
00446     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;JmatThisLevel = NULL;
00447     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;BmatThisLevel = NULL;
00448     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00449     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00450     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00451   }
00452 
00453   <span class="comment">//Default values is the same as the const. coeff. case </span>
00454   PetscReal lapFac = 0.0;
00455   PetscReal massFac = 0.0;
00456   PetscReal massBase = 1.0;
00457   PetscTruth optFound;
00458   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00459   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;massFac,&amp;optFound);
00460   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-BaseMatProp"</span>,&amp;massBase,&amp;optFound);
00461   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD ;
00462   <span class="keywordtype">double</span> *matPropArr = NULL;
00463   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da;
00464 
00465   PetscTruth setMatPropFromAnalyticFn;
00466   PetscOptionsHasName(0,<span class="stringliteral">"-setMatPropFromAnalyticFn"</span>,&amp;setMatPropFromAnalyticFn);
00467 
00468   <span class="keywordflow">if</span>(setMatPropFromAnalyticFn) {
00469     PetscReal lapFreq = 1.0;
00470     PetscOptionsGetReal(0,<span class="stringliteral">"-lapFreq"</span>,&amp;lapFreq,&amp;optFound);
00471     <span class="keywordtype">int</span> dummyInit;
00472     <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(\
00473         <a class="code" href="matProp_8C.html#a5">ASSIGN_MAT_PROP_ANALYTIC_FN_ELEM_BLOCK</a>, dummyInit = 0;) 
00474   } <span class="keywordflow">else</span> {
00475     PetscTruth setCheckerBoardMatProp;
00476     PetscOptionsHasName(0,<span class="stringliteral">"-setCheckerBoardMatProp"</span>,&amp;setCheckerBoardMatProp);
00477     <span class="keywordflow">if</span>(setCheckerBoardMatProp) {
00478       <span class="keywordtype">int</span> dummyInit;
00479       <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(\
00480           <a class="code" href="matProp_8C.html#a4">ASSIGN_MAT_PROP_CHECKER_BOARD_ELEM_BLOCK</a>, dummyInit = 0;) 
00481     } <span class="keywordflow">else</span> {
00482       PetscInt numCubes = 1;
00483       PetscOptionsGetInt(0,<span class="stringliteral">"-numCubes"</span>,&amp;numCubes,0);
00484       <span class="keywordflow">if</span>(numCubes == 1) {
00485         <span class="keywordtype">int</span> dummyInit;
00486         <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(\
00487             <a class="code" href="matProp_8C.html#a2">ASSIGN_MAT_PROP_1_CUBE_ELEM_BLOCK</a>, dummyInit = 0;) 
00488       } <span class="keywordflow">else</span> {
00489         <span class="keywordtype">int</span> dummyInit;
00490         <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(\
00491             <a class="code" href="matProp_8C.html#a3">ASSIGN_MAT_PROP_MULTIPLE_CUBES_ELEM_BLOCK</a>, dummyInit = 0;) 
00492       }
00493     }
00494   }
00495 
00496   <a class="code" href="classot_1_1DA.html">ot::DA</a>* daf;
00497   std::vector&lt;double&gt;* fMatPropVec = NULL;
00498   <span class="keywordtype">bool</span> changedPartition;
00499 
00500   <span class="keywordflow">if</span>(nlevels &gt; 1) {
00501     <a class="code" href="matProp_8C.html#a7">CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK</a> 
00502   }
00503 
00504   <span class="comment">//Coarser levels</span>
00505   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (nlevels-2); i &gt;= 0; i--) {
00506     <span class="keywordflow">if</span>(jacType == 2) {
00507       ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;
00508     }<span class="keywordflow">else</span> {
00509       ctx = <span class="keyword">new</span> <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a>;
00510     }
00511 
00512     matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00513 
00514     <span class="keywordflow">if</span>(jacType == 2) {
00515       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00516       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">false</span>;
00517       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00518       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00519       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00520     }<span class="keywordflow">else</span> {
00521       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00522       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">false</span>;
00523       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isCoarsestLevel = <span class="keyword">false</span>;
00524       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;daf = daf;
00525       <span class="comment">//Note, while using matPropFine, first check changedPartition. If the</span>
00526       <span class="comment">//partition was changed, then the vector is a non-ghosted elemental</span>
00527       <span class="comment">//vector. Else it is a ghosted elemental vector.</span>
00528       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matPropFine = fMatPropVec;
00529       <span class="comment">//If the partition was changed a new vector would have been created. Else</span>
00530       <span class="comment">// only the pointer is copied.</span>
00531       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;changedPartition = changedPartition;
00532       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;JmatThisLevel = NULL;
00533       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;BmatThisLevel = NULL;
00534       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00535       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00536       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00537     }
00538 
00539     <a class="code" href="matProp_8C.html#a9">FINE_TO_COARSE_BLOCK</a>
00540 
00541       <span class="keywordflow">if</span>(changedPartition &amp;&amp; (jacType == 2)) {
00542         fMatPropVec-&gt;clear();
00543         <span class="keyword">delete</span> fMatPropVec;
00544       }
00545 
00546     <span class="keywordflow">if</span>(i) {     
00547       <a class="code" href="matProp_8C.html#a7">CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK</a> 
00548     }
00549   }<span class="comment">//end for i</span>
00550 
00551   <span class="comment">//To handle the case of a single grid, it is best to set the coarsest level's</span>
00552   <span class="comment">//flag separately at the end.</span>
00553   <span class="keywordflow">if</span>(jacType == 3) {
00554     (static_cast&lt;Jac3MFreeData*&gt;(damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>))-&gt;isCoarsestLevel = <span class="keyword">true</span>;
00555   }
00556 }<span class="comment">//end fn.</span>
00557 
<a name="l00558"></a><a class="code" href="omgJac_8h.html#a3">00558</a> <span class="keywordtype">void</span> <a class="code" href="omgJac_8h.html#a3">SetUserContextsFromPts</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg,
00559     <span class="keyword">const</span> std::vector&lt;double&gt;&amp; pts,
00560     <span class="keyword">const</span> std::vector&lt;double&gt; &amp; lapJump) {
00561 
00562   PetscInt       jacType = 1;
00563   PetscOptionsGetInt(0, <span class="stringliteral">"-jacType"</span>, &amp;jacType, 0);
00564 
00565   assert(jacType != 1);
00566 
00567   assert(pts.size() == (3*lapJump.size()));
00568 
00569   <span class="keywordtype">int</span> nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of mg levels</span>
00570   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg_i = damg[nlevels-1];
00571 
00572   <span class="comment">//Set Mat Props Finest to Coarsest...</span>
00573   <span class="keywordtype">void</span> * ctx;
00574 
00575   <span class="comment">// Set for the finest level first</span>
00576   <span class="keywordflow">if</span>(jacType == 2) {
00577     ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;
00578   }<span class="keywordflow">else</span> {
00579     ctx = <span class="keyword">new</span> <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a>;
00580   }
00581 
00582   std::vector&lt;double&gt; * matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00583 
00584   <span class="keywordflow">if</span>(jacType == 2) {
00585     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00586     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">true</span>;
00587     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00588     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00589     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00590   }<span class="keywordflow">else</span> {
00591     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00592     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">true</span>;
00593     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isCoarsestLevel = <span class="keyword">false</span>;
00594     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;daf = NULL;
00595     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matPropFine = NULL;
00596     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;changedPartition = <span class="keyword">false</span>;
00597     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;JmatThisLevel = NULL;
00598     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;BmatThisLevel = NULL;
00599     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00600     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00601     (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00602   }
00603 
00604   <span class="comment">//Default values is the same as the const. coeff. case </span>
00605   PetscReal lapBase = 1.0;
00606   PetscReal massBase = 1.0;
00607   PetscTruth optFound;
00608   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-BaseMatProp"</span>,&amp;lapBase,&amp;optFound);
00609   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-BaseMatProp"</span>,&amp;massBase,&amp;optFound);
00610   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD ;
00611   <span class="keywordtype">double</span> *matPropArr = NULL;
00612   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da;
00613   <span class="keywordtype">int</span> rank;
00614   MPI_Comm comm;
00615 
00616   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ptsCtr;
00617   <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(<a class="code" href="matProp_8C.html#a1">ASSIGN_MAT_PROP_FROM_PTS_ELEM_BLOCK</a>,
00618       ptsCtr = 0;) 
00619 
00620     <span class="comment">//The coarser levels...</span>
00621     <a class="code" href="classot_1_1DA.html">ot::DA</a>* daf;
00622   std::vector&lt;double&gt;* fMatPropVec = NULL;
00623   <span class="keywordtype">bool</span> changedPartition;
00624 
00625   <span class="keywordflow">if</span>(nlevels &gt; 1) {
00626     <a class="code" href="matProp_8C.html#a7">CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK</a> 
00627   }
00628 
00629   <span class="comment">//Coarser levels</span>
00630   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = (nlevels-2); i &gt;= 0; i--) {
00631     <span class="keywordflow">if</span>(jacType == 2) {
00632       ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;
00633     }<span class="keywordflow">else</span> {
00634       ctx = <span class="keyword">new</span> <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a>;
00635     }
00636 
00637     matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00638 
00639     <span class="keywordflow">if</span>(jacType == 2) {
00640       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00641       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">false</span>;
00642       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00643       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00644       (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00645     }<span class="keywordflow">else</span> {
00646       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00647       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isFinestLevel = <span class="keyword">false</span>;
00648       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;isCoarsestLevel = <span class="keyword">false</span>;
00649       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;daf = daf;
00650       <span class="comment">//Note, while using matPropFine, first check changedPartition. If the</span>
00651       <span class="comment">//partition was changed, then the vector is a non-ghosted elemental</span>
00652       <span class="comment">//vector. Else it is a ghosted elemental vector.</span>
00653       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;matPropFine = fMatPropVec;
00654       <span class="comment">//If the partition was changed a new vector would have been created. Else</span>
00655       <span class="comment">// only the pointer is copied.</span>
00656       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;changedPartition = changedPartition;
00657       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;JmatThisLevel = NULL;
00658       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;BmatThisLevel = NULL;
00659       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00660       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00661       (static_cast&lt;Jac3MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00662     }
00663 
00664     <a class="code" href="matProp_8C.html#a9">FINE_TO_COARSE_BLOCK</a>
00665 
00666       <span class="keywordflow">if</span>(changedPartition &amp;&amp; (jacType == 2)) {
00667         fMatPropVec-&gt;clear();
00668         <span class="keyword">delete</span> fMatPropVec;
00669       }
00670 
00671     <span class="keywordflow">if</span>(i) {     
00672       <a class="code" href="matProp_8C.html#a7">CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK</a> 
00673     }
00674   }<span class="comment">//end for i</span>
00675 
00676   <span class="comment">//To handle the case of a single grid, it is best to set the coarsest level's</span>
00677   <span class="comment">//flag separately at the end.</span>
00678   <span class="keywordflow">if</span>(jacType == 3) {
00679     (static_cast&lt;Jac3MFreeData*&gt;(damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>))-&gt;isCoarsestLevel = <span class="keyword">true</span>;
00680   }
00681 }<span class="comment">//end fn.</span>
00682 
00683 <span class="preprocessor">#undef ASSIGN_MAT_PROP_FINE_TO_COARSE_ELEM_BLOCK </span>
00684 <span class="preprocessor"></span><span class="preprocessor">#undef CHK_AND_SCATTER_FINE_TO_COARSE_BLOCK </span>
00685 <span class="preprocessor"></span><span class="preprocessor">#undef FINE_TO_COARSE_BLOCK</span>
00686 <span class="preprocessor"></span>
<a name="l00687"></a><a class="code" href="matProp_8C.html#a10">00687</a> <span class="preprocessor">#define ASSIGN_MAT_PROP_COARSE_TO_FINE_ELEM_BLOCK {\</span>
00688 <span class="preprocessor">  </span><span class="comment">/*The fine loop is always Writable, but the coarse loop*/</span>\
00689   <span class="comment">/*could be Independent or W_Dependent. Hence the fine counter must*/</span>\
00690   <span class="comment">/*be incremented properly to align with the coarse.*/</span>\
00691   unsigned int idxC= dac-&gt;curr();\
00692   Point Cpt = dac-&gt;getCurrentOffset();\
00693   assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00694   while(daf-&gt;getCurrentOffset() != Cpt) {\
00695     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00696     assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00697   }\
00698   if(daf-&gt;getLevel(daf-&gt;curr()) == dac-&gt;getLevel(idxC)) {\
00699     <span class="comment">/*The coarse and fine elements are the same,*/</span>\
00700     assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00701     unsigned int idxF = daf-&gt;curr();\
00702     fMatArr[2*idxF] = cMatArr[2*idxC];\
00703     fMatArr[(2*idxF)+1] = cMatArr[(2*idxC)+1];\
00704     if(fMatArr[2*idxF] &gt; maxCoeff) {\
00705       maxCoeff = fMatArr[2*idxF];\
00706     }\
00707     if(fMatArr[2*idxF] &lt; minCoeff) {\
00708       minCoeff = fMatArr[2*idxF];\
00709     }\
00710     daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00711   }else {\
00712     for(unsigned char cNumFine = 0; cNumFine &lt; 8; cNumFine++) {\
00713       <span class="comment">/*The coarse and fine elements are NOT the same. */</span>\
00714       <span class="comment">/*Loop over each of the 8 children of the coarse element.*/</span>\
00715       <span class="comment">/*These are the underlying fine elements.*/</span>\
00716       assert(daf-&gt;curr() &lt; daf-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;());\
00717       unsigned int idxF = daf-&gt;curr();\
00718       fMatArr[2*idxF] = cMatArr[2*idxC];\
00719       fMatArr[(2*idxF)+1] = cMatArr[(2*idxC)+1];\
00720       if(fMatArr[2*idxF] &gt; maxCoeff) {\
00721         maxCoeff = fMatArr[2*idxF];\
00722       }\
00723       if(fMatArr[2*idxF] &lt; minCoeff) {\
00724         minCoeff = fMatArr[2*idxF];\
00725       }\
00726       daf-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00727     }\
00728   }\
00729 }
00730 
<a name="l00731"></a><a class="code" href="matProp_8C.html#a11">00731</a> <span class="preprocessor">#define COARSE_TO_FINE_BLOCK {\</span>
00732 <span class="preprocessor">  </span><span class="comment">/*The finer levels... */</span>\
00733   for(int i = 1; i &lt; nlevels; i++) {\
00734     ot::DA* dac = damg[i-1]-&gt;da;\
00735     ot::DA* daf;\
00736     bool changedPartition;\
00737     if(damg[i]-&gt;da_aux) {\
00738       daf = damg[i]-&gt;da_aux;\
00739       changedPartition = true;\
00740     }else {\
00741       daf = damg[i]-&gt;da;\
00742       changedPartition = false;\
00743     }\
00744     assert(dac-&gt;iAmActive() == daf-&gt;iAmActive());\
00745     comm = daf-&gt;getCommActive();\
00746     if(daf-&gt;iAmActive()) {\
00747       MPI_Comm_rank(comm,&amp;rank);\
00748     }\
00749     std::vector&lt;double&gt;* cMatPropVec = \
00750     (static_cast&lt;Jac2MFreeData*&gt;(damg[i-1]-&gt;user))-&gt;matProp;\
00751     std::vector&lt;double&gt;* fMatPropVec = new std::vector&lt;double&gt;;\
00752     if(changedPartition) {\
00753       <span class="comment">/*Elemental and Non-Ghosted*/</span>\
00754       daf-&gt;createVector&lt;double&gt;((*fMatPropVec), true, false, 2);\
00755     } else {\
00756       <span class="comment">/*Elemental and Ghosted*/</span>\
00757       daf-&gt;createVector&lt;double&gt;((*fMatPropVec), true, true, 2);\
00758     }\
00759     for(unsigned int j = 0; j &lt; fMatPropVec-&gt;size(); j++) {\
00760       (*fMatPropVec)[j] = 0.0;\
00761     }\
00762     double *cMatArr = NULL;\
00763     double *fMatArr = NULL;\
00764     double maxCoeff = 0.0;\
00765     double minCoeff = 1.0e+8;\
00766     double globalMaxCoeff;\
00767     double globalMinCoeff;\
00768     <span class="comment">/*Read-only buffer*/</span>\
00769     dac-&gt;vecGetBuffer&lt;double&gt;((*cMatPropVec), cMatArr,true, true, true, 2);\
00770     if(changedPartition) {\
00771       if(daf-&gt;iAmActive()) {\
00772         <span class="comment">/*Writable buffer*/</span>\
00773         daf-&gt;vecGetBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00774             true, false, false, 2);\
00775         <span class="comment">/*Can not overlap comm and comp here. So direct WRITABLE loop*/</span>\
00776         for(dac-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;(),\
00777             daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00778             dac-&gt;curr() &lt; dac-&gt;end&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00779             dac-&gt;next&lt;ot::DA_FLAGS::WRITABLE&gt;()) {\
00780           ASSIGN_MAT_PROP_COARSE_TO_FINE_ELEM_BLOCK \
00781         } <span class="comment">/*end loop*/</span>\
00782         daf-&gt;vecRestoreBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00783             true, false, false, 2);\
00784       }<span class="comment">/*end if active*/</span>\
00785       std::vector&lt;double&gt; tmpVecForScatter;\
00786       <span class="comment">/*Scatter from fMatPropVec to*/</span>\
00787       <span class="comment">/*tmpVecForScatter (created in the function)*/</span>\
00788       par::scatterValues&lt;double&gt;((*fMatPropVec), tmpVecForScatter,\
00789           (2*(damg[i]-&gt;da-&gt;getElementSize())),\
00790           daf-&gt;getComm());\
00791       fMatPropVec-&gt;clear();\
00792       delete fMatPropVec;\
00793       std::vector&lt;double&gt; *tmpFineVec = new std::vector&lt;double&gt;;\
00794       <span class="comment">/*Elemental and Ghosted*/</span>\
00795       damg[i]-&gt;da-&gt;createVector&lt;double&gt;((*tmpFineVec), true, true, 2);\
00796       if(damg[i]-&gt;da-&gt;iAmActive()) {\
00797         <span class="comment">/*Writable buffer*/</span>\
00798         damg[i]-&gt;da-&gt;vecGetBuffer&lt;double&gt;((*tmpFineVec), fMatArr,\
00799             true, true, false, 2);\
00800         <span class="comment">/*Read-only buffer*/</span>\
00801         double *tmpFmatArr = NULL;\
00802         damg[i]-&gt;da-&gt;vecGetBuffer&lt;double&gt;(tmpVecForScatter, tmpFmatArr,\
00803             true, false, true, 2);\
00804         <span class="comment">/*Copy from tmpVecForScatter to tmpFineVec*/</span>\
00805         <span class="comment">/*W_DEPENDENT loop*/</span>\
00806         for(damg[i]-&gt;da-&gt;init&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();\
00807             damg[i]-&gt;da-&gt;curr() &lt; damg[i]-&gt;da-&gt;end&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();\
00808             damg[i]-&gt;da-&gt;next&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {\
00809           unsigned int idxCurr = damg[i]-&gt;da-&gt;curr();\
00810           fMatArr[2*idxCurr] = tmpFmatArr[2*idxCurr]; \
00811           fMatArr[(2*idxCurr) + 1] = tmpFmatArr[(2*idxCurr) + 1]; \
00812         } <span class="comment">/*end dependent loop*/</span>\
00813         <span class="comment">/*Begin read from ghost elements on the da grid*/</span>      \
00814         damg[i]-&gt;da-&gt;ReadFromGhostElemsBegin&lt;double&gt;(fMatArr,2);\
00815         <span class="comment">/*Overlap communication with Independent loop*/</span>\
00816         for(damg[i]-&gt;da-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00817             damg[i]-&gt;da-&gt;curr() &lt; damg[i]-&gt;da-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00818             damg[i]-&gt;da-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {\
00819           unsigned int idxCurr = damg[i]-&gt;da-&gt;curr();\
00820           fMatArr[2*idxCurr] = tmpFmatArr[2*idxCurr]; \
00821           fMatArr[(2*idxCurr) + 1] = tmpFmatArr[(2*idxCurr) + 1]; \
00822         } <span class="comment">/*end Independent loop */</span>\
00823         <span class="comment">/*End read from ghost elements on the da grid*/</span>      \
00824         damg[i]-&gt;da-&gt;ReadFromGhostElemsEnd&lt;double&gt;(fMatArr);\
00825         damg[i]-&gt;da-&gt;vecRestoreBuffer&lt;double&gt;(tmpVecForScatter, tmpFmatArr,\
00826             true, false, true, 2);\
00827         tmpVecForScatter.clear();\
00828         damg[i]-&gt;da-&gt;vecRestoreBuffer&lt;double&gt;((*tmpFineVec), fMatArr,\
00829             true, true, false, 2);\
00830       }<span class="comment">/*end if active*/</span>\
00831       fMatPropVec = tmpFineVec;\
00832       tmpFineVec = NULL;      \
00833     } else {\
00834       if(daf-&gt;iAmActive()) {\
00835         <span class="comment">/*Writable buffer*/</span>\
00836         daf-&gt;vecGetBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00837             true, true, false, 2);\
00838         <span class="comment">/*W_DEPENDENT loop*/</span>\
00839         for(dac-&gt;init&lt;ot::DA_FLAGS::W_DEPENDENT&gt;(),\
00840             daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00841             dac-&gt;curr() &lt; dac-&gt;end&lt;ot::DA_FLAGS::W_DEPENDENT&gt;();\
00842             dac-&gt;next&lt;ot::DA_FLAGS::W_DEPENDENT&gt;()) {\
00843           ASSIGN_MAT_PROP_COARSE_TO_FINE_ELEM_BLOCK \
00844         } <span class="comment">/*end dependent loop*/</span>\
00845         daf-&gt;ReadFromGhostElemsBegin&lt;double&gt;(fMatArr,2);\
00846         <span class="comment">/*Overlap communication with INDEPEDENT*/</span>\
00847         for(dac-&gt;init&lt;ot::DA_FLAGS::INDEPENDENT&gt;(),\
00848             daf-&gt;init&lt;ot::DA_FLAGS::WRITABLE&gt;();\
00849             dac-&gt;curr() &lt; dac-&gt;end&lt;ot::DA_FLAGS::INDEPENDENT&gt;();\
00850             dac-&gt;next&lt;ot::DA_FLAGS::INDEPENDENT&gt;()) {\
00851           ASSIGN_MAT_PROP_COARSE_TO_FINE_ELEM_BLOCK \
00852         } <span class="comment">/*end Independent loop */</span>\
00853         daf-&gt;ReadFromGhostElemsEnd&lt;double&gt;(fMatArr);\
00854         daf-&gt;vecRestoreBuffer&lt;double&gt;((*fMatPropVec), fMatArr,\
00855             true, true, false, 2);\
00856       } <span class="comment">/*end check if active*/</span>\
00857     }<span class="comment">/*end if changedPartition*/</span>\
00858     dac-&gt;vecRestoreBuffer&lt;double&gt;((*cMatPropVec), cMatArr,\
00859         true, true, true, 2);\
00860     ctx = new Jac2MFreeData;\
00861     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = fMatPropVec;\
00862     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = (i == (nlevels-1));\
00863     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;\
00864     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;\
00865     (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;\
00866     damg[i]-&gt;user = ctx;\
00867     if(daf-&gt;iAmActive()) {\
00868       par::Mpi_Reduce&lt;double&gt;(&amp;maxCoeff, &amp;globalMaxCoeff, 1, MPI_MAX, 0, comm);\
00869       par::Mpi_Reduce&lt;double&gt;(&amp;minCoeff, &amp;globalMinCoeff, 1, MPI_MIN, 0, comm);\
00870       if(!rank) {\
00871         std::cout&lt;&lt;"Level: "&lt;&lt;i&lt;&lt;" Max Lap. Coeff: "\
00872         &lt;&lt;globalMaxCoeff&lt;&lt;" Min Lap. Coeff: "\
00873         &lt;&lt;globalMinCoeff&lt;&lt;std::endl;\
00874       }\
00875       MPI_Barrier(comm);\
00876     }<span class="comment">/*end if active*/</span>\
00877   }<span class="comment">/*end for i*/</span>\
00878 }
00879 
<a name="l00880"></a><a class="code" href="omgJac_8h.html#a1">00880</a> <span class="keywordtype">void</span> <a class="code" href="omgJac_8h.html#a1">SetUserContextsCoarsestToFinest</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg) {
00881   <span class="comment">//jactype =2 only</span>
00882   <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
00883 
00884   <span class="comment">//coarsest first...</span>
00885   <span class="keywordtype">void</span> * ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;   
00886   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg_i = damg[0];
00887 
00888   std::vector&lt;double&gt; * matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00889   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00890   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = (nlevels == 1);
00891   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00892   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00893   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00894 
00895   <span class="keywordtype">int</span> rank;
00896   MPI_Comm comm;
00897 
00898   <span class="comment">//Default values is the same as the const. coeff. case </span>
00899   PetscReal lapFac = 0.0;
00900   PetscReal massFac = 0.0;
00901   PetscReal massBase = 1.0;
00902   PetscTruth optFound;
00903   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;lapFac,&amp;optFound);
00904   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-MatPropFac"</span>,&amp;massFac,&amp;optFound);
00905   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-BaseMatProp"</span>,&amp;massBase,&amp;optFound);
00906   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00907   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da;
00908   <span class="keywordtype">double</span> *matPropArr = NULL;
00909 
00910   PetscTruth setMatPropFromAnalyticFn;
00911   PetscOptionsHasName(0,<span class="stringliteral">"-setMatPropFromAnalyticFn"</span>,&amp;setMatPropFromAnalyticFn);
00912 
00913   <span class="keywordflow">if</span>(setMatPropFromAnalyticFn) {
00914     PetscReal lapFreq = 1.0;
00915     PetscOptionsGetReal(0,<span class="stringliteral">"-lapFreq"</span>,&amp;lapFreq,&amp;optFound);
00916     <span class="keywordtype">int</span> dummyInit;
00917     <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(\
00918         <a class="code" href="matProp_8C.html#a5">ASSIGN_MAT_PROP_ANALYTIC_FN_ELEM_BLOCK</a>, dummyInit = 0;) 
00919   } <span class="keywordflow">else</span> {
00920     PetscTruth setCheckerBoardMatProp;
00921     PetscOptionsHasName(0,<span class="stringliteral">"-setCheckerBoardMatProp"</span>,&amp;setCheckerBoardMatProp);
00922     <span class="keywordflow">if</span>(setCheckerBoardMatProp) {
00923       <span class="keywordtype">int</span> dummyInit;
00924       <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(<a class="code" href="matProp_8C.html#a4">ASSIGN_MAT_PROP_CHECKER_BOARD_ELEM_BLOCK</a>, 
00925           dummyInit = 0;) 
00926     } <span class="keywordflow">else</span> {
00927       PetscInt numCubes = 1;
00928       PetscOptionsGetInt(0,<span class="stringliteral">"-numCubes"</span>,&amp;numCubes,0);
00929       <span class="keywordflow">if</span>(numCubes == 1) {
00930         <span class="keywordtype">int</span> dummyInit;
00931         <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(<a class="code" href="matProp_8C.html#a2">ASSIGN_MAT_PROP_1_CUBE_ELEM_BLOCK</a>, 
00932             dummyInit = 0;) 
00933       } <span class="keywordflow">else</span> {
00934         <span class="keywordtype">int</span> dummyInit;
00935         <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(<a class="code" href="matProp_8C.html#a3">ASSIGN_MAT_PROP_MULTIPLE_CUBES_ELEM_BLOCK</a>,
00936             dummyInit = 0;) 
00937       }
00938     }
00939   }
00940 
00941   <a class="code" href="matProp_8C.html#a11">COARSE_TO_FINE_BLOCK</a>
00942 
00943 }<span class="comment">//end fn.</span>
00944 
<a name="l00945"></a><a class="code" href="omgJac_8h.html#a2">00945</a> <span class="keywordtype">void</span> <a class="code" href="omgJac_8h.html#a2">SetCoarseToFineFromPts</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg,
00946     <span class="keyword">const</span> std::vector&lt;double&gt;&amp; pts,
00947     <span class="keyword">const</span> std::vector&lt;double&gt; &amp; lapJump) {
00948 
00949   assert(pts.size() == (3*lapJump.size()));
00950 
00951   <span class="comment">//jactype =2 only</span>
00952   <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
00953 
00954   <span class="comment">//coarsest first...</span>
00955   <span class="keywordtype">void</span> * ctx = <span class="keyword">new</span> <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>;   
00956   <a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a> damg_i = damg[0];
00957 
00958   std::vector&lt;double&gt; * matPropVecPtr = <span class="keyword">new</span> std::vector&lt;double&gt;;
00959   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;matProp = matPropVecPtr;
00960   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;isFinestLevel = (nlevels == 1);
00961   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;Jmat_private = NULL;
00962   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;inTmp = NULL;
00963   (static_cast&lt;Jac2MFreeData*&gt;(ctx))-&gt;outTmp = NULL;
00964 
00965   <span class="keywordtype">int</span> rank;
00966   MPI_Comm comm;
00967 
00968   <span class="comment">//Default values is the same as the const. coeff. case </span>
00969   PetscReal lapBase = 1.0;
00970   PetscReal massBase = 1.0;
00971   PetscTruth optFound;
00972   PetscOptionsGetReal(<span class="stringliteral">"lap"</span>,<span class="stringliteral">"-BaseMatProp"</span>,&amp;lapBase,&amp;optFound);
00973   PetscOptionsGetReal(<span class="stringliteral">"mass"</span>,<span class="stringliteral">"-BaseMatProp"</span>,&amp;massBase,&amp;optFound);
00974   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maxD;
00975   <a class="code" href="classot_1_1DA.html">ot::DA</a>* da;
00976   <span class="keywordtype">double</span> *matPropArr = NULL;
00977 
00978   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> ptsCtr;
00979   <a class="code" href="matProp_8C.html#a8">SET_SINGLE_LEVEL_MAT_PROP_BLOCK</a>(<a class="code" href="matProp_8C.html#a1">ASSIGN_MAT_PROP_FROM_PTS_ELEM_BLOCK</a>,
00980       ptsCtr = 0;) 
00981 
00982     <a class="code" href="matProp_8C.html#a11">COARSE_TO_FINE_BLOCK</a>
00983 
00984 }<span class="comment">//end fn.</span>
00985 
00986 <span class="preprocessor">#undef ASSIGN_MAT_PROP_FROM_PTS_ELEM_BLOCK </span>
00987 <span class="preprocessor"></span><span class="preprocessor">#undef ASSIGN_MAT_PROP_1_CUBE_ELEM_BLOCK </span>
00988 <span class="preprocessor"></span><span class="preprocessor">#undef ASSIGN_MAT_PROP_MULTIPLE_CUBES_ELEM_BLOCK </span>
00989 <span class="preprocessor"></span><span class="preprocessor">#undef ASSIGN_MAT_PROP_CHECKER_BOARD_ELEM_BLOCK </span>
00990 <span class="preprocessor"></span>
00991 <span class="preprocessor">#undef SET_SINGLE_LEVEL_MAT_PROP_BLOCK</span>
00992 <span class="preprocessor"></span>
00993 <span class="preprocessor">#undef ASSIGN_MAT_PROP_COARSE_TO_FINE_ELEM_BLOCK </span>
00994 <span class="preprocessor"></span><span class="preprocessor">#undef COARSE_TO_FINE_BLOCK </span>
00995 <span class="preprocessor"></span>
00996 <span class="preprocessor">#undef ASSIGN_MAT_PROP_ANALYTIC_FN_ELEM_BLOCK </span>
00997 <span class="preprocessor"></span><span class="preprocessor">#undef SQUARE</span>
00998 <span class="preprocessor"></span>
<a name="l00999"></a><a class="code" href="omgJac_8h.html#a4">00999</a> <span class="keywordtype">void</span> <a class="code" href="omgNeumann_8C.html#a13">DestroyUserContexts</a>(<a class="code" href="structot_1_1__p__DAMG.html">ot::DAMG</a>* damg) {
01000 
01001   PetscInt       jacType = 1;
01002   PetscOptionsGetInt(0,<span class="stringliteral">"-jacType"</span>,&amp;jacType,0);
01003 
01004   <span class="keywordflow">if</span>(jacType == 1) { <span class="keywordflow">return</span>; }
01005 
01006   <span class="keywordtype">int</span>       nlevels = damg[0]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o10">nlevels</a>; <span class="comment">//number of multigrid levels</span>
01007 
01008   <span class="keywordflow">if</span>(jacType == 2) {
01009     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
01010       <a class="code" href="structJac2MFreeData.html">Jac2MFreeData</a>* ctx = (static_cast&lt;Jac2MFreeData*&gt;(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
01011       ctx-&gt;<a class="code" href="structJac2MFreeData.html#o4">matProp</a>-&gt;clear();
01012       <span class="keyword">delete</span> ctx-&gt;<a class="code" href="structJac2MFreeData.html#o4">matProp</a>;
01013       ctx-&gt;<a class="code" href="structJac2MFreeData.html#o4">matProp</a> = NULL;
01014       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>) {
01015         MatDestroy(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a>);
01016         ctx-&gt;<a class="code" href="structJac2MFreeData.html#o2">Jmat_private</a> = NULL;
01017       }
01018       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>) {
01019         VecDestroy(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a>);
01020         ctx-&gt;<a class="code" href="structJac2MFreeData.html#o0">inTmp</a> = NULL;
01021       }
01022       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>) {
01023         VecDestroy(ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a>);
01024         ctx-&gt;<a class="code" href="structJac2MFreeData.html#o5">outTmp</a> = NULL;
01025       }
01026       <span class="keyword">delete</span> ctx;
01027       ctx = NULL;
01028     }
01029   }<span class="comment">//end type-2</span>
01030 
01031   <span class="keywordflow">if</span>(jacType == 3) {
01032     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i = 0; i &lt; nlevels; i++) {
01033       <a class="code" href="structJac3MFreeData.html">Jac3MFreeData</a>* ctx = (static_cast&lt;Jac3MFreeData*&gt;(damg[i]-&gt;<a class="code" href="structot_1_1__p__DAMG.html#o18">user</a>));
01034       <span class="comment">//The coarsest level will not create matProp. It will only use the finer</span>
01035       <span class="comment">//level's material properties.</span>
01036       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o8">matProp</a>) {
01037         ctx-&gt;<a class="code" href="structJac3MFreeData.html#o8">matProp</a>-&gt;clear();
01038         <span class="keyword">delete</span> ctx-&gt;<a class="code" href="structJac3MFreeData.html#o8">matProp</a>;
01039         ctx-&gt;<a class="code" href="structJac3MFreeData.html#o8">matProp</a> = NULL;
01040       }
01041       <span class="comment">//Sometimes, memory is allocated for the fine material property vector.</span>
01042       <span class="comment">//Sometimes it is just a copy of pointers.</span>
01043       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o1">changedPartition</a>) {
01044         ctx-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>-&gt;clear();
01045         <span class="keyword">delete</span> ctx-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a>;
01046         ctx-&gt;<a class="code" href="structJac3MFreeData.html#o9">matPropFine</a> = NULL;
01047       }
01048       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>) {
01049         MatDestroy(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a>);
01050         ctx-&gt;<a class="code" href="structJac3MFreeData.html#o6">Jmat_private</a> = NULL;
01051       }
01052       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a>) {
01053         VecDestroy(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a>);
01054         ctx-&gt;<a class="code" href="structJac3MFreeData.html#o3">inTmp</a> = NULL;
01055       }
01056       <span class="keywordflow">if</span>(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a>) {
01057         VecDestroy(ctx-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a>);
01058         ctx-&gt;<a class="code" href="structJac3MFreeData.html#o10">outTmp</a> = NULL;
01059       }
01060       <span class="keyword">delete</span> ctx;
01061       ctx = NULL;
01062     }
01063   }<span class="comment">//end type-3</span>
01064 
01065 }<span class="comment">//end fn.</span>
01066 
01067 
01068 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Wed Dec 10 11:31:24 2008 for DENDRO by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
